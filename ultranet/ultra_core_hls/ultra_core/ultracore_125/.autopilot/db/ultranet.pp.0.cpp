# 1 "./src/ultranet.cpp"
# 1 "./src/ultranet.cpp" 1
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 155 "<built-in>" 3
# 1 "<command line>" 1






# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/etc/autopilot_ssdm_op.h" 1
# 157 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/etc/autopilot_ssdm_op.h"
extern "C" {






    void _ssdm_op_IfRead(...) __attribute__ ((nothrow));
    void _ssdm_op_IfWrite(...) __attribute__ ((nothrow));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfNbRead(...) __attribute__ ((nothrow));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfNbWrite(...) __attribute__ ((nothrow));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfCanRead(...) __attribute__ ((nothrow));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfCanWrite(...) __attribute__ ((nothrow));


    void _ssdm_StreamRead(...) __attribute__ ((nothrow));
    void _ssdm_StreamWrite(...) __attribute__ ((nothrow));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamNbRead(...) __attribute__ ((nothrow));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamNbWrite(...) __attribute__ ((nothrow));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamCanRead(...) __attribute__ ((nothrow));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamCanWrite(...) __attribute__ ((nothrow));
    unsigned _ssdm_StreamSize(...) __attribute__ ((nothrow));




    void _ssdm_op_MemShiftRead(...) __attribute__ ((nothrow));

    void _ssdm_op_Wait(...) __attribute__ ((nothrow));
    void _ssdm_op_Poll(...) __attribute__ ((nothrow));

    void _ssdm_op_Return(...) __attribute__ ((nothrow));


    void _ssdm_op_SpecSynModule(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecTopModule(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecProcessDecl(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecProcessDef(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecPort(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecConnection(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecChannel(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecSensitive(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecModuleInst(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecPortMap(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecReset(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecPlatform(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecClockDomain(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecPowerDomain(...) __attribute__ ((nothrow));

    int _ssdm_op_SpecRegionBegin(...) __attribute__ ((nothrow));
    int _ssdm_op_SpecRegionEnd(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecLoopName(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecLoopTripCount(...) __attribute__ ((nothrow));

    int _ssdm_op_SpecStateBegin(...) __attribute__ ((nothrow));
    int _ssdm_op_SpecStateEnd(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecInterface(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecPipeline(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecDataflowPipeline(...) __attribute__ ((nothrow));


    void _ssdm_op_SpecLatency(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecParallel(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecProtocol(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecOccurrence(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecResource(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecResourceLimit(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecCHCore(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecFUCore(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecIFCore(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecIPCore(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecKeepValue(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecMemCore(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecExt(...) __attribute__ ((nothrow));




    void _ssdm_SpecArrayDimSize(...) __attribute__ ((nothrow));

    void _ssdm_RegionBegin(...) __attribute__ ((nothrow));
    void _ssdm_RegionEnd(...) __attribute__ ((nothrow));

    void _ssdm_Unroll(...) __attribute__ ((nothrow));
    void _ssdm_UnrollRegion(...) __attribute__ ((nothrow));

    void _ssdm_InlineAll(...) __attribute__ ((nothrow));
    void _ssdm_InlineLoop(...) __attribute__ ((nothrow));
    void _ssdm_Inline(...) __attribute__ ((nothrow));
    void _ssdm_InlineSelf(...) __attribute__ ((nothrow));
    void _ssdm_InlineRegion(...) __attribute__ ((nothrow));

    void _ssdm_SpecArrayMap(...) __attribute__ ((nothrow));
    void _ssdm_SpecArrayPartition(...) __attribute__ ((nothrow));
    void _ssdm_SpecArrayReshape(...) __attribute__ ((nothrow));

    void _ssdm_SpecStream(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecStable(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecStableContent(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecPipoDepth(...) __attribute__ ((nothrow));

    void _ssdm_SpecExpr(...) __attribute__ ((nothrow));
    void _ssdm_SpecExprBalance(...) __attribute__ ((nothrow));

    void _ssdm_SpecDependence(...) __attribute__ ((nothrow));

    void _ssdm_SpecLoopMerge(...) __attribute__ ((nothrow));
    void _ssdm_SpecLoopFlatten(...) __attribute__ ((nothrow));
    void _ssdm_SpecLoopRewind(...) __attribute__ ((nothrow));

    void _ssdm_SpecFuncInstantiation(...) __attribute__ ((nothrow));
    void _ssdm_SpecFuncBuffer(...) __attribute__ ((nothrow));
    void _ssdm_SpecFuncExtract(...) __attribute__ ((nothrow));
    void _ssdm_SpecConstant(...) __attribute__ ((nothrow));

    void _ssdm_DataPack(...) __attribute__ ((nothrow));
    void _ssdm_SpecDataPack(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecBitsMap(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecLicense(...) __attribute__ ((nothrow));

    void __xilinx_ip_top(...) __attribute__ ((nothrow));


}
# 8 "<command line>" 2
# 1 "<built-in>" 2
# 1 "./src/ultranet.cpp" 2





# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 1 3
# 38 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
# 38 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3

# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 1 3
# 38 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
# 38 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3

# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 1 3
# 37 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 3
# 37 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 3

# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iosfwd" 1 3
# 38 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iosfwd" 3
# 38 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iosfwd" 3

# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 1 3
# 153 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 393 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/os_defines.h" 1 3
# 40 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 392 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 393 "/usr/include/features.h" 2 3 4
# 464 "/usr/include/features.h" 3 4
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 465 "/usr/include/features.h" 2 3 4
# 486 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 559 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 560 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 561 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 487 "/usr/include/features.h" 2 3 4
# 510 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 511 "/usr/include/features.h" 2 3 4
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/os_defines.h" 2 3
# 394 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 2 3


# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/cpu_defines.h" 1 3
# 397 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 2 3
# 40 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iosfwd" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stringfwd.h" 1 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stringfwd.h" 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stringfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    class allocator;







  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;





  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;

  typedef basic_string<char16_t> u16string;
  typedef basic_string<char32_t> u32string;





}
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iosfwd" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 1 3
# 40 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3
# 40 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3

# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 1 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 27 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 119 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 214 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 251 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 268 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 285 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 31 "/usr/include/wchar.h" 2 3 4




# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
# 31 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 3 4
typedef __typeof__(((int*)0)-((int*)0)) ptrdiff_t;



typedef __typeof__(sizeof(int)) size_t;
# 55 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 3 4
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 36 "/usr/include/wchar.h" 2 3 4


# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/clang/bin/../lib/clang/3.1/include/stdarg.h" 1 3 4
# 30 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/clang/bin/../lib/clang/3.1/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 48 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/clang/bin/../lib/clang/3.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 39 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 41 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 3 4
typedef unsigned int wint_t;
# 42 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 2 3 4

typedef __mbstate_t mbstate_t;
# 43 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 44 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 47 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 50 "/usr/include/wchar.h" 2 3 4
# 79 "/usr/include/wchar.h" 3 4
extern "C" {



struct tm;



extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) noexcept (true);


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) noexcept (true);



extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    locale_t __loc) noexcept (true);

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, locale_t __loc) noexcept (true);




extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) noexcept (true);



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) noexcept (true);







extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        locale_t __loc) noexcept (true);




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, locale_t __loc) noexcept (true);


extern wchar_t *wcsdup (const wchar_t *__s) noexcept (true)
  __attribute__ ((__malloc__)) ;
# 165 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     noexcept (true) __attribute__ ((__pure__));
# 175 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     noexcept (true) __attribute__ ((__pure__));





extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     noexcept (true) __attribute__ ((__pure__));




extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     noexcept (true) __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     noexcept (true) __attribute__ ((__pure__));
# 202 "/usr/include/wchar.h" 3 4
extern wchar_t *wcspbrk (const wchar_t *__wcs, const wchar_t *__accept)
     noexcept (true) __attribute__ ((__pure__));
# 213 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsstr (const wchar_t *__haystack, const wchar_t *__needle)
     noexcept (true) __attribute__ ((__pure__));



extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) noexcept (true);


extern size_t wcslen (const wchar_t *__s) noexcept (true) __attribute__ ((__pure__));
# 234 "/usr/include/wchar.h" 3 4
extern wchar_t *wcswcs (const wchar_t *__haystack, const wchar_t *__needle)
     noexcept (true) __attribute__ ((__pure__));





extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     noexcept (true) __attribute__ ((__pure__));
# 254 "/usr/include/wchar.h" 3 4
extern wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, size_t __n)
     noexcept (true) __attribute__ ((__pure__));



extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) noexcept (true);



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     noexcept (true);


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) noexcept (true);




extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     noexcept (true);





extern wint_t btowc (int __c) noexcept (true);



extern int wctob (wint_t __c) noexcept (true);



extern int mbsinit (const mbstate_t *__ps) noexcept (true) __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) noexcept (true);


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) noexcept (true);


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) noexcept (true);
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) noexcept (true);
# 338 "/usr/include/wchar.h" 3 4
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) noexcept (true);



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) noexcept (true);





extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) noexcept (true);



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) noexcept (true);






extern int wcwidth (wchar_t __c) noexcept (true);



extern int wcswidth (const wchar_t *__s, size_t __n) noexcept (true);





extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) noexcept (true);



extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) noexcept (true);
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) noexcept (true);
# 397 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) noexcept (true);



extern _Float64 wcstof64 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) noexcept (true);
# 412 "/usr/include/wchar.h" 3 4
extern _Float32x wcstof32x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) noexcept (true);



extern _Float64x wcstof64x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) noexcept (true);
# 429 "/usr/include/wchar.h" 3 4
extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) noexcept (true);



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     noexcept (true);




__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     noexcept (true);



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) noexcept (true);





__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     noexcept (true);



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) noexcept (true);






extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     locale_t __loc) noexcept (true);

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, locale_t __loc) noexcept (true);

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, locale_t __loc) noexcept (true);

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, locale_t __loc)
     noexcept (true);

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, locale_t __loc)
     noexcept (true);

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, locale_t __loc)
     noexcept (true);

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) noexcept (true);
# 512 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) noexcept (true);



extern _Float64 wcstof64_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) noexcept (true);
# 530 "/usr/include/wchar.h" 3 4
extern _Float32x wcstof32x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) noexcept (true);



extern _Float64x wcstof64x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) noexcept (true);
# 552 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) noexcept (true);



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     noexcept (true);
# 581 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) noexcept (true)
  __attribute__ ((__malloc__)) ;





extern int fwide (__FILE *__fp, int __mode) noexcept (true);






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     noexcept (true) ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     noexcept (true) ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     noexcept (true) ;
# 657 "/usr/include/wchar.h" 3 4
extern int fwscanf (__FILE *__restrict __stream, const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc99_fwscanf")


                                                          ;
extern int wscanf (const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc99_wscanf")

                                                          ;
extern int swscanf (const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) noexcept (true) __asm__ ("" "__isoc99_swscanf")


                                                          ;
# 688 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     noexcept (true) ;







extern int vfwscanf (__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfwscanf")


                                                          ;
extern int vwscanf (const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vwscanf")

                                                          ;
extern int vswscanf (const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) noexcept (true) __asm__ ("" "__isoc99_vswscanf")


                                                          ;
# 744 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 799 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 825 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 835 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);






extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) noexcept (true);




extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) noexcept (true);
# 875 "/usr/include/wchar.h" 3 4
}
# 46 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 2 3
# 63 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 136 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;


  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }



}







namespace __gnu_cxx
{





  using ::wcstold;
# 258 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 278 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 42 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 2 3
# 69 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 89 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3
  typedef long streamoff;
# 99 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 112 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 134 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 42 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 75 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/exception" 1 3
# 35 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/exception" 3
# 35 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/exception" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 60 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() throw() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
# 117 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/exception" 3
  bool uncaught_exception() throw() __attribute__ ((__pure__));


}

namespace __gnu_cxx
{
# 142 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop




# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/exception_ptr.h" 1 3
# 34 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)



# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/exception_defines.h" 1 3
# 38 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/exception_ptr.h" 2 3





extern "C++" {

namespace std
{




  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() throw();


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {




    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) throw();

      void _M_addref() throw();
      void _M_release() throw();

      void *_M_get() const throw() __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() throw();
      friend void std::rethrow_exception(exception_ptr);

    public:
      exception_ptr() throw();

      exception_ptr(const exception_ptr&) throw();


      exception_ptr(nullptr_t) throw()
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) throw()
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }







      exception_ptr&
      operator=(const exception_ptr&) throw();


      exception_ptr&
      operator=(exception_ptr&& __o) throw()
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() throw();

      void
      swap(exception_ptr&) throw();
# 132 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&) throw()
      __attribute__ ((__pure__));

      const class type_info*
      __cxa_exception_type() const throw() __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&) throw()
    __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&) throw()
    __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

  }



  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) throw()
    {
      if (true)
 {



 }
      if (false)
 {
   return current_exception();
 }
    }




  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) throw()
    { return std::copy_exception<_Ex>(__ex); }


}

}

#pragma GCC visibility pop
# 154 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/exception" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/nested_exception.h" 1 3
# 33 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/nested_exception.h" 3
#pragma GCC visibility push(default)
# 45 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/nested_exception.h" 3
extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() throw() : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) = default;

    nested_exception& operator=(const nested_exception&) = default;

    virtual ~nested_exception();

    void
    rethrow_nested() const __attribute__ ((__noreturn__))
    { rethrow_exception(_M_ptr); }

    exception_ptr
    nested_ptr() const
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };

  template<typename _Ex>
    struct __get_nested_helper
    {
      static const nested_exception*
      _S_get(const _Ex& __ex)
      { return dynamic_cast<const nested_exception*>(&__ex); }
    };

  template<typename _Ex>
    struct __get_nested_helper<_Ex*>
    {
      static const nested_exception*
      _S_get(const _Ex* __ex)
      { return dynamic_cast<const nested_exception*>(__ex); }
    };

  template<typename _Ex>
    inline const nested_exception*
    __get_nested_exception(const _Ex& __ex)
    { return __get_nested_helper<_Ex>::_S_get(__ex); }

  template<typename _Ex>
    void
    __throw_with_nested(_Ex&&, const nested_exception* = 0)
    __attribute__ ((__noreturn__));

  template<typename _Ex>
    void
    __throw_with_nested(_Ex&&, ...) __attribute__ ((__noreturn__));




  template<typename _Ex>
    inline void
    __throw_with_nested(_Ex&& __ex, const nested_exception*)
    { throw __ex; }

  template<typename _Ex>
    inline void
    __throw_with_nested(_Ex&& __ex, ...)
    { throw _Nested_exception<_Ex>(static_cast<_Ex&&>(__ex)); }

  template<typename _Ex>
    void
    throw_with_nested(_Ex __ex) __attribute__ ((__noreturn__));



  template<typename _Ex>
    inline void
    throw_with_nested(_Ex __ex)
    {
      if (__get_nested_exception(__ex))
        throw __ex;
      __throw_with_nested(static_cast<_Ex&&>(__ex), &__ex);
    }


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    {
      if (const nested_exception* __nested = __get_nested_exception(__ex))
        __nested->rethrow_nested();
    }


  inline void
  rethrow_if_nested(const nested_exception& __ex)
  { __ex.rethrow_nested(); }


}

}



#pragma GCC visibility pop
# 155 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/exception" 2 3
# 40 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 1 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 3

# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 1 3
# 61 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/functexcept.h" 1 3
# 43 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/functexcept.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 62 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cpp_type_traits.h" 1 3
# 36 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cpp_type_traits.h" 3
# 36 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cpp_type_traits.h" 3
# 68 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    class __normal_iterator;


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<typename _Iterator>
    class move_iterator;

  template<typename _Iterator>
    struct __is_move_iterator< move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



}
# 63 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/type_traits.h" 1 3
# 33 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/type_traits.h" 3
# 33 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
# 64 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/numeric_traits.h" 1 3
# 32 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/numeric_traits.h" 3
# 32 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
# 53 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 98 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 65 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_pair.h" 1 3
# 60 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_pair.h" 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/move.h" 1 3
# 34 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/move.h" 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/concept_check.h" 1 3
# 33 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/concept_check.h" 3
# 33 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/concept_check.h" 3
# 35 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r)
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}



# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/type_traits" 1 3
# 32 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/type_traits" 3
# 32 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/type_traits" 3







namespace std __attribute__ ((__visibility__ ("default")))
{






  struct __sfinae_types
  {
    typedef char __one;
    typedef struct { char __arr[2]; } __two;
  };
# 70 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() { return value; }
    };


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };
  template<> struct __is_void_helper<void> : public integral_constant<bool, true> { };




  template<typename _Tp>
    struct is_void
    : public integral_constant<bool, (__is_void_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };
  template<> struct __is_integral_helper<bool> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<char> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<signed char> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned char> : public integral_constant<bool, true> { };

  template<> struct __is_integral_helper<wchar_t> : public integral_constant<bool, true> { };

  template<> struct __is_integral_helper<char16_t> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<char32_t> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<short> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned short> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<int> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned int> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<long> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned long> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<long long> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned long long> : public integral_constant<bool, true> { };


  template<typename _Tp>
    struct is_integral
    : public integral_constant<bool, (__is_integral_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };
  template<> struct __is_floating_point_helper<float> : public integral_constant<bool, true> { };
  template<> struct __is_floating_point_helper<double> : public integral_constant<bool, true> { };
  template<> struct __is_floating_point_helper<long double> : public integral_constant<bool, true> { };


  template<typename _Tp>
    struct is_floating_point
    : public integral_constant<bool, (__is_floating_point_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };
  template<typename _Tp> struct __is_pointer_helper<_Tp*> : public integral_constant<bool, true> { };


  template<typename _Tp>
    struct is_pointer
    : public integral_constant<bool, (__is_pointer_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };


  template<typename _Tp>
    struct is_reference;


  template<typename _Tp>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };
  template<typename _Tp, typename _Cp> struct __is_member_object_pointer_helper<_Tp _Cp::*> : public integral_constant<bool, !is_function<_Tp>::value> { };



  template<typename _Tp>
    struct is_member_object_pointer
    : public integral_constant<bool, (__is_member_object_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };
  template<typename _Tp, typename _Cp> struct __is_member_function_pointer_helper<_Tp _Cp::*> : public integral_constant<bool, is_function<_Tp>::value> { };



  template<typename _Tp>
    struct is_member_function_pointer
    : public integral_constant<bool, (__is_member_function_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...)>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......)>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile>
    : public true_type { };

  template<typename>
    struct __is_nullptr_t_helper
    : public false_type { };
  template<> struct __is_nullptr_t_helper<std::nullptr_t> : public integral_constant<bool, true> { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public integral_constant<bool, (__is_nullptr_t_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };




  template<typename _Tp>
    struct is_arithmetic
    : public integral_constant<bool, (is_integral<_Tp>::value
          || is_floating_point<_Tp>::value)>
    { };


  template<typename _Tp>
    struct is_fundamental
    : public integral_constant<bool, (is_arithmetic<_Tp>::value
          || is_void<_Tp>::value)>
    { };


  template<typename _Tp>
    struct is_object
    : public integral_constant<bool, !(is_function<_Tp>::value
           || is_reference<_Tp>::value
           || is_void<_Tp>::value)>
    { };


  template<typename _Tp>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public integral_constant<bool, (is_arithmetic<_Tp>::value
          || is_enum<_Tp>::value
          || is_pointer<_Tp>::value
          || is_member_pointer<_Tp>::value
          || __is_nullptr_t<_Tp>::value)>
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };


  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };
  template<typename _Tp, typename _Cp> struct __is_member_pointer_helper<_Tp _Cp::*> : public integral_constant<bool, true> { };

  template<typename _Tp>
  struct is_member_pointer
    : public integral_constant<bool, (__is_member_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };



  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };


  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };


  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };


  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint = 0>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };




  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };




  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };




  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };

  template<typename>
    struct remove_reference;


  template<typename _Tp>
    struct add_pointer
    { typedef typename remove_reference<_Tp>::type* type; };




  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };




  template<typename _Tp>
    struct is_reference
    : public integral_constant<bool, (is_lvalue_reference<_Tp>::value
          || is_rvalue_reference<_Tp>::value)>
    { };




  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp,
    bool = !is_reference<_Tp>::value && !is_void<_Tp>::value,
    bool = is_rvalue_reference<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true, false>
    { typedef _Tp& type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, false, true>
    { typedef typename remove_reference<_Tp>::type& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp,
    bool = !is_reference<_Tp>::value && !is_void<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp,
    bool = is_integral<_Tp>::value,
    bool = is_floating_point<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, false, true>
    : public true_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true, false>
    : public integral_constant<bool, static_cast<bool>(_Tp(-1) < _Tp(0))>
    { };


  template<typename _Tp>
    struct is_signed
    : public integral_constant<bool, __is_signed_helper<_Tp>::value>
    { };


  template<typename _Tp>
    struct is_unsigned
    : public integral_constant<bool, (is_arithmetic<_Tp>::value
          && !is_signed<_Tp>::value)>
    { };




  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };

  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename _Tp, typename... _Args>
    class __is_constructible_helper
    : public __sfinae_types
    {
      template<typename _Tp1, typename... _Args1>
        static decltype(_Tp1(declval<_Args1>()...), __one()) __test(int);

      template<typename, typename...>
        static __two __test(...);

    public:
      static const bool __value = sizeof(__test<_Tp, _Args...>(0)) == 1;
    };

  template<typename _Tp, typename _Arg>
    class __is_constructible_helper<_Tp, _Arg>
    : public __sfinae_types
    {
      template<typename _Tp1, typename _Arg1>
        static decltype(static_cast<_Tp1>(declval<_Arg1>()), __one())
 __test(int);

      template<typename, typename>
        static __two __test(...);

    public:
      static const bool __value = sizeof(__test<_Tp, _Arg>(0)) == 1;
    };




  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public integral_constant<bool,
          __is_constructible_helper<_Tp,
        _Args...>::__value>
    { };

  template<bool, typename _Tp, typename... _Args>
    struct __is_nt_constructible_helper
    { static const bool __value = false; };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_helper<true, _Tp, _Args...>
    { static const bool __value = noexcept(_Tp(declval<_Args>()...)); };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_helper<true, _Tp, _Arg>
    {
      static const bool __value = noexcept(static_cast<_Tp>(declval<_Arg>()));
    };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public integral_constant<bool,
   __is_nt_constructible_helper<is_constructible<_Tp, _Args...>::value,
           _Tp, _Args...>::__value>
    { };


  template<typename _Tp>
    struct has_trivial_default_constructor
    : public integral_constant<bool, __has_trivial_constructor(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_copy_constructor
    : public integral_constant<bool, __has_trivial_copy(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_copy_assign
    : public integral_constant<bool, __has_trivial_assign(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_destructor
    : public integral_constant<bool, __has_trivial_destructor(_Tp)>
    { };


  template<typename _Tp>
    struct has_nothrow_default_constructor
    : public integral_constant<bool, __has_nothrow_constructor(_Tp)>
    { };


  template<typename _Tp>
    struct has_nothrow_copy_constructor
    : public integral_constant<bool, __has_nothrow_copy(_Tp)>
    { };


  template<typename _Tp>
    struct has_nothrow_copy_assign
    : public integral_constant<bool, __has_nothrow_assign(_Tp)>
    { };




  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
    bool = (is_void<_From>::value || is_function<_To>::value
     || is_array<_To>::value)>
    struct __is_convertible_helper
    { static const bool __value = is_void<_To>::value; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    : public __sfinae_types
    {
      template<typename _To1>
        static void __test_aux(_To1);

      template<typename _From1, typename _To1>
        static decltype(__test_aux<_To1>(std::declval<_From1>()), __one())
 __test(int);

      template<typename, typename>
        static __two __test(...);

    public:
      static const bool __value = sizeof(__test<_From, _To>(0)) == 1;
    };




  template<typename _From, typename _To>
    struct is_convertible
    : public integral_constant<bool,
          __is_convertible_helper<_From, _To>::__value>
    { };


  template<typename _From, typename _To>
    struct is_explicitly_convertible
    : public is_constructible<_To, _From>
    { };

  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 819 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };





  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };





  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };




  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<const reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };



  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };



  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };



  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      typedef conditional<__b2, unsigned int, unsigned long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };



  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {

      typedef signed char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(signed short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(signed int);
      typedef conditional<__b2, signed int, signed long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, signed short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;


  template<typename... _Tp>
    struct common_type;

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    { typedef decltype(true ? declval<_Tp>() : declval<_Up>()) type; };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    {
      typedef typename
        common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;
    };


  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;

  template<typename _MemPtr, typename _Arg>
    struct _Result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct _Result_of_memobj<_Res _Class::*, _Arg>
    {
    private:
      typedef _Res _Class::* _Func;

      template<typename _Tp>
 static _Tp _S_get(const _Class&);
      template<typename _Tp>
 static decltype(*std::declval<_Tp>()) _S_get(...);

    public:
      typedef
        decltype(_S_get<_Arg>(std::declval<_Arg>()).*std::declval<_Func>())
        __type;
    };

  template<typename _MemPtr, typename _Arg, typename... _ArgTypes>
    struct _Result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct _Result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
    private:
      typedef _Res _Class::* _Func;

      template<typename _Tp>
 static _Tp _S_get(const _Class&);
      template<typename _Tp>
 static decltype(*std::declval<_Tp>()) _S_get(...);

    public:
      typedef
        decltype((_S_get<_Arg>(std::declval<_Arg>()).*std::declval<_Func>())
            (std::declval<_Args>()...) )
        __type;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct _Result_of_impl;

  template<typename _Functor, typename... _ArgTypes>
    struct _Result_of_impl<false, false, _Functor, _ArgTypes...>
    {
      typedef
        decltype( std::declval<_Functor>()(std::declval<_ArgTypes>()...) )
        __type;
    };

  template<typename _MemPtr, typename _Arg>
    struct _Result_of_impl<true, false, _MemPtr, _Arg>
    : _Result_of_memobj<typename remove_reference<_MemPtr>::type, _Arg>
    {
      typedef typename _Result_of_memobj<
 typename remove_reference<_MemPtr>::type, _Arg>::__type
 __type;
    };

  template<typename _MemPtr, typename _Arg, typename... _ArgTypes>
    struct _Result_of_impl<false, true, _MemPtr, _Arg, _ArgTypes...>
    : _Result_of_memfun<typename remove_reference<_MemPtr>::type, _Arg,
                        _ArgTypes...>
    {
      typedef typename _Result_of_memfun<
 typename remove_reference<_MemPtr>::type, _Arg, _ArgTypes...>::__type
 __type;
    };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : _Result_of_impl<is_member_object_pointer<
                        typename remove_reference<_Functor>::type >::value,
                      is_member_function_pointer<
   typename remove_reference<_Functor>::type >::value,
        _Functor, _ArgTypes...>
    {
      typedef typename _Result_of_impl<
 is_member_object_pointer<
   typename remove_reference<_Functor>::type >::value,
        is_member_function_pointer<
   typename remove_reference<_Functor>::type >::value,
        _Functor, _ArgTypes...>::__type
 type;
    };
# 1266 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/type_traits" 3
}
# 54 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    inline _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t)
    { return static_cast<_Tp&&>(__t); }

  template<typename _Tp>
    inline _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t)
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }







  template<typename _Tp>
    inline typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t)
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
# 94 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r)
    { return std::__addressof(__r); }


}
# 109 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 120 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/move.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {



      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }



  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }


}
# 61 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{




  struct piecewise_construct_t { };


  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();


  template<typename...>
    class tuple;

  template<int...>
    struct _Index_tuple;



  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      constexpr pair()
      : first(), second() { }


      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


      template<class _U1, class _U2>
 constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }


      constexpr pair(const pair&) = default;





      template<class _U1, class = typename
        std::enable_if<std::is_convertible<_U1, _T1>::value>::type>
 pair(_U1&& __x, const _T2& __y)
 : first(std::forward<_U1>(__x)), second(__y) { }

      template<class _U2, class = typename
        std::enable_if<std::is_convertible<_U2, _T2>::value>::type>
 pair(const _T1& __x, _U2&& __y)
 : first(__x), second(std::forward<_U2>(__y)) { }

      template<class _U1, class _U2, class = typename
        std::enable_if<std::is_convertible<_U1, _T1>::value
         && std::is_convertible<_U2, _T2>::value>::type>
 pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<class _U1, class _U2>
 pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<class... _Args1, class... _Args2>
 pair(piecewise_construct_t,
      tuple<_Args1...> __first, tuple<_Args2...> __second)
 : first(__cons<first_type>(std::move(__first))),
   second(__cons<second_type>(std::move(__second))) { }

      pair&
      operator=(const pair& __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(pair&& __p)
      {
 first = std::move(__p.first);
 second = std::move(__p.second);
 return *this;
      }

      template<class _U1, class _U2>
 pair&
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<class _U1, class _U2>
 pair&
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::move(__p.first);
   second = std::move(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename _Tp, typename... _Args>
 static _Tp
 __cons(tuple<_Args...>&&);

      template<typename _Tp, typename... _Args, int... _Indexes>
 static _Tp
 __do_cons(tuple<_Args...>&&, const _Index_tuple<_Indexes...>&);

    };


  template<class _T1, class _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<class _T1, class _T2>
    inline void
    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    { __x.swap(__y); }
# 259 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<typename __decay_and_strip<_T1>::__type,
  typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 277 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_pair.h" 3
}
# 66 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_types.h" 1 3
# 63 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_types.h" 3
# 63 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{
# 89 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 116 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 142 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_types.h" 3
template<typename _Tp> class __has_iterator_category_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::iterator_category>*); template<typename _Up> static __two __test(...); public: static const bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_iterator_category : integral_constant<bool, __has_iterator_category_helper <typename remove_cv<_Tp>::type>::value> { };

  template<typename _Iterator,
    bool = __has_iterator_category<_Iterator>::value>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator, true>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 174 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }





  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it.base(); }
    };


}
# 67 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 1 3
# 63 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 3
# 63 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {



      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {



      return __last - __first;
    }
# 110 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {


      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {



      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {



      __i += __n;
    }
# 168 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _ForwardIterator>
    inline _ForwardIterator
    next(_ForwardIterator __x, typename
  iterator_traits<_ForwardIterator>::difference_type __n = 1)
    {
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {
      std::advance(__x, -__n);
      return __x;
    }




}
# 68 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 1 3
# 68 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 96 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 283 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>


    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())





    { return __y.base() - __x.base(); }
# 395 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 429 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 471 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 486 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 519 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 561 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 580 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 631 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 675 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
# 699 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 797 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}



namespace std __attribute__ ((__visibility__ ("default")))
{
# 923 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;
      typedef value_type&& reference;

      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      iterator_type
      base() const
      { return _M_current; }

      reference
      operator*() const
      { return std::move(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline auto
    operator-(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(const _Iterator& __i)
    { return move_iterator<_Iterator>(__i); }




}
# 69 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3

# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/debug/debug.h" 1 3
# 47 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 71 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{





  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = std::move(*__a);
          *__a = std::move(*__b);
          *__b = std::move(__tmp);
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
# 116 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;
# 135 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
# 157 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {





                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 185 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {



      if (__b < __a)
 return __b;
      return __a;
    }
# 208 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {



      if (__a < __b)
 return __b;
      return __a;
    }
# 231 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 252 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }


  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 442 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {




                                                     ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 475 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {




                                                     ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 611 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






                                                     ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 647 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






                                                     ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
# 713 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {



                                                     ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 773 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {



      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = (__is_integer<_ValueType1>::__value
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }
# 934 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;




                                                                  ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }



  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 0; __n >>= 1)
 ++__k;
      return __k - 1;
    }

  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }
# 1008 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {






                                                       ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1040 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1071 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {

      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;




                                                       ;
                                                       ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1105 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;




                                                       ;
                                                       ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 1145 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {






                                                       ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1182 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }


}
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 2 3

# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 1 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3
# 43 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
# 58 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 83 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{
# 227 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>((0xffffffffu)); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}





# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdint" 1 3
# 32 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdint" 3
# 32 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdint" 3
# 49 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdint" 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/clang/bin/../lib/clang/3.1/include/stdint.h" 1 3
# 33 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/clang/bin/../lib/clang/3.1/include/stdint.h" 3
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 34 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/clang/bin/../lib/clang/3.1/include/stdint.h" 2 3
# 50 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdint" 2 3
# 62 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdint" 3
namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 378 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/localefwd.h" 1 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/localefwd.h" 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/localefwd.h" 3


# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++locale.h" 1 3
# 40 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++locale.h" 3
# 40 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++locale.h" 3

# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/clocale" 1 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/clocale" 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) noexcept (true);


extern struct lconv *localeconv (void) noexcept (true);
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) noexcept (true);
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) noexcept (true);



extern void freelocale (locale_t __dataset) noexcept (true);






extern locale_t uselocale (locale_t __dataset) noexcept (true);







}
# 44 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/clocale" 2 3








namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 88 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
# 42 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/localefwd.h" 2 3

# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 1 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4
extern "C" {
# 39 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 40 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     noexcept (true) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     noexcept (true) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     noexcept (true) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) noexcept (true);
extern int isalpha (int) noexcept (true);
extern int iscntrl (int) noexcept (true);
extern int isdigit (int) noexcept (true);
extern int islower (int) noexcept (true);
extern int isgraph (int) noexcept (true);
extern int isprint (int) noexcept (true);
extern int ispunct (int) noexcept (true);
extern int isspace (int) noexcept (true);
extern int isupper (int) noexcept (true);
extern int isxdigit (int) noexcept (true);



extern int tolower (int __c) noexcept (true);


extern int toupper (int __c) noexcept (true);




extern int isblank (int) noexcept (true);




extern int isctype (int __c, int __mask) noexcept (true);






extern int isascii (int __c) noexcept (true);



extern int toascii (int __c) noexcept (true);



extern int _toupper (int) noexcept (true);
extern int _tolower (int) noexcept (true);
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) noexcept (true);
extern int isalpha_l (int, locale_t) noexcept (true);
extern int iscntrl_l (int, locale_t) noexcept (true);
extern int isdigit_l (int, locale_t) noexcept (true);
extern int islower_l (int, locale_t) noexcept (true);
extern int isgraph_l (int, locale_t) noexcept (true);
extern int isprint_l (int, locale_t) noexcept (true);
extern int ispunct_l (int, locale_t) noexcept (true);
extern int isspace_l (int, locale_t) noexcept (true);
extern int isupper_l (int, locale_t) noexcept (true);
extern int isxdigit_l (int, locale_t) noexcept (true);

extern int isblank_l (int, locale_t) noexcept (true);



extern int __tolower_l (int __c, locale_t __l) noexcept (true);
extern int tolower_l (int __c, locale_t __l) noexcept (true);


extern int __toupper_l (int __c, locale_t __l) noexcept (true);
extern int toupper_l (int __c, locale_t __l) noexcept (true);
# 327 "/usr/include/ctype.h" 3 4
}
# 44 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 2 3
# 63 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 44 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 56 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;


}
# 42 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 1 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3

# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/atomicity.h" 1 3
# 34 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/atomicity.h" 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr.h" 1 3
# 30 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 170 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr.h" 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 1 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 22 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 3 4
typedef __time_t time_t;
# 32 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{



  __time_t tv_sec;




  __syscall_slong_t tv_nsec;
# 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 33 "/usr/include/sched.h" 2 3 4





typedef __pid_t pid_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
# 76 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h" 3 4
struct sched_param
{
  int sched_priority;
};
# 77 "/usr/include/x86_64-linux-gnu/bits/sched.h" 2 3 4

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) noexcept (true);


extern int unshare (int __flags) noexcept (true);


extern int sched_getcpu (void) noexcept (true);


extern int getcpu (unsigned int *, unsigned int *) noexcept (true);


extern int setns (int __fd, int __nstype) noexcept (true);


}
# 44 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 115 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
     noexcept (true);
extern cpu_set_t *__sched_cpualloc (size_t __count) noexcept (true) ;
extern void __sched_cpufree (cpu_set_t *__set) noexcept (true);

}
# 45 "/usr/include/sched.h" 2 3 4






extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     noexcept (true);


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) noexcept (true);


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) noexcept (true);


extern int sched_getscheduler (__pid_t __pid) noexcept (true);


extern int sched_yield (void) noexcept (true);


extern int sched_get_priority_max (int __algorithm) noexcept (true);


extern int sched_get_priority_min (int __algorithm) noexcept (true);



extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) noexcept (true);
# 130 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) noexcept (true);


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) noexcept (true);


}
# 23 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{




  __time_t tv_sec;
  __suseconds_t tv_usec;

};
# 23 "/usr/include/x86_64-linux-gnu/bits/timex.h" 2 3 4



struct timex
{
# 58 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;

};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) noexcept (true);
# 90 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
}
# 34 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 38 "/usr/include/time.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 47 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 48 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4
extern "C" {



extern clock_t clock (void) noexcept (true);



extern time_t time (time_t *__timer) noexcept (true);


extern double difftime (time_t __time1, time_t __time0)
     noexcept (true) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) noexcept (true);
# 100 "/usr/include/time.h" 3 4
extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) noexcept (true);




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     noexcept (true);






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) noexcept (true);



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) noexcept (true);






extern struct tm *gmtime (const time_t *__timer) noexcept (true);



extern struct tm *localtime (const time_t *__timer) noexcept (true);
# 154 "/usr/include/time.h" 3 4
extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) noexcept (true);



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) noexcept (true);
# 179 "/usr/include/time.h" 3 4
extern char *asctime (const struct tm *__tp) noexcept (true);



extern char *ctime (const time_t *__timer) noexcept (true);
# 197 "/usr/include/time.h" 3 4
extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) noexcept (true);



extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) noexcept (true);
# 217 "/usr/include/time.h" 3 4
extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) noexcept (true);



extern int daylight;
extern long int timezone;
# 249 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) noexcept (true);

extern time_t timelocal (struct tm *__tp) noexcept (true);
# 262 "/usr/include/time.h" 3 4
extern int dysize (int __year) noexcept (true) __attribute__ ((__const__));
# 272 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);


extern int clock_getres (clockid_t __clock_id, struct timespec *__res) noexcept (true);


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) noexcept (true);


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     noexcept (true);
# 311 "/usr/include/time.h" 3 4
extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);
# 326 "/usr/include/time.h" 3 4
extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) noexcept (true);




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) noexcept (true);


extern int timer_delete (timer_t __timerid) noexcept (true);



extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) noexcept (true);


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     noexcept (true);
# 364 "/usr/include/time.h" 3 4
extern int timer_getoverrun (timer_t __timerid) noexcept (true);






extern int timespec_get (struct timespec *__ts, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 387 "/usr/include/time.h" 3 4
extern int timespec_getres (struct timespec *__ts, int __base)
     noexcept (true);
# 413 "/usr/include/time.h" 3 4
extern int getdate_err;
# 422 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 436 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 24 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 3 4
typedef union
{
  __extension__ unsigned long long int __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
# 47 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 76 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 89 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 90 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 27 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 31 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h" 3 4
struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };
# 32 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 3 4
extern "C" {
extern long int __sysconf (int __name) noexcept (true);
}
# 34 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 104 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 124 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 159 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 197 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) noexcept (true) __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) noexcept (true);
# 233 "/usr/include/pthread.h" 3 4
extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);
# 243 "/usr/include/pthread.h" 3 4
extern int pthread_clockjoin_np (pthread_t __th, void **__thread_return,
                                 clockid_t __clockid,
     const struct timespec *__abstime);
# 269 "/usr/include/pthread.h" 3 4
extern int pthread_detach (pthread_t __th) noexcept (true);



extern pthread_t pthread_self (void) noexcept (true) __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  noexcept (true) __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_setsigmask_np (pthread_attr_t *__attr,
           const __sigset_t *sigmask);




extern int pthread_attr_getsigmask_np (const pthread_attr_t *__attr,
           __sigset_t *sigmask);







extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     noexcept (true) __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     noexcept (true);




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) noexcept (true);


extern int pthread_setconcurrency (int __level) noexcept (true);



extern int pthread_yield (void) noexcept (true);

extern int pthread_yield (void) noexcept (true) __asm__ ("" "sched_yield")
  __attribute__ ((__deprecated__ ("pthread_yield is deprecated, use sched_yield instead")));
# 489 "/usr/include/pthread.h" 3 4
extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     noexcept (true) __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 509 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 521 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




struct __cancel_jmp_buf_tag
{
  __jmp_buf __cancel_jmp_buf;
  int __mask_was_saved;
};

typedef struct
{
  struct __cancel_jmp_buf_tag __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 557 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
# 697 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
                            ;
# 709 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
                         ;
# 732 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
                            ;
# 745 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
                         ;



extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
                             __attribute__ ((__noreturn__))

     __attribute__ ((__weak__))

     ;
# 773 "/usr/include/pthread.h" 3 4
extern int __sigsetjmp (struct __jmp_buf_tag __env[1],
   int __savemask) noexcept (true);






extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
# 817 "/usr/include/pthread.h" 3 4
extern int pthread_mutex_clocklock (pthread_mutex_t *__restrict __mutex,
        clockid_t __clockid,
        const struct timespec *__restrict
        __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 835 "/usr/include/pthread.h" 3 4
extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_consistent_np (pthread_mutex_t *) noexcept (true) __asm__ ("" "pthread_mutex_consistent") __attribute__ ((__nonnull__ (1)))

  __attribute__ ((__deprecated__ ("pthread_mutex_consistent_np is deprecated, use pthread_mutex_consistent")));
# 874 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_getrobust_np (pthread_mutexattr_t *, int *) noexcept (true) __asm__ ("" "pthread_mutexattr_getrobust") __attribute__ ((__nonnull__ (1)))


  __attribute__ ((__deprecated__ ("pthread_mutexattr_getrobust_np is deprecated, use pthread_mutexattr_getrobust")));







extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *, int) noexcept (true) __asm__ ("" "pthread_mutexattr_setrobust") __attribute__ ((__nonnull__ (1)))


  __attribute__ ((__deprecated__ ("pthread_mutexattr_setrobust_np is deprecated, use pthread_mutexattr_setrobust")));
# 967 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
# 1004 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_clockrdlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 1023 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
# 1051 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_clockwrlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 1071 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) noexcept (true) __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     noexcept (true) __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1145 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));
# 1171 "/usr/include/pthread.h" 3 4
extern int pthread_cond_clockwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __clockid_t __clock_id,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 4)));
# 1194 "/usr/include/pthread.h" 3 4
extern int pthread_condattr_init (pthread_condattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 1230 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 1297 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) noexcept (true);


extern void *pthread_getspecific (pthread_key_t __key) noexcept (true);


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer)
  noexcept (true) ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     noexcept (true) __attribute__ ((__nonnull__ (2)));
# 1332 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) noexcept (true);
# 1346 "/usr/include/pthread.h" 3 4
}
# 42 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 2 3
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4
extern "C" {
# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 220 "/usr/include/unistd.h" 3 4
typedef __ssize_t ssize_t;






# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4





typedef __gid_t gid_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __useconds_t useconds_t;
# 274 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int execveat (int __fd, const char *__path, char *const __argv[],
                     char *const __envp[], int __flags)
    noexcept (true) __attribute__ ((__nonnull__ (2, 3)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     noexcept (true) __attribute__ ((__nonnull__ (2))) ;
# 339 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) noexcept (true);
# 350 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     noexcept (true);






extern int close (int __fd);




extern void closefrom (int __lowfd) noexcept (true);







extern ssize_t read (int __fd, void *__buf, size_t __nbytes)
                                                  ;





extern ssize_t write (int __fd, const void *__buf, size_t __n)
                                         ;
# 389 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset)
                                                  ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset)
                                         ;
# 422 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset)
                                                  ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset)
                                         ;







extern int pipe (int __pipedes[2]) noexcept (true) ;




extern int pipe2 (int __pipedes[2], int __flags) noexcept (true) ;
# 452 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) noexcept (true);
# 464 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     noexcept (true);






extern int usleep (__useconds_t __useconds);
# 489 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) noexcept (true) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     noexcept (true) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) noexcept (true) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) noexcept (true) ;
# 531 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) noexcept (true) ;





extern char *get_current_dir_name (void) noexcept (true);







extern char *getwd (char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__))
                                       ;




extern int dup (int __fd) noexcept (true) ;


extern int dup2 (int __fd, int __fd2) noexcept (true);




extern int dup3 (int __fd, int __fd2, int __flags) noexcept (true);



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     noexcept (true) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) noexcept (true) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));






# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT,


    _SC_MINSIGSTKSZ,


    _SC_SIGSTKSZ

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 631 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) noexcept (true);


extern long int sysconf (int __name) noexcept (true);



extern size_t confstr (int __name, char *__buf, size_t __len) noexcept (true)
                                                  ;




extern __pid_t getpid (void) noexcept (true);


extern __pid_t getppid (void) noexcept (true);


extern __pid_t getpgrp (void) noexcept (true);


extern __pid_t __getpgid (__pid_t __pid) noexcept (true);

extern __pid_t getpgid (__pid_t __pid) noexcept (true);






extern int setpgid (__pid_t __pid, __pid_t __pgid) noexcept (true);
# 682 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) noexcept (true);






extern __pid_t setsid (void) noexcept (true);



extern __pid_t getsid (__pid_t __pid) noexcept (true);



extern __uid_t getuid (void) noexcept (true);


extern __uid_t geteuid (void) noexcept (true);


extern __gid_t getgid (void) noexcept (true);


extern __gid_t getegid (void) noexcept (true);




extern int getgroups (int __size, __gid_t __list[]) noexcept (true)
                                                  ;


extern int group_member (__gid_t __gid) noexcept (true);






extern int setuid (__uid_t __uid) noexcept (true) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) noexcept (true) ;




extern int seteuid (__uid_t __uid) noexcept (true) ;






extern int setgid (__gid_t __gid) noexcept (true) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) noexcept (true) ;




extern int setegid (__gid_t __gid) noexcept (true) ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     noexcept (true);



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     noexcept (true);



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     noexcept (true) ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     noexcept (true) ;






extern __pid_t fork (void) noexcept (true);







extern __pid_t vfork (void) noexcept (true);






extern __pid_t _Fork (void) noexcept (true);





extern char *ttyname (int __fd) noexcept (true);



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2)))
                                                   ;



extern int isatty (int __fd) noexcept (true);




extern int ttyslot (void) noexcept (true);




extern int link (const char *__from, const char *__to)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     noexcept (true) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)))
                                                   ;





extern int symlinkat (const char *__from, int __tofd,
        const char *__to) noexcept (true) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)))
                                                   ;



extern int unlink (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     noexcept (true) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) noexcept (true);


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) noexcept (true);






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)))
                                                  ;




extern int setlogin (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1)));








# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern "C" {







extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       noexcept (true) __attribute__ ((__nonnull__ (2, 3)));

}
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4

extern "C" {
# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
}
# 904 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) noexcept (true) __attribute__ ((__nonnull__ (1)))
                                                  ;






extern int sethostname (const char *__name, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) noexcept (true) ;





extern int getdomainname (char *__name, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (1)))
                                                   ;
extern int setdomainname (const char *__name, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern int vhangup (void) noexcept (true);


extern int revoke (const char *__file) noexcept (true) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) noexcept (true);



extern char *getusershell (void) noexcept (true);
extern void endusershell (void) noexcept (true);
extern void setusershell (void) noexcept (true);





extern int daemon (int __nochdir, int __noclose) noexcept (true) ;






extern int chroot (const char *__path) noexcept (true) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) noexcept (true);






extern long int gethostid (void);


extern void sync (void) noexcept (true);





extern int getpagesize (void) noexcept (true) __attribute__ ((__const__));




extern int getdtablesize (void) noexcept (true);
# 1026 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 1038 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 1049 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) noexcept (true) ;
# 1059 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) noexcept (true) ;
# 1070 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) noexcept (true) ;





extern void *sbrk (intptr_t __delta) noexcept (true);
# 1091 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) noexcept (true);
# 1114 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1124 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1142 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);
# 1159 "/usr/include/unistd.h" 3 4
extern char *crypt (const char *__key, const char *__salt)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));







extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)))

                                          ;
# 1198 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length)
                                          ;
# 1208 "/usr/include/unistd.h" 3 4
extern int close_range (unsigned int __fd, unsigned int __max_fd,
   int __flags) noexcept (true);
# 1218 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 3 4
extern __pid_t gettid (void) noexcept (true);




# 1 "/usr/include/linux/close_range.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 2 3 4
# 1219 "/usr/include/unistd.h" 2 3 4

}
# 43 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 2 3

typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 118 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));


static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));


static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));


static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 239 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw_pthread_cancel;






  return __gthread_active_ptr != 0;
}
# 657 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}



static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}



static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 800 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}



static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}



static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait_recursive (__gthread_cond_t *__cond,
        __gthread_recursive_mutex_t *__mutex,
        const __gthread_time_t *__abs_timeout)
{
  return __gthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 171 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr.h" 2 3







#pragma GCC visibility pop
# 35 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/atomicity.h" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/atomic_word.h" 1 3
# 32 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 36 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __sync_fetch_and_add(__mem, __val); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __sync_fetch_and_add(__mem, __val); }
# 63 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 2 3

# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 1 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3


# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 1 3
# 38 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 3
# 38 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 3




# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/allocator.h" 1 3
# 48 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/allocator.h" 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++allocator.h" 1 3
# 34 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++allocator.h" 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/new_allocator.h" 1 3
# 34 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/new_allocator.h" 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/new" 1 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/new" 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/new" 3




#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 92 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
# 35 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/new_allocator.h" 2 3



namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
# 53 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }


      template<typename... _Args>
        void
        construct(pointer __p, _Args&&... __args)
 { ::new((void *)__p) _Tp(std::forward<_Args>(__args)...); }


      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 35 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++allocator.h" 2 3
# 49 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/allocator.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 65 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/allocator.h" 3
  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };
# 91 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }




  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };
# 191 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/allocator.h" 3
  template<typename _Tp,
    bool = __has_trivial_copy(typename _Tp::value_type)>
    struct __shrink_to_fit
    { static void _S_do_it(_Tp&) { } };

  template<typename _Tp>
    struct __shrink_to_fit<_Tp, true>
    {
      static void
      _S_do_it(_Tp& __v)
      {
 if (true)
   { _Tp(__v).swap(__v); }
 if (false) { }
      }
    };



  struct allocator_arg_t { };

  constexpr allocator_arg_t allocator_arg = allocator_arg_t();

template<typename _Tp> class __has_allocator_type_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::allocator_type>*); template<typename _Up> static __two __test(...); public: static const bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_allocator_type : integral_constant<bool, __has_allocator_type_helper <typename remove_cv<_Tp>::type>::value> { };

  template<typename _Tp, typename _Alloc,
    bool = __has_allocator_type<_Tp>::value>
    struct __uses_allocator_helper
    : public false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc, true>
    : public integral_constant<bool, is_convertible<_Alloc,
         typename _Tp::allocator_type>::value>
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : public integral_constant<bool,
          __uses_allocator_helper<_Tp, _Alloc>::value>
    { };




}
# 43 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 2 3


# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream_insert.h" 1 3
# 33 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream_insert.h" 3
# 33 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream_insert.h" 3


# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cxxabi_forced.h" 1 3
# 34 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cxxabi_forced.h" 3
# 34 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 36 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   if (true)
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   if (false)
     {
       __out._M_setstate(__ios_base::badbit);
                              ;
     }
   if (false)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 46 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 2 3



# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 1 3
# 60 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 101 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 140 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 204 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 268 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
# 351 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 422 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 541 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}



# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/backward/binders.h" 1 3
# 60 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/backward/binders.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 99 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}
# 732 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 2 3
# 50 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 2 3


# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/range_access.h" 1 3
# 33 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/range_access.h" 3
# 33 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/range_access.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{







  template<class _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<class _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<class _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<class _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<class _Tp, size_t _Nm>
    inline _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<class _Tp, size_t _Nm>
    inline _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }


}
# 53 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 1 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3



# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/initializer_list" 1 3
# 33 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/initializer_list" 3
# 33 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/initializer_list" 3



#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() { return _M_len; }


      constexpr const_iterator
      begin() { return _M_array; }


      constexpr const_iterator
      end() { return begin() + size(); }
  };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils)
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils)
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 43 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 105 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 142 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 167 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);


     }
 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {

                                                                  ;
       if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
        -1) <= 0)
  {
                                                              ;
    _M_destroy(__a);
  }
     }
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      basic_string()

      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }







      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 477 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
# 501 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string(basic_string&& __str)
      : _M_dataplus(__str._M_dataplus)
      {

 __str._M_data(_S_empty_rep()._M_refdata());



      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc());
# 525 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 558 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 573 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      {

 this->swap(__str);
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }







      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const
      { return _M_rep()->_M_length; }



      size_type
      length() const
      { return _M_rep()->_M_length; }


      size_type
      max_size() const
      { return _Rep::_S_max_size; }
# 733 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 746 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit()
      {
 if (true)
   { reserve(0); }
 if (false)
   { }
      }






      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
# 787 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear()
      { _M_mutate(0, this->size(), 0); }





      bool
      empty() const
      { return this->size() == 0; }
# 816 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
                                       ;
 return _M_data()[__pos];
      }
# 833 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

                                       ;

                                         ;
 _M_leak();
 return _M_data()[__pos];
      }
# 854 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }






      reference
      front()
      { return operator[](0); }





      const_reference
      front() const
      { return operator[](0); }





      reference
      back()
      { return operator[](this->size() - 1); }





      const_reference
      back() const
      { return operator[](this->size() - 1); }
# 907 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }







      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }







      basic_string&
      append(const basic_string& __str);
# 978 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
                               ;
 return this->append(__s, traits_type::length(__s));
      }
# 1010 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1032 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 1068 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      {
 this->swap(__str);
 return *this;
      }
# 1088 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 1104 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 1116 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
                               ;
 return this->assign(__s, traits_type::length(__s));
      }
# 1132 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1144 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1172 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 1187 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1199 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
                                                                 ;
 this->insert(__p - _M_ibegin(), __l.begin(), __l.size());
      }
# 1218 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1240 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1263 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1281 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
                               ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1304 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1321 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
                                                                 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1345 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1361 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1381 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1400 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1422 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1446 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1465 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
                               ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1488 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1506 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1524 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1545 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
                               ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1566 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1588 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {

                            ;
                                             ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1658 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string& replace(iterator __i1, iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }


    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
        __end, __a); }

      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1744 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1754 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1764 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      const _CharT*
      c_str() const
      { return _M_data(); }







      const _CharT*
      data() const
      { return _M_data(); }




      allocator_type
      get_allocator() const
      { return _M_dataplus; }
# 1796 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1809 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
# 1823 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1840 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const;
# 1853 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1868 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1881 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1898 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
# 1911 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1926 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1939 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 1958 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
# 1972 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 1987 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 2000 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2019 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
# 2033 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2048 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 2062 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2079 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
# 2092 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2108 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 2121 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2138 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
# 2153 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2171 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2201 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2225 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2243 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2266 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2291 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
# 2303 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 2424 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2470 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 2507 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2544 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2581 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2618 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2655 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2672 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 2690 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 2713 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2731 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}





# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/string_conversions.h" 1 3
# 32 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/string_conversions.h" 3
# 32 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/string_conversions.h" 3




# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 1 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3
# 65 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 26 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdlib.h" 2 3 4





# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 59 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 98 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) noexcept (true) ;



extern double atof (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) noexcept (true) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 141 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 159 "/usr/include/stdlib.h" 3 4
extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 177 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 233 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 251 "/usr/include/stdlib.h" 3 4
extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 275 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 317 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 338 "/usr/include/stdlib.h" 3 4
extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 386 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) noexcept (true) ;


extern long int a64l (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;
# 69 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __mode_t mode_t;




typedef __nlink_t nlink_t;
# 103 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __id_t id_t;
# 114 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 138 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __suseconds_t suseconds_t;






# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;







typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{



  return ((__uint16_t) ((((__bsx) >> 8) & 0xff) | (((__bsx) & 0xff) << 8)));

}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{



  return ((((__bsx) & 0xff000000u) >> 24) | (((__bsx) & 0x00ff0000u) >> 8) | (((__bsx) & 0x0000ff00u) << 8) | (((__bsx) & 0x000000ffu) << 24));

}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{



  return ((((__bsx) & 0xff00000000000000ull) >> 56) | (((__bsx) & 0x00ff000000000000ull) >> 40) | (((__bsx) & 0x0000ff0000000000ull) >> 24) | (((__bsx) & 0x000000ff00000000ull) >> 8) | (((__bsx) & 0x00000000ff000000ull) << 8) | (((__bsx) & 0x0000000000ff0000ull) << 24) | (((__bsx) & 0x000000000000ff00ull) << 40) | (((__bsx) & 0x00000000000000ffull) << 56));

}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4






typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 102 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 127 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 153 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
# 230 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
}
# 396 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) noexcept (true);


extern void srandom (unsigned int __seed) noexcept (true);





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) noexcept (true) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) noexcept (true);

extern void srand (unsigned int __seed) noexcept (true);



extern int rand_r (unsigned int *__seed) noexcept (true);







extern double drand48 (void) noexcept (true);
extern double erand48 (unsigned short int __xsubi[3]) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) noexcept (true);
extern long int nrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) noexcept (true);
extern long int jrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) noexcept (true);
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) noexcept (true) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
                                         ;

extern void *calloc (size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) ;






extern void *realloc (void *__ptr, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__)) ;


extern void free (void *__ptr) noexcept (true);







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__))

                       ;


extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) ;




# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) noexcept (true);





}
# 575 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
                                         ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__malloc__))
                                         ;



extern void abort (void) noexcept (true) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) noexcept (true) __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     noexcept (true) __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 617 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void _Exit (int __status) noexcept (true) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     noexcept (true) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) noexcept (true);
# 682 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1)));
# 695 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 705 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 727 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 738 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 749 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 759 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 769 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 781 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 791 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__malloc__))
                              ;
# 808 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) noexcept (true) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) noexcept (true) __attribute__ ((__const__)) ;
extern long int labs (long int __x) noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     noexcept (true) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
# 880 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) noexcept (true);


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) noexcept (true);


extern int wctomb (char *__s, wchar_t __wchar) noexcept (true);



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) noexcept (true)
                                      ;

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     noexcept (true)

                                    ;






extern int rpmatch (const char *__response) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 967 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) noexcept (true);



extern int unlockpt (int __fd) noexcept (true);




extern char *ptsname (int __fd) noexcept (true) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) ;


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 1023 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1024 "/usr/include/stdlib.h" 2 3 4
# 1035 "/usr/include/stdlib.h" 3 4
}
# 66 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 2 3
# 97 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;


  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }


}
# 157 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }


  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 192 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



namespace std
{


  using std::lldiv_t;


  using std::llabs;
  using std::lldiv;


  using std::atoll;
  using std::strtoll;
  using std::strtoull;

  using std::strtof;
  using std::strtold;


  using std::abs;

  using std::div;

}
# 37 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/string_conversions.h" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 1 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3
# 38 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/string_conversions.h" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 1 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 3


# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4

extern "C" {




# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 3 4
typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 84 "/usr/include/stdio.h" 3 4
typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4
# 143 "/usr/include/stdio.h" 3 4
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) noexcept (true);

extern int rename (const char *__old, const char *__new) noexcept (true);



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) noexcept (true);
# 170 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) noexcept (true);






extern int fclose (FILE *__stream);
# 188 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void)
  __attribute__ ((__malloc__)) ;
# 200 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void)
   __attribute__ ((__malloc__)) ;



extern char *tmpnam (char[20]) noexcept (true) ;




extern char *tmpnam_r (char __s[20]) noexcept (true) ;
# 222 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
   noexcept (true) __attribute__ ((__malloc__)) ;






extern int fflush (FILE *__stream);
# 239 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 249 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 258 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes)
  __attribute__ ((__malloc__)) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 283 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes)
  __attribute__ ((__malloc__)) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) noexcept (true)
  __attribute__ ((__malloc__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) noexcept (true)
  __attribute__ ((__malloc__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  noexcept (true) __attribute__ ((__malloc__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) noexcept (true)
  __attribute__ ((__malloc__)) ;





extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) noexcept (true)
  __attribute__ ((__malloc__)) ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) noexcept (true);



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) noexcept (true);




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) noexcept (true);


extern void setlinebuf (FILE *__stream) noexcept (true);







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) noexcept (true);





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) noexcept (true);



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) noexcept (true);
# 434 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf") ;


extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf") ;

extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) noexcept (true) __asm__ ("" "__isoc99_sscanf");
# 459 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__scanf__, 2, 0)));





extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept (true) __asm__ ("" "__isoc99_vsscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 513 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 538 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 549 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 565 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
                                                         ;
# 605 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));
# 615 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream)
                                                  ;
# 632 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 691 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 702 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 736 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 760 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 779 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) noexcept (true);

extern int feof (FILE *__stream) noexcept (true) ;

extern int ferror (FILE *__stream) noexcept (true) ;



extern void clearerr_unlocked (FILE *__stream) noexcept (true);
extern int feof_unlocked (FILE *__stream) noexcept (true) ;
extern int ferror_unlocked (FILE *__stream) noexcept (true) ;







extern void perror (const char *__s);




extern int fileno (FILE *__stream) noexcept (true) ;




extern int fileno_unlocked (FILE *__stream) noexcept (true) ;
# 823 "/usr/include/stdio.h" 3 4
extern int pclose (FILE *__stream);





extern FILE *popen (const char *__command, const char *__modes)
  __attribute__ ((__malloc__)) ;






extern char *ctermid (char *__s) noexcept (true)
                                     ;





extern char *cuserid (char *__s)
                                     ;




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) noexcept (true);



extern int ftrylockfile (FILE *__stream) noexcept (true) ;


extern void funlockfile (FILE *__stream) noexcept (true);
# 885 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 902 "/usr/include/stdio.h" 3 4
}
# 44 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 2 3
# 91 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 147 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 3
namespace __gnu_cxx
{
# 165 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/string_conversions.h" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cerrno" 1 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cerrno" 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cerrno" 3

# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4





extern "C" {


extern int *__errno_location (void) noexcept (true) __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;


# 1 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4



}
# 43 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cerrno" 2 3
# 40 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;
      (*__errno_location ()) = 0;
      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
        || (std::__are_same<_Ret, int>::__value
     && (__tmp < __numeric_traits<int>::__min
         || __tmp > __numeric_traits<int>::__max)))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 2756 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }




  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }


  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }


  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}






# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/functional_hash.h" 1 3
# 33 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/functional_hash.h" 3
# 33 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/functional_hash.h" 3

# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/hash_bytes.h" 1 3
# 33 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/hash_bytes.h" 3
# 33 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 35 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/functional_hash.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 48 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type;
      typedef _Arg argument_type;
    };


  template<typename _Tp>
    struct hash : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const;
    };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const
      { return reinterpret_cast<size_t>(__p); }
    };
# 80 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/functional_hash.h" 3
  template<> inline size_t hash<bool>::operator()(bool __val) const { return static_cast<size_t>(__val); };


  template<> inline size_t hash<char>::operator()(char __val) const { return static_cast<size_t>(__val); };


  template<> inline size_t hash<signed char>::operator()(signed char __val) const { return static_cast<size_t>(__val); };


  template<> inline size_t hash<unsigned char>::operator()(unsigned char __val) const { return static_cast<size_t>(__val); };


  template<> inline size_t hash<wchar_t>::operator()(wchar_t __val) const { return static_cast<size_t>(__val); };


  template<> inline size_t hash<char16_t>::operator()(char16_t __val) const { return static_cast<size_t>(__val); };


  template<> inline size_t hash<char32_t>::operator()(char32_t __val) const { return static_cast<size_t>(__val); };


  template<> inline size_t hash<short>::operator()(short __val) const { return static_cast<size_t>(__val); };


  template<> inline size_t hash<int>::operator()(int __val) const { return static_cast<size_t>(__val); };


  template<> inline size_t hash<long>::operator()(long __val) const { return static_cast<size_t>(__val); };


  template<> inline size_t hash<long long>::operator()(long long __val) const { return static_cast<size_t>(__val); };


  template<> inline size_t hash<unsigned short>::operator()(unsigned short __val) const { return static_cast<size_t>(__val); };


  template<> inline size_t hash<unsigned int>::operator()(unsigned int __val) const { return static_cast<size_t>(__val); };


  template<> inline size_t hash<unsigned long>::operator()(unsigned long __val) const { return static_cast<size_t>(__val); };


  template<> inline size_t hash<unsigned long long>::operator()(unsigned long long __val) const { return static_cast<size_t>(__val); };



  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };

  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    inline size_t
    hash<float>::operator()(float __val) const
    {

      return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
    }


  template<>
    inline size_t
    hash<double>::operator()(double __val) const
    {

      return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
    }


  template<>
    __attribute__ ((__pure__)) size_t
    hash<long double>::operator()(long double __val) const;




}
# 2974 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };





  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };



}
# 54 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.tcc" 1 3
# 42 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.tcc" 3
# 42 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 if (true)
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 if (false)
   {
     __r->_M_destroy(__a);
                            ;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   __throw_logic_error(("basic_string::_S_construct null not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 if (true)
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 if (false)
   {
     __r->_M_destroy(__a);
                            ;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(initializer_list<_CharT> __l, const _Alloc& __a)
    : _M_dataplus(_S_construct(__l.begin(), __l.end(), __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
                                             ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
                                             ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
                                              ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {

                           ;




       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
                                               ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 578 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
                                      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
                                             ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
                                    ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
                                    ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
                                              ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   if (true)
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   if (false)
     {
       __in._M_setstate(__ios_base::badbit);
                              ;
     }
   if (false)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   if (true)
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   if (false)
     {
       __in._M_setstate(__ios_base::badbit);
                              ;
     }
   if (false)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 55 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 2 3
# 42 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{
# 63 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 99 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 118 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    locale() throw();
# 127 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 137 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 152 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 165 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 177 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 191 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 206 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
# 225 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 253 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 269 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    static locale
    global(const locale&);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 304 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
# 338 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 369 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();

  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

                                                           ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
                                                              ;
   if (true)
     { delete this; }
   if (false)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
# 436 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

                                                           ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
                                                              ;
   if (true)
     { delete this; }
   if (false)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };
# 582 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();
# 599 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);
# 616 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 643 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 657 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 674 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 693 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 707 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 736 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 752 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 765 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };


}


# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.tcc" 1 3
# 37 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.tcc" 3
# 37 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      if (true)
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      if (false)
 {
   _M_impl->_M_remove_reference();
                          ;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      if (true)
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      if (false)
 {
   __tmp->_M_remove_reference();
                          ;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }


  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      if (true)
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      if (false)
 {
   delete [] __c;
                          ;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 823 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 2 3
# 43 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
# 200 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
  class ios_base
  {
  public:







    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
# 256 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 331 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 362 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 394 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 420 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 437 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    typedef void (*event_callback) (event, ios_base&, int);
# 449 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

                                                             ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
                                                                ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 562 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 578 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 595 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 621 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 672 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 684 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 695 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 706 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 725 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 741 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 762 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 779 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }


}
# 43 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 1 3
# 37 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
# 37 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3








namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 115 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(__streambuf_type*, __streambuf_type*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:
# 181 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 205 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 222 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 235 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
# 262 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 276 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 294 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 316 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 335 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 350 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 375 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 402 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 428 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 442 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 460 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 476 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 487 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 507 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 523 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 533 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 554 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual void
      imbue(const locale&)
      { }
# 569 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 580 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 592 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 605 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual int
      sync() { return 0; }
# 627 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 643 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 665 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 678 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 702 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 720 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 746 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 761 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }

    private:


      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };


  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);



}


# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/streambuf.tcc" 1 3
# 38 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/streambuf.tcc" 3
# 38 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 808 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 2 3
# 44 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 1 3
# 35 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
# 35 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3



# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 1 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3

# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwctype" 1 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwctype" 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwctype" 3
# 51 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 38 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
typedef unsigned long int wctype_t;
# 56 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {







extern int iswalnum (wint_t __wc) noexcept (true);





extern int iswalpha (wint_t __wc) noexcept (true);


extern int iswcntrl (wint_t __wc) noexcept (true);



extern int iswdigit (wint_t __wc) noexcept (true);



extern int iswgraph (wint_t __wc) noexcept (true);




extern int iswlower (wint_t __wc) noexcept (true);


extern int iswprint (wint_t __wc) noexcept (true);




extern int iswpunct (wint_t __wc) noexcept (true);




extern int iswspace (wint_t __wc) noexcept (true);




extern int iswupper (wint_t __wc) noexcept (true);




extern int iswxdigit (wint_t __wc) noexcept (true);





extern int iswblank (wint_t __wc) noexcept (true);
# 155 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
extern wctype_t wctype (const char *__property) noexcept (true);



extern int iswctype (wint_t __wc, wctype_t __desc) noexcept (true);






extern wint_t towlower (wint_t __wc) noexcept (true);


extern wint_t towupper (wint_t __wc) noexcept (true);

}
# 39 "/usr/include/wctype.h" 2 3 4





extern "C" {



typedef const __int32_t *wctrans_t;



extern wctrans_t wctrans (const char *__property) noexcept (true);


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) noexcept (true);







extern int iswalnum_l (wint_t __wc, locale_t __locale) noexcept (true);





extern int iswalpha_l (wint_t __wc, locale_t __locale) noexcept (true);


extern int iswcntrl_l (wint_t __wc, locale_t __locale) noexcept (true);



extern int iswdigit_l (wint_t __wc, locale_t __locale) noexcept (true);



extern int iswgraph_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswlower_l (wint_t __wc, locale_t __locale) noexcept (true);


extern int iswprint_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswpunct_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswspace_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswupper_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswxdigit_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswblank_l (wint_t __wc, locale_t __locale) noexcept (true);



extern wctype_t wctype_l (const char *__property, locale_t __locale)
     noexcept (true);



extern int iswctype_l (wint_t __wc, wctype_t __desc, locale_t __locale)
     noexcept (true);






extern wint_t towlower_l (wint_t __wc, locale_t __locale) noexcept (true);


extern wint_t towupper_l (wint_t __wc, locale_t __locale) noexcept (true);



extern wctrans_t wctrans_l (const char *__property, locale_t __locale)
     noexcept (true);


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      locale_t __locale) noexcept (true);



}
# 52 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwctype" 2 3
# 81 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}







namespace std
{

  using std::iswblank;

}
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 1 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 3
# 42 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/ctype_base.h" 1 3
# 37 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;
  };


}
# 43 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 2 3






# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/streambuf_iterator.h" 1 3
# 35 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/streambuf_iterator.h" 3
# 35 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{
# 50 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      constexpr istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }




}
# 50 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 65 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 143 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 161 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 178 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 194 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 210 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 224 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 239 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 253 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 268 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 285 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 304 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 323 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 345 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 370 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 389 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 408 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 427 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 445 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const = 0;
# 462 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 478 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const = 0;
# 495 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 514 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const = 0;
# 535 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
# 557 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
# 581 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
# 604 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 673 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 710 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 723 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 736 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 751 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 765 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 779 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 794 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 811 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 827 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 844 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 864 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 891 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 922 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 955 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1004 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1021 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1037 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1054 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1074 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1097 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
# 1123 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
# 1149 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1174 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1207 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1218 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1242 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1261 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1279 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1297 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1314 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1331 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1347 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1364 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1384 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const;
# 1406 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
# 1429 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const;
# 1455 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };



}



# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/ctype_inline.h" 1 3
# 37 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}
# 1512 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
        { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
# 1640 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1678 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1692 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1706 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1719 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1750 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1763 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1776 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1793 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1805 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1818 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1831 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1844 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };
# 1914 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1935 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1961 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 1997 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2056 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2098 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
        _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
        _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2169 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;
# 2234 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2252 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2273 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2291 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2333 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2396 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2421 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2469 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;
# 2527 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3
  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}


# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 1 3
# 35 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3
# 35 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     if (true)
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     if (false)
       {
  delete __tmp;
                         ;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      if (true)
 {
   _M_grouping_size = __np.grouping().size();
   __grouping = new char[_M_grouping_size];
   __np.grouping().copy(__grouping, _M_grouping_size);
   _M_grouping = __grouping;
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(_M_grouping[0]) > 0
        && (_M_grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   _M_truename_size = __np.truename().size();
   __truename = new _CharT[_M_truename_size];
   __np.truename().copy(__truename, _M_truename_size);
   _M_truename = __truename;

   _M_falsename_size = __np.falsename().size();
   __falsename = new _CharT[_M_falsename_size];
   __np.falsename().copy(__falsename, _M_falsename_size);
   _M_falsename = __falsename;

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);
 }
      if (false)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
                          ;
 }
    }
# 137 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 731 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 967 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
# 1028 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1153 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }
# 1190 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2608 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 2 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 62 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 127 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 138 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
                          ;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 191 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 212 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 247 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 285 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 297 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 337 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 351 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 380 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 400 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 420 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 439 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };


}


# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.tcc" 1 3
# 34 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.tcc" 3
# 34 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 473 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 2 3
# 45 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
# 40 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 1 3
# 38 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
# 38 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{
# 55 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 82 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 108 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }


      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 250 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 283 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      __ostream_type&
      put(char_type __c);


      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 311 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 324 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      __ostream_type&
      flush();
# 335 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      pos_type
      tellp();
# 346 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 358 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }

      template<typename _ValueT>
        __ostream_type&
        _M_insert(_ValueT __v);
    };
# 377 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 396 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 406 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 425 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 448 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 490 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 540 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }







  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
# 578 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)
    { return (__os << __x); }



}


# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream.tcc" 1 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream.tcc" 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     if (true)
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     if (false)
       {
  this->_M_setstate(ios_base::badbit);
                         ;
       }
     if (false)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   if (true)
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   if (true)
     { _M_write(__s, __n); }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      if (true)
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
                          ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      if (true)
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
                          ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (true)
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
                          ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (true)
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
                          ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   if (true)
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   if (false)
     {
       __out._M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 588 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 2 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 55 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:
# 91 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 120 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 239 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 249 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 281 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      int_type
      get();
# 295 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      get(char_type& __c);
# 322 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 333 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 356 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 366 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 395 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 406 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 430 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      ignore();

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore(streamsize __n, int_type __delim);
# 447 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      int_type
      peek();
# 465 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 484 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 501 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      putback(char_type __c);
# 517 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      unget();
# 535 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      int
      sync();
# 550 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      pos_type
      tellg();
# 565 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      seekg(pos_type);
# 581 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }

      template<typename _ValueT>
        __istream_type&
        _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 636 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 672 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 683 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 702 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 744 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 772 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };
# 833 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
# 849 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>&& __is, _Tp& __x)
    { return (__is >> __x); }



}


# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/istream.tcc" 1 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/istream.tcc" 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     if (true)
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     if (false)
       {
  this->_M_setstate(ios_base::badbit);
                         ;
       }
     if (false)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   if (true)
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::failbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          if (true)
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
          if (false)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          if (true)
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 514 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
          if (false)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          if (true)
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
          if (false)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   if (false)
     {
       __in._M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   if (true)
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   if (false)
     {
       __in._M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 859 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 2 3
# 40 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 2 3

# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/codecvt.h" 1 3
# 40 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/codecvt.h" 3
# 40 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/codecvt.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 67 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 115 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 154 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 195 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 236 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };
# 275 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/codecvt.h" 3
   template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs) { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };



  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }

    protected:
      virtual
      ~codecvt_byname() { }
    };




  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);


  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);




}
# 42 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 1 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 3
# 43 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 2 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/basic_file.h" 1 3
# 38 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/basic_file.h" 3
# 38 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/basic_file.h" 3


# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++io.h" 1 3
# 36 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++io.h" 3
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 1 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdio" 3
# 37 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++io.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;


}
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/basic_file.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _CharT>
    class __basic_file;


  template<>
    class __basic_file<char>
    {

      __c_file* _M_cfile;


      bool _M_cfile_created;

    public:
      __basic_file(__c_lock* __lock = 0) throw ();

      __basic_file*
      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);

      __basic_file*
      sys_open(__c_file* __file, ios_base::openmode);

      __basic_file*
      sys_open(int __fd, ios_base::openmode __mode) throw ();

      __basic_file*
      close();

      __attribute__ ((__pure__)) bool
      is_open() const throw ();

      __attribute__ ((__pure__)) int
      fd() throw ();

      __attribute__ ((__pure__)) __c_file*
      file() throw ();

      ~__basic_file();

      streamsize
      xsputn(const char* __s, streamsize __n);

      streamsize
      xsputn_2(const char* __s1, streamsize __n1,
        const char* __s2, streamsize __n2);

      streamsize
      xsgetn(char* __s, streamsize __n);

      streamoff
      seekoff(streamoff __off, ios_base::seekdir __way) throw ();

      int
      sync();

      streamsize
      showmanyc();
    };


}
# 44 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{
# 67 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_filebuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef __basic_file<char> __file_type;
      typedef typename traits_type::state_type __state_type;
      typedef codecvt<char_type, char, __state_type> __codecvt_type;

      friend class ios_base;

    protected:


      __c_lock _M_lock;


      __file_type _M_file;


      ios_base::openmode _M_mode;


      __state_type _M_state_beg;




      __state_type _M_state_cur;



      __state_type _M_state_last;


      char_type* _M_buf;






      size_t _M_buf_size;


      bool _M_buf_allocated;
# 129 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      bool _M_reading;
      bool _M_writing;







      char_type _M_pback;
      char_type* _M_pback_cur_save;
      char_type* _M_pback_end_save;
      bool _M_pback_init;



      const __codecvt_type* _M_codecvt;






      char* _M_ext_buf;




      streamsize _M_ext_buf_size;






      const char* _M_ext_next;
      char* _M_ext_end;






      void
      _M_create_pback()
      {
 if (!_M_pback_init)
   {
     _M_pback_cur_save = this->gptr();
     _M_pback_end_save = this->egptr();
     this->setg(&_M_pback, &_M_pback, &_M_pback + 1);
     _M_pback_init = true;
   }
      }






      void
      _M_destroy_pback() throw()
      {
 if (_M_pback_init)
   {

     _M_pback_cur_save += this->gptr() != this->eback();
     this->setg(_M_buf, _M_pback_cur_save, _M_pback_end_save);
     _M_pback_init = false;
   }
      }

    public:







      basic_filebuf();




      virtual
      ~basic_filebuf()
      { this->close(); }





      bool
      is_open() const throw()
      { return _M_file.is_open(); }
# 265 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      __filebuf_type*
      open(const char* __s, ios_base::openmode __mode);
# 275 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      __filebuf_type*
      open(const std::string& __s, ios_base::openmode __mode)
      { return open(__s.c_str(), __mode); }
# 292 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      __filebuf_type*
      close();

    protected:
      void
      _M_allocate_internal_buffer();

      void
      _M_destroy_internal_buffer() throw();


      virtual streamsize
      showmanyc();






      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = _Traits::eof());
# 324 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      virtual int_type
      overflow(int_type __c = _Traits::eof());



      bool
      _M_convert_to_external(char_type*, streamsize);
# 344 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n);

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __pos,
       ios_base::openmode __mode = ios_base::in | ios_base::out);


      pos_type
      _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state);

      int
      _M_get_ext_pos(__state_type &__state);

      virtual int
      sync();

      virtual void
      imbue(const locale& __loc);

      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);

      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);


      bool
      _M_terminate_output();
# 390 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      void
      _M_set_buffer(streamsize __off)
      {
  const bool __testin = _M_mode & ios_base::in;
  const bool __testout = _M_mode & ios_base::out;

 if (__testin && __off > 0)
   this->setg(_M_buf, _M_buf, _M_buf + __off);
 else
   this->setg(_M_buf, _M_buf, _M_buf);

 if (__testout && __off == 0 && _M_buf_size > 1 )
   this->setp(_M_buf, _M_buf + _M_buf_size - 1);
 else
   this->setp(0, 0);
      }
    };
# 418 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ifstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 445 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      basic_ifstream() : __istream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 458 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      explicit
      basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 474 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      explicit
      basic_ifstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 490 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      ~basic_ifstream()
      { }
# 500 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 529 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 549 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      void
      open(const std::string& __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 567 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 586 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ofstream : public basic_ostream<_CharT,_Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 613 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      basic_ofstream(): __ostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 627 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      explicit
      basic_ofstream(const char* __s,
       ios_base::openmode __mode = ios_base::out|ios_base::trunc)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 645 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      explicit
      basic_ofstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::out|ios_base::trunc)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 661 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      ~basic_ofstream()
      { }
# 671 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 700 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::out | ios_base::trunc)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 721 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      void
      open(const std::string& __s,
    ios_base::openmode __mode = ios_base::out | ios_base::trunc)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 740 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 759 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_fstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ios<char_type, traits_type> __ios_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 787 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      basic_fstream()
      : __iostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 799 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      explicit
      basic_fstream(const char* __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }







      explicit
      basic_fstream(const std::string& __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 830 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      ~basic_fstream()
      { }
# 840 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 869 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 890 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      void
      open(const std::string& __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 909 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };


}


# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/fstream.tcc" 1 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/fstream.tcc" 3
# 39 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/fstream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_allocate_internal_buffer()
    {


      if (!_M_buf_allocated && !_M_buf)
 {
   _M_buf = new char_type[_M_buf_size];
   _M_buf_allocated = true;
 }
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_destroy_internal_buffer() throw()
    {
      if (_M_buf_allocated)
 {
   delete [] _M_buf;
   _M_buf = 0;
   _M_buf_allocated = false;
 }
      delete [] _M_ext_buf;
      _M_ext_buf = 0;
      _M_ext_buf_size = 0;
      _M_ext_next = 0;
      _M_ext_end = 0;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf() : __streambuf_type(), _M_lock(), _M_file(&_M_lock),
    _M_mode(ios_base::openmode(0)), _M_state_beg(), _M_state_cur(),
    _M_state_last(), _M_buf(0), _M_buf_size(8192),
    _M_buf_allocated(false), _M_reading(false), _M_writing(false), _M_pback(),
    _M_pback_cur_save(0), _M_pback_end_save(0), _M_pback_init(false),
    _M_codecvt(0), _M_ext_buf(0), _M_ext_buf_size(0), _M_ext_next(0),
    _M_ext_end(0)
    {
      if (has_facet<__codecvt_type>(this->_M_buf_locale))
 _M_codecvt = &use_facet<__codecvt_type>(this->_M_buf_locale);
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    open(const char* __s, ios_base::openmode __mode)
    {
      __filebuf_type *__ret = 0;
      if (!this->is_open())
 {
   _M_file.open(__s, __mode);
   if (this->is_open())
     {
       _M_allocate_internal_buffer();
       _M_mode = __mode;


       _M_reading = false;
       _M_writing = false;
       _M_set_buffer(-1);


       _M_state_last = _M_state_cur = _M_state_beg;


       if ((__mode & ios_base::ate)
    && this->seekoff(0, ios_base::end, __mode)
    == pos_type(off_type(-1)))
  this->close();
       else
  __ret = this;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    close()
    {
      if (!this->is_open())
 return 0;

      bool __testfail = false;
      {

 struct __close_sentry
 {
   basic_filebuf *__fb;
   __close_sentry (basic_filebuf *__fbi): __fb(__fbi) { }
   ~__close_sentry ()
   {
     __fb->_M_mode = ios_base::openmode(0);
     __fb->_M_pback_init = false;
     __fb->_M_destroy_internal_buffer();
     __fb->_M_reading = false;
     __fb->_M_writing = false;
     __fb->_M_set_buffer(-1);
     __fb->_M_state_last = __fb->_M_state_cur = __fb->_M_state_beg;
   }
 } __cs (this);

 if (true)
   {
     if (!_M_terminate_output())
       __testfail = true;
   }
 if (false)
   {
     _M_file.close();
                            ;
   }
 if (false)
   { __testfail = true; }
      }

      if (!_M_file.close())
 __testfail = true;

      if (__testfail)
 return 0;
      else
 return this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    showmanyc()
    {
      streamsize __ret = -1;
      const bool __testin = _M_mode & ios_base::in;
      if (__testin && this->is_open())
 {


   __ret = this->egptr() - this->gptr();







   if (__check_facet(_M_codecvt).encoding() >= 0)

     __ret += _M_file.showmanyc() / _M_codecvt->max_length();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }



   _M_destroy_pback();

   if (this->gptr() < this->egptr())
     return traits_type::to_int_type(*this->gptr());


   const size_t __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;


   bool __got_eof = false;

   streamsize __ilen = 0;
   codecvt_base::result __r = codecvt_base::ok;
   if (__check_facet(_M_codecvt).always_noconv())
     {
       __ilen = _M_file.xsgetn(reinterpret_cast<char*>(this->eback()),
          __buflen);
       if (__ilen == 0)
  __got_eof = true;
     }
   else
     {


       const int __enc = _M_codecvt->encoding();
       streamsize __blen;
       streamsize __rlen;
       if (__enc > 0)
  __blen = __rlen = __buflen * __enc;
       else
  {
    __blen = __buflen + _M_codecvt->max_length() - 1;
    __rlen = __buflen;
  }
       const streamsize __remainder = _M_ext_end - _M_ext_next;
       __rlen = __rlen > __remainder ? __rlen - __remainder : 0;



       if (_M_reading && this->egptr() == this->eback() && __remainder)
  __rlen = 0;



       if (_M_ext_buf_size < __blen)
  {
    char* __buf = new char[__blen];
    if (__remainder)
      __builtin_memcpy(__buf, _M_ext_next, __remainder);

    delete [] _M_ext_buf;
    _M_ext_buf = __buf;
    _M_ext_buf_size = __blen;
  }
       else if (__remainder)
  __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

       _M_ext_next = _M_ext_buf;
       _M_ext_end = _M_ext_buf + __remainder;
       _M_state_last = _M_state_cur;

       do
  {
    if (__rlen > 0)
      {



        if (_M_ext_end - _M_ext_buf + __rlen > _M_ext_buf_size)
   {
     __throw_ios_failure(("basic_filebuf::underflow " "codecvt::max_length() " "is not valid"));


   }
        streamsize __elen = _M_file.xsgetn(_M_ext_end, __rlen);
        if (__elen == 0)
   __got_eof = true;
        else if (__elen == -1)
   break;
        _M_ext_end += __elen;
      }

    char_type* __iend = this->eback();
    if (_M_ext_next < _M_ext_end)
      __r = _M_codecvt->in(_M_state_cur, _M_ext_next,
      _M_ext_end, _M_ext_next,
      this->eback(),
      this->eback() + __buflen, __iend);
    if (__r == codecvt_base::noconv)
      {
        size_t __avail = _M_ext_end - _M_ext_buf;
        __ilen = std::min(__avail, __buflen);
        traits_type::copy(this->eback(),
     reinterpret_cast<char_type*>
     (_M_ext_buf), __ilen);
        _M_ext_next = _M_ext_buf + __ilen;
      }
    else
      __ilen = __iend - this->eback();




    if (__r == codecvt_base::error)
      break;

    __rlen = 1;
  }
       while (__ilen == 0 && !__got_eof);
     }

   if (__ilen > 0)
     {
       _M_set_buffer(__ilen);
       _M_reading = true;
       __ret = traits_type::to_int_type(*this->gptr());
     }
   else if (__got_eof)
     {



       _M_set_buffer(-1);
       _M_reading = false;


       if (__r == codecvt_base::partial)
  __throw_ios_failure(("basic_filebuf::underflow " "incomplete character in file"));

     }
   else if (__r == codecvt_base::error)
     __throw_ios_failure(("basic_filebuf::underflow " "invalid byte sequence in file"));

   else
     __throw_ios_failure(("basic_filebuf::underflow " "error reading the file"));

 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    pbackfail(int_type __i)
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }


   const bool __testpb = _M_pback_init;
   const bool __testeof = traits_type::eq_int_type(__i, __ret);
   int_type __tmp;
   if (this->eback() < this->gptr())
     {
       this->gbump(-1);
       __tmp = traits_type::to_int_type(*this->gptr());
     }
   else if (this->seekoff(-1, ios_base::cur) != pos_type(off_type(-1)))
     {
       __tmp = this->underflow();
       if (traits_type::eq_int_type(__tmp, __ret))
  return __ret;
     }
   else
     {





       return __ret;
     }



   if (!__testeof && traits_type::eq_int_type(__i, __tmp))
     __ret = __i;
   else if (__testeof)
     __ret = traits_type::not_eof(__i);
   else if (!__testpb)
     {
       _M_create_pback();
       _M_reading = true;
       *this->gptr() = traits_type::to_char_type(__i);
       __ret = __i;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    overflow(int_type __c)
    {
      int_type __ret = traits_type::eof();
      const bool __testeof = traits_type::eq_int_type(__c, __ret);
      const bool __testout = _M_mode & ios_base::out;
      if (__testout)
 {
          if (_M_reading)
            {
              _M_destroy_pback();
              const int __gptr_off = _M_get_ext_pos(_M_state_last);
              if (_M_seek(__gptr_off, ios_base::cur, _M_state_last)
                  == pos_type(off_type(-1)))
                return __ret;
            }
   if (this->pbase() < this->pptr())
     {

       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }



       if (_M_convert_to_external(this->pbase(),
      this->pptr() - this->pbase()))
  {
    _M_set_buffer(0);
    __ret = traits_type::not_eof(__c);
  }
     }
   else if (_M_buf_size > 1)
     {



       _M_set_buffer(0);
       _M_writing = true;
       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }
       __ret = traits_type::not_eof(__c);
     }
   else
     {

       char_type __conv = traits_type::to_char_type(__c);
       if (__testeof || _M_convert_to_external(&__conv, 1))
  {
    _M_writing = true;
    __ret = traits_type::not_eof(__c);
  }
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_convert_to_external(_CharT* __ibuf, streamsize __ilen)
    {

      streamsize __elen;
      streamsize __plen;
      if (__check_facet(_M_codecvt).always_noconv())
 {
   __elen = _M_file.xsputn(reinterpret_cast<char*>(__ibuf), __ilen);
   __plen = __ilen;
 }
      else
 {


   streamsize __blen = __ilen * _M_codecvt->max_length();
   char* __buf = static_cast<char*>(__builtin_alloca(__blen));

   char* __bend;
   const char_type* __iend;
   codecvt_base::result __r;
   __r = _M_codecvt->out(_M_state_cur, __ibuf, __ibuf + __ilen,
    __iend, __buf, __buf + __blen, __bend);

   if (__r == codecvt_base::ok || __r == codecvt_base::partial)
     __blen = __bend - __buf;
   else if (__r == codecvt_base::noconv)
     {

       __buf = reinterpret_cast<char*>(__ibuf);
       __blen = __ilen;
     }
   else
     __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error"));


   __elen = _M_file.xsputn(__buf, __blen);
   __plen = __blen;


   if (__r == codecvt_base::partial && __elen == __plen)
     {
       const char_type* __iresume = __iend;
       streamsize __rlen = this->pptr() - __iend;
       __r = _M_codecvt->out(_M_state_cur, __iresume,
        __iresume + __rlen, __iend, __buf,
        __buf + __blen, __bend);
       if (__r != codecvt_base::error)
  {
    __rlen = __bend - __buf;
    __elen = _M_file.xsputn(__buf, __rlen);
    __plen = __rlen;
  }
       else
  __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error"));

     }
 }
      return __elen == __plen;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsgetn(_CharT* __s, streamsize __n)
    {

      streamsize __ret = 0;
      if (_M_pback_init)
 {
   if (__n > 0 && this->gptr() == this->eback())
     {
       *__s++ = *this->gptr();
       this->gbump(1);
       __ret = 1;
       --__n;
     }
   _M_destroy_pback();
 }
      else if (_M_writing)
 {
    if (overflow() == traits_type::eof())
      return __ret;
    _M_set_buffer(-1);
    _M_writing = false;
  }




      const bool __testin = _M_mode & ios_base::in;
      const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;

      if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()
     && __testin)
   {

     const streamsize __avail = this->egptr() - this->gptr();
     if (__avail != 0)
       {
        traits_type::copy(__s, this->gptr(), __avail);
         __s += __avail;
        this->setg(this->eback(), this->gptr() + __avail,
     this->egptr());
        __ret += __avail;
        __n -= __avail;
       }



     streamsize __len;
     for (;;)
       {
         __len = _M_file.xsgetn(reinterpret_cast<char*>(__s),
           __n);
         if (__len == -1)
    __throw_ios_failure(("basic_filebuf::xsgetn " "error reading the file"));

         if (__len == 0)
    break;

         __n -= __len;
         __ret += __len;
         if (__n == 0)
    break;

         __s += __len;
       }

     if (__n == 0)
       {
         _M_set_buffer(0);
         _M_reading = true;
       }
     else if (__len == 0)
       {



         _M_set_buffer(-1);
         _M_reading = false;
       }
   }
      else
   __ret += __streambuf_type::xsgetn(__s, __n);

      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsputn(const _CharT* __s, streamsize __n)
    {
      streamsize __ret = 0;



      const bool __testout = _M_mode & ios_base::out;
      if (__check_facet(_M_codecvt).always_noconv()
     && __testout && !_M_reading)
 {

   const streamsize __chunk = 1ul << 10;
   streamsize __bufavail = this->epptr() - this->pptr();


   if (!_M_writing && _M_buf_size > 1)
     __bufavail = _M_buf_size - 1;

   const streamsize __limit = std::min(__chunk, __bufavail);
   if (__n >= __limit)
     {
       const streamsize __buffill = this->pptr() - this->pbase();
       const char* __buf = reinterpret_cast<const char*>(this->pbase());
       __ret = _M_file.xsputn_2(__buf, __buffill,
           reinterpret_cast<const char*>(__s),
           __n);
       if (__ret == __buffill + __n)
  {
    _M_set_buffer(0);
    _M_writing = true;
  }
       if (__ret > __buffill)
  __ret -= __buffill;
       else
  __ret = 0;
     }
   else
     __ret = __streambuf_type::xsputn(__s, __n);
 }
       else
  __ret = __streambuf_type::xsputn(__s, __n);
       return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__streambuf_type*
    basic_filebuf<_CharT, _Traits>::
    setbuf(char_type* __s, streamsize __n)
    {
      if (!this->is_open())
 {
   if (__s == 0 && __n == 0)
     _M_buf_size = 1;
   else if (__s && __n > 0)
     {
# 701 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/fstream.tcc" 3
       _M_buf = __s;
       _M_buf_size = __n;
     }
 }
      return this;
    }




  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode)
    {
      int __width = 0;
      if (_M_codecvt)
 __width = _M_codecvt->encoding();
      if (__width < 0)
 __width = 0;

      pos_type __ret = pos_type(off_type(-1));
      const bool __testfail = __off != 0 && __width <= 0;
      if (this->is_open() && !__testfail)
 {




   bool __no_movement = __way == ios_base::cur && __off == 0
     && (!_M_writing || _M_codecvt->always_noconv());


   if (!__no_movement)
     _M_destroy_pback();






   __state_type __state = _M_state_beg;
   off_type __computed_off = __off * __width;
   if (_M_reading && __way == ios_base::cur)
     {
       __state = _M_state_last;
       __computed_off += _M_get_ext_pos(__state);
     }
   if (!__no_movement)
     __ret = _M_seek(__computed_off, __way, __state);
   else
     {
       if (_M_writing)
  __computed_off = this->pptr() - this->pbase();

        off_type __file_off = _M_file.seekoff(0, ios_base::cur);
        if (__file_off != off_type(-1))
  {
    __ret = __file_off + __computed_off;
    __ret.state(__state);
  }
     }
 }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekpos(pos_type __pos, ios_base::openmode)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (this->is_open())
 {

   _M_destroy_pback();
   __ret = _M_seek(off_type(__pos), ios_base::beg, __pos.state());
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (_M_terminate_output())
 {
   off_type __file_off = _M_file.seekoff(__off, __way);
   if (__file_off != off_type(-1))
     {
       _M_reading = false;
       _M_writing = false;
       _M_ext_next = _M_ext_end = _M_ext_buf;
       _M_set_buffer(-1);
       _M_state_cur = __state;
       __ret = __file_off;
       __ret.state(_M_state_cur);
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    int basic_filebuf<_CharT, _Traits>::
    _M_get_ext_pos(__state_type& __state)
    {
      if (_M_codecvt->always_noconv())
        return this->gptr() - this->egptr();
      else
        {



          const int __gptr_off =
            _M_codecvt->length(__state, _M_ext_buf, _M_ext_next,
                               this->gptr() - this->eback());
          return _M_ext_buf + __gptr_off - _M_ext_end;
        }
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_terminate_output()
    {

      bool __testvalid = true;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __testvalid = false;
 }


      if (_M_writing && !__check_facet(_M_codecvt).always_noconv()
   && __testvalid)
 {



   const size_t __blen = 128;
   char __buf[__blen];
   codecvt_base::result __r;
   streamsize __ilen = 0;

   do
     {
       char* __next;
       __r = _M_codecvt->unshift(_M_state_cur, __buf,
     __buf + __blen, __next);
       if (__r == codecvt_base::error)
  __testvalid = false;
       else if (__r == codecvt_base::ok ||
         __r == codecvt_base::partial)
  {
    __ilen = __next - __buf;
    if (__ilen > 0)
      {
        const streamsize __elen = _M_file.xsputn(__buf, __ilen);
        if (__elen != __ilen)
   __testvalid = false;
      }
  }
     }
   while (__r == codecvt_base::partial && __ilen > 0 && __testvalid);

   if (__testvalid)
     {




       const int_type __tmp = this->overflow();
       if (traits_type::eq_int_type(__tmp, traits_type::eof()))
  __testvalid = false;
     }
 }
      return __testvalid;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_filebuf<_CharT, _Traits>::
    sync()
    {


      int __ret = 0;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __ret = -1;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    imbue(const locale& __loc)
    {
      bool __testvalid = true;

      const __codecvt_type* _M_codecvt_tmp = 0;
      if (__builtin_expect(has_facet<__codecvt_type>(__loc), true))
 _M_codecvt_tmp = &use_facet<__codecvt_type>(__loc);

      if (this->is_open())
 {

   if ((_M_reading || _M_writing)
       && __check_facet(_M_codecvt).encoding() == -1)
     __testvalid = false;
   else
     {
       if (_M_reading)
  {
    if (__check_facet(_M_codecvt).always_noconv())
      {
        if (_M_codecvt_tmp
     && !__check_facet(_M_codecvt_tmp).always_noconv())
   __testvalid = this->seekoff(0, ios_base::cur, _M_mode)
                 != pos_type(off_type(-1));
      }
    else
      {

        _M_ext_next = _M_ext_buf
   + _M_codecvt->length(_M_state_last, _M_ext_buf,
          _M_ext_next,
          this->gptr() - this->eback());
        const streamsize __remainder = _M_ext_end - _M_ext_next;
        if (__remainder)
   __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

        _M_ext_next = _M_ext_buf;
        _M_ext_end = _M_ext_buf + __remainder;
        _M_set_buffer(-1);
        _M_state_last = _M_state_cur = _M_state_beg;
      }
  }
       else if (_M_writing && (__testvalid = _M_terminate_output()))
  _M_set_buffer(-1);
     }
 }

      if (__testvalid)
 _M_codecvt = _M_codecvt_tmp;
      else
 _M_codecvt = 0;
    }




  extern template class basic_filebuf<char>;
  extern template class basic_ifstream<char>;
  extern template class basic_ofstream<char>;
  extern template class basic_fstream<char>;


  extern template class basic_filebuf<wchar_t>;
  extern template class basic_ifstream<wchar_t>;
  extern template class basic_ofstream<wchar_t>;
  extern template class basic_fstream<wchar_t>;




}
# 921 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/fstream" 2 3
# 7 "./src/ultranet.cpp" 2
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iostream" 1 3
# 37 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iostream" 3
# 37 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iostream" 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 60 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
# 8 "./src/ultranet.cpp" 2
using namespace std;

# 1 "./src/bn_qrelu2d.h" 1

# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_stream.h" 1
# 66 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_stream.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/etc/autopilot_enum.h" 1
# 58 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/etc/autopilot_enum.h"
enum SsdmDataTypes {
    _ssdm_sc_int = 0,
    _ssdm_c_int = _ssdm_sc_int,
    _ssdm_sc_uint = 1,
    _ssdm_c_uint = _ssdm_sc_uint,
    _ssdm_sc_bigint = 2,
    _ssdm_sc_biguint = 3,
};



enum SsdmPortTypes {
    _ssdm_sc_in = 0,
    _ssdm_sc_out = 1,
    _ssdm_sc_inout = 2,
    _ssdm_sc_in_clk,

    _ssdm_fifo_in,
    _ssdm_sc_fifo_in = _ssdm_fifo_in,
    _ssdm_tlm_fifo_in = _ssdm_fifo_in,
    _ssdm_fifo_out,
    _ssdm_sc_fifo_out = _ssdm_fifo_out,
    _ssdm_tlm_fifo_out = _ssdm_fifo_out,
    _ssdm_fifo_inout,
    _ssdm_sc_fifo_inout = _ssdm_fifo_inout,
    _ssdm_tlm_fifo_inout = _ssdm_fifo_inout,
    _ssdm_sc_bus,
    _ssdm_hls_bus_port = _ssdm_sc_bus,
    _ssdm_AXI4M_bus_port = _ssdm_sc_bus,
    _ssdm_port_end,
};



enum SsdmProcessTypes {
    _ssdm_method = 0,
    _ssdm_sc_method = _ssdm_method,
    _ssdm_thread = 1,
    _ssdm_sc_thread = _ssdm_thread,
    _ssdm_cthread = 2,
    _ssdm_sc_cthread = _ssdm_cthread,
    _ssdm_process_end,
};



enum SsdmSensitiveTypes {
    _ssdm_sensitive = 0,
    _ssdm_sensitive_pos,
    _ssdm_sensitive_neg,
    _ssdm_sensitive_reset0,
    _ssdm_sensitive_reset1,
    _ssdm_sensitive_end,
};



enum SsdmChannelTypes {
    _ssdm_sc_sig,
    _ssdm_fifo,
    _ssdm_sc_fifo = _ssdm_fifo,
    _ssdm_mem_fifo,
    _ssdm_sc_mem_fifo = _ssdm_mem_fifo,
};


enum SsdmRegionTypes {
    _ssdm_region_reset,
    _ssdm_region_protocol,
    _ssdm_region_pipeline,
    _ssdm_region_parallel,
};
# 67 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_stream.h" 2


namespace hls {
# 88 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_stream.h"
template<typename __STREAM_T__>
class stream
{
  public:

    inline __attribute__((always_inline)) stream() {
    }

    inline __attribute__((always_inline)) stream(const char* name) {
    }


  private:
    inline __attribute__((always_inline)) stream(const stream< __STREAM_T__ >& chn):V(chn.V) {
    }

    inline __attribute__((always_inline)) stream& operator= (const stream< __STREAM_T__ >& chn) {
        V = chn.V;
        return *this;
    }

  public:

    inline __attribute__((always_inline)) void operator >> (__STREAM_T__& rdata) {
        read(rdata);
    }

    inline __attribute__((always_inline)) void operator << (const __STREAM_T__& wdata) {
        write(wdata);
    }


  public:

    inline __attribute__((always_inline)) bool empty() const {

        bool tmp = _ssdm_StreamCanRead(&V);
        return !tmp;



    }

    inline __attribute__((always_inline)) bool full() const {

        bool tmp = _ssdm_StreamCanWrite(&V);
        return !tmp;



    }


    inline __attribute__((always_inline)) void read(__STREAM_T__& dout) {

        __STREAM_T__ tmp;
        _ssdm_StreamRead(&V, &tmp);
        dout = tmp;



    }

    inline __attribute__((always_inline)) __STREAM_T__ read() {
        __STREAM_T__ tmp;

        _ssdm_StreamRead(&V, &tmp);



        return tmp;
    }


    inline __attribute__((always_inline)) bool read_nb(__STREAM_T__& dout) {

        __STREAM_T__ tmp;
        bool empty_n = _ssdm_StreamNbRead(&V, &tmp);
        dout = tmp;
        return empty_n;



    }


    inline __attribute__((always_inline)) void write(const __STREAM_T__& din) {

        __STREAM_T__ tmp = din;
        _ssdm_StreamWrite(&V, &tmp);



    }


    inline __attribute__((always_inline)) bool write_nb(const __STREAM_T__& din) {

        __STREAM_T__ tmp = din;
        bool full_n = _ssdm_StreamNbWrite(&V, &tmp);
        return full_n;



    }



    inline __attribute__((always_inline)) unsigned size() {
        unsigned size = _ssdm_StreamSize(&V);
        return size;
    }


  public:
    __STREAM_T__ V ;
};


}
# 3 "./src/bn_qrelu2d.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 54 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_common.h" 1
# 57 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_common.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_decl.h" 1
# 100 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_decl.h"
enum ap_q_mode {
  AP_RND,
  AP_RND_ZERO,
  AP_RND_MIN_INF,
  AP_RND_INF,
  AP_RND_CONV,
  AP_TRN,
  AP_TRN_ZERO,
};
# 122 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_decl.h"
enum ap_o_mode {
  AP_SAT,
  AP_SAT_ZERO,
  AP_SAT_SYM,
  AP_WRAP,
  AP_WRAP_SM,
};
# 179 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_decl.h"
template <int _AP_W, bool _AP_S>
struct ap_int_base;

template <int _AP_W>
struct ap_int;

template <int _AP_W>
struct ap_uint;

template <int _AP_W, bool _AP_S>
struct ap_range_ref;

template <int _AP_W, bool _AP_S>
struct ap_bit_ref;

template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref;

template <int _AP_W, int _AP_I, bool _AP_S = true, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_fixed_base;

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_fixed;

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_ufixed;

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_range_ref;

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_bit_ref;


enum BaseMode { AP_BIN = 2, AP_OCT = 8, AP_DEC = 10, AP_HEX = 16 };
# 233 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_decl.h"
typedef signed long long ap_slong;
typedef unsigned long long ap_ulong;


enum {
  _AP_SIZE_char = 8,
  _AP_SIZE_short = sizeof(short) * 8,
  _AP_SIZE_int = sizeof(int) * 8,
  _AP_SIZE_long = sizeof(long) * 8,
  _AP_SIZE_ap_slong = sizeof(ap_slong) * 8
};
# 58 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_common.h" 2
# 157 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_common.h"
enum { CHAR_IS_SIGNED = (char)-1 < 0 };


namespace _ap_type {
template <typename _Tp>
struct is_signed {
  static const bool value = _Tp(-1) < _Tp(1);
};

template <typename _Tp>
struct is_integral {
  static const bool value = false;
};





template <> struct is_integral<bool> { static const bool value = true; };
template <> struct is_integral<char> { static const bool value = true; };
template <> struct is_integral<signed char> { static const bool value = true; };
template <> struct is_integral<unsigned char> { static const bool value = true; };
template <> struct is_integral<short> { static const bool value = true; };
template <> struct is_integral<unsigned short> { static const bool value = true; };
template <> struct is_integral<int> { static const bool value = true; };
template <> struct is_integral<unsigned int> { static const bool value = true; };
template <> struct is_integral<long> { static const bool value = true; };
template <> struct is_integral<unsigned long> { static const bool value = true; };
template <> struct is_integral<ap_slong> { static const bool value = true; };
template <> struct is_integral<ap_ulong> { static const bool value = true; };


template <bool, typename _Tp = void>
struct enable_if {};

template <typename _Tp>
struct enable_if<true, _Tp> {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const<_Tp const> {
  typedef _Tp type;
};
}
# 220 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_common.h"
template <int _AP_N, bool _AP_S>
struct ssdm_int;
# 238 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_common.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/etc/autopilot_dt.def" 1


template <> struct ssdm_int<1 + 1024 * 0, true> { int V __attribute__((bitwidth(1 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<2 + 1024 * 0, true> { int V __attribute__((bitwidth(2 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<2 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<2 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(2 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<2 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<3 + 1024 * 0, true> { int V __attribute__((bitwidth(3 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<3 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<3 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(3 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<3 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<4 + 1024 * 0, true> { int V __attribute__((bitwidth(4 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<4 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<4 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(4 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<4 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<5 + 1024 * 0, true> { int V __attribute__((bitwidth(5 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<5 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<5 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(5 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<5 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<6 + 1024 * 0, true> { int V __attribute__((bitwidth(6 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<6 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<6 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(6 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<6 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<7 + 1024 * 0, true> { int V __attribute__((bitwidth(7 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<7 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<7 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(7 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<7 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<8 + 1024 * 0, true> { int V __attribute__((bitwidth(8 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<8 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<8 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(8 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<8 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<9 + 1024 * 0, true> { int V __attribute__((bitwidth(9 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<9 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<9 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(9 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<9 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<10 + 1024 * 0, true> { int V __attribute__((bitwidth(10 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<10 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<10 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(10 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<10 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<11 + 1024 * 0, true> { int V __attribute__((bitwidth(11 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<11 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<11 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(11 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<11 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<12 + 1024 * 0, true> { int V __attribute__((bitwidth(12 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<12 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<12 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(12 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<12 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<13 + 1024 * 0, true> { int V __attribute__((bitwidth(13 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<13 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<13 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(13 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<13 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<14 + 1024 * 0, true> { int V __attribute__((bitwidth(14 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<14 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<14 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(14 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<14 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<15 + 1024 * 0, true> { int V __attribute__((bitwidth(15 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<15 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<15 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(15 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<15 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<16 + 1024 * 0, true> { int V __attribute__((bitwidth(16 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<16 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<16 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(16 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<16 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<17 + 1024 * 0, true> { int V __attribute__((bitwidth(17 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<17 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<17 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(17 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<17 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<18 + 1024 * 0, true> { int V __attribute__((bitwidth(18 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<18 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<18 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(18 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<18 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<19 + 1024 * 0, true> { int V __attribute__((bitwidth(19 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<19 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<19 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(19 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<19 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<20 + 1024 * 0, true> { int V __attribute__((bitwidth(20 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<20 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<20 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(20 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<20 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<21 + 1024 * 0, true> { int V __attribute__((bitwidth(21 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<21 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<21 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(21 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<21 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<22 + 1024 * 0, true> { int V __attribute__((bitwidth(22 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<22 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<22 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(22 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<22 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<23 + 1024 * 0, true> { int V __attribute__((bitwidth(23 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<23 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<23 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(23 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<23 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<24 + 1024 * 0, true> { int V __attribute__((bitwidth(24 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<24 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<24 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(24 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<24 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<25 + 1024 * 0, true> { int V __attribute__((bitwidth(25 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<25 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<25 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(25 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<25 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<26 + 1024 * 0, true> { int V __attribute__((bitwidth(26 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<26 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<26 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(26 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<26 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<27 + 1024 * 0, true> { int V __attribute__((bitwidth(27 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<27 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<27 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(27 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<27 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<28 + 1024 * 0, true> { int V __attribute__((bitwidth(28 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<28 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<28 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(28 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<28 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<29 + 1024 * 0, true> { int V __attribute__((bitwidth(29 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<29 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<29 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(29 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<29 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<30 + 1024 * 0, true> { int V __attribute__((bitwidth(30 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<30 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<30 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(30 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<30 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<31 + 1024 * 0, true> { int V __attribute__((bitwidth(31 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<31 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<31 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(31 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<31 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<32 + 1024 * 0, true> { int V __attribute__((bitwidth(32 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<32 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<32 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(32 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<32 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<33 + 1024 * 0, true> { int V __attribute__((bitwidth(33 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<33 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<33 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(33 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<33 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<34 + 1024 * 0, true> { int V __attribute__((bitwidth(34 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<34 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<34 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(34 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<34 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<35 + 1024 * 0, true> { int V __attribute__((bitwidth(35 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<35 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<35 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(35 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<35 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<36 + 1024 * 0, true> { int V __attribute__((bitwidth(36 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<36 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<36 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(36 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<36 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<37 + 1024 * 0, true> { int V __attribute__((bitwidth(37 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<37 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<37 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(37 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<37 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<38 + 1024 * 0, true> { int V __attribute__((bitwidth(38 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<38 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<38 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(38 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<38 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<39 + 1024 * 0, true> { int V __attribute__((bitwidth(39 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<39 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<39 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(39 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<39 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<40 + 1024 * 0, true> { int V __attribute__((bitwidth(40 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<40 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<40 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(40 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<40 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<41 + 1024 * 0, true> { int V __attribute__((bitwidth(41 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<41 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<41 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(41 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<41 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<42 + 1024 * 0, true> { int V __attribute__((bitwidth(42 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<42 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<42 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(42 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<42 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<43 + 1024 * 0, true> { int V __attribute__((bitwidth(43 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<43 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<43 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(43 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<43 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<44 + 1024 * 0, true> { int V __attribute__((bitwidth(44 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<44 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<44 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(44 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<44 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<45 + 1024 * 0, true> { int V __attribute__((bitwidth(45 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<45 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<45 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(45 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<45 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<46 + 1024 * 0, true> { int V __attribute__((bitwidth(46 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<46 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<46 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(46 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<46 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<47 + 1024 * 0, true> { int V __attribute__((bitwidth(47 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<47 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<47 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(47 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<47 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<48 + 1024 * 0, true> { int V __attribute__((bitwidth(48 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<48 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<48 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(48 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<48 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<49 + 1024 * 0, true> { int V __attribute__((bitwidth(49 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<49 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<49 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(49 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<49 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<50 + 1024 * 0, true> { int V __attribute__((bitwidth(50 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<50 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<50 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(50 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<50 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<51 + 1024 * 0, true> { int V __attribute__((bitwidth(51 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<51 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<51 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(51 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<51 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<52 + 1024 * 0, true> { int V __attribute__((bitwidth(52 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<52 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<52 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(52 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<52 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<53 + 1024 * 0, true> { int V __attribute__((bitwidth(53 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<53 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<53 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(53 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<53 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<54 + 1024 * 0, true> { int V __attribute__((bitwidth(54 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<54 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<54 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(54 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<54 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<55 + 1024 * 0, true> { int V __attribute__((bitwidth(55 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<55 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<55 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(55 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<55 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<56 + 1024 * 0, true> { int V __attribute__((bitwidth(56 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<56 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<56 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(56 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<56 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<57 + 1024 * 0, true> { int V __attribute__((bitwidth(57 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<57 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<57 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(57 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<57 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<58 + 1024 * 0, true> { int V __attribute__((bitwidth(58 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<58 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<58 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(58 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<58 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<59 + 1024 * 0, true> { int V __attribute__((bitwidth(59 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<59 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<59 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(59 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<59 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<60 + 1024 * 0, true> { int V __attribute__((bitwidth(60 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<60 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<60 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(60 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<60 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<61 + 1024 * 0, true> { int V __attribute__((bitwidth(61 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<61 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<61 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(61 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<61 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<62 + 1024 * 0, true> { int V __attribute__((bitwidth(62 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<62 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<62 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(62 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<62 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<63 + 1024 * 0, true> { int V __attribute__((bitwidth(63 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<63 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<63 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(63 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<63 + 1024 * 0, false>(){}; };


template <> struct ssdm_int<64 + 1024 * 0, true> { int V __attribute__((bitwidth(64 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<64 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<64 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(64 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<64 + 1024 * 0, false>(){}; };




template <> struct ssdm_int<65 + 1024 * 0, true> { int V __attribute__((bitwidth(65 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<65 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<65 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(65 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<65 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<66 + 1024 * 0, true> { int V __attribute__((bitwidth(66 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<66 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<66 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(66 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<66 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<67 + 1024 * 0, true> { int V __attribute__((bitwidth(67 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<67 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<67 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(67 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<67 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<68 + 1024 * 0, true> { int V __attribute__((bitwidth(68 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<68 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<68 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(68 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<68 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<69 + 1024 * 0, true> { int V __attribute__((bitwidth(69 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<69 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<69 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(69 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<69 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<70 + 1024 * 0, true> { int V __attribute__((bitwidth(70 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<70 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<70 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(70 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<70 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<71 + 1024 * 0, true> { int V __attribute__((bitwidth(71 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<71 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<71 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(71 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<71 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<72 + 1024 * 0, true> { int V __attribute__((bitwidth(72 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<72 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<72 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(72 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<72 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<73 + 1024 * 0, true> { int V __attribute__((bitwidth(73 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<73 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<73 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(73 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<73 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<74 + 1024 * 0, true> { int V __attribute__((bitwidth(74 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<74 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<74 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(74 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<74 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<75 + 1024 * 0, true> { int V __attribute__((bitwidth(75 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<75 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<75 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(75 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<75 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<76 + 1024 * 0, true> { int V __attribute__((bitwidth(76 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<76 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<76 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(76 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<76 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<77 + 1024 * 0, true> { int V __attribute__((bitwidth(77 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<77 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<77 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(77 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<77 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<78 + 1024 * 0, true> { int V __attribute__((bitwidth(78 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<78 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<78 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(78 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<78 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<79 + 1024 * 0, true> { int V __attribute__((bitwidth(79 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<79 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<79 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(79 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<79 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<80 + 1024 * 0, true> { int V __attribute__((bitwidth(80 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<80 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<80 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(80 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<80 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<81 + 1024 * 0, true> { int V __attribute__((bitwidth(81 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<81 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<81 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(81 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<81 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<82 + 1024 * 0, true> { int V __attribute__((bitwidth(82 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<82 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<82 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(82 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<82 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<83 + 1024 * 0, true> { int V __attribute__((bitwidth(83 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<83 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<83 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(83 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<83 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<84 + 1024 * 0, true> { int V __attribute__((bitwidth(84 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<84 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<84 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(84 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<84 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<85 + 1024 * 0, true> { int V __attribute__((bitwidth(85 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<85 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<85 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(85 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<85 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<86 + 1024 * 0, true> { int V __attribute__((bitwidth(86 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<86 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<86 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(86 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<86 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<87 + 1024 * 0, true> { int V __attribute__((bitwidth(87 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<87 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<87 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(87 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<87 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<88 + 1024 * 0, true> { int V __attribute__((bitwidth(88 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<88 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<88 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(88 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<88 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<89 + 1024 * 0, true> { int V __attribute__((bitwidth(89 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<89 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<89 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(89 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<89 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<90 + 1024 * 0, true> { int V __attribute__((bitwidth(90 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<90 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<90 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(90 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<90 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<91 + 1024 * 0, true> { int V __attribute__((bitwidth(91 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<91 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<91 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(91 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<91 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<92 + 1024 * 0, true> { int V __attribute__((bitwidth(92 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<92 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<92 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(92 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<92 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<93 + 1024 * 0, true> { int V __attribute__((bitwidth(93 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<93 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<93 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(93 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<93 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<94 + 1024 * 0, true> { int V __attribute__((bitwidth(94 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<94 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<94 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(94 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<94 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<95 + 1024 * 0, true> { int V __attribute__((bitwidth(95 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<95 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<95 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(95 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<95 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<96 + 1024 * 0, true> { int V __attribute__((bitwidth(96 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<96 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<96 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(96 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<96 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<97 + 1024 * 0, true> { int V __attribute__((bitwidth(97 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<97 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<97 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(97 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<97 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<98 + 1024 * 0, true> { int V __attribute__((bitwidth(98 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<98 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<98 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(98 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<98 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<99 + 1024 * 0, true> { int V __attribute__((bitwidth(99 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<99 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<99 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(99 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<99 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<100 + 1024 * 0, true> { int V __attribute__((bitwidth(100 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<100 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<100 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(100 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<100 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<101 + 1024 * 0, true> { int V __attribute__((bitwidth(101 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<101 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<101 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(101 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<101 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<102 + 1024 * 0, true> { int V __attribute__((bitwidth(102 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<102 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<102 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(102 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<102 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<103 + 1024 * 0, true> { int V __attribute__((bitwidth(103 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<103 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<103 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(103 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<103 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<104 + 1024 * 0, true> { int V __attribute__((bitwidth(104 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<104 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<104 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(104 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<104 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<105 + 1024 * 0, true> { int V __attribute__((bitwidth(105 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<105 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<105 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(105 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<105 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<106 + 1024 * 0, true> { int V __attribute__((bitwidth(106 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<106 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<106 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(106 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<106 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<107 + 1024 * 0, true> { int V __attribute__((bitwidth(107 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<107 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<107 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(107 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<107 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<108 + 1024 * 0, true> { int V __attribute__((bitwidth(108 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<108 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<108 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(108 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<108 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<109 + 1024 * 0, true> { int V __attribute__((bitwidth(109 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<109 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<109 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(109 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<109 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<110 + 1024 * 0, true> { int V __attribute__((bitwidth(110 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<110 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<110 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(110 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<110 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<111 + 1024 * 0, true> { int V __attribute__((bitwidth(111 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<111 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<111 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(111 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<111 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<112 + 1024 * 0, true> { int V __attribute__((bitwidth(112 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<112 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<112 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(112 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<112 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<113 + 1024 * 0, true> { int V __attribute__((bitwidth(113 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<113 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<113 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(113 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<113 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<114 + 1024 * 0, true> { int V __attribute__((bitwidth(114 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<114 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<114 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(114 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<114 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<115 + 1024 * 0, true> { int V __attribute__((bitwidth(115 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<115 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<115 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(115 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<115 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<116 + 1024 * 0, true> { int V __attribute__((bitwidth(116 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<116 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<116 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(116 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<116 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<117 + 1024 * 0, true> { int V __attribute__((bitwidth(117 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<117 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<117 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(117 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<117 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<118 + 1024 * 0, true> { int V __attribute__((bitwidth(118 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<118 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<118 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(118 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<118 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<119 + 1024 * 0, true> { int V __attribute__((bitwidth(119 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<119 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<119 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(119 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<119 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<120 + 1024 * 0, true> { int V __attribute__((bitwidth(120 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<120 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<120 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(120 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<120 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<121 + 1024 * 0, true> { int V __attribute__((bitwidth(121 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<121 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<121 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(121 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<121 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<122 + 1024 * 0, true> { int V __attribute__((bitwidth(122 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<122 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<122 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(122 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<122 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<123 + 1024 * 0, true> { int V __attribute__((bitwidth(123 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<123 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<123 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(123 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<123 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<124 + 1024 * 0, true> { int V __attribute__((bitwidth(124 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<124 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<124 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(124 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<124 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<125 + 1024 * 0, true> { int V __attribute__((bitwidth(125 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<125 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<125 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(125 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<125 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<126 + 1024 * 0, true> { int V __attribute__((bitwidth(126 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<126 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<126 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(126 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<126 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<127 + 1024 * 0, true> { int V __attribute__((bitwidth(127 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<127 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<127 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(127 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<127 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<128 + 1024 * 0, true> { int V __attribute__((bitwidth(128 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<128 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<128 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(128 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<128 + 1024 * 0, false>(){}; };






template <> struct ssdm_int<129 + 1024 * 0, true> { int V __attribute__((bitwidth(129 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<129 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<129 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(129 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<129 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<130 + 1024 * 0, true> { int V __attribute__((bitwidth(130 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<130 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<130 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(130 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<130 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<131 + 1024 * 0, true> { int V __attribute__((bitwidth(131 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<131 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<131 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(131 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<131 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<132 + 1024 * 0, true> { int V __attribute__((bitwidth(132 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<132 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<132 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(132 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<132 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<133 + 1024 * 0, true> { int V __attribute__((bitwidth(133 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<133 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<133 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(133 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<133 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<134 + 1024 * 0, true> { int V __attribute__((bitwidth(134 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<134 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<134 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(134 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<134 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<135 + 1024 * 0, true> { int V __attribute__((bitwidth(135 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<135 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<135 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(135 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<135 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<136 + 1024 * 0, true> { int V __attribute__((bitwidth(136 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<136 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<136 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(136 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<136 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<137 + 1024 * 0, true> { int V __attribute__((bitwidth(137 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<137 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<137 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(137 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<137 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<138 + 1024 * 0, true> { int V __attribute__((bitwidth(138 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<138 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<138 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(138 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<138 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<139 + 1024 * 0, true> { int V __attribute__((bitwidth(139 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<139 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<139 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(139 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<139 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<140 + 1024 * 0, true> { int V __attribute__((bitwidth(140 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<140 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<140 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(140 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<140 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<141 + 1024 * 0, true> { int V __attribute__((bitwidth(141 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<141 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<141 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(141 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<141 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<142 + 1024 * 0, true> { int V __attribute__((bitwidth(142 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<142 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<142 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(142 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<142 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<143 + 1024 * 0, true> { int V __attribute__((bitwidth(143 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<143 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<143 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(143 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<143 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<144 + 1024 * 0, true> { int V __attribute__((bitwidth(144 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<144 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<144 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(144 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<144 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<145 + 1024 * 0, true> { int V __attribute__((bitwidth(145 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<145 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<145 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(145 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<145 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<146 + 1024 * 0, true> { int V __attribute__((bitwidth(146 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<146 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<146 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(146 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<146 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<147 + 1024 * 0, true> { int V __attribute__((bitwidth(147 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<147 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<147 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(147 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<147 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<148 + 1024 * 0, true> { int V __attribute__((bitwidth(148 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<148 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<148 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(148 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<148 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<149 + 1024 * 0, true> { int V __attribute__((bitwidth(149 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<149 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<149 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(149 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<149 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<150 + 1024 * 0, true> { int V __attribute__((bitwidth(150 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<150 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<150 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(150 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<150 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<151 + 1024 * 0, true> { int V __attribute__((bitwidth(151 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<151 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<151 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(151 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<151 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<152 + 1024 * 0, true> { int V __attribute__((bitwidth(152 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<152 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<152 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(152 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<152 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<153 + 1024 * 0, true> { int V __attribute__((bitwidth(153 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<153 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<153 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(153 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<153 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<154 + 1024 * 0, true> { int V __attribute__((bitwidth(154 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<154 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<154 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(154 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<154 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<155 + 1024 * 0, true> { int V __attribute__((bitwidth(155 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<155 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<155 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(155 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<155 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<156 + 1024 * 0, true> { int V __attribute__((bitwidth(156 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<156 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<156 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(156 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<156 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<157 + 1024 * 0, true> { int V __attribute__((bitwidth(157 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<157 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<157 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(157 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<157 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<158 + 1024 * 0, true> { int V __attribute__((bitwidth(158 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<158 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<158 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(158 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<158 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<159 + 1024 * 0, true> { int V __attribute__((bitwidth(159 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<159 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<159 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(159 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<159 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<160 + 1024 * 0, true> { int V __attribute__((bitwidth(160 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<160 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<160 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(160 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<160 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<161 + 1024 * 0, true> { int V __attribute__((bitwidth(161 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<161 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<161 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(161 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<161 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<162 + 1024 * 0, true> { int V __attribute__((bitwidth(162 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<162 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<162 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(162 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<162 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<163 + 1024 * 0, true> { int V __attribute__((bitwidth(163 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<163 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<163 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(163 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<163 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<164 + 1024 * 0, true> { int V __attribute__((bitwidth(164 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<164 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<164 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(164 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<164 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<165 + 1024 * 0, true> { int V __attribute__((bitwidth(165 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<165 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<165 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(165 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<165 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<166 + 1024 * 0, true> { int V __attribute__((bitwidth(166 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<166 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<166 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(166 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<166 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<167 + 1024 * 0, true> { int V __attribute__((bitwidth(167 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<167 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<167 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(167 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<167 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<168 + 1024 * 0, true> { int V __attribute__((bitwidth(168 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<168 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<168 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(168 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<168 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<169 + 1024 * 0, true> { int V __attribute__((bitwidth(169 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<169 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<169 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(169 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<169 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<170 + 1024 * 0, true> { int V __attribute__((bitwidth(170 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<170 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<170 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(170 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<170 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<171 + 1024 * 0, true> { int V __attribute__((bitwidth(171 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<171 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<171 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(171 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<171 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<172 + 1024 * 0, true> { int V __attribute__((bitwidth(172 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<172 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<172 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(172 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<172 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<173 + 1024 * 0, true> { int V __attribute__((bitwidth(173 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<173 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<173 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(173 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<173 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<174 + 1024 * 0, true> { int V __attribute__((bitwidth(174 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<174 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<174 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(174 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<174 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<175 + 1024 * 0, true> { int V __attribute__((bitwidth(175 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<175 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<175 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(175 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<175 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<176 + 1024 * 0, true> { int V __attribute__((bitwidth(176 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<176 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<176 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(176 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<176 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<177 + 1024 * 0, true> { int V __attribute__((bitwidth(177 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<177 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<177 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(177 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<177 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<178 + 1024 * 0, true> { int V __attribute__((bitwidth(178 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<178 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<178 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(178 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<178 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<179 + 1024 * 0, true> { int V __attribute__((bitwidth(179 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<179 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<179 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(179 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<179 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<180 + 1024 * 0, true> { int V __attribute__((bitwidth(180 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<180 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<180 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(180 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<180 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<181 + 1024 * 0, true> { int V __attribute__((bitwidth(181 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<181 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<181 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(181 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<181 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<182 + 1024 * 0, true> { int V __attribute__((bitwidth(182 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<182 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<182 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(182 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<182 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<183 + 1024 * 0, true> { int V __attribute__((bitwidth(183 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<183 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<183 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(183 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<183 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<184 + 1024 * 0, true> { int V __attribute__((bitwidth(184 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<184 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<184 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(184 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<184 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<185 + 1024 * 0, true> { int V __attribute__((bitwidth(185 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<185 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<185 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(185 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<185 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<186 + 1024 * 0, true> { int V __attribute__((bitwidth(186 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<186 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<186 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(186 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<186 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<187 + 1024 * 0, true> { int V __attribute__((bitwidth(187 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<187 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<187 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(187 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<187 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<188 + 1024 * 0, true> { int V __attribute__((bitwidth(188 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<188 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<188 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(188 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<188 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<189 + 1024 * 0, true> { int V __attribute__((bitwidth(189 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<189 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<189 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(189 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<189 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<190 + 1024 * 0, true> { int V __attribute__((bitwidth(190 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<190 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<190 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(190 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<190 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<191 + 1024 * 0, true> { int V __attribute__((bitwidth(191 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<191 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<191 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(191 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<191 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<192 + 1024 * 0, true> { int V __attribute__((bitwidth(192 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<192 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<192 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(192 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<192 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<193 + 1024 * 0, true> { int V __attribute__((bitwidth(193 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<193 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<193 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(193 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<193 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<194 + 1024 * 0, true> { int V __attribute__((bitwidth(194 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<194 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<194 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(194 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<194 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<195 + 1024 * 0, true> { int V __attribute__((bitwidth(195 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<195 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<195 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(195 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<195 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<196 + 1024 * 0, true> { int V __attribute__((bitwidth(196 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<196 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<196 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(196 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<196 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<197 + 1024 * 0, true> { int V __attribute__((bitwidth(197 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<197 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<197 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(197 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<197 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<198 + 1024 * 0, true> { int V __attribute__((bitwidth(198 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<198 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<198 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(198 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<198 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<199 + 1024 * 0, true> { int V __attribute__((bitwidth(199 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<199 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<199 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(199 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<199 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<200 + 1024 * 0, true> { int V __attribute__((bitwidth(200 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<200 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<200 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(200 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<200 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<201 + 1024 * 0, true> { int V __attribute__((bitwidth(201 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<201 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<201 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(201 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<201 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<202 + 1024 * 0, true> { int V __attribute__((bitwidth(202 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<202 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<202 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(202 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<202 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<203 + 1024 * 0, true> { int V __attribute__((bitwidth(203 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<203 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<203 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(203 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<203 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<204 + 1024 * 0, true> { int V __attribute__((bitwidth(204 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<204 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<204 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(204 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<204 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<205 + 1024 * 0, true> { int V __attribute__((bitwidth(205 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<205 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<205 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(205 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<205 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<206 + 1024 * 0, true> { int V __attribute__((bitwidth(206 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<206 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<206 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(206 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<206 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<207 + 1024 * 0, true> { int V __attribute__((bitwidth(207 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<207 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<207 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(207 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<207 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<208 + 1024 * 0, true> { int V __attribute__((bitwidth(208 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<208 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<208 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(208 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<208 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<209 + 1024 * 0, true> { int V __attribute__((bitwidth(209 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<209 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<209 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(209 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<209 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<210 + 1024 * 0, true> { int V __attribute__((bitwidth(210 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<210 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<210 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(210 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<210 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<211 + 1024 * 0, true> { int V __attribute__((bitwidth(211 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<211 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<211 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(211 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<211 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<212 + 1024 * 0, true> { int V __attribute__((bitwidth(212 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<212 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<212 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(212 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<212 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<213 + 1024 * 0, true> { int V __attribute__((bitwidth(213 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<213 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<213 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(213 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<213 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<214 + 1024 * 0, true> { int V __attribute__((bitwidth(214 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<214 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<214 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(214 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<214 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<215 + 1024 * 0, true> { int V __attribute__((bitwidth(215 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<215 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<215 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(215 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<215 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<216 + 1024 * 0, true> { int V __attribute__((bitwidth(216 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<216 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<216 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(216 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<216 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<217 + 1024 * 0, true> { int V __attribute__((bitwidth(217 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<217 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<217 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(217 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<217 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<218 + 1024 * 0, true> { int V __attribute__((bitwidth(218 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<218 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<218 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(218 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<218 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<219 + 1024 * 0, true> { int V __attribute__((bitwidth(219 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<219 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<219 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(219 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<219 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<220 + 1024 * 0, true> { int V __attribute__((bitwidth(220 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<220 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<220 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(220 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<220 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<221 + 1024 * 0, true> { int V __attribute__((bitwidth(221 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<221 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<221 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(221 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<221 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<222 + 1024 * 0, true> { int V __attribute__((bitwidth(222 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<222 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<222 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(222 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<222 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<223 + 1024 * 0, true> { int V __attribute__((bitwidth(223 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<223 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<223 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(223 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<223 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<224 + 1024 * 0, true> { int V __attribute__((bitwidth(224 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<224 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<224 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(224 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<224 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<225 + 1024 * 0, true> { int V __attribute__((bitwidth(225 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<225 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<225 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(225 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<225 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<226 + 1024 * 0, true> { int V __attribute__((bitwidth(226 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<226 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<226 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(226 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<226 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<227 + 1024 * 0, true> { int V __attribute__((bitwidth(227 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<227 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<227 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(227 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<227 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<228 + 1024 * 0, true> { int V __attribute__((bitwidth(228 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<228 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<228 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(228 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<228 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<229 + 1024 * 0, true> { int V __attribute__((bitwidth(229 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<229 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<229 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(229 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<229 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<230 + 1024 * 0, true> { int V __attribute__((bitwidth(230 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<230 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<230 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(230 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<230 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<231 + 1024 * 0, true> { int V __attribute__((bitwidth(231 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<231 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<231 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(231 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<231 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<232 + 1024 * 0, true> { int V __attribute__((bitwidth(232 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<232 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<232 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(232 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<232 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<233 + 1024 * 0, true> { int V __attribute__((bitwidth(233 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<233 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<233 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(233 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<233 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<234 + 1024 * 0, true> { int V __attribute__((bitwidth(234 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<234 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<234 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(234 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<234 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<235 + 1024 * 0, true> { int V __attribute__((bitwidth(235 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<235 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<235 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(235 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<235 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<236 + 1024 * 0, true> { int V __attribute__((bitwidth(236 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<236 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<236 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(236 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<236 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<237 + 1024 * 0, true> { int V __attribute__((bitwidth(237 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<237 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<237 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(237 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<237 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<238 + 1024 * 0, true> { int V __attribute__((bitwidth(238 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<238 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<238 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(238 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<238 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<239 + 1024 * 0, true> { int V __attribute__((bitwidth(239 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<239 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<239 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(239 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<239 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<240 + 1024 * 0, true> { int V __attribute__((bitwidth(240 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<240 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<240 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(240 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<240 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<241 + 1024 * 0, true> { int V __attribute__((bitwidth(241 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<241 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<241 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(241 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<241 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<242 + 1024 * 0, true> { int V __attribute__((bitwidth(242 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<242 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<242 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(242 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<242 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<243 + 1024 * 0, true> { int V __attribute__((bitwidth(243 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<243 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<243 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(243 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<243 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<244 + 1024 * 0, true> { int V __attribute__((bitwidth(244 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<244 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<244 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(244 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<244 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<245 + 1024 * 0, true> { int V __attribute__((bitwidth(245 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<245 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<245 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(245 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<245 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<246 + 1024 * 0, true> { int V __attribute__((bitwidth(246 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<246 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<246 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(246 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<246 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<247 + 1024 * 0, true> { int V __attribute__((bitwidth(247 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<247 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<247 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(247 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<247 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<248 + 1024 * 0, true> { int V __attribute__((bitwidth(248 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<248 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<248 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(248 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<248 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<249 + 1024 * 0, true> { int V __attribute__((bitwidth(249 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<249 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<249 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(249 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<249 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<250 + 1024 * 0, true> { int V __attribute__((bitwidth(250 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<250 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<250 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(250 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<250 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<251 + 1024 * 0, true> { int V __attribute__((bitwidth(251 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<251 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<251 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(251 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<251 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<252 + 1024 * 0, true> { int V __attribute__((bitwidth(252 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<252 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<252 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(252 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<252 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<253 + 1024 * 0, true> { int V __attribute__((bitwidth(253 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<253 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<253 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(253 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<253 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<254 + 1024 * 0, true> { int V __attribute__((bitwidth(254 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<254 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<254 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(254 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<254 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<255 + 1024 * 0, true> { int V __attribute__((bitwidth(255 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<255 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<255 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(255 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<255 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<256 + 1024 * 0, true> { int V __attribute__((bitwidth(256 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<256 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<256 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(256 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<256 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<257 + 1024 * 0, true> { int V __attribute__((bitwidth(257 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<257 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<257 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(257 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<257 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<258 + 1024 * 0, true> { int V __attribute__((bitwidth(258 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<258 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<258 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(258 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<258 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<259 + 1024 * 0, true> { int V __attribute__((bitwidth(259 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<259 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<259 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(259 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<259 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<260 + 1024 * 0, true> { int V __attribute__((bitwidth(260 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<260 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<260 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(260 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<260 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<261 + 1024 * 0, true> { int V __attribute__((bitwidth(261 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<261 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<261 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(261 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<261 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<262 + 1024 * 0, true> { int V __attribute__((bitwidth(262 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<262 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<262 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(262 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<262 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<263 + 1024 * 0, true> { int V __attribute__((bitwidth(263 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<263 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<263 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(263 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<263 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<264 + 1024 * 0, true> { int V __attribute__((bitwidth(264 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<264 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<264 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(264 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<264 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<265 + 1024 * 0, true> { int V __attribute__((bitwidth(265 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<265 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<265 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(265 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<265 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<266 + 1024 * 0, true> { int V __attribute__((bitwidth(266 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<266 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<266 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(266 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<266 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<267 + 1024 * 0, true> { int V __attribute__((bitwidth(267 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<267 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<267 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(267 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<267 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<268 + 1024 * 0, true> { int V __attribute__((bitwidth(268 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<268 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<268 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(268 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<268 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<269 + 1024 * 0, true> { int V __attribute__((bitwidth(269 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<269 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<269 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(269 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<269 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<270 + 1024 * 0, true> { int V __attribute__((bitwidth(270 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<270 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<270 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(270 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<270 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<271 + 1024 * 0, true> { int V __attribute__((bitwidth(271 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<271 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<271 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(271 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<271 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<272 + 1024 * 0, true> { int V __attribute__((bitwidth(272 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<272 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<272 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(272 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<272 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<273 + 1024 * 0, true> { int V __attribute__((bitwidth(273 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<273 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<273 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(273 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<273 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<274 + 1024 * 0, true> { int V __attribute__((bitwidth(274 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<274 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<274 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(274 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<274 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<275 + 1024 * 0, true> { int V __attribute__((bitwidth(275 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<275 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<275 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(275 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<275 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<276 + 1024 * 0, true> { int V __attribute__((bitwidth(276 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<276 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<276 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(276 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<276 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<277 + 1024 * 0, true> { int V __attribute__((bitwidth(277 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<277 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<277 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(277 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<277 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<278 + 1024 * 0, true> { int V __attribute__((bitwidth(278 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<278 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<278 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(278 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<278 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<279 + 1024 * 0, true> { int V __attribute__((bitwidth(279 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<279 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<279 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(279 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<279 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<280 + 1024 * 0, true> { int V __attribute__((bitwidth(280 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<280 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<280 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(280 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<280 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<281 + 1024 * 0, true> { int V __attribute__((bitwidth(281 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<281 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<281 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(281 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<281 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<282 + 1024 * 0, true> { int V __attribute__((bitwidth(282 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<282 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<282 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(282 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<282 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<283 + 1024 * 0, true> { int V __attribute__((bitwidth(283 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<283 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<283 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(283 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<283 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<284 + 1024 * 0, true> { int V __attribute__((bitwidth(284 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<284 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<284 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(284 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<284 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<285 + 1024 * 0, true> { int V __attribute__((bitwidth(285 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<285 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<285 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(285 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<285 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<286 + 1024 * 0, true> { int V __attribute__((bitwidth(286 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<286 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<286 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(286 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<286 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<287 + 1024 * 0, true> { int V __attribute__((bitwidth(287 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<287 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<287 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(287 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<287 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<288 + 1024 * 0, true> { int V __attribute__((bitwidth(288 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<288 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<288 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(288 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<288 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<289 + 1024 * 0, true> { int V __attribute__((bitwidth(289 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<289 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<289 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(289 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<289 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<290 + 1024 * 0, true> { int V __attribute__((bitwidth(290 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<290 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<290 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(290 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<290 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<291 + 1024 * 0, true> { int V __attribute__((bitwidth(291 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<291 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<291 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(291 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<291 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<292 + 1024 * 0, true> { int V __attribute__((bitwidth(292 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<292 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<292 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(292 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<292 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<293 + 1024 * 0, true> { int V __attribute__((bitwidth(293 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<293 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<293 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(293 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<293 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<294 + 1024 * 0, true> { int V __attribute__((bitwidth(294 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<294 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<294 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(294 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<294 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<295 + 1024 * 0, true> { int V __attribute__((bitwidth(295 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<295 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<295 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(295 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<295 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<296 + 1024 * 0, true> { int V __attribute__((bitwidth(296 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<296 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<296 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(296 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<296 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<297 + 1024 * 0, true> { int V __attribute__((bitwidth(297 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<297 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<297 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(297 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<297 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<298 + 1024 * 0, true> { int V __attribute__((bitwidth(298 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<298 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<298 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(298 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<298 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<299 + 1024 * 0, true> { int V __attribute__((bitwidth(299 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<299 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<299 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(299 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<299 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<300 + 1024 * 0, true> { int V __attribute__((bitwidth(300 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<300 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<300 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(300 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<300 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<301 + 1024 * 0, true> { int V __attribute__((bitwidth(301 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<301 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<301 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(301 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<301 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<302 + 1024 * 0, true> { int V __attribute__((bitwidth(302 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<302 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<302 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(302 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<302 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<303 + 1024 * 0, true> { int V __attribute__((bitwidth(303 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<303 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<303 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(303 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<303 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<304 + 1024 * 0, true> { int V __attribute__((bitwidth(304 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<304 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<304 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(304 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<304 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<305 + 1024 * 0, true> { int V __attribute__((bitwidth(305 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<305 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<305 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(305 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<305 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<306 + 1024 * 0, true> { int V __attribute__((bitwidth(306 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<306 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<306 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(306 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<306 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<307 + 1024 * 0, true> { int V __attribute__((bitwidth(307 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<307 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<307 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(307 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<307 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<308 + 1024 * 0, true> { int V __attribute__((bitwidth(308 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<308 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<308 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(308 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<308 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<309 + 1024 * 0, true> { int V __attribute__((bitwidth(309 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<309 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<309 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(309 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<309 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<310 + 1024 * 0, true> { int V __attribute__((bitwidth(310 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<310 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<310 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(310 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<310 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<311 + 1024 * 0, true> { int V __attribute__((bitwidth(311 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<311 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<311 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(311 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<311 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<312 + 1024 * 0, true> { int V __attribute__((bitwidth(312 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<312 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<312 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(312 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<312 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<313 + 1024 * 0, true> { int V __attribute__((bitwidth(313 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<313 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<313 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(313 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<313 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<314 + 1024 * 0, true> { int V __attribute__((bitwidth(314 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<314 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<314 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(314 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<314 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<315 + 1024 * 0, true> { int V __attribute__((bitwidth(315 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<315 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<315 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(315 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<315 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<316 + 1024 * 0, true> { int V __attribute__((bitwidth(316 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<316 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<316 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(316 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<316 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<317 + 1024 * 0, true> { int V __attribute__((bitwidth(317 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<317 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<317 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(317 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<317 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<318 + 1024 * 0, true> { int V __attribute__((bitwidth(318 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<318 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<318 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(318 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<318 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<319 + 1024 * 0, true> { int V __attribute__((bitwidth(319 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<319 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<319 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(319 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<319 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<320 + 1024 * 0, true> { int V __attribute__((bitwidth(320 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<320 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<320 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(320 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<320 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<321 + 1024 * 0, true> { int V __attribute__((bitwidth(321 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<321 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<321 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(321 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<321 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<322 + 1024 * 0, true> { int V __attribute__((bitwidth(322 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<322 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<322 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(322 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<322 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<323 + 1024 * 0, true> { int V __attribute__((bitwidth(323 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<323 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<323 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(323 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<323 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<324 + 1024 * 0, true> { int V __attribute__((bitwidth(324 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<324 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<324 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(324 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<324 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<325 + 1024 * 0, true> { int V __attribute__((bitwidth(325 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<325 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<325 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(325 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<325 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<326 + 1024 * 0, true> { int V __attribute__((bitwidth(326 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<326 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<326 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(326 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<326 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<327 + 1024 * 0, true> { int V __attribute__((bitwidth(327 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<327 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<327 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(327 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<327 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<328 + 1024 * 0, true> { int V __attribute__((bitwidth(328 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<328 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<328 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(328 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<328 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<329 + 1024 * 0, true> { int V __attribute__((bitwidth(329 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<329 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<329 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(329 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<329 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<330 + 1024 * 0, true> { int V __attribute__((bitwidth(330 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<330 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<330 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(330 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<330 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<331 + 1024 * 0, true> { int V __attribute__((bitwidth(331 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<331 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<331 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(331 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<331 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<332 + 1024 * 0, true> { int V __attribute__((bitwidth(332 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<332 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<332 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(332 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<332 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<333 + 1024 * 0, true> { int V __attribute__((bitwidth(333 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<333 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<333 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(333 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<333 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<334 + 1024 * 0, true> { int V __attribute__((bitwidth(334 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<334 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<334 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(334 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<334 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<335 + 1024 * 0, true> { int V __attribute__((bitwidth(335 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<335 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<335 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(335 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<335 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<336 + 1024 * 0, true> { int V __attribute__((bitwidth(336 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<336 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<336 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(336 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<336 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<337 + 1024 * 0, true> { int V __attribute__((bitwidth(337 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<337 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<337 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(337 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<337 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<338 + 1024 * 0, true> { int V __attribute__((bitwidth(338 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<338 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<338 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(338 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<338 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<339 + 1024 * 0, true> { int V __attribute__((bitwidth(339 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<339 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<339 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(339 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<339 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<340 + 1024 * 0, true> { int V __attribute__((bitwidth(340 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<340 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<340 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(340 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<340 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<341 + 1024 * 0, true> { int V __attribute__((bitwidth(341 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<341 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<341 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(341 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<341 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<342 + 1024 * 0, true> { int V __attribute__((bitwidth(342 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<342 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<342 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(342 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<342 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<343 + 1024 * 0, true> { int V __attribute__((bitwidth(343 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<343 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<343 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(343 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<343 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<344 + 1024 * 0, true> { int V __attribute__((bitwidth(344 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<344 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<344 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(344 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<344 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<345 + 1024 * 0, true> { int V __attribute__((bitwidth(345 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<345 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<345 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(345 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<345 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<346 + 1024 * 0, true> { int V __attribute__((bitwidth(346 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<346 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<346 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(346 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<346 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<347 + 1024 * 0, true> { int V __attribute__((bitwidth(347 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<347 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<347 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(347 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<347 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<348 + 1024 * 0, true> { int V __attribute__((bitwidth(348 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<348 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<348 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(348 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<348 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<349 + 1024 * 0, true> { int V __attribute__((bitwidth(349 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<349 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<349 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(349 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<349 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<350 + 1024 * 0, true> { int V __attribute__((bitwidth(350 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<350 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<350 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(350 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<350 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<351 + 1024 * 0, true> { int V __attribute__((bitwidth(351 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<351 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<351 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(351 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<351 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<352 + 1024 * 0, true> { int V __attribute__((bitwidth(352 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<352 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<352 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(352 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<352 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<353 + 1024 * 0, true> { int V __attribute__((bitwidth(353 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<353 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<353 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(353 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<353 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<354 + 1024 * 0, true> { int V __attribute__((bitwidth(354 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<354 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<354 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(354 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<354 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<355 + 1024 * 0, true> { int V __attribute__((bitwidth(355 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<355 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<355 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(355 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<355 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<356 + 1024 * 0, true> { int V __attribute__((bitwidth(356 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<356 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<356 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(356 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<356 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<357 + 1024 * 0, true> { int V __attribute__((bitwidth(357 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<357 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<357 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(357 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<357 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<358 + 1024 * 0, true> { int V __attribute__((bitwidth(358 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<358 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<358 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(358 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<358 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<359 + 1024 * 0, true> { int V __attribute__((bitwidth(359 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<359 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<359 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(359 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<359 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<360 + 1024 * 0, true> { int V __attribute__((bitwidth(360 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<360 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<360 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(360 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<360 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<361 + 1024 * 0, true> { int V __attribute__((bitwidth(361 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<361 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<361 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(361 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<361 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<362 + 1024 * 0, true> { int V __attribute__((bitwidth(362 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<362 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<362 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(362 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<362 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<363 + 1024 * 0, true> { int V __attribute__((bitwidth(363 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<363 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<363 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(363 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<363 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<364 + 1024 * 0, true> { int V __attribute__((bitwidth(364 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<364 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<364 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(364 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<364 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<365 + 1024 * 0, true> { int V __attribute__((bitwidth(365 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<365 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<365 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(365 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<365 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<366 + 1024 * 0, true> { int V __attribute__((bitwidth(366 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<366 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<366 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(366 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<366 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<367 + 1024 * 0, true> { int V __attribute__((bitwidth(367 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<367 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<367 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(367 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<367 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<368 + 1024 * 0, true> { int V __attribute__((bitwidth(368 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<368 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<368 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(368 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<368 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<369 + 1024 * 0, true> { int V __attribute__((bitwidth(369 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<369 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<369 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(369 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<369 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<370 + 1024 * 0, true> { int V __attribute__((bitwidth(370 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<370 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<370 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(370 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<370 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<371 + 1024 * 0, true> { int V __attribute__((bitwidth(371 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<371 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<371 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(371 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<371 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<372 + 1024 * 0, true> { int V __attribute__((bitwidth(372 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<372 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<372 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(372 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<372 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<373 + 1024 * 0, true> { int V __attribute__((bitwidth(373 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<373 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<373 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(373 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<373 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<374 + 1024 * 0, true> { int V __attribute__((bitwidth(374 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<374 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<374 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(374 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<374 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<375 + 1024 * 0, true> { int V __attribute__((bitwidth(375 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<375 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<375 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(375 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<375 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<376 + 1024 * 0, true> { int V __attribute__((bitwidth(376 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<376 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<376 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(376 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<376 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<377 + 1024 * 0, true> { int V __attribute__((bitwidth(377 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<377 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<377 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(377 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<377 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<378 + 1024 * 0, true> { int V __attribute__((bitwidth(378 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<378 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<378 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(378 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<378 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<379 + 1024 * 0, true> { int V __attribute__((bitwidth(379 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<379 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<379 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(379 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<379 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<380 + 1024 * 0, true> { int V __attribute__((bitwidth(380 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<380 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<380 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(380 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<380 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<381 + 1024 * 0, true> { int V __attribute__((bitwidth(381 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<381 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<381 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(381 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<381 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<382 + 1024 * 0, true> { int V __attribute__((bitwidth(382 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<382 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<382 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(382 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<382 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<383 + 1024 * 0, true> { int V __attribute__((bitwidth(383 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<383 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<383 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(383 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<383 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<384 + 1024 * 0, true> { int V __attribute__((bitwidth(384 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<384 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<384 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(384 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<384 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<385 + 1024 * 0, true> { int V __attribute__((bitwidth(385 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<385 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<385 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(385 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<385 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<386 + 1024 * 0, true> { int V __attribute__((bitwidth(386 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<386 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<386 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(386 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<386 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<387 + 1024 * 0, true> { int V __attribute__((bitwidth(387 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<387 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<387 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(387 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<387 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<388 + 1024 * 0, true> { int V __attribute__((bitwidth(388 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<388 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<388 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(388 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<388 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<389 + 1024 * 0, true> { int V __attribute__((bitwidth(389 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<389 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<389 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(389 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<389 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<390 + 1024 * 0, true> { int V __attribute__((bitwidth(390 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<390 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<390 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(390 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<390 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<391 + 1024 * 0, true> { int V __attribute__((bitwidth(391 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<391 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<391 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(391 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<391 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<392 + 1024 * 0, true> { int V __attribute__((bitwidth(392 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<392 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<392 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(392 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<392 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<393 + 1024 * 0, true> { int V __attribute__((bitwidth(393 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<393 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<393 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(393 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<393 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<394 + 1024 * 0, true> { int V __attribute__((bitwidth(394 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<394 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<394 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(394 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<394 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<395 + 1024 * 0, true> { int V __attribute__((bitwidth(395 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<395 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<395 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(395 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<395 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<396 + 1024 * 0, true> { int V __attribute__((bitwidth(396 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<396 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<396 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(396 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<396 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<397 + 1024 * 0, true> { int V __attribute__((bitwidth(397 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<397 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<397 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(397 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<397 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<398 + 1024 * 0, true> { int V __attribute__((bitwidth(398 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<398 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<398 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(398 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<398 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<399 + 1024 * 0, true> { int V __attribute__((bitwidth(399 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<399 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<399 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(399 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<399 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<400 + 1024 * 0, true> { int V __attribute__((bitwidth(400 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<400 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<400 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(400 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<400 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<401 + 1024 * 0, true> { int V __attribute__((bitwidth(401 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<401 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<401 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(401 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<401 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<402 + 1024 * 0, true> { int V __attribute__((bitwidth(402 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<402 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<402 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(402 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<402 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<403 + 1024 * 0, true> { int V __attribute__((bitwidth(403 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<403 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<403 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(403 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<403 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<404 + 1024 * 0, true> { int V __attribute__((bitwidth(404 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<404 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<404 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(404 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<404 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<405 + 1024 * 0, true> { int V __attribute__((bitwidth(405 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<405 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<405 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(405 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<405 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<406 + 1024 * 0, true> { int V __attribute__((bitwidth(406 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<406 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<406 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(406 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<406 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<407 + 1024 * 0, true> { int V __attribute__((bitwidth(407 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<407 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<407 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(407 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<407 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<408 + 1024 * 0, true> { int V __attribute__((bitwidth(408 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<408 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<408 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(408 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<408 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<409 + 1024 * 0, true> { int V __attribute__((bitwidth(409 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<409 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<409 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(409 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<409 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<410 + 1024 * 0, true> { int V __attribute__((bitwidth(410 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<410 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<410 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(410 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<410 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<411 + 1024 * 0, true> { int V __attribute__((bitwidth(411 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<411 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<411 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(411 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<411 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<412 + 1024 * 0, true> { int V __attribute__((bitwidth(412 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<412 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<412 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(412 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<412 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<413 + 1024 * 0, true> { int V __attribute__((bitwidth(413 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<413 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<413 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(413 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<413 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<414 + 1024 * 0, true> { int V __attribute__((bitwidth(414 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<414 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<414 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(414 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<414 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<415 + 1024 * 0, true> { int V __attribute__((bitwidth(415 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<415 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<415 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(415 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<415 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<416 + 1024 * 0, true> { int V __attribute__((bitwidth(416 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<416 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<416 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(416 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<416 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<417 + 1024 * 0, true> { int V __attribute__((bitwidth(417 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<417 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<417 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(417 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<417 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<418 + 1024 * 0, true> { int V __attribute__((bitwidth(418 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<418 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<418 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(418 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<418 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<419 + 1024 * 0, true> { int V __attribute__((bitwidth(419 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<419 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<419 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(419 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<419 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<420 + 1024 * 0, true> { int V __attribute__((bitwidth(420 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<420 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<420 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(420 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<420 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<421 + 1024 * 0, true> { int V __attribute__((bitwidth(421 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<421 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<421 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(421 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<421 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<422 + 1024 * 0, true> { int V __attribute__((bitwidth(422 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<422 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<422 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(422 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<422 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<423 + 1024 * 0, true> { int V __attribute__((bitwidth(423 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<423 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<423 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(423 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<423 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<424 + 1024 * 0, true> { int V __attribute__((bitwidth(424 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<424 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<424 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(424 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<424 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<425 + 1024 * 0, true> { int V __attribute__((bitwidth(425 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<425 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<425 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(425 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<425 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<426 + 1024 * 0, true> { int V __attribute__((bitwidth(426 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<426 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<426 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(426 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<426 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<427 + 1024 * 0, true> { int V __attribute__((bitwidth(427 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<427 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<427 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(427 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<427 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<428 + 1024 * 0, true> { int V __attribute__((bitwidth(428 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<428 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<428 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(428 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<428 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<429 + 1024 * 0, true> { int V __attribute__((bitwidth(429 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<429 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<429 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(429 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<429 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<430 + 1024 * 0, true> { int V __attribute__((bitwidth(430 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<430 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<430 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(430 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<430 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<431 + 1024 * 0, true> { int V __attribute__((bitwidth(431 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<431 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<431 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(431 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<431 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<432 + 1024 * 0, true> { int V __attribute__((bitwidth(432 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<432 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<432 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(432 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<432 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<433 + 1024 * 0, true> { int V __attribute__((bitwidth(433 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<433 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<433 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(433 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<433 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<434 + 1024 * 0, true> { int V __attribute__((bitwidth(434 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<434 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<434 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(434 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<434 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<435 + 1024 * 0, true> { int V __attribute__((bitwidth(435 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<435 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<435 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(435 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<435 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<436 + 1024 * 0, true> { int V __attribute__((bitwidth(436 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<436 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<436 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(436 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<436 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<437 + 1024 * 0, true> { int V __attribute__((bitwidth(437 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<437 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<437 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(437 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<437 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<438 + 1024 * 0, true> { int V __attribute__((bitwidth(438 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<438 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<438 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(438 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<438 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<439 + 1024 * 0, true> { int V __attribute__((bitwidth(439 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<439 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<439 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(439 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<439 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<440 + 1024 * 0, true> { int V __attribute__((bitwidth(440 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<440 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<440 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(440 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<440 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<441 + 1024 * 0, true> { int V __attribute__((bitwidth(441 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<441 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<441 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(441 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<441 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<442 + 1024 * 0, true> { int V __attribute__((bitwidth(442 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<442 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<442 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(442 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<442 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<443 + 1024 * 0, true> { int V __attribute__((bitwidth(443 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<443 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<443 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(443 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<443 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<444 + 1024 * 0, true> { int V __attribute__((bitwidth(444 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<444 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<444 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(444 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<444 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<445 + 1024 * 0, true> { int V __attribute__((bitwidth(445 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<445 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<445 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(445 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<445 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<446 + 1024 * 0, true> { int V __attribute__((bitwidth(446 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<446 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<446 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(446 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<446 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<447 + 1024 * 0, true> { int V __attribute__((bitwidth(447 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<447 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<447 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(447 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<447 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<448 + 1024 * 0, true> { int V __attribute__((bitwidth(448 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<448 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<448 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(448 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<448 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<449 + 1024 * 0, true> { int V __attribute__((bitwidth(449 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<449 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<449 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(449 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<449 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<450 + 1024 * 0, true> { int V __attribute__((bitwidth(450 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<450 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<450 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(450 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<450 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<451 + 1024 * 0, true> { int V __attribute__((bitwidth(451 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<451 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<451 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(451 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<451 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<452 + 1024 * 0, true> { int V __attribute__((bitwidth(452 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<452 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<452 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(452 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<452 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<453 + 1024 * 0, true> { int V __attribute__((bitwidth(453 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<453 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<453 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(453 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<453 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<454 + 1024 * 0, true> { int V __attribute__((bitwidth(454 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<454 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<454 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(454 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<454 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<455 + 1024 * 0, true> { int V __attribute__((bitwidth(455 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<455 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<455 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(455 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<455 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<456 + 1024 * 0, true> { int V __attribute__((bitwidth(456 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<456 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<456 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(456 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<456 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<457 + 1024 * 0, true> { int V __attribute__((bitwidth(457 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<457 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<457 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(457 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<457 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<458 + 1024 * 0, true> { int V __attribute__((bitwidth(458 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<458 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<458 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(458 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<458 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<459 + 1024 * 0, true> { int V __attribute__((bitwidth(459 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<459 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<459 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(459 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<459 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<460 + 1024 * 0, true> { int V __attribute__((bitwidth(460 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<460 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<460 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(460 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<460 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<461 + 1024 * 0, true> { int V __attribute__((bitwidth(461 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<461 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<461 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(461 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<461 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<462 + 1024 * 0, true> { int V __attribute__((bitwidth(462 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<462 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<462 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(462 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<462 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<463 + 1024 * 0, true> { int V __attribute__((bitwidth(463 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<463 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<463 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(463 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<463 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<464 + 1024 * 0, true> { int V __attribute__((bitwidth(464 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<464 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<464 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(464 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<464 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<465 + 1024 * 0, true> { int V __attribute__((bitwidth(465 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<465 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<465 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(465 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<465 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<466 + 1024 * 0, true> { int V __attribute__((bitwidth(466 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<466 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<466 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(466 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<466 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<467 + 1024 * 0, true> { int V __attribute__((bitwidth(467 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<467 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<467 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(467 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<467 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<468 + 1024 * 0, true> { int V __attribute__((bitwidth(468 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<468 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<468 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(468 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<468 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<469 + 1024 * 0, true> { int V __attribute__((bitwidth(469 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<469 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<469 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(469 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<469 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<470 + 1024 * 0, true> { int V __attribute__((bitwidth(470 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<470 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<470 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(470 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<470 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<471 + 1024 * 0, true> { int V __attribute__((bitwidth(471 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<471 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<471 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(471 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<471 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<472 + 1024 * 0, true> { int V __attribute__((bitwidth(472 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<472 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<472 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(472 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<472 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<473 + 1024 * 0, true> { int V __attribute__((bitwidth(473 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<473 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<473 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(473 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<473 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<474 + 1024 * 0, true> { int V __attribute__((bitwidth(474 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<474 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<474 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(474 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<474 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<475 + 1024 * 0, true> { int V __attribute__((bitwidth(475 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<475 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<475 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(475 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<475 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<476 + 1024 * 0, true> { int V __attribute__((bitwidth(476 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<476 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<476 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(476 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<476 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<477 + 1024 * 0, true> { int V __attribute__((bitwidth(477 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<477 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<477 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(477 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<477 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<478 + 1024 * 0, true> { int V __attribute__((bitwidth(478 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<478 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<478 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(478 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<478 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<479 + 1024 * 0, true> { int V __attribute__((bitwidth(479 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<479 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<479 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(479 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<479 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<480 + 1024 * 0, true> { int V __attribute__((bitwidth(480 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<480 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<480 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(480 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<480 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<481 + 1024 * 0, true> { int V __attribute__((bitwidth(481 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<481 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<481 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(481 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<481 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<482 + 1024 * 0, true> { int V __attribute__((bitwidth(482 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<482 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<482 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(482 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<482 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<483 + 1024 * 0, true> { int V __attribute__((bitwidth(483 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<483 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<483 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(483 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<483 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<484 + 1024 * 0, true> { int V __attribute__((bitwidth(484 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<484 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<484 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(484 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<484 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<485 + 1024 * 0, true> { int V __attribute__((bitwidth(485 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<485 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<485 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(485 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<485 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<486 + 1024 * 0, true> { int V __attribute__((bitwidth(486 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<486 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<486 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(486 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<486 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<487 + 1024 * 0, true> { int V __attribute__((bitwidth(487 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<487 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<487 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(487 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<487 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<488 + 1024 * 0, true> { int V __attribute__((bitwidth(488 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<488 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<488 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(488 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<488 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<489 + 1024 * 0, true> { int V __attribute__((bitwidth(489 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<489 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<489 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(489 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<489 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<490 + 1024 * 0, true> { int V __attribute__((bitwidth(490 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<490 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<490 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(490 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<490 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<491 + 1024 * 0, true> { int V __attribute__((bitwidth(491 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<491 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<491 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(491 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<491 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<492 + 1024 * 0, true> { int V __attribute__((bitwidth(492 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<492 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<492 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(492 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<492 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<493 + 1024 * 0, true> { int V __attribute__((bitwidth(493 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<493 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<493 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(493 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<493 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<494 + 1024 * 0, true> { int V __attribute__((bitwidth(494 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<494 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<494 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(494 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<494 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<495 + 1024 * 0, true> { int V __attribute__((bitwidth(495 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<495 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<495 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(495 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<495 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<496 + 1024 * 0, true> { int V __attribute__((bitwidth(496 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<496 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<496 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(496 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<496 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<497 + 1024 * 0, true> { int V __attribute__((bitwidth(497 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<497 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<497 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(497 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<497 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<498 + 1024 * 0, true> { int V __attribute__((bitwidth(498 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<498 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<498 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(498 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<498 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<499 + 1024 * 0, true> { int V __attribute__((bitwidth(499 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<499 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<499 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(499 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<499 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<500 + 1024 * 0, true> { int V __attribute__((bitwidth(500 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<500 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<500 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(500 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<500 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<501 + 1024 * 0, true> { int V __attribute__((bitwidth(501 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<501 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<501 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(501 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<501 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<502 + 1024 * 0, true> { int V __attribute__((bitwidth(502 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<502 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<502 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(502 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<502 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<503 + 1024 * 0, true> { int V __attribute__((bitwidth(503 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<503 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<503 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(503 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<503 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<504 + 1024 * 0, true> { int V __attribute__((bitwidth(504 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<504 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<504 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(504 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<504 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<505 + 1024 * 0, true> { int V __attribute__((bitwidth(505 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<505 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<505 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(505 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<505 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<506 + 1024 * 0, true> { int V __attribute__((bitwidth(506 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<506 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<506 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(506 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<506 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<507 + 1024 * 0, true> { int V __attribute__((bitwidth(507 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<507 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<507 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(507 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<507 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<508 + 1024 * 0, true> { int V __attribute__((bitwidth(508 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<508 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<508 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(508 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<508 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<509 + 1024 * 0, true> { int V __attribute__((bitwidth(509 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<509 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<509 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(509 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<509 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<510 + 1024 * 0, true> { int V __attribute__((bitwidth(510 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<510 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<510 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(510 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<510 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<511 + 1024 * 0, true> { int V __attribute__((bitwidth(511 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<511 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<511 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(511 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<511 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<512 + 1024 * 0, true> { int V __attribute__((bitwidth(512 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<512 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<512 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(512 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<512 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<513 + 1024 * 0, true> { int V __attribute__((bitwidth(513 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<513 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<513 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(513 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<513 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<514 + 1024 * 0, true> { int V __attribute__((bitwidth(514 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<514 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<514 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(514 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<514 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<515 + 1024 * 0, true> { int V __attribute__((bitwidth(515 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<515 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<515 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(515 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<515 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<516 + 1024 * 0, true> { int V __attribute__((bitwidth(516 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<516 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<516 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(516 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<516 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<517 + 1024 * 0, true> { int V __attribute__((bitwidth(517 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<517 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<517 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(517 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<517 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<518 + 1024 * 0, true> { int V __attribute__((bitwidth(518 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<518 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<518 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(518 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<518 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<519 + 1024 * 0, true> { int V __attribute__((bitwidth(519 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<519 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<519 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(519 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<519 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<520 + 1024 * 0, true> { int V __attribute__((bitwidth(520 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<520 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<520 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(520 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<520 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<521 + 1024 * 0, true> { int V __attribute__((bitwidth(521 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<521 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<521 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(521 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<521 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<522 + 1024 * 0, true> { int V __attribute__((bitwidth(522 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<522 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<522 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(522 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<522 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<523 + 1024 * 0, true> { int V __attribute__((bitwidth(523 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<523 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<523 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(523 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<523 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<524 + 1024 * 0, true> { int V __attribute__((bitwidth(524 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<524 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<524 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(524 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<524 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<525 + 1024 * 0, true> { int V __attribute__((bitwidth(525 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<525 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<525 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(525 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<525 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<526 + 1024 * 0, true> { int V __attribute__((bitwidth(526 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<526 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<526 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(526 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<526 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<527 + 1024 * 0, true> { int V __attribute__((bitwidth(527 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<527 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<527 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(527 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<527 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<528 + 1024 * 0, true> { int V __attribute__((bitwidth(528 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<528 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<528 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(528 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<528 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<529 + 1024 * 0, true> { int V __attribute__((bitwidth(529 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<529 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<529 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(529 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<529 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<530 + 1024 * 0, true> { int V __attribute__((bitwidth(530 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<530 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<530 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(530 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<530 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<531 + 1024 * 0, true> { int V __attribute__((bitwidth(531 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<531 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<531 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(531 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<531 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<532 + 1024 * 0, true> { int V __attribute__((bitwidth(532 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<532 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<532 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(532 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<532 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<533 + 1024 * 0, true> { int V __attribute__((bitwidth(533 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<533 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<533 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(533 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<533 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<534 + 1024 * 0, true> { int V __attribute__((bitwidth(534 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<534 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<534 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(534 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<534 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<535 + 1024 * 0, true> { int V __attribute__((bitwidth(535 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<535 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<535 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(535 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<535 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<536 + 1024 * 0, true> { int V __attribute__((bitwidth(536 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<536 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<536 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(536 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<536 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<537 + 1024 * 0, true> { int V __attribute__((bitwidth(537 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<537 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<537 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(537 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<537 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<538 + 1024 * 0, true> { int V __attribute__((bitwidth(538 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<538 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<538 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(538 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<538 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<539 + 1024 * 0, true> { int V __attribute__((bitwidth(539 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<539 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<539 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(539 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<539 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<540 + 1024 * 0, true> { int V __attribute__((bitwidth(540 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<540 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<540 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(540 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<540 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<541 + 1024 * 0, true> { int V __attribute__((bitwidth(541 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<541 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<541 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(541 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<541 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<542 + 1024 * 0, true> { int V __attribute__((bitwidth(542 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<542 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<542 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(542 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<542 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<543 + 1024 * 0, true> { int V __attribute__((bitwidth(543 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<543 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<543 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(543 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<543 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<544 + 1024 * 0, true> { int V __attribute__((bitwidth(544 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<544 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<544 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(544 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<544 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<545 + 1024 * 0, true> { int V __attribute__((bitwidth(545 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<545 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<545 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(545 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<545 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<546 + 1024 * 0, true> { int V __attribute__((bitwidth(546 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<546 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<546 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(546 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<546 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<547 + 1024 * 0, true> { int V __attribute__((bitwidth(547 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<547 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<547 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(547 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<547 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<548 + 1024 * 0, true> { int V __attribute__((bitwidth(548 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<548 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<548 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(548 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<548 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<549 + 1024 * 0, true> { int V __attribute__((bitwidth(549 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<549 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<549 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(549 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<549 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<550 + 1024 * 0, true> { int V __attribute__((bitwidth(550 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<550 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<550 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(550 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<550 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<551 + 1024 * 0, true> { int V __attribute__((bitwidth(551 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<551 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<551 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(551 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<551 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<552 + 1024 * 0, true> { int V __attribute__((bitwidth(552 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<552 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<552 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(552 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<552 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<553 + 1024 * 0, true> { int V __attribute__((bitwidth(553 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<553 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<553 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(553 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<553 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<554 + 1024 * 0, true> { int V __attribute__((bitwidth(554 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<554 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<554 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(554 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<554 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<555 + 1024 * 0, true> { int V __attribute__((bitwidth(555 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<555 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<555 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(555 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<555 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<556 + 1024 * 0, true> { int V __attribute__((bitwidth(556 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<556 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<556 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(556 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<556 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<557 + 1024 * 0, true> { int V __attribute__((bitwidth(557 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<557 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<557 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(557 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<557 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<558 + 1024 * 0, true> { int V __attribute__((bitwidth(558 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<558 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<558 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(558 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<558 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<559 + 1024 * 0, true> { int V __attribute__((bitwidth(559 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<559 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<559 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(559 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<559 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<560 + 1024 * 0, true> { int V __attribute__((bitwidth(560 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<560 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<560 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(560 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<560 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<561 + 1024 * 0, true> { int V __attribute__((bitwidth(561 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<561 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<561 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(561 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<561 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<562 + 1024 * 0, true> { int V __attribute__((bitwidth(562 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<562 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<562 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(562 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<562 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<563 + 1024 * 0, true> { int V __attribute__((bitwidth(563 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<563 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<563 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(563 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<563 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<564 + 1024 * 0, true> { int V __attribute__((bitwidth(564 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<564 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<564 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(564 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<564 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<565 + 1024 * 0, true> { int V __attribute__((bitwidth(565 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<565 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<565 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(565 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<565 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<566 + 1024 * 0, true> { int V __attribute__((bitwidth(566 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<566 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<566 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(566 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<566 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<567 + 1024 * 0, true> { int V __attribute__((bitwidth(567 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<567 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<567 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(567 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<567 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<568 + 1024 * 0, true> { int V __attribute__((bitwidth(568 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<568 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<568 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(568 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<568 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<569 + 1024 * 0, true> { int V __attribute__((bitwidth(569 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<569 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<569 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(569 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<569 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<570 + 1024 * 0, true> { int V __attribute__((bitwidth(570 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<570 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<570 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(570 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<570 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<571 + 1024 * 0, true> { int V __attribute__((bitwidth(571 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<571 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<571 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(571 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<571 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<572 + 1024 * 0, true> { int V __attribute__((bitwidth(572 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<572 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<572 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(572 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<572 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<573 + 1024 * 0, true> { int V __attribute__((bitwidth(573 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<573 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<573 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(573 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<573 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<574 + 1024 * 0, true> { int V __attribute__((bitwidth(574 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<574 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<574 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(574 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<574 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<575 + 1024 * 0, true> { int V __attribute__((bitwidth(575 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<575 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<575 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(575 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<575 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<576 + 1024 * 0, true> { int V __attribute__((bitwidth(576 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<576 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<576 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(576 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<576 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<577 + 1024 * 0, true> { int V __attribute__((bitwidth(577 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<577 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<577 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(577 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<577 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<578 + 1024 * 0, true> { int V __attribute__((bitwidth(578 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<578 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<578 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(578 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<578 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<579 + 1024 * 0, true> { int V __attribute__((bitwidth(579 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<579 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<579 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(579 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<579 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<580 + 1024 * 0, true> { int V __attribute__((bitwidth(580 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<580 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<580 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(580 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<580 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<581 + 1024 * 0, true> { int V __attribute__((bitwidth(581 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<581 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<581 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(581 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<581 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<582 + 1024 * 0, true> { int V __attribute__((bitwidth(582 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<582 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<582 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(582 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<582 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<583 + 1024 * 0, true> { int V __attribute__((bitwidth(583 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<583 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<583 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(583 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<583 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<584 + 1024 * 0, true> { int V __attribute__((bitwidth(584 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<584 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<584 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(584 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<584 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<585 + 1024 * 0, true> { int V __attribute__((bitwidth(585 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<585 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<585 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(585 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<585 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<586 + 1024 * 0, true> { int V __attribute__((bitwidth(586 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<586 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<586 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(586 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<586 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<587 + 1024 * 0, true> { int V __attribute__((bitwidth(587 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<587 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<587 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(587 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<587 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<588 + 1024 * 0, true> { int V __attribute__((bitwidth(588 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<588 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<588 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(588 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<588 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<589 + 1024 * 0, true> { int V __attribute__((bitwidth(589 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<589 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<589 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(589 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<589 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<590 + 1024 * 0, true> { int V __attribute__((bitwidth(590 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<590 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<590 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(590 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<590 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<591 + 1024 * 0, true> { int V __attribute__((bitwidth(591 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<591 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<591 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(591 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<591 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<592 + 1024 * 0, true> { int V __attribute__((bitwidth(592 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<592 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<592 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(592 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<592 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<593 + 1024 * 0, true> { int V __attribute__((bitwidth(593 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<593 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<593 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(593 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<593 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<594 + 1024 * 0, true> { int V __attribute__((bitwidth(594 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<594 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<594 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(594 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<594 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<595 + 1024 * 0, true> { int V __attribute__((bitwidth(595 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<595 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<595 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(595 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<595 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<596 + 1024 * 0, true> { int V __attribute__((bitwidth(596 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<596 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<596 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(596 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<596 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<597 + 1024 * 0, true> { int V __attribute__((bitwidth(597 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<597 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<597 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(597 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<597 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<598 + 1024 * 0, true> { int V __attribute__((bitwidth(598 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<598 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<598 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(598 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<598 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<599 + 1024 * 0, true> { int V __attribute__((bitwidth(599 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<599 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<599 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(599 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<599 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<600 + 1024 * 0, true> { int V __attribute__((bitwidth(600 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<600 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<600 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(600 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<600 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<601 + 1024 * 0, true> { int V __attribute__((bitwidth(601 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<601 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<601 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(601 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<601 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<602 + 1024 * 0, true> { int V __attribute__((bitwidth(602 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<602 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<602 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(602 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<602 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<603 + 1024 * 0, true> { int V __attribute__((bitwidth(603 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<603 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<603 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(603 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<603 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<604 + 1024 * 0, true> { int V __attribute__((bitwidth(604 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<604 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<604 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(604 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<604 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<605 + 1024 * 0, true> { int V __attribute__((bitwidth(605 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<605 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<605 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(605 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<605 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<606 + 1024 * 0, true> { int V __attribute__((bitwidth(606 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<606 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<606 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(606 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<606 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<607 + 1024 * 0, true> { int V __attribute__((bitwidth(607 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<607 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<607 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(607 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<607 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<608 + 1024 * 0, true> { int V __attribute__((bitwidth(608 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<608 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<608 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(608 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<608 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<609 + 1024 * 0, true> { int V __attribute__((bitwidth(609 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<609 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<609 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(609 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<609 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<610 + 1024 * 0, true> { int V __attribute__((bitwidth(610 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<610 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<610 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(610 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<610 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<611 + 1024 * 0, true> { int V __attribute__((bitwidth(611 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<611 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<611 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(611 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<611 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<612 + 1024 * 0, true> { int V __attribute__((bitwidth(612 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<612 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<612 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(612 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<612 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<613 + 1024 * 0, true> { int V __attribute__((bitwidth(613 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<613 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<613 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(613 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<613 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<614 + 1024 * 0, true> { int V __attribute__((bitwidth(614 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<614 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<614 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(614 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<614 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<615 + 1024 * 0, true> { int V __attribute__((bitwidth(615 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<615 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<615 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(615 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<615 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<616 + 1024 * 0, true> { int V __attribute__((bitwidth(616 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<616 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<616 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(616 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<616 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<617 + 1024 * 0, true> { int V __attribute__((bitwidth(617 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<617 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<617 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(617 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<617 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<618 + 1024 * 0, true> { int V __attribute__((bitwidth(618 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<618 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<618 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(618 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<618 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<619 + 1024 * 0, true> { int V __attribute__((bitwidth(619 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<619 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<619 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(619 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<619 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<620 + 1024 * 0, true> { int V __attribute__((bitwidth(620 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<620 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<620 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(620 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<620 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<621 + 1024 * 0, true> { int V __attribute__((bitwidth(621 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<621 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<621 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(621 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<621 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<622 + 1024 * 0, true> { int V __attribute__((bitwidth(622 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<622 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<622 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(622 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<622 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<623 + 1024 * 0, true> { int V __attribute__((bitwidth(623 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<623 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<623 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(623 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<623 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<624 + 1024 * 0, true> { int V __attribute__((bitwidth(624 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<624 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<624 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(624 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<624 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<625 + 1024 * 0, true> { int V __attribute__((bitwidth(625 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<625 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<625 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(625 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<625 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<626 + 1024 * 0, true> { int V __attribute__((bitwidth(626 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<626 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<626 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(626 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<626 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<627 + 1024 * 0, true> { int V __attribute__((bitwidth(627 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<627 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<627 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(627 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<627 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<628 + 1024 * 0, true> { int V __attribute__((bitwidth(628 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<628 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<628 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(628 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<628 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<629 + 1024 * 0, true> { int V __attribute__((bitwidth(629 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<629 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<629 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(629 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<629 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<630 + 1024 * 0, true> { int V __attribute__((bitwidth(630 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<630 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<630 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(630 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<630 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<631 + 1024 * 0, true> { int V __attribute__((bitwidth(631 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<631 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<631 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(631 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<631 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<632 + 1024 * 0, true> { int V __attribute__((bitwidth(632 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<632 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<632 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(632 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<632 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<633 + 1024 * 0, true> { int V __attribute__((bitwidth(633 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<633 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<633 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(633 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<633 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<634 + 1024 * 0, true> { int V __attribute__((bitwidth(634 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<634 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<634 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(634 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<634 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<635 + 1024 * 0, true> { int V __attribute__((bitwidth(635 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<635 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<635 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(635 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<635 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<636 + 1024 * 0, true> { int V __attribute__((bitwidth(636 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<636 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<636 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(636 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<636 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<637 + 1024 * 0, true> { int V __attribute__((bitwidth(637 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<637 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<637 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(637 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<637 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<638 + 1024 * 0, true> { int V __attribute__((bitwidth(638 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<638 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<638 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(638 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<638 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<639 + 1024 * 0, true> { int V __attribute__((bitwidth(639 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<639 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<639 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(639 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<639 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<640 + 1024 * 0, true> { int V __attribute__((bitwidth(640 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<640 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<640 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(640 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<640 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<641 + 1024 * 0, true> { int V __attribute__((bitwidth(641 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<641 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<641 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(641 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<641 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<642 + 1024 * 0, true> { int V __attribute__((bitwidth(642 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<642 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<642 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(642 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<642 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<643 + 1024 * 0, true> { int V __attribute__((bitwidth(643 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<643 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<643 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(643 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<643 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<644 + 1024 * 0, true> { int V __attribute__((bitwidth(644 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<644 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<644 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(644 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<644 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<645 + 1024 * 0, true> { int V __attribute__((bitwidth(645 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<645 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<645 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(645 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<645 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<646 + 1024 * 0, true> { int V __attribute__((bitwidth(646 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<646 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<646 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(646 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<646 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<647 + 1024 * 0, true> { int V __attribute__((bitwidth(647 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<647 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<647 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(647 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<647 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<648 + 1024 * 0, true> { int V __attribute__((bitwidth(648 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<648 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<648 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(648 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<648 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<649 + 1024 * 0, true> { int V __attribute__((bitwidth(649 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<649 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<649 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(649 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<649 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<650 + 1024 * 0, true> { int V __attribute__((bitwidth(650 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<650 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<650 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(650 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<650 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<651 + 1024 * 0, true> { int V __attribute__((bitwidth(651 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<651 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<651 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(651 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<651 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<652 + 1024 * 0, true> { int V __attribute__((bitwidth(652 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<652 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<652 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(652 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<652 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<653 + 1024 * 0, true> { int V __attribute__((bitwidth(653 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<653 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<653 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(653 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<653 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<654 + 1024 * 0, true> { int V __attribute__((bitwidth(654 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<654 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<654 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(654 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<654 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<655 + 1024 * 0, true> { int V __attribute__((bitwidth(655 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<655 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<655 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(655 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<655 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<656 + 1024 * 0, true> { int V __attribute__((bitwidth(656 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<656 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<656 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(656 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<656 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<657 + 1024 * 0, true> { int V __attribute__((bitwidth(657 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<657 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<657 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(657 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<657 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<658 + 1024 * 0, true> { int V __attribute__((bitwidth(658 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<658 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<658 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(658 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<658 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<659 + 1024 * 0, true> { int V __attribute__((bitwidth(659 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<659 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<659 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(659 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<659 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<660 + 1024 * 0, true> { int V __attribute__((bitwidth(660 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<660 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<660 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(660 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<660 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<661 + 1024 * 0, true> { int V __attribute__((bitwidth(661 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<661 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<661 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(661 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<661 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<662 + 1024 * 0, true> { int V __attribute__((bitwidth(662 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<662 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<662 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(662 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<662 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<663 + 1024 * 0, true> { int V __attribute__((bitwidth(663 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<663 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<663 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(663 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<663 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<664 + 1024 * 0, true> { int V __attribute__((bitwidth(664 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<664 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<664 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(664 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<664 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<665 + 1024 * 0, true> { int V __attribute__((bitwidth(665 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<665 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<665 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(665 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<665 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<666 + 1024 * 0, true> { int V __attribute__((bitwidth(666 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<666 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<666 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(666 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<666 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<667 + 1024 * 0, true> { int V __attribute__((bitwidth(667 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<667 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<667 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(667 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<667 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<668 + 1024 * 0, true> { int V __attribute__((bitwidth(668 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<668 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<668 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(668 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<668 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<669 + 1024 * 0, true> { int V __attribute__((bitwidth(669 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<669 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<669 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(669 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<669 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<670 + 1024 * 0, true> { int V __attribute__((bitwidth(670 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<670 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<670 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(670 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<670 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<671 + 1024 * 0, true> { int V __attribute__((bitwidth(671 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<671 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<671 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(671 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<671 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<672 + 1024 * 0, true> { int V __attribute__((bitwidth(672 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<672 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<672 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(672 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<672 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<673 + 1024 * 0, true> { int V __attribute__((bitwidth(673 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<673 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<673 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(673 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<673 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<674 + 1024 * 0, true> { int V __attribute__((bitwidth(674 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<674 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<674 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(674 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<674 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<675 + 1024 * 0, true> { int V __attribute__((bitwidth(675 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<675 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<675 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(675 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<675 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<676 + 1024 * 0, true> { int V __attribute__((bitwidth(676 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<676 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<676 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(676 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<676 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<677 + 1024 * 0, true> { int V __attribute__((bitwidth(677 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<677 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<677 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(677 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<677 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<678 + 1024 * 0, true> { int V __attribute__((bitwidth(678 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<678 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<678 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(678 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<678 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<679 + 1024 * 0, true> { int V __attribute__((bitwidth(679 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<679 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<679 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(679 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<679 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<680 + 1024 * 0, true> { int V __attribute__((bitwidth(680 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<680 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<680 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(680 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<680 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<681 + 1024 * 0, true> { int V __attribute__((bitwidth(681 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<681 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<681 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(681 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<681 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<682 + 1024 * 0, true> { int V __attribute__((bitwidth(682 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<682 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<682 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(682 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<682 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<683 + 1024 * 0, true> { int V __attribute__((bitwidth(683 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<683 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<683 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(683 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<683 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<684 + 1024 * 0, true> { int V __attribute__((bitwidth(684 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<684 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<684 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(684 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<684 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<685 + 1024 * 0, true> { int V __attribute__((bitwidth(685 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<685 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<685 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(685 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<685 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<686 + 1024 * 0, true> { int V __attribute__((bitwidth(686 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<686 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<686 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(686 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<686 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<687 + 1024 * 0, true> { int V __attribute__((bitwidth(687 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<687 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<687 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(687 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<687 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<688 + 1024 * 0, true> { int V __attribute__((bitwidth(688 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<688 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<688 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(688 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<688 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<689 + 1024 * 0, true> { int V __attribute__((bitwidth(689 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<689 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<689 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(689 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<689 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<690 + 1024 * 0, true> { int V __attribute__((bitwidth(690 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<690 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<690 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(690 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<690 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<691 + 1024 * 0, true> { int V __attribute__((bitwidth(691 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<691 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<691 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(691 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<691 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<692 + 1024 * 0, true> { int V __attribute__((bitwidth(692 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<692 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<692 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(692 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<692 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<693 + 1024 * 0, true> { int V __attribute__((bitwidth(693 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<693 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<693 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(693 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<693 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<694 + 1024 * 0, true> { int V __attribute__((bitwidth(694 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<694 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<694 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(694 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<694 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<695 + 1024 * 0, true> { int V __attribute__((bitwidth(695 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<695 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<695 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(695 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<695 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<696 + 1024 * 0, true> { int V __attribute__((bitwidth(696 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<696 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<696 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(696 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<696 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<697 + 1024 * 0, true> { int V __attribute__((bitwidth(697 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<697 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<697 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(697 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<697 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<698 + 1024 * 0, true> { int V __attribute__((bitwidth(698 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<698 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<698 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(698 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<698 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<699 + 1024 * 0, true> { int V __attribute__((bitwidth(699 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<699 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<699 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(699 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<699 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<700 + 1024 * 0, true> { int V __attribute__((bitwidth(700 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<700 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<700 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(700 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<700 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<701 + 1024 * 0, true> { int V __attribute__((bitwidth(701 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<701 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<701 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(701 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<701 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<702 + 1024 * 0, true> { int V __attribute__((bitwidth(702 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<702 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<702 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(702 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<702 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<703 + 1024 * 0, true> { int V __attribute__((bitwidth(703 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<703 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<703 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(703 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<703 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<704 + 1024 * 0, true> { int V __attribute__((bitwidth(704 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<704 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<704 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(704 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<704 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<705 + 1024 * 0, true> { int V __attribute__((bitwidth(705 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<705 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<705 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(705 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<705 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<706 + 1024 * 0, true> { int V __attribute__((bitwidth(706 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<706 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<706 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(706 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<706 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<707 + 1024 * 0, true> { int V __attribute__((bitwidth(707 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<707 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<707 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(707 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<707 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<708 + 1024 * 0, true> { int V __attribute__((bitwidth(708 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<708 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<708 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(708 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<708 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<709 + 1024 * 0, true> { int V __attribute__((bitwidth(709 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<709 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<709 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(709 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<709 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<710 + 1024 * 0, true> { int V __attribute__((bitwidth(710 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<710 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<710 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(710 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<710 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<711 + 1024 * 0, true> { int V __attribute__((bitwidth(711 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<711 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<711 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(711 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<711 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<712 + 1024 * 0, true> { int V __attribute__((bitwidth(712 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<712 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<712 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(712 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<712 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<713 + 1024 * 0, true> { int V __attribute__((bitwidth(713 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<713 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<713 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(713 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<713 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<714 + 1024 * 0, true> { int V __attribute__((bitwidth(714 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<714 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<714 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(714 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<714 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<715 + 1024 * 0, true> { int V __attribute__((bitwidth(715 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<715 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<715 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(715 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<715 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<716 + 1024 * 0, true> { int V __attribute__((bitwidth(716 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<716 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<716 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(716 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<716 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<717 + 1024 * 0, true> { int V __attribute__((bitwidth(717 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<717 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<717 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(717 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<717 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<718 + 1024 * 0, true> { int V __attribute__((bitwidth(718 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<718 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<718 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(718 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<718 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<719 + 1024 * 0, true> { int V __attribute__((bitwidth(719 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<719 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<719 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(719 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<719 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<720 + 1024 * 0, true> { int V __attribute__((bitwidth(720 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<720 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<720 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(720 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<720 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<721 + 1024 * 0, true> { int V __attribute__((bitwidth(721 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<721 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<721 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(721 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<721 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<722 + 1024 * 0, true> { int V __attribute__((bitwidth(722 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<722 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<722 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(722 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<722 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<723 + 1024 * 0, true> { int V __attribute__((bitwidth(723 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<723 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<723 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(723 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<723 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<724 + 1024 * 0, true> { int V __attribute__((bitwidth(724 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<724 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<724 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(724 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<724 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<725 + 1024 * 0, true> { int V __attribute__((bitwidth(725 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<725 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<725 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(725 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<725 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<726 + 1024 * 0, true> { int V __attribute__((bitwidth(726 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<726 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<726 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(726 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<726 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<727 + 1024 * 0, true> { int V __attribute__((bitwidth(727 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<727 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<727 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(727 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<727 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<728 + 1024 * 0, true> { int V __attribute__((bitwidth(728 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<728 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<728 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(728 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<728 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<729 + 1024 * 0, true> { int V __attribute__((bitwidth(729 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<729 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<729 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(729 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<729 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<730 + 1024 * 0, true> { int V __attribute__((bitwidth(730 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<730 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<730 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(730 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<730 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<731 + 1024 * 0, true> { int V __attribute__((bitwidth(731 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<731 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<731 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(731 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<731 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<732 + 1024 * 0, true> { int V __attribute__((bitwidth(732 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<732 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<732 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(732 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<732 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<733 + 1024 * 0, true> { int V __attribute__((bitwidth(733 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<733 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<733 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(733 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<733 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<734 + 1024 * 0, true> { int V __attribute__((bitwidth(734 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<734 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<734 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(734 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<734 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<735 + 1024 * 0, true> { int V __attribute__((bitwidth(735 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<735 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<735 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(735 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<735 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<736 + 1024 * 0, true> { int V __attribute__((bitwidth(736 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<736 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<736 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(736 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<736 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<737 + 1024 * 0, true> { int V __attribute__((bitwidth(737 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<737 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<737 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(737 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<737 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<738 + 1024 * 0, true> { int V __attribute__((bitwidth(738 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<738 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<738 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(738 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<738 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<739 + 1024 * 0, true> { int V __attribute__((bitwidth(739 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<739 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<739 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(739 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<739 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<740 + 1024 * 0, true> { int V __attribute__((bitwidth(740 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<740 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<740 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(740 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<740 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<741 + 1024 * 0, true> { int V __attribute__((bitwidth(741 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<741 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<741 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(741 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<741 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<742 + 1024 * 0, true> { int V __attribute__((bitwidth(742 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<742 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<742 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(742 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<742 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<743 + 1024 * 0, true> { int V __attribute__((bitwidth(743 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<743 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<743 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(743 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<743 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<744 + 1024 * 0, true> { int V __attribute__((bitwidth(744 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<744 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<744 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(744 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<744 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<745 + 1024 * 0, true> { int V __attribute__((bitwidth(745 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<745 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<745 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(745 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<745 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<746 + 1024 * 0, true> { int V __attribute__((bitwidth(746 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<746 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<746 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(746 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<746 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<747 + 1024 * 0, true> { int V __attribute__((bitwidth(747 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<747 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<747 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(747 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<747 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<748 + 1024 * 0, true> { int V __attribute__((bitwidth(748 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<748 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<748 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(748 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<748 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<749 + 1024 * 0, true> { int V __attribute__((bitwidth(749 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<749 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<749 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(749 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<749 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<750 + 1024 * 0, true> { int V __attribute__((bitwidth(750 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<750 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<750 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(750 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<750 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<751 + 1024 * 0, true> { int V __attribute__((bitwidth(751 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<751 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<751 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(751 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<751 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<752 + 1024 * 0, true> { int V __attribute__((bitwidth(752 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<752 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<752 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(752 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<752 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<753 + 1024 * 0, true> { int V __attribute__((bitwidth(753 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<753 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<753 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(753 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<753 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<754 + 1024 * 0, true> { int V __attribute__((bitwidth(754 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<754 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<754 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(754 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<754 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<755 + 1024 * 0, true> { int V __attribute__((bitwidth(755 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<755 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<755 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(755 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<755 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<756 + 1024 * 0, true> { int V __attribute__((bitwidth(756 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<756 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<756 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(756 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<756 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<757 + 1024 * 0, true> { int V __attribute__((bitwidth(757 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<757 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<757 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(757 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<757 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<758 + 1024 * 0, true> { int V __attribute__((bitwidth(758 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<758 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<758 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(758 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<758 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<759 + 1024 * 0, true> { int V __attribute__((bitwidth(759 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<759 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<759 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(759 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<759 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<760 + 1024 * 0, true> { int V __attribute__((bitwidth(760 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<760 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<760 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(760 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<760 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<761 + 1024 * 0, true> { int V __attribute__((bitwidth(761 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<761 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<761 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(761 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<761 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<762 + 1024 * 0, true> { int V __attribute__((bitwidth(762 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<762 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<762 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(762 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<762 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<763 + 1024 * 0, true> { int V __attribute__((bitwidth(763 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<763 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<763 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(763 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<763 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<764 + 1024 * 0, true> { int V __attribute__((bitwidth(764 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<764 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<764 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(764 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<764 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<765 + 1024 * 0, true> { int V __attribute__((bitwidth(765 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<765 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<765 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(765 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<765 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<766 + 1024 * 0, true> { int V __attribute__((bitwidth(766 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<766 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<766 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(766 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<766 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<767 + 1024 * 0, true> { int V __attribute__((bitwidth(767 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<767 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<767 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(767 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<767 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<768 + 1024 * 0, true> { int V __attribute__((bitwidth(768 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<768 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<768 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(768 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<768 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<769 + 1024 * 0, true> { int V __attribute__((bitwidth(769 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<769 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<769 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(769 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<769 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<770 + 1024 * 0, true> { int V __attribute__((bitwidth(770 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<770 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<770 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(770 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<770 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<771 + 1024 * 0, true> { int V __attribute__((bitwidth(771 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<771 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<771 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(771 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<771 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<772 + 1024 * 0, true> { int V __attribute__((bitwidth(772 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<772 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<772 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(772 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<772 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<773 + 1024 * 0, true> { int V __attribute__((bitwidth(773 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<773 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<773 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(773 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<773 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<774 + 1024 * 0, true> { int V __attribute__((bitwidth(774 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<774 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<774 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(774 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<774 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<775 + 1024 * 0, true> { int V __attribute__((bitwidth(775 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<775 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<775 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(775 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<775 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<776 + 1024 * 0, true> { int V __attribute__((bitwidth(776 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<776 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<776 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(776 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<776 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<777 + 1024 * 0, true> { int V __attribute__((bitwidth(777 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<777 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<777 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(777 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<777 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<778 + 1024 * 0, true> { int V __attribute__((bitwidth(778 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<778 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<778 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(778 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<778 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<779 + 1024 * 0, true> { int V __attribute__((bitwidth(779 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<779 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<779 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(779 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<779 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<780 + 1024 * 0, true> { int V __attribute__((bitwidth(780 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<780 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<780 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(780 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<780 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<781 + 1024 * 0, true> { int V __attribute__((bitwidth(781 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<781 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<781 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(781 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<781 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<782 + 1024 * 0, true> { int V __attribute__((bitwidth(782 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<782 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<782 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(782 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<782 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<783 + 1024 * 0, true> { int V __attribute__((bitwidth(783 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<783 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<783 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(783 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<783 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<784 + 1024 * 0, true> { int V __attribute__((bitwidth(784 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<784 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<784 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(784 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<784 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<785 + 1024 * 0, true> { int V __attribute__((bitwidth(785 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<785 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<785 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(785 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<785 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<786 + 1024 * 0, true> { int V __attribute__((bitwidth(786 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<786 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<786 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(786 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<786 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<787 + 1024 * 0, true> { int V __attribute__((bitwidth(787 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<787 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<787 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(787 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<787 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<788 + 1024 * 0, true> { int V __attribute__((bitwidth(788 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<788 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<788 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(788 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<788 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<789 + 1024 * 0, true> { int V __attribute__((bitwidth(789 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<789 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<789 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(789 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<789 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<790 + 1024 * 0, true> { int V __attribute__((bitwidth(790 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<790 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<790 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(790 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<790 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<791 + 1024 * 0, true> { int V __attribute__((bitwidth(791 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<791 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<791 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(791 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<791 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<792 + 1024 * 0, true> { int V __attribute__((bitwidth(792 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<792 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<792 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(792 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<792 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<793 + 1024 * 0, true> { int V __attribute__((bitwidth(793 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<793 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<793 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(793 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<793 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<794 + 1024 * 0, true> { int V __attribute__((bitwidth(794 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<794 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<794 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(794 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<794 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<795 + 1024 * 0, true> { int V __attribute__((bitwidth(795 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<795 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<795 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(795 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<795 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<796 + 1024 * 0, true> { int V __attribute__((bitwidth(796 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<796 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<796 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(796 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<796 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<797 + 1024 * 0, true> { int V __attribute__((bitwidth(797 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<797 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<797 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(797 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<797 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<798 + 1024 * 0, true> { int V __attribute__((bitwidth(798 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<798 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<798 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(798 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<798 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<799 + 1024 * 0, true> { int V __attribute__((bitwidth(799 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<799 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<799 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(799 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<799 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<800 + 1024 * 0, true> { int V __attribute__((bitwidth(800 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<800 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<800 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(800 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<800 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<801 + 1024 * 0, true> { int V __attribute__((bitwidth(801 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<801 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<801 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(801 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<801 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<802 + 1024 * 0, true> { int V __attribute__((bitwidth(802 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<802 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<802 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(802 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<802 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<803 + 1024 * 0, true> { int V __attribute__((bitwidth(803 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<803 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<803 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(803 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<803 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<804 + 1024 * 0, true> { int V __attribute__((bitwidth(804 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<804 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<804 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(804 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<804 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<805 + 1024 * 0, true> { int V __attribute__((bitwidth(805 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<805 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<805 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(805 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<805 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<806 + 1024 * 0, true> { int V __attribute__((bitwidth(806 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<806 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<806 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(806 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<806 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<807 + 1024 * 0, true> { int V __attribute__((bitwidth(807 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<807 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<807 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(807 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<807 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<808 + 1024 * 0, true> { int V __attribute__((bitwidth(808 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<808 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<808 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(808 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<808 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<809 + 1024 * 0, true> { int V __attribute__((bitwidth(809 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<809 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<809 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(809 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<809 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<810 + 1024 * 0, true> { int V __attribute__((bitwidth(810 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<810 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<810 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(810 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<810 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<811 + 1024 * 0, true> { int V __attribute__((bitwidth(811 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<811 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<811 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(811 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<811 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<812 + 1024 * 0, true> { int V __attribute__((bitwidth(812 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<812 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<812 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(812 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<812 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<813 + 1024 * 0, true> { int V __attribute__((bitwidth(813 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<813 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<813 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(813 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<813 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<814 + 1024 * 0, true> { int V __attribute__((bitwidth(814 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<814 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<814 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(814 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<814 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<815 + 1024 * 0, true> { int V __attribute__((bitwidth(815 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<815 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<815 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(815 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<815 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<816 + 1024 * 0, true> { int V __attribute__((bitwidth(816 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<816 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<816 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(816 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<816 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<817 + 1024 * 0, true> { int V __attribute__((bitwidth(817 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<817 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<817 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(817 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<817 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<818 + 1024 * 0, true> { int V __attribute__((bitwidth(818 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<818 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<818 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(818 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<818 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<819 + 1024 * 0, true> { int V __attribute__((bitwidth(819 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<819 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<819 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(819 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<819 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<820 + 1024 * 0, true> { int V __attribute__((bitwidth(820 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<820 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<820 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(820 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<820 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<821 + 1024 * 0, true> { int V __attribute__((bitwidth(821 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<821 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<821 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(821 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<821 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<822 + 1024 * 0, true> { int V __attribute__((bitwidth(822 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<822 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<822 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(822 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<822 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<823 + 1024 * 0, true> { int V __attribute__((bitwidth(823 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<823 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<823 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(823 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<823 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<824 + 1024 * 0, true> { int V __attribute__((bitwidth(824 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<824 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<824 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(824 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<824 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<825 + 1024 * 0, true> { int V __attribute__((bitwidth(825 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<825 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<825 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(825 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<825 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<826 + 1024 * 0, true> { int V __attribute__((bitwidth(826 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<826 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<826 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(826 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<826 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<827 + 1024 * 0, true> { int V __attribute__((bitwidth(827 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<827 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<827 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(827 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<827 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<828 + 1024 * 0, true> { int V __attribute__((bitwidth(828 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<828 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<828 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(828 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<828 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<829 + 1024 * 0, true> { int V __attribute__((bitwidth(829 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<829 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<829 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(829 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<829 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<830 + 1024 * 0, true> { int V __attribute__((bitwidth(830 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<830 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<830 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(830 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<830 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<831 + 1024 * 0, true> { int V __attribute__((bitwidth(831 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<831 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<831 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(831 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<831 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<832 + 1024 * 0, true> { int V __attribute__((bitwidth(832 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<832 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<832 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(832 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<832 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<833 + 1024 * 0, true> { int V __attribute__((bitwidth(833 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<833 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<833 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(833 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<833 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<834 + 1024 * 0, true> { int V __attribute__((bitwidth(834 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<834 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<834 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(834 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<834 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<835 + 1024 * 0, true> { int V __attribute__((bitwidth(835 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<835 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<835 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(835 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<835 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<836 + 1024 * 0, true> { int V __attribute__((bitwidth(836 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<836 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<836 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(836 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<836 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<837 + 1024 * 0, true> { int V __attribute__((bitwidth(837 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<837 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<837 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(837 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<837 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<838 + 1024 * 0, true> { int V __attribute__((bitwidth(838 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<838 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<838 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(838 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<838 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<839 + 1024 * 0, true> { int V __attribute__((bitwidth(839 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<839 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<839 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(839 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<839 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<840 + 1024 * 0, true> { int V __attribute__((bitwidth(840 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<840 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<840 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(840 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<840 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<841 + 1024 * 0, true> { int V __attribute__((bitwidth(841 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<841 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<841 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(841 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<841 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<842 + 1024 * 0, true> { int V __attribute__((bitwidth(842 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<842 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<842 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(842 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<842 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<843 + 1024 * 0, true> { int V __attribute__((bitwidth(843 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<843 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<843 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(843 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<843 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<844 + 1024 * 0, true> { int V __attribute__((bitwidth(844 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<844 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<844 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(844 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<844 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<845 + 1024 * 0, true> { int V __attribute__((bitwidth(845 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<845 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<845 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(845 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<845 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<846 + 1024 * 0, true> { int V __attribute__((bitwidth(846 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<846 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<846 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(846 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<846 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<847 + 1024 * 0, true> { int V __attribute__((bitwidth(847 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<847 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<847 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(847 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<847 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<848 + 1024 * 0, true> { int V __attribute__((bitwidth(848 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<848 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<848 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(848 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<848 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<849 + 1024 * 0, true> { int V __attribute__((bitwidth(849 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<849 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<849 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(849 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<849 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<850 + 1024 * 0, true> { int V __attribute__((bitwidth(850 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<850 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<850 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(850 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<850 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<851 + 1024 * 0, true> { int V __attribute__((bitwidth(851 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<851 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<851 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(851 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<851 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<852 + 1024 * 0, true> { int V __attribute__((bitwidth(852 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<852 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<852 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(852 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<852 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<853 + 1024 * 0, true> { int V __attribute__((bitwidth(853 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<853 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<853 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(853 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<853 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<854 + 1024 * 0, true> { int V __attribute__((bitwidth(854 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<854 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<854 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(854 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<854 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<855 + 1024 * 0, true> { int V __attribute__((bitwidth(855 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<855 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<855 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(855 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<855 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<856 + 1024 * 0, true> { int V __attribute__((bitwidth(856 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<856 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<856 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(856 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<856 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<857 + 1024 * 0, true> { int V __attribute__((bitwidth(857 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<857 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<857 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(857 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<857 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<858 + 1024 * 0, true> { int V __attribute__((bitwidth(858 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<858 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<858 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(858 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<858 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<859 + 1024 * 0, true> { int V __attribute__((bitwidth(859 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<859 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<859 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(859 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<859 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<860 + 1024 * 0, true> { int V __attribute__((bitwidth(860 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<860 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<860 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(860 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<860 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<861 + 1024 * 0, true> { int V __attribute__((bitwidth(861 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<861 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<861 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(861 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<861 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<862 + 1024 * 0, true> { int V __attribute__((bitwidth(862 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<862 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<862 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(862 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<862 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<863 + 1024 * 0, true> { int V __attribute__((bitwidth(863 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<863 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<863 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(863 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<863 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<864 + 1024 * 0, true> { int V __attribute__((bitwidth(864 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<864 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<864 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(864 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<864 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<865 + 1024 * 0, true> { int V __attribute__((bitwidth(865 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<865 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<865 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(865 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<865 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<866 + 1024 * 0, true> { int V __attribute__((bitwidth(866 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<866 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<866 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(866 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<866 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<867 + 1024 * 0, true> { int V __attribute__((bitwidth(867 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<867 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<867 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(867 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<867 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<868 + 1024 * 0, true> { int V __attribute__((bitwidth(868 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<868 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<868 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(868 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<868 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<869 + 1024 * 0, true> { int V __attribute__((bitwidth(869 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<869 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<869 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(869 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<869 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<870 + 1024 * 0, true> { int V __attribute__((bitwidth(870 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<870 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<870 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(870 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<870 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<871 + 1024 * 0, true> { int V __attribute__((bitwidth(871 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<871 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<871 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(871 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<871 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<872 + 1024 * 0, true> { int V __attribute__((bitwidth(872 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<872 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<872 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(872 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<872 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<873 + 1024 * 0, true> { int V __attribute__((bitwidth(873 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<873 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<873 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(873 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<873 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<874 + 1024 * 0, true> { int V __attribute__((bitwidth(874 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<874 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<874 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(874 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<874 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<875 + 1024 * 0, true> { int V __attribute__((bitwidth(875 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<875 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<875 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(875 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<875 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<876 + 1024 * 0, true> { int V __attribute__((bitwidth(876 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<876 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<876 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(876 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<876 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<877 + 1024 * 0, true> { int V __attribute__((bitwidth(877 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<877 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<877 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(877 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<877 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<878 + 1024 * 0, true> { int V __attribute__((bitwidth(878 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<878 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<878 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(878 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<878 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<879 + 1024 * 0, true> { int V __attribute__((bitwidth(879 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<879 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<879 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(879 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<879 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<880 + 1024 * 0, true> { int V __attribute__((bitwidth(880 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<880 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<880 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(880 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<880 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<881 + 1024 * 0, true> { int V __attribute__((bitwidth(881 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<881 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<881 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(881 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<881 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<882 + 1024 * 0, true> { int V __attribute__((bitwidth(882 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<882 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<882 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(882 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<882 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<883 + 1024 * 0, true> { int V __attribute__((bitwidth(883 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<883 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<883 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(883 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<883 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<884 + 1024 * 0, true> { int V __attribute__((bitwidth(884 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<884 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<884 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(884 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<884 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<885 + 1024 * 0, true> { int V __attribute__((bitwidth(885 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<885 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<885 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(885 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<885 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<886 + 1024 * 0, true> { int V __attribute__((bitwidth(886 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<886 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<886 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(886 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<886 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<887 + 1024 * 0, true> { int V __attribute__((bitwidth(887 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<887 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<887 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(887 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<887 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<888 + 1024 * 0, true> { int V __attribute__((bitwidth(888 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<888 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<888 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(888 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<888 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<889 + 1024 * 0, true> { int V __attribute__((bitwidth(889 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<889 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<889 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(889 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<889 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<890 + 1024 * 0, true> { int V __attribute__((bitwidth(890 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<890 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<890 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(890 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<890 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<891 + 1024 * 0, true> { int V __attribute__((bitwidth(891 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<891 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<891 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(891 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<891 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<892 + 1024 * 0, true> { int V __attribute__((bitwidth(892 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<892 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<892 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(892 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<892 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<893 + 1024 * 0, true> { int V __attribute__((bitwidth(893 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<893 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<893 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(893 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<893 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<894 + 1024 * 0, true> { int V __attribute__((bitwidth(894 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<894 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<894 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(894 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<894 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<895 + 1024 * 0, true> { int V __attribute__((bitwidth(895 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<895 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<895 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(895 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<895 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<896 + 1024 * 0, true> { int V __attribute__((bitwidth(896 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<896 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<896 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(896 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<896 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<897 + 1024 * 0, true> { int V __attribute__((bitwidth(897 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<897 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<897 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(897 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<897 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<898 + 1024 * 0, true> { int V __attribute__((bitwidth(898 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<898 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<898 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(898 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<898 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<899 + 1024 * 0, true> { int V __attribute__((bitwidth(899 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<899 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<899 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(899 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<899 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<900 + 1024 * 0, true> { int V __attribute__((bitwidth(900 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<900 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<900 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(900 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<900 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<901 + 1024 * 0, true> { int V __attribute__((bitwidth(901 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<901 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<901 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(901 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<901 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<902 + 1024 * 0, true> { int V __attribute__((bitwidth(902 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<902 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<902 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(902 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<902 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<903 + 1024 * 0, true> { int V __attribute__((bitwidth(903 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<903 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<903 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(903 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<903 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<904 + 1024 * 0, true> { int V __attribute__((bitwidth(904 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<904 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<904 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(904 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<904 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<905 + 1024 * 0, true> { int V __attribute__((bitwidth(905 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<905 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<905 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(905 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<905 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<906 + 1024 * 0, true> { int V __attribute__((bitwidth(906 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<906 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<906 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(906 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<906 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<907 + 1024 * 0, true> { int V __attribute__((bitwidth(907 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<907 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<907 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(907 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<907 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<908 + 1024 * 0, true> { int V __attribute__((bitwidth(908 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<908 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<908 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(908 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<908 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<909 + 1024 * 0, true> { int V __attribute__((bitwidth(909 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<909 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<909 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(909 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<909 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<910 + 1024 * 0, true> { int V __attribute__((bitwidth(910 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<910 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<910 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(910 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<910 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<911 + 1024 * 0, true> { int V __attribute__((bitwidth(911 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<911 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<911 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(911 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<911 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<912 + 1024 * 0, true> { int V __attribute__((bitwidth(912 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<912 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<912 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(912 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<912 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<913 + 1024 * 0, true> { int V __attribute__((bitwidth(913 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<913 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<913 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(913 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<913 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<914 + 1024 * 0, true> { int V __attribute__((bitwidth(914 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<914 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<914 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(914 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<914 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<915 + 1024 * 0, true> { int V __attribute__((bitwidth(915 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<915 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<915 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(915 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<915 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<916 + 1024 * 0, true> { int V __attribute__((bitwidth(916 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<916 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<916 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(916 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<916 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<917 + 1024 * 0, true> { int V __attribute__((bitwidth(917 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<917 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<917 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(917 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<917 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<918 + 1024 * 0, true> { int V __attribute__((bitwidth(918 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<918 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<918 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(918 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<918 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<919 + 1024 * 0, true> { int V __attribute__((bitwidth(919 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<919 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<919 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(919 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<919 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<920 + 1024 * 0, true> { int V __attribute__((bitwidth(920 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<920 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<920 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(920 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<920 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<921 + 1024 * 0, true> { int V __attribute__((bitwidth(921 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<921 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<921 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(921 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<921 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<922 + 1024 * 0, true> { int V __attribute__((bitwidth(922 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<922 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<922 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(922 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<922 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<923 + 1024 * 0, true> { int V __attribute__((bitwidth(923 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<923 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<923 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(923 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<923 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<924 + 1024 * 0, true> { int V __attribute__((bitwidth(924 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<924 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<924 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(924 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<924 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<925 + 1024 * 0, true> { int V __attribute__((bitwidth(925 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<925 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<925 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(925 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<925 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<926 + 1024 * 0, true> { int V __attribute__((bitwidth(926 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<926 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<926 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(926 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<926 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<927 + 1024 * 0, true> { int V __attribute__((bitwidth(927 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<927 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<927 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(927 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<927 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<928 + 1024 * 0, true> { int V __attribute__((bitwidth(928 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<928 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<928 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(928 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<928 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<929 + 1024 * 0, true> { int V __attribute__((bitwidth(929 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<929 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<929 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(929 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<929 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<930 + 1024 * 0, true> { int V __attribute__((bitwidth(930 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<930 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<930 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(930 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<930 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<931 + 1024 * 0, true> { int V __attribute__((bitwidth(931 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<931 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<931 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(931 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<931 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<932 + 1024 * 0, true> { int V __attribute__((bitwidth(932 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<932 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<932 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(932 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<932 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<933 + 1024 * 0, true> { int V __attribute__((bitwidth(933 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<933 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<933 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(933 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<933 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<934 + 1024 * 0, true> { int V __attribute__((bitwidth(934 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<934 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<934 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(934 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<934 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<935 + 1024 * 0, true> { int V __attribute__((bitwidth(935 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<935 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<935 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(935 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<935 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<936 + 1024 * 0, true> { int V __attribute__((bitwidth(936 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<936 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<936 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(936 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<936 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<937 + 1024 * 0, true> { int V __attribute__((bitwidth(937 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<937 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<937 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(937 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<937 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<938 + 1024 * 0, true> { int V __attribute__((bitwidth(938 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<938 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<938 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(938 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<938 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<939 + 1024 * 0, true> { int V __attribute__((bitwidth(939 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<939 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<939 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(939 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<939 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<940 + 1024 * 0, true> { int V __attribute__((bitwidth(940 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<940 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<940 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(940 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<940 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<941 + 1024 * 0, true> { int V __attribute__((bitwidth(941 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<941 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<941 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(941 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<941 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<942 + 1024 * 0, true> { int V __attribute__((bitwidth(942 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<942 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<942 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(942 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<942 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<943 + 1024 * 0, true> { int V __attribute__((bitwidth(943 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<943 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<943 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(943 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<943 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<944 + 1024 * 0, true> { int V __attribute__((bitwidth(944 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<944 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<944 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(944 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<944 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<945 + 1024 * 0, true> { int V __attribute__((bitwidth(945 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<945 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<945 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(945 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<945 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<946 + 1024 * 0, true> { int V __attribute__((bitwidth(946 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<946 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<946 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(946 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<946 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<947 + 1024 * 0, true> { int V __attribute__((bitwidth(947 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<947 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<947 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(947 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<947 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<948 + 1024 * 0, true> { int V __attribute__((bitwidth(948 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<948 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<948 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(948 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<948 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<949 + 1024 * 0, true> { int V __attribute__((bitwidth(949 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<949 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<949 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(949 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<949 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<950 + 1024 * 0, true> { int V __attribute__((bitwidth(950 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<950 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<950 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(950 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<950 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<951 + 1024 * 0, true> { int V __attribute__((bitwidth(951 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<951 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<951 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(951 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<951 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<952 + 1024 * 0, true> { int V __attribute__((bitwidth(952 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<952 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<952 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(952 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<952 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<953 + 1024 * 0, true> { int V __attribute__((bitwidth(953 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<953 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<953 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(953 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<953 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<954 + 1024 * 0, true> { int V __attribute__((bitwidth(954 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<954 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<954 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(954 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<954 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<955 + 1024 * 0, true> { int V __attribute__((bitwidth(955 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<955 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<955 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(955 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<955 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<956 + 1024 * 0, true> { int V __attribute__((bitwidth(956 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<956 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<956 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(956 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<956 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<957 + 1024 * 0, true> { int V __attribute__((bitwidth(957 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<957 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<957 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(957 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<957 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<958 + 1024 * 0, true> { int V __attribute__((bitwidth(958 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<958 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<958 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(958 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<958 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<959 + 1024 * 0, true> { int V __attribute__((bitwidth(959 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<959 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<959 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(959 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<959 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<960 + 1024 * 0, true> { int V __attribute__((bitwidth(960 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<960 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<960 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(960 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<960 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<961 + 1024 * 0, true> { int V __attribute__((bitwidth(961 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<961 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<961 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(961 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<961 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<962 + 1024 * 0, true> { int V __attribute__((bitwidth(962 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<962 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<962 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(962 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<962 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<963 + 1024 * 0, true> { int V __attribute__((bitwidth(963 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<963 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<963 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(963 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<963 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<964 + 1024 * 0, true> { int V __attribute__((bitwidth(964 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<964 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<964 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(964 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<964 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<965 + 1024 * 0, true> { int V __attribute__((bitwidth(965 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<965 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<965 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(965 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<965 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<966 + 1024 * 0, true> { int V __attribute__((bitwidth(966 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<966 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<966 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(966 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<966 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<967 + 1024 * 0, true> { int V __attribute__((bitwidth(967 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<967 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<967 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(967 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<967 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<968 + 1024 * 0, true> { int V __attribute__((bitwidth(968 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<968 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<968 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(968 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<968 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<969 + 1024 * 0, true> { int V __attribute__((bitwidth(969 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<969 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<969 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(969 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<969 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<970 + 1024 * 0, true> { int V __attribute__((bitwidth(970 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<970 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<970 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(970 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<970 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<971 + 1024 * 0, true> { int V __attribute__((bitwidth(971 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<971 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<971 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(971 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<971 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<972 + 1024 * 0, true> { int V __attribute__((bitwidth(972 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<972 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<972 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(972 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<972 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<973 + 1024 * 0, true> { int V __attribute__((bitwidth(973 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<973 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<973 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(973 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<973 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<974 + 1024 * 0, true> { int V __attribute__((bitwidth(974 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<974 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<974 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(974 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<974 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<975 + 1024 * 0, true> { int V __attribute__((bitwidth(975 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<975 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<975 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(975 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<975 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<976 + 1024 * 0, true> { int V __attribute__((bitwidth(976 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<976 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<976 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(976 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<976 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<977 + 1024 * 0, true> { int V __attribute__((bitwidth(977 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<977 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<977 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(977 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<977 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<978 + 1024 * 0, true> { int V __attribute__((bitwidth(978 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<978 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<978 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(978 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<978 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<979 + 1024 * 0, true> { int V __attribute__((bitwidth(979 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<979 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<979 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(979 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<979 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<980 + 1024 * 0, true> { int V __attribute__((bitwidth(980 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<980 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<980 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(980 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<980 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<981 + 1024 * 0, true> { int V __attribute__((bitwidth(981 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<981 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<981 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(981 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<981 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<982 + 1024 * 0, true> { int V __attribute__((bitwidth(982 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<982 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<982 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(982 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<982 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<983 + 1024 * 0, true> { int V __attribute__((bitwidth(983 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<983 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<983 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(983 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<983 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<984 + 1024 * 0, true> { int V __attribute__((bitwidth(984 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<984 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<984 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(984 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<984 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<985 + 1024 * 0, true> { int V __attribute__((bitwidth(985 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<985 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<985 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(985 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<985 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<986 + 1024 * 0, true> { int V __attribute__((bitwidth(986 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<986 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<986 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(986 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<986 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<987 + 1024 * 0, true> { int V __attribute__((bitwidth(987 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<987 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<987 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(987 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<987 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<988 + 1024 * 0, true> { int V __attribute__((bitwidth(988 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<988 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<988 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(988 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<988 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<989 + 1024 * 0, true> { int V __attribute__((bitwidth(989 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<989 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<989 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(989 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<989 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<990 + 1024 * 0, true> { int V __attribute__((bitwidth(990 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<990 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<990 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(990 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<990 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<991 + 1024 * 0, true> { int V __attribute__((bitwidth(991 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<991 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<991 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(991 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<991 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<992 + 1024 * 0, true> { int V __attribute__((bitwidth(992 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<992 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<992 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(992 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<992 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<993 + 1024 * 0, true> { int V __attribute__((bitwidth(993 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<993 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<993 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(993 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<993 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<994 + 1024 * 0, true> { int V __attribute__((bitwidth(994 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<994 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<994 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(994 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<994 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<995 + 1024 * 0, true> { int V __attribute__((bitwidth(995 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<995 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<995 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(995 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<995 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<996 + 1024 * 0, true> { int V __attribute__((bitwidth(996 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<996 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<996 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(996 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<996 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<997 + 1024 * 0, true> { int V __attribute__((bitwidth(997 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<997 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<997 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(997 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<997 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<998 + 1024 * 0, true> { int V __attribute__((bitwidth(998 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<998 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<998 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(998 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<998 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<999 + 1024 * 0, true> { int V __attribute__((bitwidth(999 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<999 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<999 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(999 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<999 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1000 + 1024 * 0, true> { int V __attribute__((bitwidth(1000 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1000 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1000 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1000 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1000 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1001 + 1024 * 0, true> { int V __attribute__((bitwidth(1001 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1001 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1001 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1001 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1001 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1002 + 1024 * 0, true> { int V __attribute__((bitwidth(1002 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1002 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1002 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1002 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1002 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1003 + 1024 * 0, true> { int V __attribute__((bitwidth(1003 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1003 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1003 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1003 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1003 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1004 + 1024 * 0, true> { int V __attribute__((bitwidth(1004 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1004 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1004 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1004 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1004 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1005 + 1024 * 0, true> { int V __attribute__((bitwidth(1005 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1005 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1005 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1005 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1005 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1006 + 1024 * 0, true> { int V __attribute__((bitwidth(1006 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1006 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1006 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1006 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1006 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1007 + 1024 * 0, true> { int V __attribute__((bitwidth(1007 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1007 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1007 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1007 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1007 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1008 + 1024 * 0, true> { int V __attribute__((bitwidth(1008 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1008 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1008 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1008 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1008 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1009 + 1024 * 0, true> { int V __attribute__((bitwidth(1009 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1009 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1009 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1009 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1009 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1010 + 1024 * 0, true> { int V __attribute__((bitwidth(1010 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1010 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1010 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1010 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1010 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1011 + 1024 * 0, true> { int V __attribute__((bitwidth(1011 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1011 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1011 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1011 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1011 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1012 + 1024 * 0, true> { int V __attribute__((bitwidth(1012 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1012 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1012 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1012 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1012 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1013 + 1024 * 0, true> { int V __attribute__((bitwidth(1013 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1013 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1013 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1013 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1013 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1014 + 1024 * 0, true> { int V __attribute__((bitwidth(1014 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1014 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1014 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1014 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1014 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1015 + 1024 * 0, true> { int V __attribute__((bitwidth(1015 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1015 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1015 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1015 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1015 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1016 + 1024 * 0, true> { int V __attribute__((bitwidth(1016 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1016 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1016 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1016 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1016 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1017 + 1024 * 0, true> { int V __attribute__((bitwidth(1017 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1017 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1017 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1017 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1017 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1018 + 1024 * 0, true> { int V __attribute__((bitwidth(1018 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1018 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1018 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1018 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1018 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1019 + 1024 * 0, true> { int V __attribute__((bitwidth(1019 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1019 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1019 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1019 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1019 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1020 + 1024 * 0, true> { int V __attribute__((bitwidth(1020 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1020 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1020 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1020 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1020 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1021 + 1024 * 0, true> { int V __attribute__((bitwidth(1021 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1021 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1021 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1021 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1021 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1022 + 1024 * 0, true> { int V __attribute__((bitwidth(1022 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1022 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1022 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1022 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1022 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1023 + 1024 * 0, true> { int V __attribute__((bitwidth(1023 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1023 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1023 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1023 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1023 + 1024 * 0, false>(){}; };
template <> struct ssdm_int<1024 + 1024 * 0, true> { int V __attribute__((bitwidth(1024 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1024 + 1024 * 0, true>(){}; }; template <> struct ssdm_int<1024 + 1024 * 0, false> { unsigned int V __attribute__((bitwidth(1024 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1024 + 1024 * 0, false>(){}; };
# 239 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_common.h" 2
# 562 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_common.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/etc/autopilot_ssdm_bits.h" 1
# 563 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_common.h" 2

extern "C" void _ssdm_string2bits(...);
# 574 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_common.h"
static inline unsigned char guess_radix(const char* s) {
  unsigned char rd = 10;
  const char* p = s;

  if (p[0] == '-' || p[0] == '+') ++p;

  if (p[0] == '0') {
    if (p[1] == 'b' || p[1] == 'B') {
      rd = 2;
    } else if (p[1] == 'o' || p[1] == 'O') {
      rd = 8;
    } else if (p[1] == 'x' || p[1] == 'X') {
      rd = 16;
    } else if (p[1] == 'd' || p[1] == 'D') {
      rd = 10;
    }
  }
  return rd;
}







typedef __fp16 half;
# 691 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_common.h"
inline __attribute__((always_inline)) ap_ulong doubleToRawBits(double pf) {
  union {
    ap_ulong __L;
    double __D;
  } LD;
  LD.__D = pf;
  return LD.__L;
}

inline __attribute__((always_inline)) unsigned int floatToRawBits(float pf) {
  union {
    unsigned int __L;
    float __D;
  } LD;
  LD.__D = pf;
  return LD.__L;
}

inline __attribute__((always_inline)) unsigned short halfToRawBits(half pf) {

  union {
    unsigned short __L;
    half __D;
  } LD;
  LD.__D = pf;
  return LD.__L;



}


inline __attribute__((always_inline)) double rawBitsToDouble(ap_ulong pi) {
  union {
    ap_ulong __L;
    double __D;
  } LD;
  LD.__L = pi;
  return LD.__D;
}


inline __attribute__((always_inline)) float rawBitsToFloat(unsigned long pi) {
  union {
    unsigned int __L;
    float __D;
  } LD;
  LD.__L = pi;
  return LD.__D;
}


inline __attribute__((always_inline)) half rawBitsToHalf(unsigned short pi) {

  union {
    unsigned short __L;
    half __D;
  } LD;
  LD.__L = pi;
  return LD.__D;






}
# 55 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h" 1
# 80 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <int _AP_N, bool _AP_S>
struct retval;


template <int _AP_N>
struct retval<_AP_N, true> {
  typedef ap_slong Type;
};

template <int _AP_N>
struct retval<_AP_N, false> {
  typedef ap_ulong Type;
};


template <>
struct retval<1, true> {
  typedef signed char Type;
};

template <>
struct retval<1, false> {
  typedef unsigned char Type;
};


template <>
struct retval<2, true> {
  typedef short Type;
};

template <>
struct retval<2, false> {
  typedef unsigned short Type;
};


template <>
struct retval<3, true> {
  typedef long Type;
};

template <>
struct retval<3, false> {
  typedef unsigned long Type;
};

template <>
struct retval<4, true> {
  typedef long Type;
};

template <>
struct retval<4, false> {
  typedef unsigned long Type;
};




template <int _AP_W2, bool _AP_S2>
struct _ap_int_factory;
template <int _AP_W2>
struct _ap_int_factory<_AP_W2,true> { typedef ap_int<_AP_W2> type; };
template <int _AP_W2>
struct _ap_int_factory<_AP_W2,false> { typedef ap_uint<_AP_W2> type; };

template <int _AP_W, bool _AP_S>
struct ap_int_base : public ssdm_int<_AP_W, _AP_S> {
 public:
  typedef ssdm_int<_AP_W, _AP_S> Base;







  typedef typename retval<(((_AP_W + 7) / 8) > (8) ? ((_AP_W + 7) / 8) : (8)), _AP_S>::Type RetType;

  static const int width = _AP_W;

  template <int _AP_W2, bool _AP_S2>
  struct RType {
    enum {
      mult_w = _AP_W + _AP_W2,
      mult_s = _AP_S || _AP_S2,
      plus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,
      div_w = _AP_W + _AP_S2,
      div_s = _AP_S || _AP_S2,
      mod_w = ((_AP_W) < (_AP_W2 + (!_AP_S2 && _AP_S)) ? (_AP_W) : (_AP_W2 + (!_AP_S2 && _AP_S))),
      mod_s = _AP_S,
      logic_w = ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };


    typedef ap_int_base<mult_w, mult_s> mult_base;
    typedef ap_int_base<plus_w, plus_s> plus_base;
    typedef ap_int_base<minus_w, minus_s> minus_base;
    typedef ap_int_base<logic_w, logic_s> logic_base;
    typedef ap_int_base<div_w, div_s> div_base;
    typedef ap_int_base<mod_w, mod_s> mod_base;
    typedef ap_int_base<_AP_W, _AP_S> arg1_base;

    typedef typename _ap_int_factory<mult_w, mult_s>::type mult;
    typedef typename _ap_int_factory<plus_w, plus_s>::type plus;
    typedef typename _ap_int_factory<minus_w, minus_s>::type minus;
    typedef typename _ap_int_factory<logic_w, logic_s>::type logic;
    typedef typename _ap_int_factory<div_w, div_s>::type div;
    typedef typename _ap_int_factory<mod_w, mod_s>::type mod;
    typedef typename _ap_int_factory<_AP_W, _AP_S>::type arg1;
    typedef bool reduce;
  };





  inline __attribute__((always_inline)) ap_int_base() {





  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base(const ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }
# 237 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
  inline __attribute__((always_inline)) ap_int_base(const bool op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const char op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const signed char op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const unsigned char op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const short op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const unsigned short op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const int op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const unsigned int op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const long op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const unsigned long op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const ap_slong op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const ap_ulong op) { Base::V = op; }




  inline __attribute__((always_inline)) ap_int_base(half op) {
    ap_int_base<_AP_W, _AP_S> t((float)op);
    Base::V = t.V;
  }


  inline __attribute__((always_inline)) ap_int_base(float op) {
    const int BITS = 23 + 8 + 1;
    ap_int_base<BITS, false> reg;
    reg.V = floatToRawBits(op);
    bool is_neg = ({ __typeof__(reg.V) __Val2__ = reg.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), BITS - 1); __Result__; });

    ap_int_base<8 + 1, true> exp = 0;
    exp.V = ({ typename _ap_type::remove_const<__typeof__(reg.V)>::type __Result__ = 0; __typeof__(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 23, BITS - 2); __Result__; });
    exp = exp - ((1L << (8 - 1L)) - 1L);

    ap_int_base<23 + 2, true> man;
    man.V = ({ typename _ap_type::remove_const<__typeof__(reg.V)>::type __Result__ = 0; __typeof__(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 23 - 1); __Result__; });

    (static_cast<void>(0));


    man.V = ({ typename _ap_type::remove_const<__typeof__(man.V)>::type __Result__ = 0; __typeof__(man.V) __Val2__ = man.V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 23, 23); __Result__; });


    if ((reg.V & 0x7ffffffful) == 0) {
      Base::V = 0;
    } else {
      int sh_amt = 23 - exp.V;
      if (sh_amt == 0) {
        Base::V = man.V;
      } else if (sh_amt > 0) {
        if (sh_amt < 23 + 2) {
          Base::V = man.V >> sh_amt;
        } else {
          if (is_neg)
            Base::V = -1;
          else
            Base::V = 0;
        }
      } else {
        sh_amt = -sh_amt;
        if (sh_amt < _AP_W) {
          Base::V = man.V;
          Base::V <<= sh_amt;
        } else {
          Base::V = 0;
        }
      }
    }
    if (is_neg) *this = -(*this);
  }


  inline __attribute__((always_inline)) ap_int_base(double op) {
    const int BITS = 52 + 11 + 1;
    ap_int_base<BITS, false> reg;
    reg.V = doubleToRawBits(op);
    bool is_neg = ({ __typeof__(reg.V) __Val2__ = reg.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), BITS - 1); __Result__; });

    ap_int_base<11 + 1, true> exp = 0;
    exp.V = ({ typename _ap_type::remove_const<__typeof__(reg.V)>::type __Result__ = 0; __typeof__(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 52, BITS - 2); __Result__; });
    exp = exp - ((1L << (11 - 1L)) - 1L);

    ap_int_base<52 + 2, true> man;
    man.V = ({ typename _ap_type::remove_const<__typeof__(reg.V)>::type __Result__ = 0; __typeof__(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 52 - 1); __Result__; });

    (static_cast<void>(0));


    man.V = ({ typename _ap_type::remove_const<__typeof__(man.V)>::type __Result__ = 0; __typeof__(man.V) __Val2__ = man.V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52); __Result__; });


    if ((reg.V & 0x7fffffffffffffffull) == 0) {
      Base::V = 0;
    } else {
      int sh_amt = 52 - exp.V;
      if (sh_amt == 0) {
        Base::V = man.V;
      } else if (sh_amt > 0) {
        if (sh_amt < 52 + 2) {
          Base::V = man.V >> sh_amt;
        } else {
          if (is_neg)
            Base::V = -1;
          else
            Base::V = 0;
        }
      } else {
        sh_amt = -sh_amt;
        if (sh_amt < _AP_W) {
          Base::V = man.V;
          Base::V <<= sh_amt;
        } else {
          Base::V = 0;
        }
      }
    }
    if (is_neg) *this = -(*this);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = op.to_ap_int_base().V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base(const ap_range_ref<_AP_W2, _AP_S2>& ref) {
    Base::V = (ref.get()).V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base(const ap_bit_ref<_AP_W2, _AP_S2>& ref) {
    Base::V = ref.operator bool();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref) {
    const ap_int_base<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>::_AP_WR,
                      false>
        tmp = ref.get();
    Base::V = tmp.V;
  }
# 391 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
  inline __attribute__((always_inline)) ap_int_base(const char* s) {
    __typeof__(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), 10, _AP_W, _AP_S,
                      AP_TRN, AP_WRAP, 0, true);
    Base::V = t;
  }
  inline __attribute__((always_inline)) ap_int_base(const char* s, signed char rd) {
    __typeof__(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), rd, _AP_W, _AP_S,
                      AP_TRN, AP_WRAP, 0, true);
    Base::V = t;
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    Base::V = (val.get()).V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    Base::V = val.operator bool();
  }

  inline __attribute__((always_inline)) ap_int_base read() volatile {

    ap_int_base ret;
    ret.V = Base::V;
    return ret;
  }

  inline __attribute__((always_inline)) void write(const ap_int_base<_AP_W, _AP_S>& op2) volatile {

    Base::V = op2.V;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) void operator=(
      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) volatile {
    Base::V = op2.V;
  }

  inline __attribute__((always_inline)) void operator=(
      const volatile ap_int_base<_AP_W, _AP_S>& op2) volatile {
    Base::V = op2.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) void operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) volatile {
    Base::V = op2.V;
  }

  inline __attribute__((always_inline)) void operator=(const ap_int_base<_AP_W, _AP_S>& op2) volatile {
    Base::V = op2.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) {
    Base::V = op2.V;
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base& operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) {
    Base::V = op2.V;
    return *this;
  }

  inline __attribute__((always_inline)) ap_int_base& operator=(const volatile ap_int_base<_AP_W, _AP_S>& op2) {
    Base::V = op2.V;
    return *this;
  }

  inline __attribute__((always_inline)) ap_int_base& operator=(const ap_int_base<_AP_W, _AP_S>& op2) {
    Base::V = op2.V;
    return *this;
  }
# 482 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
  inline __attribute__((always_inline)) ap_int_base& operator=(bool op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(char op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(signed char op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(unsigned char op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(short op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(unsigned short op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(int op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(unsigned int op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(long op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(unsigned long op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(ap_slong op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(ap_ulong op) { Base::V = op; return *this; }



  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& op2) {
    Base::V = (bool)op2;
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base& operator=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    Base::V = (ap_int_base<_AP_W2, false>(op2)).V;
    return *this;
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op2) {
    Base::V = op2.get().V;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = op.to_ap_int_base().V;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = (bool)op;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = ((const ap_int_base<_AP_W2, false>)(op)).V;
    return *this;
  }





  inline __attribute__((always_inline)) operator RetType() const { return (RetType)(Base::V); }




  inline __attribute__((always_inline)) bool to_bool() const { return (bool)(Base::V); }
  inline __attribute__((always_inline)) char to_char() const { return (char)(Base::V); }
  inline __attribute__((always_inline)) signed char to_schar() const { return (signed char)(Base::V); }
  inline __attribute__((always_inline)) unsigned char to_uchar() const { return (unsigned char)(Base::V); }
  inline __attribute__((always_inline)) short to_short() const { return (short)(Base::V); }
  inline __attribute__((always_inline)) unsigned short to_ushort() const { return (unsigned short)(Base::V); }
  inline __attribute__((always_inline)) int to_int() const { return (int)(Base::V); }
  inline __attribute__((always_inline)) unsigned to_uint() const { return (unsigned)(Base::V); }
  inline __attribute__((always_inline)) long to_long() const { return (long)(Base::V); }
  inline __attribute__((always_inline)) unsigned long to_ulong() const { return (unsigned long)(Base::V); }
  inline __attribute__((always_inline)) ap_slong to_int64() const { return (ap_slong)(Base::V); }
  inline __attribute__((always_inline)) ap_ulong to_uint64() const { return (ap_ulong)(Base::V); }
  inline __attribute__((always_inline)) float to_float() const { return (float)(Base::V); }
  inline __attribute__((always_inline)) double to_double() const { return (double)(Base::V); }
# 586 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
  inline __attribute__((always_inline)) int length() const volatile { return _AP_W; }


  inline __attribute__((always_inline)) bool iszero() const { return Base::V == 0; }


  inline __attribute__((always_inline)) bool is_zero() const { return Base::V == 0; }


  inline __attribute__((always_inline)) bool sign() const {
    if (_AP_S &&
        ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; }))
      return true;
    else
      return false;
  }


  inline __attribute__((always_inline)) void clear(int i) {
                                                           ;
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(0) __Repl2__ = !!0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }


  inline __attribute__((always_inline)) void invert(int i) {
                                                           ;
    bool val = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    if (val)
      Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(0) __Repl2__ = !!0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    else
      Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }

  inline __attribute__((always_inline)) bool test(int i) const {
                                                           ;
    return ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
  }


  inline __attribute__((always_inline)) ap_int_base& get() { return *this; }


  inline __attribute__((always_inline)) void set(int i) {
                                                           ;
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }


  inline __attribute__((always_inline)) void set(int i, bool v) {
                                                           ;
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(v) __Repl2__ = !!v; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }



  inline __attribute__((always_inline)) ap_int_base& lrotate(int n) {
                                                              ;


    __typeof__(Base::V) l_p = Base::V << n;
    __typeof__(Base::V) r_p = Base::V >> (_AP_W - n);
    Base::V = l_p | r_p;



    return *this;
  }



  inline __attribute__((always_inline)) ap_int_base& rrotate(int n) {
                                                              ;


    __typeof__(Base::V) l_p = Base::V << (_AP_W - n);
    __typeof__(Base::V) r_p = Base::V >> n;
    Base::V = l_p | r_p;



    return *this;
  }



  inline __attribute__((always_inline)) ap_int_base& reverse() {
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
    return *this;
  }


  inline __attribute__((always_inline)) void set_bit(int i, bool v) {
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(v) __Repl2__ = !!v; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }


  inline __attribute__((always_inline)) bool get_bit(int i) const {
    return (bool)({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
  }


  inline __attribute__((always_inline)) void b_not() { Base::V = ~Base::V; }
# 699 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator *=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V *= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator +=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V += op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator -=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V -= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator /=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V /= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator %=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V %= op2.V; return *this; }
# 717 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator &=(const ap_int_base<_AP_W2, _AP_S2>& op2) { (static_cast<void>(0)); Base::V &= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator |=(const ap_int_base<_AP_W2, _AP_S2>& op2) { (static_cast<void>(0)); Base::V |= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator ^=(const ap_int_base<_AP_W2, _AP_S2>& op2) { (static_cast<void>(0)); Base::V ^= op2.V; return *this; }





  inline __attribute__((always_inline)) ap_int_base& operator++() {
    operator+=((ap_int_base<1, false>)1);
    return *this;
  }
  inline __attribute__((always_inline)) ap_int_base& operator--() {
    operator-=((ap_int_base<1, false>)1);
    return *this;
  }




  inline __attribute__((always_inline)) const typename RType<_AP_W,_AP_S>::arg1 operator++(int) {
    ap_int_base t = *this;
    operator+=((ap_int_base<1, false>)1);
    return t;
  }
  inline __attribute__((always_inline)) const typename RType<_AP_W,_AP_S>::arg1 operator--(int) {
    ap_int_base t = *this;
    operator-=((ap_int_base<1, false>)1);
    return t;
  }




  inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator+() const { return *this; }


  inline __attribute__((always_inline)) typename RType<1, false>::minus operator-() const {
    return ap_int_base<1, false>(0) - *this;
  }




  inline __attribute__((always_inline)) bool operator!() const { return Base::V == 0; }





  inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator~() const {
    ap_int_base<_AP_W, _AP_S> r;
    r.V = ~Base::V;
    return r;
  }




  template <int _AP_W2>
  inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, true>& op2) const {
    bool isNeg = ({ __typeof__(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator>>(sh);
    } else
      return operator<<(sh);
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, false>& op2) const {
    ap_int_base r;
    r.V = Base::V << op2.to_uint();
    return r;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, true>& op2) const {
    bool isNeg = ({ __typeof__(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator<<(sh);
    }
    return operator>>(sh);
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, false>& op2) const {
    ap_int_base r;
    r.V = Base::V >> op2.to_uint();
    return r;
  }
# 828 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_int_base& operator<<=(const ap_int_base<_AP_W2, true>& op2) {
    bool isNeg = ({ __typeof__(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator>>=(sh);
    } else
      return operator<<=(sh);
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_int_base& operator<<=(const ap_int_base<_AP_W2, false>& op2) {
    Base::V <<= op2.to_uint();
    return *this;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_int_base& operator>>=(const ap_int_base<_AP_W2, true>& op2) {
    bool isNeg = ({ __typeof__(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator<<=(sh);
    }
    return operator>>=(sh);
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_int_base& operator>>=(const ap_int_base<_AP_W2, false>& op2) {
    Base::V >>= op2.to_uint();
    return *this;
  }
# 877 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator==(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V == op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator!=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return !(Base::V == op2.V);
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V < op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V >= op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V > op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V <= op2.V;
  }




  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ap_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }


  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) const {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ap_range_ref<_AP_W, _AP_S>(const_cast<ap_int_base*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range() {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range() const {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) {
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) const {
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }
# 986 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
  inline __attribute__((always_inline)) ap_bit_ref<_AP_W, _AP_S> operator[](int index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);
    return bvh;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref<_AP_W, _AP_S> operator[](
      const ap_int_base<_AP_W2, _AP_S2>& index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());
    return bvh;
  }

  inline __attribute__((always_inline)) bool operator[](int index) const {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index);
    return br.to_bool();
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator[](const ap_int_base<_AP_W2, _AP_S2>& index) const {
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index.to_int());
    return br.to_bool();
  }

  inline __attribute__((always_inline)) ap_bit_ref<_AP_W, _AP_S> bit(int index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);
    return bvh;
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref<_AP_W, _AP_S> bit(
      const ap_int_base<_AP_W2, _AP_S2>& index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());
    return bvh;
  }

  inline __attribute__((always_inline)) bool bit(int index) const {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index);
    return br.to_bool();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool bit(const ap_int_base<_AP_W2, _AP_S2>& index) const {
    return bit(index.to_int());
  }
# 1053 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
  inline __attribute__((always_inline)) int countLeadingZeros() {

    if (_AP_W <= 32) {
      ap_int_base<32, false> t(-1UL), x;
      x.V = ({ typename _ap_type::remove_const<__typeof__(this->V)>::type __Result__ = 0; __typeof__(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
      t.V = ({ typename _ap_type::remove_const<__typeof__(t.V)>::type __Result__ = 0; __typeof__(t.V) __Val2__ = t.V; __typeof__(x.V) __Repl2__ = x.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, _AP_W - 1); __Result__; });
      return __builtin_ctz(t.V);
    } else if (_AP_W <= 64) {
      ap_int_base<64, false> t(-1ULL);
      ap_int_base<64, false> x;
      x.V = ({ typename _ap_type::remove_const<__typeof__(this->V)>::type __Result__ = 0; __typeof__(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
      t.V = ({ typename _ap_type::remove_const<__typeof__(t.V)>::type __Result__ = 0; __typeof__(t.V) __Val2__ = t.V; __typeof__(x.V) __Repl2__ = x.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, _AP_W - 1); __Result__; });
      return __builtin_ctzll(t.V);
    } else {
      enum { __N = (_AP_W + 63) / 64 };
      int NZeros = 0;
      int i = 0;
      bool hitNonZero = false;
      for (i = 0; i < __N - 1; ++i) {
        ap_int_base<64, false> t;
        t.V = ({ typename _ap_type::remove_const<__typeof__(this->V)>::type __Result__ = 0; __typeof__(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - i * 64 - 64, _AP_W - i * 64 - 1); __Result__; });
        NZeros += hitNonZero ? 0 : __builtin_clzll(t.V);
        hitNonZero |= (t.V != 0);
      }
      if (!hitNonZero) {
        ap_int_base<64, false> t(-1ULL);
        enum { REST = (_AP_W - 1) % 64 };
        ap_int_base<64, false> x;
        x.V = ({ typename _ap_type::remove_const<__typeof__(this->V)>::type __Result__ = 0; __typeof__(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, REST); __Result__; });
        t.V = ({ typename _ap_type::remove_const<__typeof__(t.V)>::type __Result__ = 0; __typeof__(t.V) __Val2__ = t.V; __typeof__(x.V) __Repl2__ = x.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 63 - REST, 63); __Result__; });
        NZeros += __builtin_clzll(t.V);
      }
      return NZeros;
    }



  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  concat(const ap_int_base<_AP_W2, _AP_S2>& a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  concat(ap_int_base<_AP_W2, _AP_S2>& a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this), a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, a2);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                                                                         a2);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      _AP_W, ap_int_base, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                &a2) const {
    return ap_concat_ref<
        _AP_W, ap_int_base, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      _AP_W, ap_int_base, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        _AP_W, ap_int_base, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                                                                       a2);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_int_base, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &a2) const {
    return ap_concat_ref<
        _AP_W, ap_int_base, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_int_base, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(
          af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        _AP_W, ap_int_base, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator&(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this & a2.get();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator|(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this | a2.get();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator^(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this ^ a2.get();
  }

  template <int _AP_W3>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
    Base::V = val.V;
  }





  inline __attribute__((always_inline)) bool and_reduce() const { return ({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_and_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) bool nand_reduce() const { return ({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_nand_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) bool or_reduce() const { return ({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) bool nor_reduce() const { return !(({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); })); }
  inline __attribute__((always_inline)) bool xor_reduce() const { return ({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) bool xnor_reduce() const {
    return !(({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); }));
  }
# 1293 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
  inline __attribute__((always_inline)) char* to_string(signed char rd = 2, bool sign = _AP_S) const {
    return 0;
  }

};
# 1352 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: mult_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: mult_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: mult_base ret; ret.V = lhs.V * rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: plus_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: plus_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: plus_base ret; ret.V = lhs.V + rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: minus_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: minus_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: minus_base ret; ret.V = lhs.V - rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: logic_base ret; ret.V = lhs.V & rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: logic_base ret; ret.V = lhs.V | rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: logic_base ret; ret.V = lhs.V ^ rhs.V; return ret; }
# 1371 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: div_base ret; ret.V = op.V / op2.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>:: mod_base ret; ret.V = op.V % op2.V; return ret; }
# 1399 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator +(PTR_TYPE* i_op, const ap_int_base<_AP_W, _AP_S>& op) { ap_slong op2 = op.to_int64(); return i_op + op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator +(const ap_int_base<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { ap_slong op2 = op.to_int64(); return op2 + i_op; }
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator -(PTR_TYPE* i_op, const ap_int_base<_AP_W, _AP_S>& op) { ap_slong op2 = op.to_int64(); return i_op - op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator -(const ap_int_base<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { ap_slong op2 = op.to_int64(); return op2 - i_op; }
# 1427 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator *(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator *(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator /(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator /(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator +(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator +(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator -(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator -(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator *(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator *(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator /(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator /(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator +(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator +(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator -(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator -(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator *(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator *(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator /(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator /(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator +(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator +(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator -(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator -(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
# 1461 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mult operator *(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op * ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::plus operator +(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op + ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::minus operator -(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op - ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::div operator /(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op / ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mod operator %(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op % ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator &(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op & ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator |(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op | ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator ^(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op ^ ap_int_base<1, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mult operator *(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op * ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::plus operator +(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op + ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::minus operator -(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op - ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::div operator /(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op / ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mod operator %(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op % ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator &(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op & ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator |(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op | ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator ^(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op ^ ap_int_base<8, CHAR_IS_SIGNED>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mult operator *(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op * ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::plus operator +(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op + ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::minus operator -(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op - ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::div operator /(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op / ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mod operator %(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op % ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator &(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op & ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator |(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op | ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator ^(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op ^ ap_int_base<8, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mult operator *(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op * ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::plus operator +(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op + ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::minus operator -(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op - ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::div operator /(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op / ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mod operator %(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op % ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator &(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op & ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator |(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op | ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator ^(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op ^ ap_int_base<8, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mult operator *(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op * ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::plus operator +(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op + ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::minus operator -(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op - ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::div operator /(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op / ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mod operator %(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op % ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator &(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op & ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator |(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op | ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator ^(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op ^ ap_int_base<_AP_SIZE_short, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mult operator *(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op * ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::plus operator +(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op + ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::minus operator -(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op - ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::div operator /(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op / ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mod operator %(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op % ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator &(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op & ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator |(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op | ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator ^(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op ^ ap_int_base<_AP_SIZE_short, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mult operator *(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op * ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::plus operator +(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op + ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::minus operator -(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op - ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::div operator /(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op / ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mod operator %(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op % ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator &(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op & ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator |(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op | ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator ^(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op ^ ap_int_base<_AP_SIZE_int, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mult operator *(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op * ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::plus operator +(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op + ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::minus operator -(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op - ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::div operator /(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op / ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mod operator %(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op % ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator &(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op & ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator |(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op | ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator ^(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op ^ ap_int_base<_AP_SIZE_int, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mult operator *(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op * ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::plus operator +(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op + ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::minus operator -(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op - ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::div operator /(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op / ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mod operator %(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op % ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator &(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op & ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator |(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op | ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator ^(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op ^ ap_int_base<_AP_SIZE_long, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mult operator *(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op * ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::plus operator +(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op + ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::minus operator -(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op - ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::div operator /(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op / ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mod operator %(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op % ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator &(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op & ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator |(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op | ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator ^(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op ^ ap_int_base<_AP_SIZE_long, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mult operator *(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op * ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::plus operator +(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op + ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::minus operator -(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op - ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::div operator /(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op / ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mod operator %(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op % ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator &(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op & ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator |(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op | ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator ^(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op ^ ap_int_base<_AP_SIZE_ap_slong, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mult operator *(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op * ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::plus operator +(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op + ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::minus operator -(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op - ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::div operator /(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op / ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mod operator %(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op % ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator &(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op & ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator |(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op | ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator ^(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op ^ ap_int_base<_AP_SIZE_ap_slong, false>(i_op); }
# 1500 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r; if (CHAR_IS_SIGNED) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r; if (CHAR_IS_SIGNED) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
# 1524 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
# 1555 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op += ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op -= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op *= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op /= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op %= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op &= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op |= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op ^= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op >>= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op <<= ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op += ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op -= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op *= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op /= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op %= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op &= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op |= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op ^= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op >>= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op <<= ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op += ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op -= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op *= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op /= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op %= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op &= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op |= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op ^= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op >>= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op <<= ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op += ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op -= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op *= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op /= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op %= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op &= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op |= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op ^= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op >>= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op <<= ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op += ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op -= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op *= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op /= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op %= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op &= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op |= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op ^= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op >>= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op <<= ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op += ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op -= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op *= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op /= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op %= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op &= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op |= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op ^= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op >>= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op <<= ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op += ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op -= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op *= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op /= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op %= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op &= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op |= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op ^= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op >>= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op <<= ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op += ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op -= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op *= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op /= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op %= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op &= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op |= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op ^= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op >>= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op <<= ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op += ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op -= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op *= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op /= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op %= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op &= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op |= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op ^= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op >>= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op <<= ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op += ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op -= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op *= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op /= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op %= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op &= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op |= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op ^= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op >>= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op <<= ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op += ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op -= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op *= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op /= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op %= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op &= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op |= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op ^= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op >>= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op <<= ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op += ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op -= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op *= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op /= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op %= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op &= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op |= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op ^= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op >>= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op <<= ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1592 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op <= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op != ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op <= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op != ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op <= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op != ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op <= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op != ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op <= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op != ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op <= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op != ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op <= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op != ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op <= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op != ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op <= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op != ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op <= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op != ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op != ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op != ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1629 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() > op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 > op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() > op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 > op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() < op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 < op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() < op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 < op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() >= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 >= op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() >= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 >= op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() <= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 <= op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() <= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 <= op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() == op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 == op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() == op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 == op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() != op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 != op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() != op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 != op2.to_double() ; }
# 1659 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) + op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 + ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) - op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 - ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) * op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 * ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) / op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 / ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) % op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 % ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) & op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 & ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) | op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 | ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) ^ op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 ^ ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) >> op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 >> ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) << op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 << ap_int_base<_AP_W2, false>(op2); }
# 1690 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator +=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 += ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator +=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp += op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator -=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 -= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator -=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp -= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator *=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 *= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator *=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp *= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator /=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 /= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator /=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp /= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator %=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 %= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator %=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp %= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator >>=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 >>= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator >>=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp >>= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator <<=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 <<= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator <<=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp <<= op2; op1 = tmp; return op1; }
# 1722 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator &=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V &= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator &=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V &= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator |=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V |= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator |=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V |= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator ^=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V ^= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator ^=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V ^= op2.V; op1 = tmp; return op1; }
# 1741 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator ==(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ==(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator !=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator !=(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >=(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator <(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator <=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <=(op2.operator ap_int_base<_AP_W2, false>()); }
# 1768 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::plus operator +(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 + ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) + op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::minus operator -(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 - ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) - op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::mult operator *(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 * ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) * op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::div operator /(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 / ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) / op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::mod operator %(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 % ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) % op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator &(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 & ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) & op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator |(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 | ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) | op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator ^(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 ^ ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) ^ op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator >>(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >> ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) >> op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator <<(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 << ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) << op2; }
# 1799 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator +=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 += ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator +=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp += op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator -=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 -= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator -=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp -= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator *=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 *= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator *=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp *= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator /=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 /= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator /=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp /= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator %=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 %= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator %=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp %= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator >>=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >>= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator >>=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp >>= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator <<=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 <<= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator <<=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp <<= op2; op1 = tmp; return op1; }
# 1831 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator &=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V &= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator &=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V &= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator |=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V |= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator |=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V |= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator ^=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V ^= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator ^=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V ^= op2.V; op1 = tmp; return op1; }
# 1850 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 == ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) == op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 != ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) != op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 > ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) > op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) >= op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 < ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) < op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 <= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) <= op2; }
# 1958 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_base.h"
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator ==( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 == op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() == op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator !=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 != op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() != op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator >( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 > op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() > op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator >=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 >= op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() >= op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator <( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 < op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() < op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator <=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 <= op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() <= op2; }
# 56 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_ref.h" 1
# 73 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_ref.h"
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref {
  enum {
    _AP_WR = _AP_W1 + _AP_W2,
  };

  _AP_T1& mbv1;
  _AP_T2& mbv2;

  inline __attribute__((always_inline)) ap_concat_ref(const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& ref)
      : mbv1(ref.mbv1), mbv2(ref.mbv2) {}

  inline __attribute__((always_inline)) ap_concat_ref(_AP_T1& bv1, _AP_T2& bv2) : mbv1(bv1), mbv2(bv2) {}

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W1, false> Part1;
    Part1.V = ({ typename _ap_type::remove_const<__typeof__(vval.V)>::type __Result__ = 0; __typeof__(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), W_ref2, W_ref1 + W_ref2 - 1); __Result__; });
    mbv1.set(Part1);
    ap_int_base<_AP_W2, false> Part2;
    Part2.V = ({ typename _ap_type::remove_const<__typeof__(vval.V)>::type __Result__ = 0; __typeof__(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, W_ref2 - 1); __Result__; });
    mbv2.set(Part2);
    return *this;
  }
# 116 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_ref.h"
  inline __attribute__((always_inline)) ap_concat_ref& operator=(bool val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(signed char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(unsigned char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(short val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(unsigned short val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(int val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(unsigned int val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(long val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(unsigned long val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(ap_slong val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(ap_ulong val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(half val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(float val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(double val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }





  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(const ap_bit_ref<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }
  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(const ap_range_ref<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {
    return operator=((const ap_int_base<_AP_W3, false>)(val));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const ap_fixed_base<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&
          val) {
    return operator=(val.to_ap_int_base());
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {
    return operator=((ap_ulong)(bool)(val));
  }

  inline __attribute__((always_inline)) operator ap_int_base<_AP_WR, false>() const { return get(); }

  inline __attribute__((always_inline)) operator ap_ulong() const { return get().to_uint64(); }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                       ap_range_ref<_AP_W3, _AP_S3> >
  operator,(const ap_range_ref<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_range_ref<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_range_ref<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(*this, a2);
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(volatile ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(const ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(const volatile ap_int_base<_AP_W3, _AP_S3> &a2) {

    ap_int_base<_AP_W3, _AP_S3> op(a2);
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(op));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >
  operator,(const ap_bit_ref<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_bit_ref<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,
                       ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >
  operator,(const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,
                         ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >(
        *this, const_cast<ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>&>(a2));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) ap_concat_ref<
      _AP_WR, ap_concat_ref, _AP_W3,
      af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
  operator,(
      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> &a2) {
    return ap_concat_ref<
        _AP_WR, ap_concat_ref, _AP_W3,
        af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(
        *this,
        const_cast<
            af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(a2));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, 1,
                    af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
      operator,(const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>
                    &a2) {
    return ap_concat_ref<
        _AP_WR, ap_concat_ref, 1,
        af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(
        *this,
        const_cast<af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(
            a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator&(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() & a2;
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator|(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() | a2;
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator^(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() ^ a2;
  }
# 304 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_ref.h"
  inline __attribute__((always_inline)) ap_int_base<_AP_WR, false> get() const {
    ap_int_base<_AP_WR, false> tmpVal(0);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W2, false> v2(mbv2);
    ap_int_base<_AP_W1, false> v1(mbv1);
    tmpVal.V = ({ typename _ap_type::remove_const<__typeof__(tmpVal.V)>::type __Result__ = 0; __typeof__(tmpVal.V) __Val2__ = tmpVal.V; __typeof__(v2.V) __Repl2__ = v2.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, W_ref2 - 1); __Result__; });
    tmpVal.V =
        ({ typename _ap_type::remove_const<__typeof__(tmpVal.V)>::type __Result__ = 0; __typeof__(tmpVal.V) __Val2__ = tmpVal.V; __typeof__(v1.V) __Repl2__ = v1.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), W_ref2, W_ref1 + W_ref2 - 1); __Result__; });
    return tmpVal;
  }

  template <int _AP_W3>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W1, false> tmpVal1;
    tmpVal1.V = ({ typename _ap_type::remove_const<__typeof__(vval.V)>::type __Result__ = 0; __typeof__(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), W_ref2, W_ref1 + W_ref2 - 1); __Result__; });
    mbv1.set(tmpVal1);
    ap_int_base<_AP_W2, false> tmpVal2;
    tmpVal2.V = ({ typename _ap_type::remove_const<__typeof__(vval.V)>::type __Result__ = 0; __typeof__(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, W_ref2 - 1); __Result__; });
    mbv2.set(tmpVal2);
  }

  inline __attribute__((always_inline)) int length() const { return mbv1.length() + mbv2.length(); }
};




template <int _AP_W, bool _AP_S>
struct ap_range_ref {



  typedef ap_int_base<_AP_W, _AP_S> ref_type;
  ref_type& d_bv;
  int l_index;
  int h_index;

 public:
  inline __attribute__((always_inline)) ap_range_ref(const ap_range_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}

  inline __attribute__((always_inline)) ap_range_ref(ref_type* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {}

  inline __attribute__((always_inline)) ap_range_ref(const ref_type* bv, int h, int l)
      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {}

  inline __attribute__((always_inline)) operator ap_int_base<_AP_W, false>() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) operator ap_ulong() const { return to_uint64(); }
# 385 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_ref.h"
  inline __attribute__((always_inline)) ap_range_ref& operator=(bool val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(signed char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(unsigned char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(short val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(unsigned short val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(int val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(unsigned int val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(long val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(unsigned long val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(ap_slong val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(ap_ulong val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(half val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(float val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(double val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }




  inline __attribute__((always_inline)) ap_range_ref& operator=(const char* val) {
    const ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }




  inline __attribute__((always_inline)) ap_range_ref& operator=(const ap_range_ref& val) {
    return operator=((const ap_int_base<_AP_W, false>)val);
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(bool)(val));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          val) {
    return operator=(val.to_ap_int_base());
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((ap_ulong)(bool)(val));
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_range_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)(val));
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  inline __attribute__((always_inline))
  ap_concat_ref<_AP_W, ap_range_ref, _AP_W, ap_int_base<_AP_W, _AP_S> >
  operator,(ap_int_base<_AP_W, _AP_S>& a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W,
                         ap_int_base<_AP_W, _AP_S> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      _AP_W, ap_range_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> a2) {
    return ap_concat_ref<
        _AP_W, ap_range_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &a2) {
    return ap_concat_ref<
        _AP_W, ap_range_ref, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop == hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop < hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop <= hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<=(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator|=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V |= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator|=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V |= op2.V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator&=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V &= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator&=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V &= op2.V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator^=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V ^= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator^=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V ^= op2.V;
    return *this;
  };

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> get() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W2, false>& val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
  }

  inline __attribute__((always_inline)) int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }

  inline __attribute__((always_inline)) int to_int() const {
    return (int)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) unsigned to_uint() const {
    return (unsigned)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) long to_long() const {
    return (long)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) unsigned long to_ulong() const {
    return (unsigned long)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) ap_slong to_int64() const {
    return (ap_slong)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) ap_ulong to_uint64() const {
    return (ap_ulong)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) bool and_reduce() const {
    bool ret = true;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) {

#pragma HLS unroll

 ret &= ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    }
    return ret;
  }

  inline __attribute__((always_inline)) bool or_reduce() const {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) {

#pragma HLS unroll

 ret |= ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    }
    return ret;
  }

  inline __attribute__((always_inline)) bool xor_reduce() const {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) {

#pragma HLS unroll

 ret ^= ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    }
    return ret;
  }
# 733 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_ref.h"
  inline __attribute__((always_inline)) char* to_string(signed char radix = 2) const {
    return 0;
  }

};
# 772 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_ref.h"
template <int _AP_W, bool _AP_S>
struct ap_bit_ref {



  typedef ap_int_base<_AP_W, _AP_S> ref_type;
  ref_type& d_bv;
  int d_index;

 public:

  inline __attribute__((always_inline)) ap_bit_ref(const ap_bit_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {}

  inline __attribute__((always_inline)) ap_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}

  inline __attribute__((always_inline)) ap_bit_ref(const ref_type* bv, int index = 0)
      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}

  inline __attribute__((always_inline)) operator bool() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }
  inline __attribute__((always_inline)) bool to_bool() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }
# 810 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_ref.h"
  inline __attribute__((always_inline)) ap_bit_ref& operator=(bool val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(char val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(signed char val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(unsigned char val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(short val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(unsigned short val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(int val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(unsigned int val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(long val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(unsigned long val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(ap_slong val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(ap_ulong val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
# 832 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_ref.h"
  inline __attribute__((always_inline)) ap_bit_ref& operator=(half val) { bool tmp_val = val; d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp_val) __Repl2__ = !!tmp_val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(float val) { bool tmp_val = val; d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp_val) __Repl2__ = !!tmp_val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(double val) { bool tmp_val = val; d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp_val) __Repl2__ = !!tmp_val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }




  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(val.V != 0));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_int_base<_AP_W2, false>)val);
  }



  inline __attribute__((always_inline)) ap_bit_ref& operator=(const ap_bit_ref& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    ap_int_base<_AP_W2, _AP_S2> op(a2);
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    ap_int_base<_AP_W2, _AP_S2> op(a2);
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(
      const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      1, ap_bit_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        1, ap_bit_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                    _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                      _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator==(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    return get() == op.get();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator!=(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    return get() != op.get();
  }

  inline __attribute__((always_inline)) bool get() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }

  inline __attribute__((always_inline)) bool get() { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }

  template <int _AP_W3>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
    operator=(val);
  }

  inline __attribute__((always_inline)) bool operator~() const {
    bool bit = ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; });
    return bit ? false : true;
  }

  inline __attribute__((always_inline)) int length() const { return 1; }





  inline __attribute__((always_inline)) char* to_string() const { return 0; }

};
# 1030 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); }






template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1089 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::plus operator +(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::minus operator -(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::mult operator *(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::div operator /(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::mod operator %(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::plus operator +(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::minus operator -(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mult operator *(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::div operator /(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mod operator %(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::plus operator +(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::minus operator -(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::mult operator *(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::div operator /(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::mod operator %(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::div operator /(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::plus operator +(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::minus operator -(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::mult operator *(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::div operator /(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::mod operator %(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::plus operator +(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::minus operator -(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::mult operator *(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::div operator /(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::mod operator %(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::plus operator +(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::minus operator -(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::mult operator *(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::div operator /(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::mod operator %(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::plus operator +(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::minus operator -(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::mult operator *(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::div operator /(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::mod operator %(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::plus operator +(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::minus operator -(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::mult operator *(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::div operator /(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::mod operator %(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::plus operator +(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::minus operator -(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::mult operator *(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::div operator /(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::mod operator %(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::plus operator +(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::minus operator -(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::mult operator *(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::div operator /(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::mod operator %(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::plus operator +(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::minus operator -(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::mult operator *(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::div operator /(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::mod operator %(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
# 1112 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator &(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator |(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator ^(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::arg1 operator >>(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::arg1 operator <<(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator &(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator |(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator ^(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator >>(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator <<(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator &(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator |(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator ^(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::arg1 operator >>(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::arg1 operator <<(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator &(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator |(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator ^(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::arg1 operator >>(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::arg1 operator <<(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator &(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator |(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator &(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator |(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator ^(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::arg1 operator >>(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::arg1 operator <<(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator &(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator |(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator &(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator |(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator ^(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::arg1 operator >>(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::arg1 operator <<(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator &(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator |(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator &(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator |(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator ^(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::arg1 operator >>(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::arg1 operator <<(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator &(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator |(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator ^(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::arg1 operator >>(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::arg1 operator <<(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
# 1140 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_ref.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())+( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())-( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())*( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::div operator /(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())/( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())%( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())&( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())|( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())^( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())>>( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())<<( rhs.operator ap_int_base<_AP_W2, false>()); }
# 1189 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_ref.h"
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::plus operator +( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() + rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::minus operator -( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() - rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::mult operator *( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() * rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::div operator /( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() / rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::mod operator %( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() % rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator &( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() & rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator |( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() | rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator ^( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() ^ rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::arg1 operator >>( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() >> rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::arg1 operator <<( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() << rhs.get(); }
# 1336 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( bool op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 1; ret >>= 1; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( bool op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<1 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<1 + 1, false> operator,( bool op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 1, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, bool op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op2); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 1; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 1, false> operator,( bool op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op1); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 1; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( bool op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 1, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 1, false> operator,( bool op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, char op2) { ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> val(op2); ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> ret(op1); if (CHAR_IS_SIGNED) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> val(op1); ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + 1, CHAR_IS_SIGNED> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, CHAR_IS_SIGNED> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( signed char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( signed char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( signed char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, signed char op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op2); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( signed char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op1); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( signed char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + 1, true> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( signed char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( unsigned char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned char op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op2); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( unsigned char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op1); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( unsigned char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_short; ret >>= _AP_SIZE_short; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_short + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_short + 1, false> operator,( short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_short, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<_AP_SIZE_short + 1, true> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_short, false> operator,( short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_short; ret >>= _AP_SIZE_short; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_short + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_short + 1, false> operator,( unsigned short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_short, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_short, false> operator,( unsigned short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_int; ret >>= _AP_SIZE_int; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_int + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_int + 1, false> operator,( int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_int, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<_AP_SIZE_int + 1, true> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_int, false> operator,( int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_int; ret >>= _AP_SIZE_int; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_int + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_int + 1, false> operator,( unsigned int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_int, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_int, false> operator,( unsigned int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_long; ret >>= _AP_SIZE_long; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_long + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_long + 1, false> operator,( long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_long, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<_AP_SIZE_long + 1, true> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_long, false> operator,( long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_long; ret >>= _AP_SIZE_long; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_long + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_long + 1, false> operator,( unsigned long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_long, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_long, false> operator,( unsigned long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_ap_slong; ret >>= _AP_SIZE_ap_slong; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( ap_slong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, true> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_ap_slong; ret >>= _AP_SIZE_ap_slong; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( ap_ulong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
# 1360 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_ref.h"
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }

template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
# 57 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 2




template <int _AP_W>
struct ap_int : ap_int_base<_AP_W, true> {
  typedef ap_int_base<_AP_W, true> Base;

  inline __attribute__((always_inline)) ap_int() : Base() {}
  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_int(const ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_int(const volatile ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_int(const ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_int(const volatile ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }
# 95 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)
      : Base(ref) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_int(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_int(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_int(
      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_int(
      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int(const ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}



  inline __attribute__((always_inline)) ap_int(bool val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(char val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(signed char val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(unsigned char val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(short val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(unsigned short val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(int val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(unsigned int val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(long val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(unsigned long val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(ap_slong val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(ap_ulong val) { Base::V = val; }

  ap_int(double val) : Base(val) {}
  ap_int(float val) : Base(val) {}
  ap_int(half val) : Base(val) {}


  inline __attribute__((always_inline)) ap_int(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) ap_int(const char* s, signed char rd) : Base(s, rd) {}




  inline __attribute__((always_inline)) ap_int& operator=(const ap_int<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline __attribute__((always_inline)) ap_int& operator=(const volatile ap_int<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline __attribute__((always_inline)) void operator=(const ap_int<_AP_W>& op2) volatile { Base::V = op2.V; }

  inline __attribute__((always_inline)) void operator=(const volatile ap_int<_AP_W>& op2) volatile {
    Base::V = op2.V;
  }

};




template <int _AP_W>
struct ap_uint : ap_int_base<_AP_W, false> {
  typedef ap_int_base<_AP_W, false> Base;

  inline __attribute__((always_inline)) ap_uint() : Base() {}
  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_uint(const ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_uint(const ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_uint(const volatile ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_uint(const volatile ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }
# 236 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_uint(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_uint(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_uint(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)
      : Base(ref) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(
      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(
      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_uint(const ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}



  inline __attribute__((always_inline)) ap_uint(bool val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(char val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(signed char val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(unsigned char val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(short val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(unsigned short val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(int val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(unsigned int val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(long val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(unsigned long val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(ap_slong val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(ap_ulong val) { Base::V = val; }

  ap_uint(double val) : Base(val) {}
  ap_uint(float val) : Base(val) {}
  ap_uint(half val) : Base(val) {}


  inline __attribute__((always_inline)) ap_uint(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) ap_uint(const char* s, signed char rd) : Base(s, rd) {}




  inline __attribute__((always_inline)) ap_uint& operator=(const ap_uint<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline __attribute__((always_inline)) ap_uint& operator=(const volatile ap_uint<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline __attribute__((always_inline)) void operator=(const ap_uint<_AP_W>& op2) volatile { Base::V = op2.V; }

  inline __attribute__((always_inline)) void operator=(const volatile ap_uint<_AP_W>& op2) volatile {
    Base::V = op2.V;
  }

};
# 359 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_special.h" 1
# 61 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_special.h"
namespace std {
template<typename _Tp> class complex;
}







namespace std {
# 89 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_special.h"
template <int _AP_W>
class complex<ap_int<_AP_W> > {
 public:
  typedef ap_int<_AP_W> _Tp;
  typedef _Tp value_type;




  complex() : _M_real(_Tp()), _M_imag(_Tp()) {}


  complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const _Tp& real() const { return _M_real; }
  const _Tp& imag() const { return _M_imag; }







  void real(_Tp __val) { _M_real = __val; }

  void imag(_Tp __val) { _M_imag = __val; }



  complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  complex<_Tp> &operator=(const complex<_Up> &__z) {
    _M_real = __z.real();
    _M_imag = __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 222 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int_special.h"
template <int _AP_W>
inline bool operator==(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W>
inline bool operator==(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W>
inline bool operator!=(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W>
inline bool operator!=(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}

}
# 360 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 2







# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed.h" 1
# 55 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h" 1
# 62 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 63 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h" 2
# 133 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
template <int _AP_W2, int _AP_I2, bool _AP_S2>
struct _ap_fixed_factory;
template <int _AP_W2, int _AP_I2>
struct _ap_fixed_factory<_AP_W2, _AP_I2, true> {
  typedef ap_fixed<_AP_W2, _AP_I2> type;
};
template <int _AP_W2, int _AP_I2>
struct _ap_fixed_factory<_AP_W2, _AP_I2, false> {
  typedef ap_ufixed<_AP_W2, _AP_I2> type;
};
# 154 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct ap_fixed_base : ssdm_int<_AP_W, _AP_S> {
 public:
  typedef ssdm_int<_AP_W, _AP_S> Base;
  static const int width = _AP_W;
  static const int iwidth = _AP_I;
  static const ap_q_mode qmode = _AP_Q;
  static const ap_o_mode omode = _AP_O;


  template <int _AP_W2, int _AP_I2, bool _AP_S2>
  struct RType {
    enum {
      _AP_F = _AP_W - _AP_I,
      F2 = _AP_W2 - _AP_I2,
      mult_w = _AP_W + _AP_W2,
      mult_i = _AP_I + _AP_I2,
      mult_s = _AP_S || _AP_S2,
      plus_w = ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) +
               1 + ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      plus_i =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1 +
          ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      minus_i =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,

      div_w = _AP_S2 + _AP_W + ((F2) > (0) ? (F2) : (0)),



      div_i = _AP_S2 + _AP_I + F2,
      div_s = _AP_S || _AP_S2,
      logic_w =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) +
          ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      logic_i = ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };

    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> lhs;
    typedef ap_fixed_base<_AP_W2, _AP_I2, _AP_S2> rhs;

    typedef ap_fixed_base<mult_w, mult_i, mult_s> mult_base;
    typedef ap_fixed_base<plus_w, plus_i, plus_s> plus_base;
    typedef ap_fixed_base<minus_w, minus_i, minus_s> minus_base;
    typedef ap_fixed_base<logic_w, logic_i, logic_s> logic_base;
    typedef ap_fixed_base<div_w, div_i, div_s> div_base;
    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> arg1_base;

    typedef typename _ap_fixed_factory<mult_w, mult_i, mult_s>::type mult;
    typedef typename _ap_fixed_factory<plus_w, plus_i, plus_s>::type plus;
    typedef typename _ap_fixed_factory<minus_w, minus_i, minus_s>::type minus;
    typedef typename _ap_fixed_factory<logic_w, logic_i, logic_s>::type logic;
    typedef typename _ap_fixed_factory<div_w, div_i, div_s>::type div;
    typedef typename _ap_fixed_factory<_AP_W, _AP_I, _AP_S>::type arg1;
  };

 private:
# 333 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
  inline __attribute__((always_inline)) void report() {}




  inline __attribute__((always_inline)) void overflow_adjust(bool underflow, bool overflow, bool lD,
                              bool sign) {
    if (!underflow && !overflow) return;
    if (_AP_O == AP_WRAP) {
      if (_AP_N == 0) return;
      if (_AP_S) {


        Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(sign) __Repl2__ = !!sign; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
        if (_AP_N > 1) {

          ap_int_base<_AP_W, false> mask(-1);
          if (sign) mask.V = 0;
          Base::V =
              ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 2); __Result__; });
        }
      } else {

        ap_int_base<_AP_W, false> mask(-1);
        Base::V =
            ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 1); __Result__; });
      }
    } else if (_AP_O == AP_SAT_ZERO) {
      Base::V = 0;
    } else if (_AP_O == AP_WRAP_SM && _AP_S) {
      bool Ro = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
      if (_AP_N == 0) {
        if (lD != Ro) {
          Base::V = ~Base::V;
          Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(lD) __Repl2__ = !!lD; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
        }
      } else {
        if (_AP_N == 1 && sign != Ro) {
          Base::V = ~Base::V;
        } else if (_AP_N > 1) {
          bool lNo = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - _AP_N); __Result__; });
          if (lNo == sign) Base::V = ~Base::V;
          ap_int_base<_AP_W, false> mask(-1);
          if (sign) mask.V = 0;
          Base::V =
              ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 2); __Result__; });
        }
        Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(sign) __Repl2__ = !!sign; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
      }
    } else {
      if (_AP_S) {
        if (overflow) {
          Base::V = 1;
          Base::V <<= _AP_W - 1;
          Base::V = ~Base::V;
        } else if (underflow) {
          Base::V = 1;
          Base::V <<= _AP_W - 1;
          if (_AP_O == AP_SAT_SYM) Base::V |= 1;
        }
      } else {
        if (overflow)
          Base::V = ~(ap_int_base<_AP_W, false>(0).V);
        else if (underflow)
          Base::V = 0;
      }
    }
  }

  inline __attribute__((always_inline)) bool quantization_adjust(bool qb, bool r, bool s) {
    bool carry = (bool)({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    if (_AP_Q == AP_TRN) return false;
    if (_AP_Q == AP_RND_ZERO)
      qb &= s || r;
    else if (_AP_Q == AP_RND_MIN_INF)
      qb &= r;
    else if (_AP_Q == AP_RND_INF)
      qb &= !s || r;
    else if (_AP_Q == AP_RND_CONV)
      qb &= ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 0); __Result__; }) || r;
    else if (_AP_Q == AP_TRN_ZERO)
      qb = s && (qb || r);
    Base::V += qb;
    return carry && (!(bool)({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; }));
  }


 public:



  inline __attribute__((always_inline)) ap_fixed_base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(op);
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base(
      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(op);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed_base(const ap_int_base<_AP_W2, _AP_S2>& op) {
    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp;
    tmp.V = op.V;
    operator=(tmp);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {
    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp;
    tmp.V = op.V;
    operator=(tmp);
    report();
  }
# 477 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
  inline __attribute__((always_inline)) ap_fixed_base(const char* s) {
    __typeof__(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), 10, _AP_I, _AP_S, _AP_Q,
                      _AP_O, _AP_N, true);
    Base::V = t;
  }
  inline __attribute__((always_inline)) ap_fixed_base(const char* s, signed char rd) {
    __typeof__(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), rd, _AP_I, _AP_S, _AP_Q,
                      _AP_O, _AP_N, true);
    Base::V = t;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed_base(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    *this = ((bool)op);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed_base(const ap_range_ref<_AP_W2, _AP_S2>& op) {
    *this = (ap_int_base<_AP_W2, false>(op));
    report();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_fixed_base(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op) {
    *this = (ap_int_base<_AP_W2 + _AP_W3, false>(op));
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    *this = (bool(op));
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    *this = (ap_int_base<_AP_W2, false>(op));
    report();
  }
# 535 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
  inline __attribute__((always_inline)) ap_fixed_base(const bool x) { ap_fixed_base<(1), (1), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const char x) { ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const signed char x) { ap_fixed_base<(8), (8), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const unsigned char x) { ap_fixed_base<(8), (8), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const short x) { ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const unsigned short x) { ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const int x) { ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const unsigned int x) { ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const long x) { ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const unsigned long x) { ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const ap_slong x) { ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const ap_ulong x) { ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)> tmp; tmp.V = x; *this = tmp; }







          ap_fixed_base(double d) {
    ap_int_base<64, false> ireg;
    ireg.V = doubleToRawBits(d);
    bool isneg = ({ __typeof__(ireg.V) __Val2__ = ireg.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 63); __Result__; });

    ap_int_base<11 + 1, true> exp;
    ap_int_base<11, false> exp_tmp;
    exp_tmp.V =
        ({ typename _ap_type::remove_const<__typeof__(ireg.V)>::type __Result__ = 0; __typeof__(ireg.V) __Val2__ = ireg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 52, 52 + 11 - 1); __Result__; });
    exp = exp_tmp - ((1L << (11 - 1L)) - 1L);
    ap_int_base<52 + 2, true> man;
    man.V = ({ typename _ap_type::remove_const<__typeof__(ireg.V)>::type __Result__ = 0; __typeof__(ireg.V) __Val2__ = ireg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 52 - 1); __Result__; });

    (static_cast<void>(0));

    man.V = ({ typename _ap_type::remove_const<__typeof__(man.V)>::type __Result__ = 0; __typeof__(man.V) __Val2__ = man.V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52); __Result__; });
    if (isneg) man = -man;
    if ((ireg.V & 0x7fffffffffffffffLL) == 0) {
      Base::V = 0;
    } else {
      int _AP_W2 = 52 + 2, _AP_I2 = exp.V + 2, _AP_F = _AP_W - _AP_I,
          F2 = _AP_W2 - _AP_I2;
      bool _AP_S2 = true,
           QUAN_INC = F2 > _AP_F &&
                      !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));
      bool carry = false;

      unsigned sh_amt = (F2 > _AP_F) ? F2 - _AP_F : _AP_F - F2;
      if (F2 == _AP_F)
        Base::V = man.V;
      else if (F2 > _AP_F) {
        if (sh_amt < 52 + 2)
          Base::V = man.V >> sh_amt;
        else {
          Base::V = isneg ? -1 : 0;
        }
        if ((_AP_Q != AP_TRN) && !((_AP_Q == AP_TRN_ZERO) && !_AP_S2)) {
          bool qb = (F2 - _AP_F > _AP_W2) ? isneg : (bool)({ __typeof__(man.V) __Val2__ = man.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), F2 - _AP_F - 1); __Result__; });

          bool r =
              (F2 > _AP_F + 1)
                  ? ({ typename _ap_type::remove_const<__typeof__(man.V)>::type __Result__ = 0; __typeof__(man.V) __Val2__ = man.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, (F2 - _AP_F - 2 < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1)); __Result__; }) != 0


                  : false;
          carry = quantization_adjust(qb, r, isneg);
        }
      } else {
        Base::V = man.V;
        if (sh_amt < _AP_W)
          Base::V = Base::V << sh_amt;
        else
          Base::V = 0;
      }

      if ((_AP_O != AP_WRAP || _AP_N != 0) &&
          ((!_AP_S && _AP_S2) ||
           _AP_I - _AP_S <
               _AP_I2 - _AP_S2 +
                   (QUAN_INC ||
                    (_AP_S2 && (_AP_O == AP_SAT_SYM))))) {
        bool deleted_zeros = _AP_S2 ? true : !carry, deleted_ones = true;
        bool neg_src = isneg;
        bool lD = false;
        int pos1 = F2 - _AP_F + _AP_W;
        int pos2 = F2 - _AP_F + _AP_W + 1;
        bool newsignbit = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
        if (pos1 < _AP_W2 && pos1 >= 0)

          lD = (man.V >> pos1) & 1;
        if (pos1 < _AP_W2) {
          bool Range1_all_ones = true;
          bool Range1_all_zeros = true;
          bool Range2_all_ones = true;
          ap_int_base<52 + 2, false> Range2;
          ap_int_base<52 + 2, false> all_ones(-1);

          if (pos2 >= 0 && pos2 < _AP_W2) {


            Range2.V = man.V;
            Range2.V >>= pos2;
            Range2_all_ones = Range2 == (all_ones >> pos2);
          } else if (pos2 < 0)
            Range2_all_ones = false;
          if (pos1 >= 0 && pos2 < _AP_W2) {
            Range1_all_ones = Range2_all_ones && lD;
            Range1_all_zeros = !Range2.V && !lD;
          } else if (pos2 == _AP_W2) {
            Range1_all_ones = lD;
            Range1_all_zeros = !lD;
          } else if (pos1 < 0) {
            Range1_all_zeros = !man.V;
            Range1_all_ones = false;
          }

          deleted_zeros =
              deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);
          deleted_ones =
              carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;
          neg_src = isneg && !(carry && Range1_all_ones);
        } else
          neg_src = isneg && newsignbit;
        bool neg_trg = _AP_S && newsignbit;
        bool overflow = (neg_trg || !deleted_zeros) && !isneg;
        bool underflow = (!neg_trg || !deleted_ones) && neg_src;
        if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)
          underflow |=
              neg_src &&
              (_AP_W > 1 ? ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 2); __Result__; }) == 0
                         : true);
        overflow_adjust(underflow, overflow, lD, neg_src);
      }
    }
    report();
  }


  inline __attribute__((always_inline)) ap_fixed_base(float d) { *this = ap_fixed_base(double(d)); }


  inline __attribute__((always_inline)) ap_fixed_base(half d) { *this = ap_fixed_base(double(d)); }
# 688 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {

    const int _AP_F = _AP_W - _AP_I;
    const int F2 = _AP_W2 - _AP_I2;
    const int QUAN_INC =
          F2 > _AP_F && !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));

    if (!op) Base::V = 0;
    bool carry = false;
    bool signbit = ({ __typeof__(op.V) __Val2__ = op.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    bool isneg = signbit && _AP_S2;
    if (F2 == _AP_F)
      Base::V = op.V;
    else if (F2 > _AP_F) {
      unsigned int sh_amt = F2 - _AP_F;

      if (sh_amt < _AP_W2) {
        Base::V = op.V >> sh_amt;
      } else {
        Base::V = isneg ? -1 : 0;
      }
      if (_AP_Q != AP_TRN && !(_AP_Q == AP_TRN_ZERO && !_AP_S2)) {
        bool qbit = ({ __typeof__(op.V) __Val2__ = op.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), F2 - _AP_F - 1); __Result__; });

        bool qb = (F2 - _AP_F > _AP_W2) ? _AP_S2 && signbit : qbit;
        enum { hi = ((F2 - _AP_F - 2) < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1) };

        bool r = (F2 > _AP_F + 1) ? (({ typename _ap_type::remove_const<__typeof__(op.V)>::type __Result__ = 0; __typeof__(op.V) __Val2__ = op.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, hi); __Result__; }) != 0) : false;
        carry = quantization_adjust(qb, r, isneg);
      }
    } else {
      unsigned sh_amt = _AP_F - F2;

      if (sh_amt < _AP_W) {
        if (_AP_W > _AP_W2) {

          Base::V = op.V;
          Base::V <<= sh_amt;
        } else {

          Base::V = op.V << sh_amt;
        }
      } else {
        Base::V = 0;
      }
    }

    if ((_AP_O != AP_WRAP || _AP_N != 0) &&
        ((!_AP_S && _AP_S2) ||
         _AP_I - _AP_S <
             _AP_I2 - _AP_S2 +
                 (QUAN_INC || (_AP_S2 && _AP_O == AP_SAT_SYM)))) {
      bool deleted_zeros = _AP_S2 ? true : !carry;
      bool deleted_ones = true;
      bool neg_src = isneg;
      bool newsignbit = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
      enum { pos1 = F2 - _AP_F + _AP_W, pos2 = F2 - _AP_F + _AP_W + 1 };
      bool lD = (pos1 < _AP_W2 && pos1 >= 0) ? ({ __typeof__(op.V) __Val2__ = op.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), pos1); __Result__; })
                                             : false;
      if (pos1 < _AP_W2) {
        bool Range1_all_ones = true;
        bool Range1_all_zeros = true;
        bool Range2_all_ones = true;
        ap_int_base<_AP_W2, false> all_ones(-1);

        if (pos2 < _AP_W2 && pos2 >= 0) {
          ap_int_base<_AP_W2, false> Range2;
          Range2.V = ({ typename _ap_type::remove_const<__typeof__(op.V)>::type __Result__ = 0; __typeof__(op.V) __Val2__ = op.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), pos2, _AP_W2 - 1); __Result__; });
          Range2_all_ones = Range2 == (all_ones >> pos2);
        } else if (pos2 < 0) {
          Range2_all_ones = false;
        }

        if (pos1 >= 0 && pos2 < _AP_W2) {
          ap_int_base<_AP_W2, false> Range1;
          Range1.V = ({ typename _ap_type::remove_const<__typeof__(op.V)>::type __Result__ = 0; __typeof__(op.V) __Val2__ = op.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), pos1, _AP_W2 - 1); __Result__; });
          Range1_all_ones = Range1 == (all_ones >> pos1);
          Range1_all_zeros = !Range1.V;
        } else if (pos2 == _AP_W2) {
          Range1_all_ones = lD;
          Range1_all_zeros = !lD;
        } else if (pos1 < 0) {
          Range1_all_zeros = !op.V;
          Range1_all_ones = false;
        }

        deleted_zeros =
            deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);
        deleted_ones =
            carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;
        neg_src = isneg && !(carry && Range1_all_ones);
      } else
        neg_src = isneg && newsignbit;
      bool neg_trg = _AP_S && newsignbit;
      bool overflow = (neg_trg || !deleted_zeros) && !isneg;
      bool underflow = (!neg_trg || !deleted_ones) && neg_src;
      if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)
        underflow |=
            neg_src &&
            (_AP_W > 1 ? ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 2); __Result__; }) == 0
                       : true);

      overflow_adjust(underflow, overflow, lD, neg_src);
    }
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base& operator=(
      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(const_cast<const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(op));
    return *this;
  }


  inline __attribute__((always_inline)) ap_fixed_base& setBits(ap_ulong bv) {

    Base::V = bv;
    return *this;
  }


  static inline __attribute__((always_inline)) ap_fixed_base bitsToFixed(ap_ulong bv) {

    ap_fixed_base t;

    t.V = bv;



    return t;
  }





  inline __attribute__((always_inline)) ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)), _AP_S> to_ap_int_base(
      bool Cnative = true) const {
    ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)), _AP_S> ret;
    if (_AP_I == 0) {
      ret.V = 0;
    } else if (_AP_I > 0 && _AP_I <= _AP_W) {
      ret.V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - _AP_I, _AP_W - 1); __Result__; });
    } else if (_AP_I > _AP_W) {
      ret.V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 1); __Result__; });
      ret.V <<= (_AP_I - _AP_W);
    }
# 848 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
    if (Cnative && _AP_I < _AP_W) {

      if (_AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; }) && (_AP_I < _AP_W) &&
          (({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_I < 0 ? _AP_W - 1 : _AP_W - _AP_I - 1); __Result__; }) != 0))

        ++ret;
    } else {

    }
    return ret;
  };

 public:
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) operator ap_int_base<_AP_W2, _AP_S2>() const {
    return ap_int_base<_AP_W2, _AP_S2>(to_ap_int_base());
  }


  inline __attribute__((always_inline)) char to_char() const { return to_ap_int_base().to_char(); }

  inline __attribute__((always_inline)) int to_int() const { return to_ap_int_base().to_int(); }

  inline __attribute__((always_inline)) unsigned to_uint() const { return to_ap_int_base().to_uint(); }

  inline __attribute__((always_inline)) ap_slong to_int64() const { return to_ap_int_base().to_int64(); }

  inline __attribute__((always_inline)) ap_ulong to_uint64() const { return to_ap_int_base().to_uint64(); }



  inline __attribute__((always_inline)) double to_double() const {




    enum { BITS = 52 + 11 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (11 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 52;

    bool a = (lsb_index >=2) ?
        (({ typename _ap_type::remove_const<__typeof__(tmp.V)>::type __Result__ = 0; __typeof__(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, lsb_index - 2); __Result__; }) != 0) : 0;

    a |= (lsb_index >=0) ? ({ __typeof__(tmp.V) __Val2__ = tmp.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), lsb_index); __Result__; }) : 0;

    ap_ulong m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (ap_ulong)(tmp.V >> (lsb_index - 1))
                           : (ap_ulong)(tmp.V << (1 - lsb_index));
    } else {
      m = (ap_ulong)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;


    if (({ __typeof__(m) __Val2__ = m; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 52 + 1); __Result__; })) {
      e += 1;
    }

    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(s) __Repl2__ = !!s; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), BITS - 1, BITS - 1); __Result__; });

    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(e) __Repl2__ = e; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52 + 11 - 1); __Result__; });


    return rawBitsToDouble(m);
  }



  inline __attribute__((always_inline)) float to_float() const {




    enum { BITS = 23 + 8 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (8 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 23;

    bool a = (lsb_index >=2) ?
        (({ typename _ap_type::remove_const<__typeof__(tmp.V)>::type __Result__ = 0; __typeof__(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, lsb_index - 2); __Result__; }) != 0) : 0;

    a |= (lsb_index >=0) ? ({ __typeof__(tmp.V) __Val2__ = tmp.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), lsb_index); __Result__; }) : 0;

    unsigned long m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (unsigned long)(tmp.V >> (lsb_index - 1))
                           : (unsigned long)(tmp.V << (1 - lsb_index));
    } else {
      m = (unsigned long)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;

    if (({ __typeof__(m) __Val2__ = m; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 23 + 1); __Result__; })) {
      e += 1;
    }

    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(s) __Repl2__ = !!s; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), BITS - 1, BITS - 1); __Result__; });
    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(e) __Repl2__ = e; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 23, 23 + 8 - 1); __Result__; });

    return rawBitsToFloat(m);
  }



  inline __attribute__((always_inline)) half to_half() const {




    enum { BITS = 10 + 5 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (5 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 10;

    bool a = (lsb_index >=2) ?
        (({ typename _ap_type::remove_const<__typeof__(tmp.V)>::type __Result__ = 0; __typeof__(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, lsb_index - 2); __Result__; }) != 0) : 0;

    a |= (lsb_index >=0) ? ({ __typeof__(tmp.V) __Val2__ = tmp.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), lsb_index); __Result__; }) : 0;

    unsigned short m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (unsigned short)(tmp.V >> (lsb_index - 1))
                           : (unsigned short)(tmp.V << (1 - lsb_index));
    } else {
      m = (unsigned short)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;

    if (({ __typeof__(m) __Val2__ = m; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 10 + 1); __Result__; })) {
      e += 1;
    }

    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(s) __Repl2__ = !!s; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), BITS - 1, BITS - 1); __Result__; });
    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(e) __Repl2__ = e; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 10, 10 + 5 - 1); __Result__; });

    return rawBitsToHalf(m);
  }


  inline __attribute__((always_inline)) operator long double() const { return (long double)to_double(); }

  inline __attribute__((always_inline)) operator double() const { return to_double(); }

  inline __attribute__((always_inline)) operator float() const { return to_float(); }

  inline __attribute__((always_inline)) operator half() const { return to_half(); }

  inline __attribute__((always_inline)) operator bool() const { return (bool)Base::V != 0; }

  inline __attribute__((always_inline)) operator char() const { return (char)to_int(); }

  inline __attribute__((always_inline)) operator signed char() const { return (signed char)to_int(); }

  inline __attribute__((always_inline)) operator unsigned char() const { return (unsigned char)to_uint(); }

  inline __attribute__((always_inline)) operator short() const { return (short)to_int(); }

  inline __attribute__((always_inline)) operator unsigned short() const { return (unsigned short)to_uint(); }

  inline __attribute__((always_inline)) operator int() const { return to_int(); }

  inline __attribute__((always_inline)) operator unsigned int() const { return to_uint(); }



  inline __attribute__((always_inline)) operator long() const { return (long)to_int64(); }

  inline __attribute__((always_inline)) operator unsigned long() const { return (unsigned long)to_uint64(); }






  inline __attribute__((always_inline)) operator ap_ulong() const { return to_uint64(); }

  inline __attribute__((always_inline)) operator ap_slong() const { return to_int64(); }

  inline __attribute__((always_inline)) int length() const { return _AP_W; };
# 1074 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
  inline __attribute__((always_inline)) int countLeadingZeros() {


    if (_AP_W <= 32) {
      ap_int_base<32, false> t(-1ULL);
      t.range(_AP_W - 1, 0) = this->range(0, _AP_W - 1);
      return __builtin_ctz(t.V);
    } else if (_AP_W <= 64) {
      ap_int_base<64, false> t(-1ULL);
      t.range(_AP_W - 1, 0) = this->range(0, _AP_W - 1);
      return __builtin_ctzll(t.V);
    } else {
      enum {__N = (_AP_W + 63) / 64};
      int NZeros = 0;
      int i = 0;
      bool hitNonZero = false;
      for (i = 0; i < __N - 1; ++i) {
        ap_int_base<64, false> t;
        t.range(0, 63) = this->range(_AP_W - i * 64 - 64, _AP_W - i * 64 - 1);
        NZeros += hitNonZero ? 0 : __builtin_clzll(t.V);
        hitNonZero |= (t != 0);
      }
      if (!hitNonZero) {
        ap_int_base<64, false> t(-1ULL);
        t.range(63 - (_AP_W - 1) % 64, 63) = this->range(0, (_AP_W - 1) % 64);
        NZeros += __builtin_clzll(t.V);
      }
      return NZeros;
    }



  }



  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::mult operator*(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)
      const {
    typename RType<_AP_W2, _AP_I2, _AP_S2>::mult_base r, t;
    r.V = Base::V;
    t.V = op2.V;
    r.V *= op2.V;
    return r;
  }



  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::div operator/(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)
      const {
    typename RType<_AP_W2, _AP_I2, _AP_S2>::div_base r;
# 1144 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
        ap_fixed_base<_AP_W + ((_AP_W2 - _AP_I2) > (0) ? (_AP_W2 - _AP_I2) : (0)),_AP_I, _AP_S> t(*this);



        r.V = t.V / op2.V;
# 1177 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
    return r;
  }
# 1192 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::plus operator +( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>:: plus_base ret, lhs(*this), rhs(op2); ret.V = lhs.V + rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::minus operator -( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>:: minus_base ret, lhs(*this), rhs(op2); ret.V = lhs.V - rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator &( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>:: logic_base ret, lhs(*this), rhs(op2); ret.V = lhs.V & rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator |( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>:: logic_base ret, lhs(*this), rhs(op2); ret.V = lhs.V | rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator ^( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>:: logic_base ret, lhs(*this), rhs(op2); ret.V = lhs.V ^ rhs.V; return ret; }
# 1210 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator *=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator *(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator /=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator /(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator +=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator +(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator -=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator -(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator &=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator &(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator |=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator |(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator ^=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator ^(op2); return *this; }





  inline __attribute__((always_inline)) ap_fixed_base& operator++() {
    operator+=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));
    return *this;
  }


  inline __attribute__((always_inline)) ap_fixed_base& operator--() {
    operator-=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));
    return *this;
  }


  inline __attribute__((always_inline)) const ap_fixed_base operator++(int) {
    ap_fixed_base r(*this);
    operator++();
    return r;
  }


  inline __attribute__((always_inline)) const ap_fixed_base operator--(int) {
    ap_fixed_base r(*this);
    operator--();
    return r;
  }



  inline __attribute__((always_inline)) ap_fixed_base operator+() { return *this; }

  inline __attribute__((always_inline)) ap_fixed_base<_AP_W + 1, _AP_I + 1, true> operator-() const {
    ap_fixed_base<_AP_W + 1, _AP_I + 1, true> r(*this);
    r.V = -r.V;
    return r;
  }

  inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> getNeg() {
    ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> r(*this);
    r.V = -r.V;
    return r;
  }



  inline __attribute__((always_inline)) bool operator!() const { return Base::V == 0; }




  inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S> operator~() const {
    ap_fixed_base<_AP_W, _AP_I, _AP_S> r;
    r.V = ~Base::V;
    return r;
  }




  template <int _AP_SHIFT>
  inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> lshift() const {
    ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> r;
    r.V = Base::V;
    return r;
  }

  template <int _AP_SHIFT>
  inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> rshift() const {
    ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> r;
    r.V = Base::V;
    return r;
  }





  inline __attribute__((always_inline)) ap_fixed_base operator<<(unsigned int sh) const {
    ap_fixed_base r;
    r.V = Base::V << sh;
# 1328 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
    return r;
  }

  inline __attribute__((always_inline)) ap_fixed_base operator>>(unsigned int sh) const {
    ap_fixed_base r;
    r.V = Base::V >> sh;
# 1350 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
    return r;
  }


  inline __attribute__((always_inline)) ap_fixed_base operator<<(int sh) const {
    ap_fixed_base r;
    bool isNeg = sh < 0;
    unsigned int ush = isNeg ? -sh : sh;
    if (isNeg) {
      return operator>>(ush);
    } else {
      return operator<<(ush);
    }
  }

  inline __attribute__((always_inline)) ap_fixed_base operator>>(int sh) const {
    bool isNeg = sh < 0;
    unsigned int ush = isNeg ? -sh : sh;
    if (isNeg) {
      return operator<<(ush);
    } else {
      return operator>>(ush);
    }
  }


  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_fixed_base operator<<(const ap_int_base<_AP_W2, true>& op2) const {


    int sh = op2.to_int();
    return operator<<(sh);
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_fixed_base operator>>(const ap_int_base<_AP_W2, true>& op2) const {
    int sh = op2.to_int();
    return operator>>(sh);
  }


  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_fixed_base operator<<(const ap_int_base<_AP_W2, false>& op2) const {
    unsigned int sh = op2.to_uint();
    return operator<<(sh);
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_fixed_base operator>>(const ap_int_base<_AP_W2, false>& op2) const {
    unsigned int sh = op2.to_uint();
    return operator>>(sh);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base operator<<(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          op2) {
    return operator<<(op2.to_ap_int_base());
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base operator>>(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          op2) {
    return operator>>(op2.to_ap_int_base());
  }





  inline __attribute__((always_inline)) ap_fixed_base& operator<<=(const int sh) {
    *this = operator<<(sh);
    return *this;
  }

  inline __attribute__((always_inline)) ap_fixed_base& operator<<=(const unsigned int sh) {
    *this = operator<<(sh);
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed_base& operator<<=(const ap_int_base<_AP_W2, _AP_S2>& sh) {
    *this = operator<<(sh.to_int());
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base& operator<<=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          sh) {
    *this = operator<<(sh.to_int());
    return *this;
  }


  inline __attribute__((always_inline)) ap_fixed_base& operator>>=(const int sh) {
    *this = operator>>(sh);
    return *this;
  }

  inline __attribute__((always_inline)) ap_fixed_base& operator>>=(const unsigned int sh) {
    *this = operator>>(sh);
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed_base& operator>>=(const ap_int_base<_AP_W2, _AP_S2>& sh) {
    *this = operator>>(sh.to_int());
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base& operator>>=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          sh) {
    *this = operator>>(sh.to_int());
    return *this;
  }
# 1494 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator >(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V > op2.V; else if (_AP_F > F2) return Base::V > ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V > op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator <(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V < op2.V; else if (_AP_F > F2) return Base::V < ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V < op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator >=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V >= op2.V; else if (_AP_F > F2) return Base::V >= ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V >= op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator <=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V <= op2.V; else if (_AP_F > F2) return Base::V <= ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V <= op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator ==(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V == op2.V; else if (_AP_F > F2) return Base::V == ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V == op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator !=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V != op2.V; else if (_AP_F > F2) return Base::V != ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V != op2.V; return false; }





  inline __attribute__((always_inline)) bool operator >(double d) const { return to_double() > d; }
  inline __attribute__((always_inline)) bool operator <(double d) const { return to_double() < d; }
  inline __attribute__((always_inline)) bool operator >=(double d) const { return to_double() >= d; }
  inline __attribute__((always_inline)) bool operator <=(double d) const { return to_double() <= d; }
  inline __attribute__((always_inline)) bool operator ==(double d) const { return to_double() == d; }
  inline __attribute__((always_inline)) bool operator !=(double d) const { return to_double() != d; }


  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](
      unsigned index) {
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,
                                                                index.to_int());
  }

  inline __attribute__((always_inline)) bool operator[](unsigned index) const {
    (static_cast<void>(0));
    return ({ __typeof__(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index); __Result__; });
  }

  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(
      unsigned index) {
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,
                                                                index.to_int());
  }

  inline __attribute__((always_inline)) bool bit(unsigned index) const {
    (static_cast<void>(0));
    return ({ __typeof__(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index); __Result__; });
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> get_bit(
      const ap_int_base<_AP_W2, true>& index) {
    (static_cast<void>(0));

    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(
        this, index.to_int() + _AP_W - _AP_I);
  }

  inline __attribute__((always_inline)) bool get_bit(int index) const {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ({ __typeof__(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index + _AP_W - _AP_I); __Result__; });

  }
# 1580 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
  template <int _AP_W2>
  inline __attribute__((always_inline)) bool get_bit(const ap_int_base<_AP_W2, true>& index) const {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ({ __typeof__(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index.to_int() + _AP_W - _AP_I); __Result__; });

  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(int Hi,
                                                                      int Lo) {
    (static_cast<void>(0));
    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
  }


  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      int Hi, int Lo) const {
    (static_cast<void>(0));
    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(
        const_cast<ap_fixed_base*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() const {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      int Hi, int Lo) {
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      int Hi, int Lo) const {
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) bool is_zero() const { return Base::V == 0; }

  inline __attribute__((always_inline)) bool is_neg() const {
    if (_AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; })) return true;
    return false;
  }

  inline __attribute__((always_inline)) int wl() const { return _AP_W; }

  inline __attribute__((always_inline)) int iwl() const { return _AP_I; }

  inline __attribute__((always_inline)) ap_q_mode q_mode() const { return _AP_Q; }

  inline __attribute__((always_inline)) ap_o_mode o_mode() const { return _AP_O; }

  inline __attribute__((always_inline)) int n_bits() const { return _AP_N; }
# 1763 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
  inline __attribute__((always_inline)) char* to_string(unsigned char radix = 2, bool sign = _AP_S) const {
    return 0;
  }

};

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) void b_not(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {
  ret.V = ~op.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) void b_and(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V & op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) void b_or(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V | op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) void b_xor(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V ^ op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
inline __attribute__((always_inline)) void neg(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
  ap_fixed_base<_AP_W2 + !_AP_S2, _AP_I2 + !_AP_S2, true, _AP_Q2, _AP_O2,
                _AP_N2>
      t;
  t.V = -op.V;
  ret = t;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
inline __attribute__((always_inline)) void lshift(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
    int i) {
  enum {
    F2 = _AP_W2 - _AP_I2,
    _AP_I3 = ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)),
    _AP_W3 = _AP_I3 + F2,
  };

  ap_fixed_base<_AP_W3, _AP_I3, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t;
  t.V = op.V;
  t.V <<= i;

  ret = t;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
inline __attribute__((always_inline)) void rshift(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
    int i) {
  enum {
    F = _AP_W - _AP_I,
    F2 = _AP_W2 - _AP_I2,
    F3 = ((F) > (F2) ? (F) : (F2)),
    _AP_W3 = _AP_I2 + F3,
    sh = F - F2,
  };

  ap_fixed_base<_AP_W3, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t;
  t.V = op.V;
  if (sh >= 0)
    t.V <<= (int) sh;
  t.V >>= i;

  ret = t;
}
# 2213 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator +(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::plus operator +( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::minus operator -( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::mult operator *( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::div operator /( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator &( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator |( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator ^( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >>(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <<(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator +=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >>=(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <<=(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ==(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator !=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator +(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::plus operator +( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::minus operator -( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::mult operator *( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::div operator /( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator &( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator |( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator ^( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >>(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <<(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >>=(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <<=(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator +(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::plus operator +( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::minus operator -( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::mult operator *( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::div operator /( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator &( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator |( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator ^( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >>(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <<(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >>=(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <<=(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator +(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::plus operator +( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::minus operator -( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::mult operator *( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::div operator /( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator &( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator |( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator ^( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>=(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<=(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::plus operator +( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::minus operator -( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::mult operator *( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::div operator /( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator &( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator |( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator ^( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::plus operator +( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::minus operator -( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::mult operator *( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::div operator /( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator &( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator |( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator ^( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::plus operator +( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::minus operator -( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::mult operator *( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::div operator /( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator &( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator |( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator ^( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::plus operator +( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::minus operator -( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::mult operator *( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::div operator /( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator &( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator |( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator ^( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::plus operator +( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::minus operator -( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::mult operator *( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::div operator /( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator &( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator |( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator ^( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::plus operator +( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::minus operator -( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::mult operator *( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::div operator /( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator &( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator |( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator ^( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::plus operator +( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::minus operator -( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::mult operator *( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::div operator /( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator &( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator |( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator ^( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::plus operator +( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::minus operator -( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::mult operator *( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::div operator /( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator &( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator |( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator ^( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator !=(op); }
# 2301 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::plus operator +( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator +(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::minus operator -( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator -(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::mult operator *( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator *(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::div operator /( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator /(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator &( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator &(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator |( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator |(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator ^( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ^(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }



template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator +=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator +=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator +=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator -=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator -=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator -=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator *=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator *=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator *=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator /=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator /=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator /=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator &=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator &=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator &=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator |=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator |=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator |=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ^=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator ^=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator ^=(op.to_ap_int_base()); }



template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ==(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator ==(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator !=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator >(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator >(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator >=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator >=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator <(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator <(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator <=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator <=(op); }




template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) bool operator==(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator==(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) bool operator!=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator!=(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) bool operator>(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator<(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) bool operator>=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator<=(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) bool operator<(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator>(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) bool operator<=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator>=(op1);
}
# 56 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_ref.h" 1
# 70 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_bit_ref {



  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;
  ref_type& d_bv;
  int d_index;

 public:
  inline __attribute__((always_inline)) af_bit_ref(
      const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {






  }

  inline __attribute__((always_inline)) af_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}

  inline __attribute__((always_inline)) af_bit_ref(const ref_type* bv, int index = 0)
      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}


  inline __attribute__((always_inline)) operator bool() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }



  inline __attribute__((always_inline)) af_bit_ref& operator=(bool val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; });
    return *this;
  }



  inline __attribute__((always_inline)) af_bit_ref& operator=(const af_bit_ref& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    return operator=(val != 0);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=(ap_int_base<_AP_W2, false>(val));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(ap_int_base<_AP_W2, false>(val));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) af_bit_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=(ap_int_base<_AP_W2 + _AP_W3, false>(val));
  }




  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, op);
  }

  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(
      const ap_bit_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(*this,
                                                                        op);
  }

  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(
        *this, op);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                                                                         op);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      1, af_bit_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<
        1, af_bit_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                                                                       op);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                    _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                      _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }




  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator==(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    return get() == op.get();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator!=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    return get() != op.get();
  }


  inline __attribute__((always_inline)) bool operator~() const {
    bool bit = ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; });
    return bit ? false : true;
  }

  inline __attribute__((always_inline)) bool get() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }

  inline __attribute__((always_inline)) int length() const { return 1; }





  inline __attribute__((always_inline)) char* to_string() const { return 0; }

};
# 257 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_range_ref {



  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;
  ref_type& d_bv;
  int l_index;
  int h_index;

 public:

  inline __attribute__((always_inline)) af_range_ref(
      const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}




  inline __attribute__((always_inline)) af_range_ref(ref_type* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {
# 287 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_ref.h"
  }

  inline __attribute__((always_inline)) af_range_ref(const ref_type* bv, int h, int l)
      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {
# 299 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_ref.h"
  }
# 311 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_ref.h"
  inline __attribute__((always_inline)) af_range_ref& operator=(const bool val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const signed char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const unsigned char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const unsigned short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const unsigned int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const unsigned long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_slong val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_ulong val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const half val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const float val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const double val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }



  inline __attribute__((always_inline)) af_range_ref& operator=(const char* val) {
    const ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }



  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    const ap_int_base<_AP_W2, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    const ap_int_base<1, false> tmp((bool)val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }




  inline __attribute__((always_inline)) af_range_ref& operator=(const af_range_ref& val) {
    ap_int_base<_AP_W, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    ap_int_base<_AP_W2, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    ap_int_base<1, false> tmp((bool)val);
    return operator=(tmp);
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) af_range_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    const ap_int_base<_AP_W2 + _AP_W3, false> tmp(val);
    return operator=(tmp);
  }




  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop == rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop < rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop > rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator>(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<(op2));
  }




  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator==(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop == rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator!=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator<(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop < rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator>(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop > rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator<=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator>(op2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator>=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator<(op2));
  }





  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(ap_int_base<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, op);
  }


  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(op));
  }


  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(op));
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(op));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                    af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &op) {
    return ap_concat_ref<
        _AP_W, af_range_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, af_range_ref, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(
          const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<
        _AP_W, af_range_ref, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }


  inline __attribute__((always_inline)) operator ap_ulong() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret.to_uint64();
  }

  inline __attribute__((always_inline)) operator ap_int_base<_AP_W, false>() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> to_ap_int_base() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }


  inline __attribute__((always_inline)) char to_char() const {
    return (char)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) int to_int() const {
    return (int)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) unsigned to_uint() const {
    return (unsigned)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) long to_long() const {
    return (long)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) unsigned long to_ulong() const {
    return (unsigned long)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) ap_slong to_int64() const {
    return (ap_slong)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) ap_ulong to_uint64() const {
    return (ap_ulong)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> get() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W2, false>& val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
  }

  inline __attribute__((always_inline)) int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }
# 633 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_ref.h"
  inline __attribute__((always_inline)) char* to_string(signed char rd = 2) const {
    return 0;
  }

};
# 696 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
# 742 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != ap_int_base<1, false>(op); }
# 57 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed.h" 2





template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_fixed : ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> {
  typedef ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> Base;


  inline __attribute__((always_inline)) ap_fixed() : Base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                      _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                               _AP_O2, _AP_N2>& op)
      : Base(op) {}
# 111 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}
# 145 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_fixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}





  inline __attribute__((always_inline)) ap_fixed(bool v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(char v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(signed char v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(unsigned char v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(short v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(unsigned short v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(int v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(unsigned int v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(long v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(unsigned long v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(ap_slong v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(ap_ulong v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(half v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(float v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(double v) : Base(v) {}


  inline __attribute__((always_inline)) ap_fixed(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) ap_fixed(const char* s, signed char rd) : Base(s, rd) {}






  inline __attribute__((always_inline)) ap_fixed& operator=(
      const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline __attribute__((always_inline)) void operator=(
      const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }

  inline __attribute__((always_inline)) ap_fixed& operator=(
      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline __attribute__((always_inline)) void operator=(
      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }
};





template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_ufixed : ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> {
  typedef ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> Base;


  inline __attribute__((always_inline)) ap_ufixed() : Base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_ufixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                       _AP_O2, _AP_N2>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_ufixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                                _AP_O2, _AP_N2>& op)
      : Base(op) {}
# 276 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_ufixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_ufixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}
# 307 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_ufixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_ufixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_ufixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_ufixed(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_ufixed(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}




  inline __attribute__((always_inline)) ap_ufixed(bool v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(char v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(signed char v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(unsigned char v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(short v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(unsigned short v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(int v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(unsigned int v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(long v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(unsigned long v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(ap_slong v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(ap_ulong v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(half v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(float v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(double v) : Base(v) {}


  inline __attribute__((always_inline)) ap_ufixed(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) ap_ufixed(const char* s, signed char rd) : Base(s, rd) {}


  inline __attribute__((always_inline)) ap_ufixed& operator=(
      const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline __attribute__((always_inline)) void operator=(
      const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }

  inline __attribute__((always_inline)) ap_ufixed& operator=(
      const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline __attribute__((always_inline)) void operator=(const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O,
                                                 _AP_N>& op) volatile {
    Base::V = op.V;
  }
};
# 398 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_special.h" 1
# 61 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_special.h"
namespace std {
template<typename _Tp> class complex;
}







namespace std {
# 89 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
class complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > {
 public:
  typedef ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> _Tp;
  typedef _Tp value_type;




  complex() : _M_real(_Tp()), _M_imag(_Tp()) {}


  complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const _Tp& real() const { return _M_real; }
  const _Tp& imag() const { return _M_imag; }







  void real(_Tp __val) { _M_real = __val; }

  void imag(_Tp __val) { _M_imag = __val; }



  complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  complex<_Tp> &operator=(const complex<_Up> &__z) {
    _M_real = __z.real();
    _M_imag = __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 221 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator==(
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator==(
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator!=(
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator!=(
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}

}
# 399 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_fixed.h" 2
# 368 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 2
# 4 "./src/bn_qrelu2d.h" 2
using namespace hls;

# 1 "./src/function.h" 1

# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 3 "./src/function.h" 2



using namespace std;

# 1 "./src/stream_tools.h" 1


# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 4 "./src/stream_tools.h" 2

using namespace hls;
using namespace std;


struct my_ap_axis {
    ap_uint<64> data;
    ap_uint<1> last;
    ap_uint<8> keep;
};

template <unsigned NumLines>
void AddLast(stream<ap_uint<64>> &in, stream<my_ap_axis> &out,
             const unsigned reps = 1) {
    my_ap_axis temp;
    temp.keep = 0xff;

    for (unsigned i = 0; i < reps * NumLines - 1; i++) {
        temp.data = in.read();
        temp.last = 0;
        out.write(temp);
    }

    temp.data = in.read();
    temp.last = 1;
    out.write(temp);
}

template <unsigned LineWidth, unsigned NumLines>
void Mem2Stream(ap_uint<LineWidth> *in, stream<ap_uint<LineWidth>> &out,
                const unsigned reps = 1) {
    for (unsigned i = 0; i < reps * NumLines; i++) {
        out.write(in[i]);
    }
}

template <unsigned LineWidth, unsigned NumLines>
void Stream2Mem(stream<ap_uint<LineWidth>> &in, ap_uint<LineWidth> *out,
                const unsigned reps = 1) {
    for (unsigned i = 0; i < reps * NumLines; i++) {
        out[i] = in.read();
    }
}

template <unsigned StreamW, unsigned NumLines>
void StreamCopy(stream<ap_uint<StreamW>> &in, stream<ap_uint<StreamW>> &out,
                const unsigned reps = 1) {
    ap_uint<StreamW> temp;

    for (unsigned rep = 0; rep < reps * NumLines; rep++) {
        temp = in.read();
        out.write(temp);
    }
}

template <unsigned OutStreamW, unsigned NumLines>
void ExtractPixels(stream<my_ap_axis> &in, stream<ap_uint<OutStreamW>> &out,
                   const unsigned reps = 1) {
    my_ap_axis temp;

    for (unsigned rep = 0; rep < reps * NumLines; rep++) {
#pragma HLS PIPELINE II = 1
 temp = in.read();
        out.write(temp.data(OutStreamW - 1, 0));
    }
}
template <unsigned InStreamW, unsigned OutStreamW, unsigned NumLines>
void AppendZeros(stream<ap_uint<InStreamW>> &in,
                 stream<ap_uint<OutStreamW>> &out, const unsigned reps = 1) {
    static_assert(InStreamW < OutStreamW,
                  "For AppendZeros in stream is wider than out stream.");

    ap_uint<OutStreamW> buffer;

    for (unsigned rep = 0; rep < reps * NumLines; rep++) {
        buffer(OutStreamW - 1, InStreamW) = 0;
        buffer(InStreamW - 1, 0) = in.read();
        out.write(buffer);
    }
}

template <unsigned InStreamW, unsigned OutStreamW, unsigned NumLines>
void ReduceWidth(stream<ap_uint<InStreamW>> &in,
                 stream<ap_uint<OutStreamW>> &out, const unsigned reps = 1) {
    static_assert(InStreamW % OutStreamW == 0,
                  "For ReduceWidth, InStreamW mod OutStreamW is not 0");

    const unsigned parts = InStreamW / OutStreamW;

    for (unsigned rep = 0; rep < reps * NumLines; rep++) {

        ap_uint<InStreamW> temp_in = in.read();
        for (unsigned p = 0; p < parts; p++) {
#pragma HLS PIPELINE II = 1

 ap_uint<OutStreamW> temp_out = temp_in(OutStreamW - 1, 0);
            out.write(temp_out);
            temp_in = temp_in >> OutStreamW;
        }
    }
}

template <unsigned InStreamW, unsigned OutStreamW, unsigned NumLines>
void ExpandWidth(stream<ap_uint<InStreamW>> &in,
                 stream<ap_uint<OutStreamW>> &out, const unsigned reps = 1) {
    static_assert(OutStreamW % InStreamW == 0,
                  "For ExpandWidth, OutStreamW mod InStreamW is not 0");

    const unsigned parts = OutStreamW / InStreamW;
    ap_uint<OutStreamW> buffer;

    for (unsigned rep = 0; rep < reps * NumLines; rep++) {

        for (unsigned p = 0; p < parts; p++) {
#pragma HLS PIPELINE II = 1
 ap_uint<InStreamW> temp = in.read();
            buffer((p + 1) * InStreamW - 1, p * InStreamW) = temp;
        }
        out.write(buffer);
    }
}





template <unsigned IN_BIT, unsigned OUT_BIT, unsigned IN_NUMS>
void adjust_width(stream<ap_uint<IN_BIT>> &in, stream<ap_uint<OUT_BIT>> &out,
                  const unsigned reps = 1) {
    static_assert(!(IN_BIT > OUT_BIT && IN_BIT % OUT_BIT != 0),
                  "For ReduceWidth, InStreamW mod OutStreamW is not 0");
    static_assert(!(IN_BIT < OUT_BIT && OUT_BIT % IN_BIT != 0),
                  "For ExpandWidth, OutStreamW mod InStreamW is not 0");

    if (IN_BIT > OUT_BIT) {

        const unsigned PARTS = IN_BIT / OUT_BIT;

        for (unsigned rep = 0; rep < reps * IN_NUMS; rep++) {

            ap_uint<IN_BIT> temp_in = in.read();
            for (unsigned p = 0; p < PARTS; p++) {
#pragma HLS PIPELINE II = 1

 ap_uint<OUT_BIT> temp_out = temp_in(OUT_BIT - 1, 0);
                out.write(temp_out);
                temp_in = temp_in >> OUT_BIT;
            }
        }

    } else if (IN_BIT == OUT_BIT) {


        for (unsigned int i = 0; i < IN_NUMS * reps; i++) {
#pragma HLS PIPELINE II = 1
 ap_uint<IN_BIT> e = in.read();
            out.write(e);
        }
    } else {

        const unsigned PARTS = OUT_BIT / IN_BIT;
        const unsigned OUT_NUMS = IN_NUMS / PARTS;
        ap_uint<OUT_BIT> buffer;

        for (unsigned rep = 0; rep < reps * OUT_NUMS; rep++) {

            for (unsigned p = 0; p < PARTS; p++) {
#pragma HLS PIPELINE II = 1
 ap_uint<IN_BIT> temp = in.read();
                buffer((p + 1) * IN_BIT - 1, p * IN_BIT) = temp;
            }
            out.write(buffer);
        }
    }
}
template <unsigned int InWidth,
          unsigned int OutWidth,
          unsigned int NumInWords
          >
void StreamingDataWidthConverter_Batch(hls::stream<ap_uint<InWidth>> &in,
                                       hls::stream<ap_uint<OutWidth>> &out,
                                       const unsigned int numReps) {
    if (InWidth > OutWidth) {


        const unsigned int outPerIn = InWidth / OutWidth;
        const unsigned int totalIters = NumInWords * outPerIn * numReps;
        unsigned int o = 0;
        ap_uint<InWidth> ei = 0;
        for (unsigned int t = 0; t < totalIters; t++) {
#pragma HLS PIPELINE II = 1

 if (o == 0) {
                ei = in.read();
            }

            ap_uint<OutWidth> eo = ei(OutWidth - 1, 0);
            out.write(eo);

            ei = ei >> OutWidth;

            o++;

            if (o == outPerIn) {
                o = 0;
            }
        }
    } else if (InWidth == OutWidth) {

        for (unsigned int i = 0; i < NumInWords * numReps; i++) {
#pragma HLS PIPELINE II = 1
 ap_uint<InWidth> e = in.read();
            out.write(e);
        }
    } else {


        const unsigned int inPerOut = OutWidth / InWidth;
        const unsigned int totalIters = NumInWords * numReps;
        unsigned int i = 0;
        ap_uint<OutWidth> eo = 0;
        for (unsigned int t = 0; t < totalIters; t++) {
#pragma HLS PIPELINE II = 1

 ap_uint<InWidth> ei = in.read();
            eo = eo >> InWidth;
            eo(OutWidth - 1, OutWidth - InWidth) = ei;

            i++;

            if (i == inPerOut) {
                i = 0;
                out.write(eo);
            }
        }
    }
}




template <unsigned IN_BIT>
void append_zero(stream<ap_uint<IN_BIT>> &in, const unsigned n) {
    for (int i = 0; i < n; i++) {
#pragma HLS PIPELINE II = 1
 in.write(0);
    }
}



template <unsigned IN_BIT>
void stream_move(stream<ap_uint<IN_BIT>> &in, stream<ap_uint<IN_BIT>> &out,
                 const unsigned n) {
    for (int i = 0; i < n; i++) {
#pragma HLS PIPELINE II = 1
 ap_uint<IN_BIT> temp = in.read();
        out.write(temp);
    }
}





template <unsigned BIT, unsigned NumLines>
void demux_stream3(stream<ap_uint<BIT>> &in, stream<ap_uint<BIT>> &out1,
                   stream<ap_uint<BIT>> &out2, stream<ap_uint<BIT>> &out3,
                   const unsigned short which, const unsigned reps = 1) {
    for (unsigned i = 0; i < NumLines * reps; i++) {
#pragma HLS PIPELINE II = 1
 ap_uint<BIT> temp = in.read();
        if (which == 0)
            out1.write(temp);
        else if (which == 1)
            out2.write(temp);
        else
            out3.write(temp);
    }
}






template <unsigned IN_BIT, unsigned OUT_BIT>
void adjust_width_var(stream<ap_uint<IN_BIT>> &in,
                      stream<ap_uint<OUT_BIT>> &out, const unsigned in_nums,
                      const unsigned reps = 1) {
    static_assert(!(IN_BIT > OUT_BIT && IN_BIT % OUT_BIT != 0),
                  "For ReduceWidth, InStreamW mod OutStreamW is not 0");
    static_assert(!(IN_BIT < OUT_BIT && OUT_BIT % IN_BIT != 0),
                  "For ExpandWidth, OutStreamW mod InStreamW is not 0");

    if (IN_BIT > OUT_BIT) {

        const unsigned PARTS = IN_BIT / OUT_BIT;

        for (unsigned rep = 0; rep < reps * in_nums; rep++) {

            ap_uint<IN_BIT> temp_in = in.read();
            for (unsigned p = 0; p < PARTS; p++) {
#pragma HLS PIPELINE II = 1

 ap_uint<OUT_BIT> temp_out = temp_in(OUT_BIT - 1, 0);
                out.write(temp_out);
                temp_in = temp_in >> OUT_BIT;
            }
        }

    } else if (IN_BIT == OUT_BIT) {


        for (unsigned int i = 0; i < in_nums * reps; i++) {
#pragma HLS PIPELINE II = 1
 ap_uint<IN_BIT> e = in.read();
            out.write(e);
        }
    } else {

        const unsigned PARTS = OUT_BIT / IN_BIT;
        const unsigned out_nums = in_nums / PARTS;
        ap_uint<OUT_BIT> buffer;

        for (unsigned rep = 0; rep < reps * out_nums; rep++) {

            for (unsigned p = 0; p < PARTS; p++) {
#pragma HLS PIPELINE II = 1
 ap_uint<IN_BIT> temp = in.read();
                buffer((p + 1) * IN_BIT - 1, p * IN_BIT) = temp;
            }
            out.write(buffer);
        }
    }
}






template <unsigned IN_BIT, unsigned OUT0_BIT, unsigned OUT1_BIT>
void demux_stream1to2_adj(stream<ap_uint<IN_BIT>> &in,
                          stream<ap_uint<OUT0_BIT>> &out0,
                          stream<ap_uint<OUT1_BIT>> &out1,
                          const unsigned short which, const unsigned in_nums,
                          const unsigned reps = 1) {
    if (which == 0) {
        adjust_width_var<IN_BIT, OUT0_BIT>(in, out0, in_nums, reps);
    } else {
        adjust_width_var<IN_BIT, OUT1_BIT>(in, out1, in_nums, reps);
    }
}





template <unsigned IN0_BIT, unsigned IN1_BIT, unsigned OUT_BIT>
void demux_stream2to1_adj(stream<ap_uint<IN0_BIT>> &in0,
                          stream<ap_uint<IN1_BIT>> &in1,
                          stream<ap_uint<OUT_BIT>> &out,
                          const unsigned short which, const unsigned in0_nums,
                          const unsigned in1_nums, const unsigned reps = 1) {
    if (which == 0) {
        adjust_width_var<IN0_BIT, OUT_BIT>(in0, out, in0_nums, reps);
    } else {
        adjust_width_var<IN1_BIT, OUT_BIT>(in1, out, in1_nums, reps);
    }
}




template <unsigned int BIT>
void mem_to_stream(ap_uint<BIT> *in, stream<ap_uint<BIT>> &out,
                   const unsigned nums_per_rep, const unsigned reps) {
    for (unsigned int rep = 0; rep < reps; rep++) {
        for (unsigned int i = 0; i < nums_per_rep; i++) {
#pragma HLS PIPELINE II = 1
 ap_uint<BIT> e = in[i];
            out.write(e);
        }
    }
}




template <unsigned int BIT>
void stream_to_mem(stream<ap_uint<BIT>> &in, ap_uint<BIT> *out,
                   const unsigned nums_per_rep, const unsigned reps) {
    for (unsigned int rep = 0; rep < reps; rep++) {
        for (unsigned int i = 0; i < nums_per_rep; i++) {
#pragma HLS PIPELINE II = 1
 ap_uint<BIT> e = in.read();
            out[i] = e;
        }
    }
}

template <unsigned BIT>
void in_to_stream(stream<my_ap_axis> &in, stream<ap_uint<BIT>> &out,
                  const unsigned nums = 1) {
    my_ap_axis temp;
    for (unsigned num = 0; num < nums; num++) {
        temp = in.read();
        out.write(temp.data(BIT - 1, 0));
    }
}

template <unsigned BIT>
void stream_to_out(stream<ap_uint<BIT>> &in, stream<my_ap_axis> &out,
                   const unsigned nums = 1) {
    my_ap_axis temp;
    temp.keep = "0xffffffffffffffff";

    for (unsigned i = 0; i < nums - 1; i++) {
#pragma HLS PIPELINE II = 1
 temp.data = in.read();
        temp.last = 0;
        out.write(temp);
    }

    temp.data = in.read();
    temp.last = 1;
    out.write(temp);
}
# 8 "./src/function.h" 2
# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     noexcept (true) __attribute__ ((__noreturn__));


}
# 9 "./src/function.h" 2






template <unsigned IN_BIT, unsigned SIMD, unsigned P>
void padding_var(

    stream<ap_uint<IN_BIT * SIMD>> &in, stream<ap_uint<IN_BIT * SIMD>> &out,
    const unsigned in_row,
    const unsigned in_col,
    const unsigned in_simd_pre_ch,
    const unsigned reps = 1) {

  const unsigned OUT_COL = in_col + 2 * P;


  for (unsigned rep = 0; rep < reps; rep++) {

    for (unsigned h = 0; h < P; h++) {
      for (unsigned s = 0; s < OUT_COL; s++) {

        append_zero<IN_BIT * SIMD>(out, in_simd_pre_ch);
      }
    }

    for (unsigned h = 0; h < in_row; h++) {

      for (unsigned s = 0; s < OUT_COL; s++) {


        if ((s < P) || (s >= OUT_COL - P)) {

          append_zero<IN_BIT * SIMD>(out, in_simd_pre_ch);
        } else {

          stream_move<IN_BIT * SIMD>(in, out, in_simd_pre_ch);
        }

      }
    }

    for (unsigned h = 0; h < P; h++) {
      for (unsigned i = 0; i < OUT_COL; i++) {
        append_zero<IN_BIT * SIMD>(out, in_simd_pre_ch);
      }
    }
  }
}




template <unsigned IN_ROW, unsigned IN_COL, unsigned IN_CH, unsigned IN_BIT,
          unsigned P>
void padding(

    stream<ap_uint<IN_CH * IN_BIT>> &in, stream<ap_uint<IN_CH * IN_BIT>> &out,
    const unsigned reps = 1) {
  const unsigned OUT_ROW = IN_ROW + 2 * P;
  const unsigned OUT_COL = IN_COL + 2 * P;

  ap_uint<IN_CH *IN_BIT> temp_out = 0;

  for (unsigned rep = 0; rep < reps; rep++) {

    for (unsigned h = 0; h < P; h++) {
      for (unsigned s = 0; s < OUT_COL; s++) {
        out.write(0);
      }
    }

    for (unsigned h = 0; h < IN_ROW; h++) {

      for (unsigned s = 0; s < OUT_COL; s++) {
#pragma HLS PIPELINE II = 1

 if ((s < P) || (s >= OUT_COL - P)) {
          temp_out = 0;
        } else {
          temp_out = in.read();
        }

        out.write(temp_out);
      }
    }

    for (unsigned h = 0; h < P; h++) {
      for (unsigned i = 0; i < OUT_COL; i++) {
        out.write(0);
      }
    }
  }
}
# 153 "./src/function.h"
template <unsigned IN_BIT, unsigned OUT_BIT, unsigned INC_BIT,
          unsigned BIAS_BIT,

          unsigned DATA_BIT, unsigned W_BIT, unsigned L_SHIFT>
ap_uint<OUT_BIT> bn_qurelu(ap_int<IN_BIT> in, ap_int<INC_BIT> inc,
                           ap_int<BIAS_BIT> bias) {

  const unsigned D = 1 << (W_BIT - 1 + DATA_BIT + L_SHIFT);

  ap_int<IN_BIT> bn_res = in * inc + bias;
  ap_uint<OUT_BIT> res;

  if (bn_res > 0) {
    bn_res = (bn_res + (D >> 1)) >> (W_BIT - 1 + DATA_BIT + L_SHIFT);
    if (bn_res > 15) {
      res = 15;
    } else {
      res = bn_res;
    }
  } else {
    res = 0;
  }
  return res;
}

template <unsigned IN_BIT, unsigned OUT_BIT, unsigned INC_BIT,
          unsigned BIAS_BIT,

          unsigned DATA_BIT, unsigned W_BIT, unsigned L_SHIFT>
ap_uint<OUT_BIT> bn_qurelu_fixed(ap_int<IN_BIT> in, ap_int<INC_BIT> inc,
                                 ap_int<BIAS_BIT> bias) {

  const unsigned D = 1 << (W_BIT - 1 + DATA_BIT + L_SHIFT);

  ap_int<IN_BIT + INC_BIT + 1> bn_res = in * inc + bias;
  ap_uint<OUT_BIT> res;

  if (bn_res > 0) {
    bn_res = (bn_res + (D >> 1)) >> (W_BIT - 1 + DATA_BIT + L_SHIFT);
    if (bn_res > 15) {
      res = 15;
    } else {
      res = bn_res;
    }
  } else {
    res = 0;
  }
  return res;
}
# 6 "./src/bn_qrelu2d.h" 2





template < unsigned IN_ROW,
            unsigned IN_COL,
            unsigned IN_CH,

            unsigned IN_BIT,
   unsigned OUT_BIT,
   unsigned INC_BIT,
   unsigned BIAS_BIT,
            unsigned PE>
void bn_qrelu2d(
    stream<ap_uint<IN_CH*IN_BIT> >& in,
    const ap_uint<INC_BIT> inc[PE][IN_CH/PE],
 const ap_int<BIAS_BIT> bias[PE][IN_CH/PE],
 stream<ap_uint<OUT_BIT> >& out,
 const unsigned reps = 1) {

    hls::stream<ap_uint<IN_BIT>> adj_out("adj_out");
    adjust_width<IN_CH*IN_BIT, IN_BIT, IN_ROW*IN_COL>(in, adj_out, reps);

    unsigned pe = 0;
    unsigned f = 0;
    for(unsigned rep=0; rep < IN_ROW*IN_COL*IN_CH*reps; rep ++) {
        ap_int<IN_BIT> in_elem = adj_out.read();
        ap_uint<OUT_BIT> out_elem = bn_qurelu<IN_BIT, OUT_BIT, INC_BIT, BIAS_BIT>(in_elem, inc[pe][f], bias[pe][f]);
        out.write(out_elem);

        if(++ pe == PE) {
            pe = 0;
            if(++ f == IN_CH/PE) {
                f = 0;
            }
        }
    }
}
# 10 "./src/ultranet.cpp" 2
# 1 "./src/config.h" 1
# 11 "./src/ultranet.cpp" 2
# 1 "./src/conv1x1DSP2.hpp" 1



# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 5 "./src/conv1x1DSP2.hpp" 2

using namespace hls;




# 1 "./src/matrix_vector_unit.h" 1


# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 4 "./src/matrix_vector_unit.h" 2

using namespace hls;






template <unsigned W_BIT, unsigned IN_BIT, unsigned M_BIT, unsigned SIMD>
ap_int<M_BIT> simd_mul_lut(ap_uint<SIMD * W_BIT> weights,
                           ap_uint<SIMD * IN_BIT> in) {
  ap_int<M_BIT> accumulation = 0;

  for (unsigned p = 0; p < SIMD; p++) {
#pragma HLS UNROLL
 ap_int<W_BIT> temp_w = weights((p + 1) * W_BIT - 1, p * W_BIT);
    ap_uint<IN_BIT> temp_in = in((p + 1) * IN_BIT - 1, p * IN_BIT);
    ap_int<W_BIT + IN_BIT> result = temp_w * temp_in;
#pragma HLS RESOURCE variable = &result core = Mul_LUT
 accumulation += result;
  }
  return accumulation;
}





template <unsigned W_BIT, unsigned IN_BIT, unsigned M_BIT, unsigned SIMD>
ap_int<M_BIT> simd_mul(ap_uint<SIMD * W_BIT> weights,
                       ap_uint<SIMD * IN_BIT> in) {
  ap_int<M_BIT> accumulation = 0;

  for (unsigned p = 0; p < SIMD; p++) {
#pragma HLS UNROLL
 ap_int<W_BIT> temp_w = weights((p + 1) * W_BIT - 1, p * W_BIT);
    ap_uint<IN_BIT> temp_in = in((p + 1) * IN_BIT - 1, p * IN_BIT);
    ap_int<W_BIT + IN_BIT> result = temp_w * temp_in;

    accumulation += result;
  }
  return accumulation;
}





template <unsigned MAT_ROW,
          unsigned MAT_COL,
          unsigned IN_BIT, unsigned W_BIT,
          unsigned M_BIT,
          unsigned SIMD, unsigned PE, unsigned VECT_NUMS>
void matrix_vector_unit(
    stream<ap_uint<SIMD * IN_BIT>> &vec,
    const ap_uint<SIMD * W_BIT> weights[PE][(MAT_ROW / SIMD) * (MAT_COL / PE)],
    stream<ap_uint<PE * M_BIT>> &out, const unsigned reps = 1) {
  static_assert(MAT_ROW % SIMD == 0, "MAT_ROW mod SIMD is not 0");
  static_assert(MAT_COL % PE == 0, "MAT_COL mod PE is not 0");

  const unsigned INPUT_FOLD = MAT_ROW / SIMD;
  const unsigned OUTPUT_FOLD = MAT_COL / PE;

  const unsigned total_reps = INPUT_FOLD * OUTPUT_FOLD * VECT_NUMS * reps;


  ap_uint<SIMD * IN_BIT> row_store[INPUT_FOLD];
#pragma HLS RESOURCE variable = &row_store core = RAM_2P_BRAM




 unsigned in_fold_cnt = 0;
  unsigned out_fold_cnt = 0;
  unsigned tile = 0;


  ap_uint<SIMD * IN_BIT> temp_vec;



  ap_int<M_BIT> acc[PE];
# 99 "./src/matrix_vector_unit.h"
  for (unsigned rep = 0; rep < total_reps; rep++) {
#pragma HLS PIPELINE II = 1



 if (out_fold_cnt == 0) {
      temp_vec = vec.read();
      row_store[in_fold_cnt] = temp_vec;
    } else {
      temp_vec = row_store[in_fold_cnt];
    }




    if (in_fold_cnt == 0) {
      for (unsigned p = 0; p < PE; p++) {
#pragma HLS UNROLL
 acc[p] = 0;
      }
    }



    for (unsigned p = 0; p < PE; p++) {
#pragma HLS UNROLL

 ap_uint<SIMD *W_BIT> temp_mat = weights[p][tile];

      acc[p] += simd_mul<W_BIT, IN_BIT, M_BIT, SIMD>(temp_mat, temp_vec);
    }


    tile++;
    if (++in_fold_cnt == INPUT_FOLD) {
      in_fold_cnt = 0;
      ap_uint<PE * M_BIT> out_buf;

      for (unsigned p = 0; p < PE; p++) {
#pragma HLS UNROLL
 out_buf((p + 1) * M_BIT - 1, p * M_BIT) = acc[p];

      }
      out.write(out_buf);

      if (++out_fold_cnt == OUTPUT_FOLD) {
        out_fold_cnt = 0;
        tile = 0;
      }
    }
  }
}





template <unsigned MAT_ROW,
          unsigned MAT_COL,

          unsigned IN_BIT,
          unsigned OUT_BIT,

          unsigned W_BIT,
          unsigned M_BIT,

          unsigned INC_BIT,
          unsigned BIAS_BIT,

          unsigned SIMD, unsigned PE, unsigned L_SHIFT, unsigned VECT_NUMS>
void matrix_vector_act_unit(
    stream<ap_uint<SIMD * IN_BIT>> &vec,
    const ap_uint<SIMD * W_BIT> weights[PE][(MAT_ROW / SIMD) * (MAT_COL / PE)],
    const ap_int<INC_BIT> inc[PE][MAT_COL / PE],
    const ap_int<BIAS_BIT> bias[PE][MAT_COL / PE],

    stream<ap_uint<PE * OUT_BIT>> &out, const unsigned reps = 1) {
  static_assert(MAT_ROW % SIMD == 0, "MAT_ROW mod SIMD is not 0");
  static_assert(MAT_COL % PE == 0, "MAT_COL mod PE is not 0");

  const unsigned INPUT_FOLD = MAT_ROW / SIMD;
  const unsigned OUTPUT_FOLD = MAT_COL / PE;

  const unsigned total_reps = INPUT_FOLD * OUTPUT_FOLD * VECT_NUMS * reps;


  ap_uint<SIMD * IN_BIT> row_store[INPUT_FOLD];
#pragma HLS RESOURCE variable = &row_store core = RAM_2P_BRAM




 unsigned in_fold_cnt = 0;
  unsigned out_fold_cnt = 0;
  unsigned tile = 0;


  ap_uint<SIMD * IN_BIT> temp_vec;

  ap_int<M_BIT> acc[PE];


  for (unsigned rep = 0; rep < total_reps; rep++) {
#pragma HLS PIPELINE II = 1



 if (out_fold_cnt == 0) {
      temp_vec = vec.read();
      row_store[in_fold_cnt] = temp_vec;
    } else {
      temp_vec = row_store[in_fold_cnt];
    }




    if (in_fold_cnt == 0) {
      for (unsigned p = 0; p < PE; p++) {
#pragma HLS UNROLL
 acc[p] = 0;
      }
    }



    for (unsigned p = 0; p < PE; p++) {
#pragma HLS UNROLL

 ap_uint<SIMD *W_BIT> temp_mat = weights[p][tile];

      acc[p] += simd_mul<W_BIT, IN_BIT, M_BIT, SIMD>(temp_mat, temp_vec);



    }


    tile++;
    if (++in_fold_cnt == INPUT_FOLD) {
      in_fold_cnt = 0;
      ap_uint<PE * OUT_BIT> out_buf;


      for (unsigned p = 0; p < PE; p++) {
#pragma HLS UNROLL
 out_buf((p + 1) * OUT_BIT - 1, p * OUT_BIT) =
            bn_qurelu<M_BIT, OUT_BIT, INC_BIT, BIAS_BIT, IN_BIT, W_BIT,
                      L_SHIFT>(acc[p], inc[p][out_fold_cnt],
                               bias[p][out_fold_cnt]);




      }
      out.write(out_buf);

      if (++out_fold_cnt == OUTPUT_FOLD) {
        out_fold_cnt = 0;
        tile = 0;
      }
    }
  }
}






template <unsigned MAT_ROW,
          unsigned MAT_COL,
          unsigned IN_BIT, unsigned W_BIT,
          unsigned M_BIT,
          unsigned SIMD, unsigned PE, unsigned VECT_NUMS>
void matrix_vector_unit_lut(
    stream<ap_uint<SIMD * IN_BIT>> &vec,
    const ap_uint<SIMD * W_BIT> weights[PE][(MAT_ROW / SIMD) * (MAT_COL / PE)],
    stream<ap_uint<PE * M_BIT>> &out, const unsigned reps = 1) {
  static_assert(MAT_ROW % SIMD == 0, "MAT_ROW mod SIMD is not 0");
  static_assert(MAT_COL % PE == 0, "MAT_COL mod PE is not 0");

  const unsigned INPUT_FOLD = MAT_ROW / SIMD;
  const unsigned OUTPUT_FOLD = MAT_COL / PE;

  const unsigned total_reps = INPUT_FOLD * OUTPUT_FOLD * VECT_NUMS * reps;


  ap_uint<SIMD * IN_BIT> row_store[INPUT_FOLD];
#pragma HLS RESOURCE variable = &row_store core = RAM_2P_BRAM




 unsigned in_fold_cnt = 0;
  unsigned out_fold_cnt = 0;
  unsigned tile = 0;


  ap_uint<SIMD * IN_BIT> temp_vec;



  ap_int<M_BIT> acc[PE];
# 316 "./src/matrix_vector_unit.h"
  for (unsigned rep = 0; rep < total_reps; rep++) {
#pragma HLS PIPELINE II = 1



 if (out_fold_cnt == 0) {
      temp_vec = vec.read();
      row_store[in_fold_cnt] = temp_vec;
    } else {
      temp_vec = row_store[in_fold_cnt];
    }




    if (in_fold_cnt == 0) {
      for (unsigned p = 0; p < PE; p++) {
#pragma HLS UNROLL
 acc[p] = 0;
      }
    }



    for (unsigned p = 0; p < PE; p++) {
#pragma HLS UNROLL

 ap_uint<SIMD *W_BIT> temp_mat = weights[p][tile];

      acc[p] += simd_mul_lut<W_BIT, IN_BIT, M_BIT, SIMD>(temp_mat, temp_vec);
    }


    tile++;
    if (++in_fold_cnt == INPUT_FOLD) {
      in_fold_cnt = 0;
      ap_uint<PE * M_BIT> out_buf;

      for (unsigned p = 0; p < PE; p++) {
#pragma HLS UNROLL
 out_buf((p + 1) * M_BIT - 1, p * M_BIT) = acc[p];

      }
      out.write(out_buf);

      if (++out_fold_cnt == OUTPUT_FOLD) {
        out_fold_cnt = 0;
        tile = 0;
      }
    }
  }
}






template <unsigned MAT_ROW,
          unsigned MAT_COL,

          unsigned IN_BIT,
          unsigned OUT_BIT,

          unsigned W_BIT,
          unsigned M_BIT,

          unsigned INC_BIT,
          unsigned BIAS_BIT,

          unsigned SIMD, unsigned PE, unsigned L_SHIFT, unsigned VECT_NUMS>
void matrix_vector_act_unit_lut(
    stream<ap_uint<SIMD * IN_BIT>> &vec,
    const ap_uint<SIMD * W_BIT> weights[PE][(MAT_ROW / SIMD) * (MAT_COL / PE)],
    const ap_uint<INC_BIT> inc[PE][MAT_COL / PE],
    const ap_int<BIAS_BIT> bias[PE][MAT_COL / PE],
    stream<ap_uint<PE * OUT_BIT>> &out, const unsigned reps = 1) {
  static_assert(MAT_ROW % SIMD == 0, "MAT_ROW mod SIMD is not 0");
  static_assert(MAT_COL % PE == 0, "MAT_COL mod PE is not 0");

  const unsigned INPUT_FOLD = MAT_ROW / SIMD;
  const unsigned OUTPUT_FOLD = MAT_COL / PE;

  const unsigned total_reps = INPUT_FOLD * OUTPUT_FOLD * VECT_NUMS * reps;


  ap_uint<SIMD * IN_BIT> row_store[INPUT_FOLD];
#pragma HLS RESOURCE variable = &row_store core = RAM_2P_BRAM




 unsigned in_fold_cnt = 0;
  unsigned out_fold_cnt = 0;
  unsigned tile = 0;


  ap_uint<SIMD * IN_BIT> temp_vec;

  ap_int<M_BIT> acc[PE];


  for (unsigned rep = 0; rep < total_reps; rep++) {
#pragma HLS PIPELINE II = 1



 if (out_fold_cnt == 0) {
      temp_vec = vec.read();
      row_store[in_fold_cnt] = temp_vec;
    } else {
      temp_vec = row_store[in_fold_cnt];
    }




    if (in_fold_cnt == 0) {
      for (unsigned p = 0; p < PE; p++) {
#pragma HLS UNROLL
 acc[p] = 0;
      }
    }



    for (unsigned p = 0; p < PE; p++) {
#pragma HLS UNROLL

 ap_uint<SIMD *W_BIT> temp_mat = weights[p][tile];

      acc[p] += simd_mul_lut<W_BIT, IN_BIT, M_BIT, SIMD>(temp_mat, temp_vec);
    }


    tile++;
    if (++in_fold_cnt == INPUT_FOLD) {
      in_fold_cnt = 0;
      ap_uint<PE * M_BIT> out_buf;

      for (unsigned p = 0; p < PE; p++) {
#pragma HLS UNROLL
 out_buf((p + 1) * OUT_BIT - 1, p * OUT_BIT) =
            bn_qurelu<M_BIT, OUT_BIT, INC_BIT, BIAS_BIT, IN_BIT, W_BIT,
                      L_SHIFT>(acc[p], inc[p][out_fold_cnt],
                               bias[p][out_fold_cnt]);



      }
      out.write(out_buf);

      if (++out_fold_cnt == OUTPUT_FOLD) {
        out_fold_cnt = 0;
        tile = 0;
      }
    }
  }
}
# 11 "./src/conv1x1DSP2.hpp" 2
# 1 "./src/sliding_window_unit.h" 1


# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 4 "./src/sliding_window_unit.h" 2

using namespace hls;


template <unsigned K, unsigned S, unsigned Din_H, unsigned Din_W, unsigned Cin,
          unsigned Ibit>
void SWU(stream<ap_uint<Cin * Ibit>> &in, stream<ap_uint<Cin * Ibit>> &out,
         const unsigned reps = 1) {
  static_assert((Din_W - K) % S == 0, "(Din_W-K) mod S is not 0");
  static_assert((Din_H - K) % S == 0, "(Din_H-K) mod S is not 0");
  static_assert(K >= S, "K is not >= than S");

  const unsigned steps = (Din_W - K) / S + 1;
  const unsigned line_buffer_size = K * Din_W;





  ap_uint<Cin * Ibit> line_buffer[line_buffer_size];
#pragma HLS RESOURCE variable line_buffer core = RAM_2P

 ap_uint<Cin * Ibit> temp_in;

  ap_uint<1> initial_fill = 0;
  unsigned stride = 0;
  unsigned pointer = 0;
  unsigned h = 0;

  for (unsigned rep = 0; rep < reps * Din_H; rep++) {

    if (h == Din_H) {
      initial_fill = 0;
      stride = 0;
      pointer = 0;
      h = 0;
    }
    h += 1;





    for (unsigned w = 0; w < Din_W; w++) {
#pragma HLS PIPELINE II = 1
 temp_in = in.read();

      unsigned line_buffer_pointer = pointer + w;
      if (line_buffer_pointer >= line_buffer_size) {
        line_buffer_pointer = line_buffer_pointer - line_buffer_size;
      }



      line_buffer[line_buffer_pointer] = temp_in;
    }

    stride += 1;
    pointer += Din_W;
    if (pointer >= line_buffer_size) {
      pointer = pointer - line_buffer_size;
      initial_fill = 1;



    }
# 80 "./src/sliding_window_unit.h"
    if (initial_fill == 1 && stride >= S) {
      stride = 0;

      unsigned s = 0;
      unsigned x = 0;
      unsigned y = 0;

      for (unsigned i = 0; i < steps * (K * K); i++) {
#pragma HLS PIPELINE II = 1
 unsigned read_address = (pointer + s * S) + y * Din_W + x;

        if (read_address >= line_buffer_size)
          read_address = read_address - line_buffer_size;



        ap_uint<Cin *Ibit> temp_out = line_buffer[read_address];
        out.write(temp_out);

        if (x == K - 1) {
          x = 0;
          if (y == K - 1) {
            y = 0;
            if (s == steps - 1)
              s = 0;
            else
              s++;
          } else
            y++;
        } else
          x++;
      }
    }
  }
}

template <unsigned K, unsigned S, unsigned IN_ROW, unsigned IN_COL,
          unsigned IN_CH, unsigned IN_BIT>
void sliding_window_unit(stream<ap_uint<IN_CH * IN_BIT>> &in,
                         stream<ap_uint<IN_CH * IN_BIT>> &out,
                         const unsigned reps = 1) {
  static_assert((IN_ROW - K) % S == 0, "(IN_ROW-K) mod S is not 0");
  static_assert((IN_COL - K) % S == 0, "(IN_COL-K) mod S is not 0");
  static_assert(K >= S, "K is not >= than S");


  const unsigned ROW_STEPS = (IN_ROW - K) / S + 1;

  const unsigned COL_STEPS = (IN_COL - K) / S + 1;






  const unsigned BUF_SIZE = (K - 1) * IN_COL + K;
  ap_uint<IN_CH * IN_BIT> line_buffer[BUF_SIZE];
#pragma HLS RESOURCE variable line_buffer core = RAM_2P
 unsigned buf_len = 0;
  unsigned buf_pointer = 0;
  ap_uint<IN_CH * IN_BIT> temp_in;


  unsigned right_slid = 0;
  unsigned down_slid = 0;

  for (unsigned rep = 0; rep < IN_ROW * IN_COL * reps; rep++) {


    if (buf_len < BUF_SIZE) {

      temp_in = in.read();
      line_buffer[buf_pointer++] = temp_in;
      if (buf_pointer == BUF_SIZE) {
        buf_pointer = 0;
      }
      buf_len++;
    }


    if (buf_len == BUF_SIZE) {




      for (unsigned i = 0; i < K; i++) {
        for (unsigned j = 0; j < K; j++) {

          unsigned temp_pointer = (buf_pointer + (i * IN_COL) + j);

          if (temp_pointer > BUF_SIZE) {
            temp_pointer -= BUF_SIZE;
          }

          ap_uint<IN_CH *IN_BIT> temp_out = line_buffer[temp_pointer];
          out.write(temp_out);
        }
      }


      if (++right_slid == COL_STEPS) {
        right_slid = 0;

        if (++down_slid == ROW_STEPS) {
          down_slid = 0;

          buf_len = 0;
        } else {

          buf_len = buf_len - (S - 1) * IN_COL - K;
        }
      } else {


        buf_len -= S;
      }
    }
  }
}
# 12 "./src/conv1x1DSP2.hpp" 2


template <unsigned IN_W, unsigned IN_CH, unsigned IN_BIT, unsigned IN_PE,
          unsigned SIMD>
void streamInOneRowTwoPix(
    stream<ap_uint<IN_PE * IN_BIT * 2>> &in,
    ap_uint<IN_PE * IN_BIT> row_buffer[SIMD / IN_PE][2][2]
                                      [IN_W / 2 * IN_CH / SIMD],
    bool skip_flag, ap_uint<1> rowBufferIdx) {
#pragma HLS inline off
 const unsigned INPENUM = SIMD / IN_PE;
  const unsigned SIMDNUM = IN_CH / SIMD;

  if (skip_flag)
    return;
  static ap_uint<IN_PE *IN_BIT> reg = 0;

  for (unsigned s = 0; s < SIMDNUM; s++)
    for (unsigned p = 0; p < INPENUM; p++)
      for (unsigned w = 0; w < IN_W / 2; w++) {
#pragma HLS pipeline
 ap_uint<IN_PE * IN_BIT> data1, data0;
        (data1, data0) = in.read();

        row_buffer[p][0][rowBufferIdx][w * SIMDNUM + s] = data0;
        row_buffer[p][1][rowBufferIdx][w * SIMDNUM + s] = data1;
      }
}

template <unsigned IN_H, unsigned IN_W, unsigned IN_CH, unsigned IN_BIT,
          unsigned IN_PE, unsigned SIMD, unsigned OUTPENUM>
void streamOutOneRowTwoPix(
    stream<ap_uint<SIMD * IN_BIT>> &out,
    ap_uint<IN_PE * IN_BIT> row_buffer[SIMD / IN_PE][2][2]
                                      [IN_W / 2 * IN_CH / SIMD],
    bool skip_flag, ap_uint<1> rowBufferIdx) {
#pragma HLS array_partition variable = &row_buffer dim = 1 complete
 const unsigned IN_PE_BIT = IN_PE * IN_BIT;

  const unsigned INPENUM = SIMD / IN_PE;
  const unsigned SIMDNUM = IN_CH / SIMD;
  if (skip_flag)
    return;

  for (unsigned w = 0; w < IN_W; w++) {
    for (unsigned peIdx = 0; peIdx < OUTPENUM; peIdx++) {
      for (unsigned s = 0; s < SIMDNUM; s++) {
#pragma HLS pipeline
 ap_uint<SIMD * IN_BIT> data;
        ap_uint<IN_PE * IN_BIT> buffer_data[INPENUM];
#pragma HLS array_partition variable = &buffer_data complete
 ap_uint<1> sel = w % 2;

        for (unsigned i = 0; i < INPENUM; i++) {
          buffer_data[i] =
              row_buffer[i][sel][rowBufferIdx][w / 2 * SIMDNUM + s];
        }

        for (unsigned p = 0; p < INPENUM; p++) {
          data((p + 1) * IN_PE_BIT - 1, p * IN_PE_BIT) = buffer_data[p];
        }
        out.write(data);
      }
    }
  }
}

template <unsigned IN_H, unsigned IN_W, unsigned IN_CH, unsigned IN_BIT,
          unsigned IN_PE, unsigned SIMD, unsigned OUTPENUM>
void conv1x1convert(stream<ap_uint<IN_PE * IN_BIT * 2>> &in,
                    stream<ap_uint<SIMD * IN_BIT>> &out,
                    const unsigned reps = 1) {
  static_assert(SIMD % IN_PE == 0, "SIMD %IN_PE !=0");

  const unsigned INPENUM = SIMD / IN_PE;
  const unsigned SIMDNUM = IN_CH / SIMD;
  ap_uint<IN_PE * IN_BIT> row_buffer[INPENUM][2][2][IN_W / 2 * SIMDNUM];

#pragma HLS ARRAY_PARTITION variable = &row_buffer dim = 1 complete

#pragma HLS RESOURCE variable = &row_buffer core = RAM_S2P_BRAM

 ap_uint<1> storeBufferIdx = 0;
  ap_uint<1> loadBufferIdx = 1;

  for (unsigned rep = 0; rep < reps * IN_H + 1; rep++) {
#pragma HLS dependence intra false variable = &row_buffer

 streamInOneRowTwoPix<IN_W, IN_CH, IN_BIT, IN_PE, SIMD>(
        in, row_buffer, (rep >= reps * IN_H), storeBufferIdx);
    streamOutOneRowTwoPix<IN_H, IN_W, IN_CH, IN_BIT, IN_PE, SIMD, OUTPENUM>(
        out, row_buffer, (rep == 0), loadBufferIdx);
    loadBufferIdx++;
    storeBufferIdx++;
  }
}

template <unsigned W, unsigned CH, unsigned BIT, unsigned PE>
void streamInOneRow(stream<ap_uint<PE * BIT>> &in,
                    ap_uint<PE * BIT> row_buffer[W * CH / PE * 2],
                    bool skip_flag, ap_uint<1> rowBufferIdx) {

  const unsigned PENUM = CH / PE;

  if (skip_flag)
    return;

  for (unsigned p = 0; p < PENUM; p++) {
    for (unsigned w = 0; w < W; w++) {
#pragma HLS pipeline
 ap_uint<PE * BIT> data;
      data = in.read();
      row_buffer[(w * PENUM + p) * 2 + rowBufferIdx] = data;
    }
  }
}

template <unsigned W, unsigned CH, unsigned BIT, unsigned PE>
void streamOutOneRow(stream<ap_uint<PE * BIT>> &out,
                     ap_uint<PE * BIT> row_buffer[W * CH / PE * 2],
                     bool skip_flag, ap_uint<1> rowBufferIdx) {
  const unsigned PENUM = CH / PE;

  if (skip_flag)
    return;
  unsigned addr = 0;

  for (unsigned it = 0; it < W * PENUM; it++) {

#pragma HLS pipeline
 out << row_buffer[addr * 2 + rowBufferIdx];
    addr++;
  }
}

template <unsigned ROW, unsigned COL, unsigned CH, unsigned PE, unsigned BIT>
void reorderChannelPE(stream<ap_uint<PE * BIT>> &in,
                      stream<ap_uint<PE * BIT>> &out, const unsigned reps = 1) {

  const unsigned PENUM = CH / PE;
  ap_uint<PE * BIT> row_buffer[COL * PENUM * 2];

  ap_uint<1> storeBufferIdx = 0;
  ap_uint<1> loadBufferIdx = 1;

  for (unsigned rep = 0; rep < reps * ROW + 1; rep++) {
#pragma HLS dependence intra false variable = &row_buffer
#pragma HLS dependence inter false variable = &row_buffer
 streamInOneRow<COL, CH, BIT, PE>(in, row_buffer, (rep >= reps * ROW),
                                     storeBufferIdx);
    streamOutOneRow<COL, CH, BIT, PE>(out, row_buffer, (rep == 0),
                                      loadBufferIdx);
    loadBufferIdx++;
    storeBufferIdx++;
  }
}

template <unsigned IN_BIT, unsigned W_BIT, unsigned PROD_BIT, unsigned SIMD>
void simd_mac_DSP2(ap_uint<IN_BIT> invec[SIMD], ap_int<W_BIT> w0vec[SIMD],
                   ap_int<W_BIT> w1vec[SIMD], ap_int<PROD_BIT> &out0,
                   ap_int<PROD_BIT> &out1) {
#pragma HLS pipeline
#pragma HLS array_partition variable = &invec
#pragma HLS array_partition variable = &w1vec
#pragma HLS array_partition variable = &w0vec
 ap_int<PROD_BIT * 2> acc = 0;
  for (int i = 0; i < SIMD; i++) {
    ap_int<PROD_BIT + W_BIT + 1> rst = w1vec[i] * (1 << PROD_BIT) + w0vec[i];
    ap_int<PROD_BIT * 2> m = invec[i] * rst;
    acc += m;
  }

  out0 = acc(PROD_BIT - 1, 0);
  out1 = acc(PROD_BIT * 2 - 1, PROD_BIT) + acc[PROD_BIT - 1];
}

template <unsigned OUT_ROW, unsigned OUT_COL, unsigned OUT_CH, unsigned IN_BIT,
          unsigned IN_CH,

          unsigned W_BIT, unsigned B_BIT, unsigned M_BIT,

          unsigned SIMD, unsigned PE>
void conv1x1DSP2(stream<ap_uint<IN_BIT * SIMD>> &in,
                 const ap_uint<SIMD * W_BIT>
                     weights[PE][((IN_CH * 1) / SIMD) * (OUT_CH / PE)],
                 const ap_int<B_BIT> bias[PE][OUT_CH / PE],
                 stream<ap_uint<PE * M_BIT>> &out, const unsigned reps = 1) {
  const unsigned PROD_BIT = IN_BIT + W_BIT + 2;

#pragma HLS ARRAY_PARTITION variable = &bias complete dim = 1

 ap_int<W_BIT> wvec[PE][SIMD];
#pragma HLS ARRAY_PARTITION variable = &wvec complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &wvec complete dim = 2

 ap_uint<IN_BIT> ivec[SIMD];
#pragma HLS ARRAY_PARTITION variable = &ivec complete dim = 1

 ap_int<M_BIT> outPartialArr[PE];
#pragma HLS ARRAY_PARTITION variable = &outPartialArr complete dim = 1

 for (unsigned int h = 0; h < OUT_ROW * reps; h++) {
    for (unsigned int w = 0; w < OUT_COL; w++) {
      for (unsigned peIdx = 0; peIdx < OUT_CH / PE; peIdx++)
        for (unsigned int simdIdx = 0; simdIdx < IN_CH / SIMD; simdIdx++) {
#pragma HLS pipeline
 ap_uint<IN_BIT *SIMD> inData = in.read();
          for (int s = 0; s < SIMD; s++) {
            ivec[s] = inData((s + 1) * IN_BIT - 1, s * IN_BIT);
          }
          for (int i = 0; i < PE; i++) {
            for (int s = 0; s < SIMD; s++) {
              wvec[i][s] = weights[i][peIdx * IN_CH / SIMD + simdIdx](
                  (s + 1) * W_BIT - 1, s * W_BIT);
            }
          }


          for (int p = 0; p < PE; p += 2) {
            ap_int<PROD_BIT> outPartial0;
            ap_int<PROD_BIT> outPartial1;
            simd_mac_DSP2<IN_BIT, W_BIT, PROD_BIT, SIMD>(
                ivec, wvec[p], wvec[p + 1], outPartial0, outPartial1);
            if (simdIdx == 0) {
              outPartialArr[p] = outPartial0;
              outPartialArr[p + 1] = outPartial1;
            } else {
              outPartialArr[p] += outPartial0;
              outPartialArr[p + 1] += outPartial1;
            }
          }
          ap_uint<M_BIT * PE> odata;
          if (simdIdx == IN_CH / SIMD - 1) {
            for (int i = 0; i < PE; i++) {
              odata((i + 1) * M_BIT - 1, i * M_BIT) =
                  outPartialArr[i] + bias[i][peIdx];
            }
            out.write(odata);
          }
        }
    }
  }
}

template <unsigned IN_ROW, unsigned IN_COL, unsigned IN_CH, unsigned IN_BIT,
          unsigned OUT_CH, unsigned W_BIT, unsigned B_BIT, unsigned M_BIT,
          unsigned SIMD, unsigned PE, unsigned INPE>
void conv1x1_DSPopt(stream<ap_uint<IN_BIT * INPE * 2>> &in,
                    const ap_uint<SIMD * W_BIT>
                        weights[PE][((IN_CH * 1) / SIMD) * (OUT_CH / PE)],
                    const ap_int<B_BIT> bias[PE][OUT_CH / PE],
                    stream<ap_uint<PE * M_BIT>> &out, const unsigned reps = 1) {
#pragma HLS DATAFLOW
 hls::stream<ap_uint<IN_BIT * SIMD>> conv1in("conv1in");
  conv1x1convert<IN_ROW, IN_COL, IN_CH, IN_BIT, INPE, SIMD, OUT_CH / PE>(
      in, conv1in, reps);





  conv1x1DSP2<IN_ROW, IN_COL, OUT_CH, IN_BIT, IN_CH, W_BIT, B_BIT, M_BIT, SIMD,
              PE>(conv1in, weights, bias, out, reps);

}
# 12 "./src/ultranet.cpp" 2
# 1 "./src/conv2d.h" 1

# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 3 "./src/conv2d.h" 2

using namespace hls;
# 18 "./src/conv2d.h"
template <unsigned IN_ROW, unsigned IN_COL, unsigned IN_CH, unsigned IN_BIT,

          unsigned OUT_CH,
          unsigned OUT_BIT,

          unsigned W_BIT, unsigned M_BIT, unsigned INC_BIT, unsigned BIAS_BIT,

          unsigned SIMD, unsigned PE, unsigned L_SHIFT>
void conv3x3_bn_act(stream<ap_uint<IN_BIT * IN_CH>> &in,
                    const ap_uint<SIMD * W_BIT>
                        weights[PE][((IN_CH * 9) / SIMD) * (OUT_CH / PE)],
                    const ap_int<INC_BIT> inc[PE][OUT_CH / PE],
                    const ap_int<BIAS_BIT> bias[PE][OUT_CH / PE],
                    stream<ap_uint<OUT_BIT * OUT_CH>> &out,
                    const unsigned reps = 1) {
#pragma HLS DATAFLOW

 const unsigned INTER_ROW = IN_ROW + 2;
  const unsigned INTER_COL = IN_COL + 2;

  const unsigned OUT_ROW = IN_ROW;
  const unsigned OUT_COL = IN_COL;




  stream<ap_uint<IN_CH * IN_BIT>> padding_out("samepad_out");

  padding<IN_ROW, IN_COL, IN_CH, IN_BIT, 1>(in, padding_out, reps);

  stream<ap_uint<IN_CH * IN_BIT>> swu_out("swu_out");
  SWU<3, 1, INTER_ROW, INTER_COL, IN_CH, IN_BIT>(padding_out, swu_out, reps);

  stream<ap_uint<SIMD * IN_BIT>> adj_out("adj_out");
  StreamingDataWidthConverter_Batch<IN_CH * IN_BIT, SIMD * IN_BIT,
                                    9 * OUT_ROW * OUT_COL>(swu_out, adj_out,
                                                           reps);




  stream<ap_uint<PE * OUT_BIT>> mvau_out("mvau_out");
  matrix_vector_act_unit<IN_CH * 3 * 3, OUT_CH, IN_BIT, OUT_BIT, W_BIT, M_BIT,
                         INC_BIT, BIAS_BIT, SIMD, PE, L_SHIFT,
                         OUT_ROW * OUT_COL>(adj_out, weights, inc, bias,
                                            mvau_out, reps);



  StreamingDataWidthConverter_Batch<PE * OUT_BIT, OUT_CH * OUT_BIT,
                                    OUT_ROW * OUT_COL * OUT_CH / PE>(mvau_out,
                                                                     out, reps);
}
# 80 "./src/conv2d.h"
template <unsigned IN_ROW, unsigned IN_COL, unsigned IN_CH, unsigned IN_BIT,

          unsigned OUT_CH,
          unsigned OUT_BIT,

          unsigned W_BIT, unsigned M_BIT, unsigned INC_BIT, unsigned BIAS_BIT,

          unsigned SIMD, unsigned PE, unsigned L_SHIFT>
void conv3x3_bn_act_lut(stream<ap_uint<IN_BIT * IN_CH>> &in,
                        const ap_uint<SIMD * W_BIT>
                            weights[PE][((IN_CH * 9) / SIMD) * (OUT_CH / PE)],
                        const ap_uint<INC_BIT> inc[PE][OUT_CH / PE],
                        const ap_int<BIAS_BIT> bias[PE][OUT_CH / PE],
                        stream<ap_uint<OUT_BIT * OUT_CH>> &out,
                        const unsigned reps = 1) {
#pragma HLS DATAFLOW

 const unsigned INTER_ROW = IN_ROW + 2;
  const unsigned INTER_COL = IN_COL + 2;

  const unsigned OUT_ROW = IN_ROW;
  const unsigned OUT_COL = IN_COL;




  stream<ap_uint<IN_CH * IN_BIT>> padding_out("samepad_out");
  padding<IN_ROW, IN_COL, IN_CH, IN_BIT, 1>(in, padding_out, reps);


  stream<ap_uint<IN_CH * IN_BIT>> swu_out("swu_out");
  SWU<3, 1, INTER_ROW, INTER_COL, IN_CH, IN_BIT>(padding_out, swu_out, reps);

  stream<ap_uint<SIMD * IN_BIT>> adj_out("adj_out");
  StreamingDataWidthConverter_Batch<IN_CH * IN_BIT, SIMD * IN_BIT,
                                    9 * OUT_ROW * OUT_COL>(swu_out, adj_out,
                                                           reps);

  stream<ap_uint<PE * OUT_BIT>> mvau_out("mvau_out");
  matrix_vector_act_unit_lut<IN_CH * 3 * 3, OUT_CH, IN_BIT, OUT_BIT, W_BIT,
                             M_BIT, INC_BIT, BIAS_BIT, SIMD, PE, L_SHIFT,
                             OUT_ROW * OUT_COL>(adj_out, weights, inc, bias,
                                                mvau_out, reps);

  StreamingDataWidthConverter_Batch<PE * OUT_BIT, OUT_CH * OUT_BIT,
                                    OUT_ROW * OUT_COL>(mvau_out, out, reps);
}






template <unsigned IN_ROW, unsigned IN_COL, unsigned IN_CH, unsigned IN_BIT,

          unsigned OUT_CH,
          unsigned OUT_BIT,

          unsigned W_BIT, unsigned M_BIT, unsigned INC_BIT, unsigned BIAS_BIT,

          unsigned SIMD, unsigned PE, unsigned L_SHIFT>
void conv1x1_bn_act(
    stream<ap_uint<IN_BIT * IN_CH>> &in,
    const ap_uint<SIMD * W_BIT> weights[PE][((IN_CH) / SIMD) * (OUT_CH / PE)],
    const ap_uint<INC_BIT> inc[PE][OUT_CH / PE],
    const ap_int<BIAS_BIT> bias[PE][OUT_CH / PE],
    stream<ap_uint<OUT_BIT * OUT_CH>> &out, const unsigned reps = 1) {
#pragma HLS DATAFLOW

 const unsigned OUT_ROW = IN_ROW;
  const unsigned OUT_COL = IN_COL;
  stream<ap_uint<SIMD * IN_BIT>> adj_out("adj_out");
  StreamingDataWidthConverter_Batch<IN_CH * IN_BIT, SIMD * IN_BIT,
                                    OUT_ROW * OUT_COL>(in, adj_out, reps);

  stream<ap_uint<PE * OUT_BIT>> mvau_out("mvau_out");
  matrix_vector_act_unit<IN_CH, OUT_CH, IN_BIT, OUT_BIT, W_BIT, M_BIT, INC_BIT,
                         BIAS_BIT, SIMD, PE, L_SHIFT, OUT_ROW * OUT_COL>(
      adj_out, weights, inc, bias, mvau_out, reps);

  StreamingDataWidthConverter_Batch<PE * OUT_BIT, OUT_CH * OUT_BIT,
                                    OUT_ROW * OUT_COL * OUT_CH / PE>(mvau_out,
                                                                     out, reps);
}

template <unsigned IN_ROW, unsigned IN_COL, unsigned IN_CH, unsigned IN_BIT,
          unsigned OUT_CH,

          unsigned W_BIT, unsigned M_BIT,

          unsigned SIMD, unsigned PE>
void conv1x1(stream<ap_uint<IN_BIT * SIMD>> &in,
             const ap_uint<SIMD * W_BIT>
                 weights[PE][((IN_CH * 1) / SIMD) * (OUT_CH / PE)],
             stream<ap_uint<PE * M_BIT>> &out, const unsigned reps = 1) {
  const unsigned OUT_ROW = IN_ROW;
  const unsigned OUT_COL = IN_COL;

  matrix_vector_unit<IN_CH, OUT_CH, IN_BIT, W_BIT, M_BIT, SIMD, PE,
                     OUT_ROW * OUT_COL>(in, weights, out, reps);
}
# 13 "./src/ultranet.cpp" 2
# 1 "./src/conv2d_DSPopt.hpp" 1



# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 5 "./src/conv2d_DSPopt.hpp" 2

using namespace hls;
# 16 "./src/conv2d_DSPopt.hpp"
template <unsigned IN_W, unsigned IN_CH, unsigned IN_BIT, unsigned IN_PE,
          unsigned SIMD>
void stream_in_row(
    stream<ap_uint<IN_PE * IN_BIT * 2>> &in,
    ap_uint<IN_PE * IN_BIT * 2> row_buffer[SIMD / IN_PE][4]
                                          [(IN_W / 2 + 1) * IN_CH / SIMD],
    bool skip_flag, ap_uint<2> rowBufferIdx) {
#pragma HLS inline off
 if (skip_flag)
    return;
  ap_uint<IN_PE *IN_BIT> reg = 0;

  for (unsigned peIdx = 0; peIdx < IN_CH / IN_PE; peIdx++)
    for (unsigned w = 0; w < IN_W / 2 + 1; w++) {
#pragma HLS pipeline
 ap_uint<IN_PE * IN_BIT * 2> data;
      ap_uint<IN_PE * IN_BIT> data0, data1;
      if (w != (IN_W / 2)) {
        (data1, data0) = in.read();
      } else {
        data1 = 0;
        data0 = 0;
      }
      data = (data0, reg);
      reg = data1;

      row_buffer[peIdx % (SIMD / IN_PE)][rowBufferIdx]
                [w * IN_CH / SIMD + peIdx / (SIMD / IN_PE)] = data;
    }
}

template <unsigned K, unsigned IN_H, unsigned IN_W, unsigned IN_CH,
          unsigned IN_BIT, unsigned IN_PE, unsigned SIMD, unsigned OUTPENUM>
void stream_out_data(
    stream<ap_uint<SIMD * IN_BIT * 2>> &out,
    ap_uint<IN_PE * IN_BIT * 2> row_buffer[SIMD / IN_PE][4]
                                          [(IN_W / 2 + 1) * IN_CH / SIMD],
    bool skip_flag, ap_int<12> outRowIdx, ap_uint<2> startRowBufferIdx) {
#pragma HLS array_partition variable = &row_buffer dim = 1 complete

 const unsigned IN_PE_BIT = IN_PE * IN_BIT;
  const unsigned SIMDNUM = IN_CH / SIMD;
  const unsigned WLEN = IN_W / 2 + 1;
  if (skip_flag)
    return;

  ap_uint<8> infoldIdx = 0;
  ap_uint<8> w = 0;

  for (unsigned peIdx = 0; peIdx < OUTPENUM; peIdx++) {
    for (unsigned cycle = 0; cycle < WLEN * K * SIMDNUM; cycle++) {



      ap_uint<2> wr = infoldIdx / SIMDNUM;
      ap_uint<4> simdIdx = infoldIdx % SIMDNUM;
#pragma HLS pipeline
 ap_uint<SIMD * IN_BIT> data0;
      ap_uint<SIMD * IN_BIT> data1;
      ap_uint<IN_PE * IN_BIT * 2> buffer_data[SIMD / IN_PE];
#pragma HLS array_partition variable = &buffer_data complete
 ap_uint<2> rowBufferIdx = startRowBufferIdx + wr;
      for (unsigned i = 0; i < SIMD / IN_PE; i++) {
#pragma HLS unroll
 buffer_data[i] = row_buffer[i][rowBufferIdx][w * SIMDNUM + simdIdx];
      }

      if (outRowIdx - K / 2 + wr < 0 || outRowIdx - K / 2 + wr >= IN_H) {
        data0 = 0;
        data1 = 0;
      } else {
        for (unsigned i = 0; i < SIMD / IN_PE; i++) {
          data0((i + 1) * IN_PE_BIT - 1, i * IN_PE_BIT) =
              buffer_data[i](IN_PE_BIT - 1, 0);
          data1((i + 1) * IN_PE_BIT - 1, i * IN_PE_BIT) =
              buffer_data[i](IN_PE_BIT * 2 - 1, IN_PE_BIT);
        }
      }
      out.write((data1, data0));

      if (cycle == WLEN * K * SIMDNUM - 1) {
        w = 0;
      } else if (infoldIdx == K * SIMDNUM - 1) {
        w++;
      }

      if (infoldIdx == K * SIMDNUM - 1) {
        infoldIdx = 0;
      } else {
        infoldIdx++;
      }
    }
  }
}

template <unsigned K, unsigned IN_H, unsigned IN_W, unsigned IN_CH,
          unsigned IN_BIT, unsigned IN_PE, unsigned SIMD, unsigned OUTPENUM>
void conv3padding(stream<ap_uint<IN_PE * IN_BIT * 2>> &in,
                  stream<ap_uint<SIMD * IN_BIT * 2>> &out,
                  const unsigned reps = 1) {
  static_assert(SIMD % IN_PE == 0, "SIMD %IN_PE !=0");
  static_assert(K == 3, "K!=3");

  ap_uint<IN_PE * IN_BIT * 2> row_buffer[SIMD / IN_PE][4]
                                        [(IN_W / 2 + 1) * IN_CH / SIMD];
#pragma HLS ARRAY_PARTITION variable = &row_buffer dim = 1 complete
#pragma HLS RESOURCE variable = &row_buffer core = RAM_S2P_BRAM
 ap_uint<8> inh = 0;
  ap_uint<8> outh = 0;

  ap_uint<2> storeBufferIdx = 0;
  ap_uint<2> loadBufferIdx = 1;
  ap_int<10> rowIdx = -2;

  for (unsigned rep = 0; rep < reps * IN_H + 2; rep++) {
#pragma HLS dependence intra false variable = &row_buffer
 stream_in_row<IN_W, IN_CH, IN_BIT, IN_PE, SIMD>(
        in, row_buffer, (rep >= reps * IN_H), storeBufferIdx);
    stream_out_data<K, IN_H, IN_W, IN_CH, IN_BIT, IN_PE, SIMD, OUTPENUM>(
        out, row_buffer, (rep < 2), rowIdx, loadBufferIdx);
    loadBufferIdx++;
    storeBufferIdx++;

    if (rowIdx == IN_H - 1) {
      rowIdx = 0;
    } else {
      rowIdx++;
    }
  }
}

template <unsigned OUT_ROW, unsigned OUT_COL, unsigned OUT_CH, unsigned M_BIT,
          unsigned OUT_BIT, unsigned INC_BIT, unsigned BIAS_BIT,
          unsigned IN_BIT, unsigned W_BIT, unsigned L_SHIFT, unsigned PE>
void streamBnRelu(stream<ap_uint<PE * M_BIT * 2>> &in,
                  const ap_int<INC_BIT> inc[PE][OUT_CH / PE],
                  const ap_int<BIAS_BIT> bias[PE][OUT_CH / PE],
                  stream<ap_uint<PE * OUT_BIT * 2>> &out,
                  const unsigned rep = 1) {
#pragma HLS ARRAY_PARTITION variable = &inc complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &bias complete dim = 1
 for (int r = 0; r < OUT_ROW * rep; r++)
    for (int peIdx = 0; peIdx < OUT_CH / PE; peIdx++)
      for (int w = 0; w < OUT_COL; w += 2) {

#pragma HLS pipeline II = 2
 ap_uint<M_BIT * PE * 2> data;
        ap_uint<OUT_BIT * PE * 2> data0, data1;
        ap_int<M_BIT> invec[PE];
#pragma HLS array_partition variable = &invec dim = 1 complete
 data = in.read();
        for (int i = 0; i < PE * 2; i++) {
          invec[i] = data((i + 1) * M_BIT - 1, i * M_BIT);
        }
        for (int i = 0; i < PE * 2; i++) {
          data0((i + 1) * OUT_BIT - 1, i * OUT_BIT) =
              bn_qurelu_fixed<M_BIT, OUT_BIT, INC_BIT, BIAS_BIT, IN_BIT, W_BIT,
                              L_SHIFT>(invec[i], inc[i % PE][peIdx],
                                       bias[i % PE][peIdx]);
        }
        out.write(data0);
      }
}

template <unsigned IN_BIT, unsigned SIMD, unsigned PROD_BIT>
void pack_input_data(ap_uint<IN_BIT * SIMD> A, ap_uint<IN_BIT * SIMD> B,
                     ap_uint<PROD_BIT + IN_BIT> ipack[SIMD]) {
#pragma HLS array_partition variable = &ipack

 for (int i = 0; i < SIMD; i++) {
    ipack[i] =
        (A(i * IN_BIT + IN_BIT - 1, i * IN_BIT), (ap_uint<PROD_BIT - IN_BIT>)0,
         B(i * IN_BIT + IN_BIT - 1, i * IN_BIT));
  }
}

template <unsigned W_BIT, unsigned SIMD, unsigned PROD_BIT>
void pack_weight_data(ap_uint<W_BIT * SIMD> w2, ap_uint<W_BIT * SIMD> w1,
                      ap_uint<W_BIT * SIMD> w0,
                      ap_int<PROD_BIT * 2 + W_BIT> wpack[SIMD]) {
#pragma HLS array_partition variable = &wpack

 for (int i = 0; i < SIMD; i++) {
    ap_int<W_BIT> w2_seg = w2(i * W_BIT + W_BIT - 1, i * W_BIT);
    ap_int<W_BIT> w1_seg = w1(i * W_BIT + W_BIT - 1, i * W_BIT);
    ap_int<W_BIT> w0_seg = w0(i * W_BIT + W_BIT - 1, i * W_BIT);
    wpack[i] =
        (w0_seg * (1 << (PROD_BIT * 2))) + (w1_seg * (1 << PROD_BIT)) + w2_seg;
  }
}

template <unsigned W_BIT, unsigned IN_BIT, unsigned SIMD, unsigned PROD_BIT>
void simd_MAC_normal(ap_int<W_BIT * SIMD> w0, ap_int<W_BIT * SIMD> w1,
                     ap_int<W_BIT * SIMD> w2, ap_uint<IN_BIT * SIMD> i0,
                     ap_uint<IN_BIT * SIMD> i1, ap_int<PROD_BIT + 5> &partial0,
                     ap_int<PROD_BIT + 5> &partial1,
                     ap_int<PROD_BIT + 5> &partial2,
                     ap_int<PROD_BIT + 5> &partial3) {
  ap_int<PROD_BIT + 5> r0, r1, r2, r3;
  r0 = 0;
  r1 = 0;
  r2 = 0;
  r3 = 0;
  for (int i = 0; i < SIMD; i++) {
    ap_int<W_BIT> w0_seg = w0((i + 1) * W_BIT - 1, i * W_BIT);
    ap_int<W_BIT> w1_seg = w1((i + 1) * W_BIT - 1, i * W_BIT);
    ap_int<W_BIT> w2_seg = w2((i + 1) * W_BIT - 1, i * W_BIT);
    ap_uint<IN_BIT> x0_seg = i0((i + 1) * IN_BIT - 1, i * IN_BIT);
    ap_uint<IN_BIT> x1_seg = i1((i + 1) * IN_BIT - 1, i * IN_BIT);
# 234 "./src/conv2d_DSPopt.hpp"
    r0 += x0_seg * w2_seg;
    r1 += x0_seg * w1_seg + x1_seg * w2_seg;
    r2 += x0_seg * w0_seg + x1_seg * w1_seg;
    r3 += x1_seg * w0_seg;
  }
  partial0 = r0;
  partial1 = r1;
  partial2 = r2;
  partial3 = r3;
}

template <unsigned W_BIT, unsigned IN_BIT, unsigned PROD_BIT, unsigned SIMD,
          unsigned CASCADE>
void simd_MAC(ap_int<PROD_BIT * 2 + W_BIT> wpack[SIMD],
              ap_uint<PROD_BIT + IN_BIT> ipack[SIMD],
              ap_int<PROD_BIT + 5> &partial0, ap_int<PROD_BIT + 5> &partial1,
              ap_int<PROD_BIT + 5> &partial2, ap_int<PROD_BIT + 5> &partial3) {
#pragma HLS ARRAY_PARTITION variable = &wpack complete
#pragma HLS ARRAY_PARTITION variable = &ipack complete
 ap_int<PROD_BIT + 5> r0, r1, r2, r3;
  r0 = 0;
  r1 = 0;
  r2 = 0;
  r3 = 0;
  for (int i = 0; i < SIMD; i += CASCADE) {
#pragma HLS unroll
 ap_int<PROD_BIT * 4> m = 0;
    for (int cs = 0; cs < CASCADE; cs++) {
#pragma HLS unroll
 m += wpack[i + cs] * ipack[i + cs];
    }

    ap_int<PROD_BIT> p0 = m(PROD_BIT - 1, 0);
    ap_int<PROD_BIT> p1 = m(PROD_BIT * 2 - 1, PROD_BIT) + m[PROD_BIT - 1];
    ap_int<PROD_BIT> p2 =
        m(PROD_BIT * 3 - 1, PROD_BIT * 2) + m[PROD_BIT * 2 - 1];
    ap_int<PROD_BIT> p3 =
        m(PROD_BIT * 4 - 1, PROD_BIT * 3) + m[PROD_BIT * 3 - 1];

    r0 += p0;
    r1 += p1;
    r2 += p2;
    r3 += p3;
  }
  partial0 = r0;
  partial1 = r1;
  partial2 = r2;
  partial3 = r3;
}

template <unsigned W_BIT, unsigned IN_BIT, unsigned PROD_BIT, unsigned SIMD>
void simd_MAC_compare(ap_int<PROD_BIT * 2 + W_BIT> wpack[SIMD],
                      ap_uint<PROD_BIT + IN_BIT> ipack[SIMD],
                      ap_int<W_BIT * SIMD> w0, ap_int<W_BIT * SIMD> w1,
                      ap_int<W_BIT * SIMD> w2, ap_uint<IN_BIT * SIMD> i0,
                      ap_uint<IN_BIT * SIMD> i1, ap_int<PROD_BIT + 5> &partial0,
                      ap_int<PROD_BIT + 5> &partial1,
                      ap_int<PROD_BIT + 5> &partial2,
                      ap_int<PROD_BIT + 5> &partial3) {

  ap_int<PROD_BIT + 5> r0, r1, r2, r3;
  r0 = 0;
  r1 = 0;
  r2 = 0;
  r3 = 0;
  for (int i = 0; i < SIMD; i++) {

    ap_int<PROD_BIT * 4> m = wpack[i] * ipack[i];
    ap_int<PROD_BIT> p0 = m(PROD_BIT - 1, 0);
    ap_int<PROD_BIT> p1 = m(PROD_BIT * 2 - 1, PROD_BIT) + m[PROD_BIT - 1];
    ap_int<PROD_BIT> p2 =
        m(PROD_BIT * 3 - 1, PROD_BIT * 2) + m[PROD_BIT * 2 - 1];
    ap_int<PROD_BIT> p3 =
        m(PROD_BIT * 4 - 1, PROD_BIT * 3) + m[PROD_BIT * 3 - 1];

    ap_int<W_BIT> w0_seg = w0((i + 1) * W_BIT - 1, i * W_BIT);
    ap_int<W_BIT> w1_seg = w1((i + 1) * W_BIT - 1, i * W_BIT);
    ap_int<W_BIT> w2_seg = w2((i + 1) * W_BIT - 1, i * W_BIT);
    ap_uint<IN_BIT> x0_seg = i0((i + 1) * IN_BIT - 1, i * IN_BIT);
    ap_uint<IN_BIT> x1_seg = i1((i + 1) * IN_BIT - 1, i * IN_BIT);
# 330 "./src/conv2d_DSPopt.hpp"
    r0 += p0;
    r1 += p1;
    r2 += p2;
    r3 += p3;
  }
  partial0 = r0;
  partial1 = r1;
  partial2 = r2;
  partial3 = r3;
}

template <unsigned K, unsigned IN_BIT, unsigned IN_CH, unsigned OUT_BIT,
          unsigned OUT_W, unsigned OUT_H, unsigned OUT_CH, unsigned W_BIT,
          unsigned GUARD_BIT, unsigned M_BIT, unsigned INC_BIT,
          unsigned BIAS_BIT, unsigned SIMD, unsigned CASCADE, unsigned PE,
          unsigned L_SHIFT>
void convDSPOpt(
    stream<ap_uint<SIMD * IN_BIT * 2>> &vec,
    const ap_uint<SIMD * W_BIT> weights[PE][3][K * IN_CH / SIMD * OUT_CH / PE],
    const ap_int<INC_BIT> inc[PE][OUT_CH / PE],
    const ap_int<BIAS_BIT> bias[PE][OUT_CH / PE],
    stream<ap_uint<PE * OUT_BIT * 2>> &out,

    const unsigned reps = 1) {

  static_assert(IN_CH % SIMD == 0, "IN_CH % SIMD !=0");
  static_assert(SIMD % CASCADE == 0, "SIMD % CASCADE != 0");
  static_assert(CASCADE <= 4, "SIMD % CASCADE != 0");
  const unsigned PENUM = OUT_CH / PE;
  const unsigned SIMDNUM = IN_CH / SIMD;
  const unsigned PROD_BIT = W_BIT + IN_BIT + GUARD_BIT;
  const unsigned WPACK_BIT = W_BIT * 3 + IN_BIT * 2 + GUARD_BIT * 2;
  const unsigned IPACK_BIT = IN_BIT * 2 + W_BIT + GUARD_BIT * 1;
  const unsigned INFOLD = K * SIMDNUM;

#pragma HLS ARRAY_PARTITION variable = &weights complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &weights complete dim = 2
#pragma HLS ARRAY_PARTITION variable = &inc complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &bias complete dim = 1





 ap_int<WPACK_BIT> wpacks[PE][SIMD];
#pragma HLS ARRAY_PARTITION variable = &wpacks complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &wpacks complete dim = 2

 ap_uint<IPACK_BIT> ipack[SIMD];
#pragma HLS ARRAY_PARTITION variable = &ipack complete dim = 1


 ap_int<M_BIT> firPartialRes0[PE];
#pragma HLS ARRAY_PARTITION variable = &firPartialRes0 complete dim = 1
 ap_int<M_BIT> firPartialRes1[PE];
#pragma HLS ARRAY_PARTITION variable = &firPartialRes1 complete dim = 1

 ap_int<M_BIT> outPartialArr0[PE];
#pragma HLS ARRAY_PARTITION variable = &outPartialArr0 complete dim = 1
 ap_int<M_BIT> outPartialArr1[PE];
#pragma HLS ARRAY_PARTITION variable = &outPartialArr1 complete dim = 1

 for (unsigned int h = 0; h < OUT_H * reps; h++) {
    for (unsigned int peIdx = 0; peIdx < PENUM; peIdx++) {
      for (unsigned int w = 0; w < OUT_W + K - 1; w += 2) {
        for (unsigned int infoldIdx = 0; infoldIdx < INFOLD; infoldIdx++) {
#pragma HLS pipeline
 bool m_clear = (w == 0);
          bool o_clear = (infoldIdx == 0);
          bool o_out = (infoldIdx == INFOLD - 1 && w != 0);
          ap_uint<SIMD * IN_BIT> data1, data0;
          (data1, data0) = vec.read();
          pack_input_data<IN_BIT, SIMD, PROD_BIT>(data1, data0, ipack);
          for (unsigned p = 0; p < PE; p++) {
            pack_weight_data<W_BIT, SIMD, PROD_BIT>(
                weights[p][2][peIdx * INFOLD + infoldIdx],
                weights[p][1][peIdx * INFOLD + infoldIdx],
                weights[p][0][peIdx * INFOLD + infoldIdx], wpacks[p]);
          }

          for (int p = 0; p < PE; p++) {


            ap_int<PROD_BIT + 5> firPartial0;
            ap_int<PROD_BIT + 5> firPartial1;
            ap_int<PROD_BIT + 5> firPartial2;
            ap_int<PROD_BIT + 5> firPartial3;






            simd_MAC<W_BIT, IN_BIT, PROD_BIT, SIMD, CASCADE>(
                wpacks[p], ipack, firPartial0, firPartial1, firPartial2,
                firPartial3);


            if (o_clear) {
              outPartialArr0[p] = firPartial0 + firPartialRes0[p];
              outPartialArr1[p] = firPartial1 + firPartialRes1[p];
              firPartialRes0[p] = firPartial2;
              firPartialRes1[p] = firPartial3;
            } else {
              outPartialArr0[p] += firPartial0;
              outPartialArr1[p] += firPartial1;
              firPartialRes0[p] += firPartial2;
              firPartialRes1[p] += firPartial3;
            }
# 447 "./src/conv2d_DSPopt.hpp"
          }
          ap_int<OUT_BIT * PE> oData0;
          ap_int<OUT_BIT * PE> oData1;

          if (o_out) {


            for (int p = 0; p < PE; p++) {


              oData0((p + 1) * OUT_BIT - 1, p * OUT_BIT) =
                  bn_qurelu_fixed<M_BIT, OUT_BIT, INC_BIT, BIAS_BIT, IN_BIT,
                                  W_BIT, L_SHIFT>(
                      outPartialArr0[p], inc[p][peIdx], bias[p][peIdx]);
              oData1((p + 1) * OUT_BIT - 1, p * OUT_BIT) =
                  bn_qurelu_fixed<M_BIT, OUT_BIT, INC_BIT, BIAS_BIT, IN_BIT,
                                  W_BIT, L_SHIFT>(
                      outPartialArr1[p], inc[p][peIdx], bias[p][peIdx]);
            }
            out.write((oData1, oData0));

          }
        }
      }
    }
  }
}
# 488 "./src/conv2d_DSPopt.hpp"
template <unsigned IN_ROW, unsigned IN_COL, unsigned IN_CH, unsigned IN_BIT,

          unsigned OUT_CH,
          unsigned OUT_BIT,

          unsigned W_BIT, unsigned M_BIT, unsigned INC_BIT, unsigned BIAS_BIT,

          unsigned SIMD, unsigned CASCADE, unsigned IN_PE, unsigned PE,
          unsigned L_SHIFT>
void conv3x3_bn_act_DSPopt(
    stream<ap_uint<IN_BIT * IN_PE * 2>> &in,
    const ap_uint<SIMD * W_BIT> weights[PE][3]
                                       [((IN_CH * 3) / SIMD) * (OUT_CH / PE)],
    const ap_int<INC_BIT> inc[PE][OUT_CH / PE],
    const ap_int<BIAS_BIT> bias[PE][OUT_CH / PE],
    stream<ap_uint<OUT_BIT * PE * 2>> &out, const unsigned reps = 1) {
#pragma HLS DATAFLOW

 const unsigned INTER_ROW = IN_ROW + 2;
  const unsigned INTER_COL = IN_COL + 2;

  const unsigned OUT_ROW = IN_ROW;
  const unsigned OUT_COL = IN_COL;

  stream<ap_uint<SIMD * IN_BIT * 2>> padding_out("padding_out");
  conv3padding<3, IN_ROW, IN_COL, IN_CH, IN_BIT, IN_PE, SIMD, OUT_CH / PE>(
      in, padding_out, reps);

  stream<ap_uint<PE * OUT_BIT * 2>> mvau_out("mvau_out");
  convDSPOpt<3, IN_BIT, IN_CH, OUT_BIT, OUT_COL, OUT_ROW, OUT_CH, W_BIT, 3,
             M_BIT, INC_BIT, BIAS_BIT, SIMD, CASCADE, PE, L_SHIFT>(
      padding_out, weights, inc, bias, out, reps);
}
# 14 "./src/ultranet.cpp" 2
# 1 "./src/conv2d_l0.hpp" 1



# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 5 "./src/conv2d_l0.hpp" 2

using namespace hls;







template <unsigned IN_W, unsigned IN_BIT>
void stream_in_row_l0(stream<ap_uint<3 * IN_BIT>> &in,
                      ap_uint<3 * IN_BIT> row_buffer[4][IN_W + 2],
                      bool skip_flag, ap_uint<2> rowBufferIdx) {_ssdm_SpecArrayDimSize(row_buffer, 4);

  if (skip_flag)
    return;

  for (unsigned w = 0; w < IN_W + 2; w++) {
#pragma HLS pipeline
 ap_uint<3 * IN_BIT> data;
    if (w != 0 && w != IN_W + 1) {
      data = in.read();
    } else {
      data = 0;
    }
    row_buffer[rowBufferIdx][w] = data;
  }
}

template <unsigned IN_H, unsigned IN_W, unsigned IN_BIT, unsigned OUTPENUM>
void stream_out_data_l0(stream<ap_uint<3 * IN_BIT * 3>> &out,
                        ap_uint<3 * IN_BIT> row_buffer[4][IN_W + 2],
                        bool skip_flag, ap_int<12> outRowIdx,
                        ap_uint<2> centerRowBufferIdx) {_ssdm_SpecArrayDimSize(row_buffer, 4);
#pragma HLS array_partition variable = &row_buffer dim = 1 complete

 if (skip_flag)
    return;

  for (unsigned peIdx = 0; peIdx < OUTPENUM; peIdx++)
    for (unsigned c = 0; c < IN_W; c++)
      for (unsigned kc = 0; kc < 3; kc++) {
#pragma HLS pipeline
 ap_uint<3 * IN_BIT> data[4];
#pragma HLS array_partition variable = &data dim = 1 complete
 for (unsigned i = 0; i < 4; i++) {
          data[i] = row_buffer[i][c + kc];
        }
        ap_uint<2> row_sel0, row_sel1, row_sel2;
        row_sel0 = centerRowBufferIdx - 1;
        row_sel1 = centerRowBufferIdx;
        row_sel2 = centerRowBufferIdx + 1;
        ap_uint<3 * IN_BIT> data0, data1, data2;

        if (outRowIdx - 1 < 0)
          data0 = 0;
        else
          data0 = data[row_sel0];
        data1 = data[row_sel1];
        if (outRowIdx + 1 == IN_H)
          data2 = 0;
        else
          data2 = data[row_sel2];
        out.write((data2, data1, data0));
      }
}

template <unsigned K, unsigned IN_H, unsigned IN_W, unsigned IN_CH,
          unsigned IN_BIT, unsigned OUTPENUM>
void conv3padding_l0(stream<ap_uint<3 * IN_BIT>> &in,
                     stream<ap_uint<3 * IN_BIT * 3>> &out,
                     const unsigned reps = 1) {
  static_assert(K == 3, "K!=3");
  ap_uint<IN_CH * IN_BIT> row_buffer[4][IN_W + 2];
#pragma HLS ARRAY_PARTITION variable = &row_buffer dim = 1 complete
#pragma HLS RESOURCE variable = &row_buffer core = RAM_S2P_BRAM
 ap_uint<2> storeBufferIdx = 0;
  ap_uint<2> loadBufferIdx = -2;
  ap_int<10> rowIdx = -2;

  for (unsigned rep = 0; rep < reps * IN_H + 2; rep++) {
#pragma HLS dependence intra false variable = &row_buffer
 stream_in_row_l0<IN_W, IN_BIT>(in, row_buffer, (rep >= reps * IN_H),
                                   storeBufferIdx);
    stream_out_data_l0<IN_H, IN_W, IN_BIT, OUTPENUM>(out, row_buffer, (rep < 2),
                                                     rowIdx, loadBufferIdx);
    loadBufferIdx++;
    storeBufferIdx++;
    if (rowIdx == IN_H - 1) {
      rowIdx = 0;
    } else {
      rowIdx++;
    }
  }
}

template <unsigned IN_BIT, unsigned W_BIT, unsigned PROD_BIT>
void simd_mac9_DSP2(ap_uint<IN_BIT> invec[9], ap_int<W_BIT> w0vec[9],
                    ap_int<W_BIT> w1vec[9], ap_int<PROD_BIT> &out0,
                    ap_int<PROD_BIT> &out1) {_ssdm_SpecArrayDimSize(invec, 9);_ssdm_SpecArrayDimSize(w0vec, 9);_ssdm_SpecArrayDimSize(w1vec, 9);

#pragma HLS array_partition variable = &invec
#pragma HLS array_partition variable = &w1vec
#pragma HLS array_partition variable = &w0vec

 ap_int<PROD_BIT * 2> acc = 0;
# 130 "./src/conv2d_l0.hpp"
  for (int i = 0; i < 9; i++) {
    ap_int<PROD_BIT + W_BIT> rst = w1vec[i] * (1 << PROD_BIT) + w0vec[i];
    ap_int<PROD_BIT * 2> m = invec[i] * rst;

    acc += m;


  }


  out0 = acc(PROD_BIT - 1, 0);
  out1 = acc(PROD_BIT * 2 - 1, PROD_BIT) + acc[PROD_BIT - 1];
}

template <unsigned IN_BIT>
void loadInReg9(ap_uint<IN_BIT * 9> inData, ap_uint<IN_BIT> ivec[9]) {_ssdm_SpecArrayDimSize(ivec, 9);
#pragma HLS pipeline II = 1
#pragma HLS inline off
#pragma HLS ARRAY_PARTITION variable = &ivec complete dim = 1

 for (unsigned s = 0; s < 9; s++) {
    ivec[s] = inData((s + 1) * IN_BIT - 1, s * IN_BIT);
  }
}

template <unsigned OUT_ROW, unsigned OUT_COL, unsigned OUT_CH, unsigned PE,
          unsigned IN_BIT, unsigned W_BIT, unsigned M_BIT,


          unsigned OUT_BIT>
void convDSPOpt_l0(stream<ap_uint<IN_BIT * 9>> &in,
                   const ap_uint<3 * W_BIT> weights[PE][3][3 * (OUT_CH / PE)],
                   stream<ap_uint<M_BIT * PE>> &out, const unsigned reps = 1) {
#pragma HLS ARRAY_PARTITION variable = &weights complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &weights complete dim = 2






 const unsigned PROD_BIT = IN_BIT + W_BIT + 4;

  ap_int<M_BIT> outPartialArr[PE];
#pragma HLS ARRAY_PARTITION variable = &outPartialArr complete dim = 1

 for (unsigned int h = 0; h < OUT_ROW * reps; h++) {
    for (unsigned peIdx = 0; peIdx < OUT_CH / PE; peIdx++)
      for (unsigned int w = 0; w < OUT_COL; w++) {
        for (unsigned int kc = 0; kc < 3; kc++) {
#pragma HLS pipeline II = 1

 ap_uint<IN_BIT> ivec[9];
#pragma HLS ARRAY_PARTITION variable = &ivec complete dim = 1
 ap_int<W_BIT> wvec[PE][9];
#pragma HLS ARRAY_PARTITION variable = &wvec complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &wvec complete dim = 2

 ap_uint<IN_BIT * 9> inData;
          in >> inData;
          loadInReg9<IN_BIT>(inData, ivec);
          for (int i = 0; i < PE; i++) {
            for (int s = 0; s < 9; s++) {
              wvec[i][s] = weights[i][s / 3][peIdx * 3 + kc](
                  (s % 3 + 1) * W_BIT - 1, s % 3 * W_BIT);
            }
          }



          for (int p = 0; p < PE; p += 2) {
            ap_int<PROD_BIT> outPartial0;
            ap_int<PROD_BIT> outPartial1;
            simd_mac9_DSP2<IN_BIT, W_BIT, PROD_BIT>(ivec, wvec[p], wvec[p + 1],
                                                    outPartial0, outPartial1);




            if (kc == 0) {
              outPartialArr[p] = outPartial0;
              outPartialArr[p + 1] = outPartial1;
            } else {
              outPartialArr[p] += outPartial0;
              outPartialArr[p + 1] += outPartial1;
            }
          }

          ap_uint<M_BIT * PE> odata;
          if (kc == 2) {


            for (int i = 0; i < PE; i++) {

              odata((i + 1) * M_BIT - 1, i * M_BIT) = outPartialArr[i];
            }

            out.write(odata);
          }
        }
      }
  }
}

template <unsigned OUT_ROW, unsigned OUT_COL, unsigned OUT_CH, unsigned M_BIT,
          unsigned OUT_BIT, unsigned INC_BIT, unsigned BIAS_BIT,
          unsigned IN_BIT, unsigned W_BIT, unsigned L_SHIFT, unsigned PE>
void streamBnRelu_l0(stream<ap_uint<PE * M_BIT>> &in,
                     const ap_int<INC_BIT> inc[PE][OUT_CH / PE],
                     const ap_int<BIAS_BIT> bias[PE][OUT_CH / PE],
                     stream<ap_uint<PE * OUT_BIT * 2>> &out,
                     const unsigned rep = 1) {
#pragma HLS ARRAY_PARTITION variable = &inc complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &bias complete dim = 1
 for (unsigned r = 0; r < OUT_ROW * rep; r++)
    for (unsigned peIdx = 0; peIdx < OUT_CH / PE; peIdx++)
      for (unsigned w = 0; w < OUT_COL; w += 2) {

#pragma HLS pipeline II = 4
 ap_uint<M_BIT * PE> data;
        ap_uint<OUT_BIT * PE> data0, data1;
        ap_int<M_BIT> invec[PE];
#pragma HLS array_partition variable = &invec dim = 1 complete
 data = in.read();
        for (int i = 0; i < PE; i++) {
          invec[i] = data((i + 1) * M_BIT - 1, i * M_BIT);
        }
        for (int i = 0; i < PE; i++) {
          data0((i + 1) * OUT_BIT - 1, i * OUT_BIT) =
              bn_qurelu_fixed<M_BIT, OUT_BIT, INC_BIT, BIAS_BIT, IN_BIT, W_BIT,
                              L_SHIFT>(invec[i], inc[i][peIdx], bias[i][peIdx]);
        }

        data = in.read();
        for (int i = 0; i < PE; i++) {
          invec[i] = data((i + 1) * M_BIT - 1, i * M_BIT);
        }
        for (int i = 0; i < PE; i++) {
          data1((i + 1) * OUT_BIT - 1, i * OUT_BIT) =
              bn_qurelu_fixed<M_BIT, OUT_BIT, INC_BIT, BIAS_BIT, IN_BIT, W_BIT,
                              L_SHIFT>(invec[i], inc[i][peIdx], bias[i][peIdx]);
        }
        out.write((data1, data0));
      }
}

template <unsigned IN_ROW, unsigned IN_COL, unsigned IN_CH, unsigned IN_BIT,

          unsigned OUT_CH,
          unsigned OUT_BIT,

          unsigned W_BIT, unsigned M_BIT, unsigned INC_BIT, unsigned BIAS_BIT,

          unsigned SIMD, unsigned CASCADE, unsigned IN_PE, unsigned PE,
          unsigned L_SHIFT>
void conv3x3_l0_bn_act_DSPopt(
    stream<ap_uint<IN_BIT * IN_CH>> &in,
    const ap_uint<IN_CH * W_BIT> weights[PE][3][3 * (OUT_CH / PE)],
    const ap_int<INC_BIT> inc[PE][OUT_CH / PE],
    const ap_int<BIAS_BIT> bias[PE][OUT_CH / PE],

    stream<ap_uint<OUT_BIT * PE * 2>> &out, const unsigned reps = 1) {
#pragma HLS DATAFLOW


 const unsigned OUT_ROW = IN_ROW;
  const unsigned OUT_COL = IN_COL;

  stream<ap_uint<SIMD * IN_BIT * 3>> padding_out("pad_l0_out");
  conv3padding_l0<3, IN_ROW, IN_COL, IN_CH, IN_BIT, OUT_CH / PE>(
      in, padding_out, reps);

  stream<ap_uint<M_BIT * PE>> conv_l0_out("conv_l0_out");
  convDSPOpt_l0<OUT_ROW, OUT_COL, OUT_CH, PE, IN_BIT, W_BIT, M_BIT, OUT_BIT>(
      padding_out, weights, conv_l0_out, reps);
  streamBnRelu_l0<OUT_ROW, OUT_COL, OUT_CH, M_BIT, OUT_BIT, INC_BIT, BIAS_BIT,
                  L_SHIFT, IN_BIT, W_BIT, PE>(conv_l0_out, inc, bias, out,
                                              reps);
}
# 15 "./src/ultranet.cpp" 2


# 1 "./src/param.h" 1



# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 5 "./src/param.h" 2
const ap_uint<12> conv_0_w[16][9] = {
{"0xbab", "0xbaa", "0xbaa", "0xbaa", "0xaaa", "0xaaa", "0xaaa", "0xaaa", "0xaaa"},
{"0xf0a", "0xf76", "0x3ea", "0xeef", "0x99d", "0x415", "0x5f5", "0x991", "0xcb4"},
{"0x39b", "0x343", "0x446", "0x777", "0x777", "0x999", "0xb63", "0x999", "0x999"},
{"0x691", "0x497", "0x497", "0x295", "0xa97", "0xc97", "0x293", "0xa17", "0xbe7"},
{"0x9d7", "0x497", "0x293", "0x396", "0x795", "0x799", "0x697", "0x799", "0x793"},
{"0x71e", "0x4af", "0x999", "0x53f", "0xdd1", "0xbb6", "0xf41", "0xa52", "0x965"},
{"0x4ce", "0x120", "0x220", "0x4e1", "0xb12", "0xc45", "0x6fd", "0xd31", "0xb13"},
{"0xb65", "0x705", "0xa9b", "0x999", "0x777", "0x732", "0x999", "0xfa9", "0x777"},
{"0x11f", "0xfff", "0x1f1", "0xfff", "0xf00", "0x1", "0x10", "0x100", "0xf1f"},
{"0x110", "0x101", "0x1ff", "0x1f1", "0xff", "0x10", "0xf0", "0x1ff", "0xf0"},
{"0xf30", "0xcdc", "0x222", "0x311", "0xa99", "0x534", "0xf32", "0xaab", "0x544"},
{"0x331", "0x133", "0x121", "0x222", "0x112", "0x111", "0x133", "0x12", "0x120"},
{"0x916", "0x962", "0x952", "0x916", "0x964", "0x954", "0xa6e", "0x97e", "0x97d"},
{"0x211", "0xa17", "0xf05", "0x1e0", "0x999", "0xfcf", "0xd5d", "0x6fe", "0x60b"},
{"0x111", "0xf1", "0xf11", "0x100", "0x101", "0xf1", "0xff1", "0x1f1", "0x111"},
{"0x7db", "0x439", "0x973", "0x7be", "0x935", "0x946", "0x7ed", "0x926", "0x927"}};



const ap_int<14> conv_0_inc[16][1] = {
{"0x49a"},
{"0x769"},
{"0x103a"},
{"0xd40"},
{"0x990"},
{"0xdb2"},
{"0x1f6b"},
{"0x10b2"},
{"-0x80c"},
{"-0x69d"},
{"0x1118"},
{"0x392"},
{"0xe11"},
{"0x12ee"},
{"0x620"},
{"0xc1a"}};



const ap_int<26> conv_0_bias[16][1] = {
{"0x69b728"},
{"0x7f25e6"},
{"0x108737"},
{"0x316842"},
{"0x315fb4"},
{"0x1fe9fe"},
{"-0x15423c4"},
{"0xf6d34"},
{"-0x469560"},
{"-0x2caf28"},
{"0x20bd47"},
{"-0xb2905d"},
{"0x2ba298"},
{"0x51221e"},
{"-0x728451"},
{"-0xce047"}};



const ap_uint<64> conv_1_w[8][36] = {
{"0x23fe00f3e7030c", "0x1c9f0100e37f02d", "0xa01a11100f062f12", "0x4f17f2ff11f721de", "0xd1d9f1fffe074250", "0xc10a10f0ff0640e3", "0x50270101f3151fdd", "0x10ed1200f01711ff", "0xdf1912f00fc73043", "0xf1a0031f2149e0dd", "0x9f3d0300efe20f33", "0xf002f1f05f622074", "0x4fc0020023e90fee", "0xa0ccf4f14036d20f", "0x2074f50053f73073", "0x300df10f11f90190", "0xc0e313f07cfebbc0", "0x104c010ffd774723", "0x60e30111e01f311d", "0x7ff70f10e30900ce", "0xdfd51f00102a400d", "0xff00001fc100dc", "0x70140e0002a9bfdc", "0x30df1000f2dd01fe", "0x901df0002df6f151", "0x917e02001e07b271", "0xcf5c00f01cc71173", "0x60f10e0145f312b1", "0x70471ef027b2670d", "0x2511f0eee707fe", "0x906b01ff1d01e122", "0xb16bf200ea523070", "0xe02911011d1ba10f", "0xc0ff11ff0130b032", "0xe10d0f0002ee9243", "0x103d1f1ff30bf101"},
{"0x1001010022711cce", "0x21751301e22b1f90", "0xf1bb1010e0e330ce", "0x3fdf1001d01acd30", "0xc0e4ff00c0f9acbf", "0xdf191211f46b5f00", "0x6fe3fe0f00f60372", "0x401401100fc9d163", "0x21db00f011c0415e", "0x71f3030102f502dc", "0x6005f2001fd0110e", "0x70f4f31030022f3e", "0xb1130eff20e5e35f", "0x913ffc00bedc2c30", "0x402100f020e15031", "0x903afbf0df2ca3e3", "0x903b0ef090c9c9e5", "0x10eaf10fe2fbfea4", "0x406312011429b214", "0x5f3e210011ee0421", "0x301a221124f3c1a2", "0xfff302102f2c4271", "0x1f1030f1fee7370", "0x3fe1130003d6142e", "0x90f500f03e2c2270", "0xc01203f02fee4271", "0x5024140121cf001e", "0x10ed0200ed0fed3f", "0x60221001321e3eb0", "0xb011fd0f9f23c6d2", "0xa16df301ad201b20", "0x70a412f075991b0f", "0x90000f10a007c7f0", "0x10ed020f0c51fb21", "0x700304f056994e5f", "0xbfef1100fd4723f0"},
{"0x30ff21100eb6f50e", "0x501f11005236f140", "0x2112120011eed120", "0x4fd21f10703ec01d", "0x70f62100d5a747af", "0x30e1120f103de4ae", "0xd0dd300022ef22ee", "0xe0f02f0021e251be", "0x10cf2f0011f3f3ad", "0x1fee1f10211e103", "0xe00c0ff0132001f5", "0xb0090e0ff2f1f0e2", "0x1ffe001ecdcb02c", "0xdfd4eff00d199f2d", "0x403ff100300cc24e", "0xff10ee0fdb199e7d", "0x5014e1001cc99e2e", "0x7023041f4209d120", "0xc30ff0df0be19f", "0x300d0f0003335200", "0x6f101ef004e67412", "0xf0de101fb00edd9f", "0x2f0d0ff0f003134f", "0xd0df0d0010e56260", "0x10f1ff01a01efd21", "0xcf000d10be0f0133", "0xb0031c01cece3175", "0xdf4c0010f3cc0db0", "0xc1ff0ff0ffe09f90", "0xf0f00e0f1f1e7231", "0x91dc0ff0fe0cfcde", "0x20d20df0f3d1bedf", "0x7075ff1002547373", "0xb0aa0000ee9fdcef", "0x41e200f0f306a27e", "0x617502000f6f7173"},
{"0x341d0fcfc21cad", "0x60bf1b1fc3f9f4cc", "0xd10f0ef1dfef241c", "0x40911ef093999e9b", "0xf142f20001073773", "0xb13a04105c643074", "0xd111f1f0d11d3323", "0x907be2005e773177", "0x61d2ff1fe3bdbe9f", "0xd01202111efdf172", "0x9022f3011f0fff72", "0xb10ff300fef0127d", "0x1000fff0f02f30c0", "0xd04f0001fe5e4034", "0xe0510f111d1e3054", "0x7fce0e00f4d4ed9c", "0x70b21c0014e3bb9f", "0x60cf1d00e133a99e", "0xa0ee1000e0ca0222", "0x914ffefffecf5376", "0xc0f9ffff1e315e63", "0xf14a03f02f761c21", "0x6051f200326d4ef1", "0x6f0e020004f7a2dc", "0x40f30e0f13c4c3dd", "0x20071d0f129c47dc", "0xb1101ef111bed4dd", "0x70050110ff0c3000", "0xdf0f0f0ef0214e", "0x90490ff01ff39df3", "0x71f70000f2095fff", "0x21e511ff04e3513d", "0x9f39010f2cd79ed1", "0x71270ffff0f9e0dd", "0xe1e00f0000d1303c", "0xa0f901f11236df15"},
{"0xe02b1f000fefdc11", "0x4ff200ff32d04c1d", "0xfae1ef024f12a9c", "0xfc0000fee00e62", "0x60e3010031204940", "0x4fc112001153599f", "0xdf1d0ff121ccee71", "0x10150001114b3e11", "0x1fb3100ff05b599f", "0xa03304003204b221", "0x1160f40f3132d13e", "0x4fb5f0101ffe1fad", "0xaf59f001001e92ef", "0xf1290ff1d00b92bf", "0xa21011cf1c9f90", "0xd1fcfe00100a9310", "0x10db0d00f1ca950f", "0x10e20ef1f0e2c20f", "0xf1ff1d00b0302ffe", "0xe143001ffe5f1f35", "0xf0c1000f00922dae", "0xe00df00fd04fd0fc", "0xb07214101e4d1076", "0xd0dd0ff000aceccc", "0x40ef02001055d1cf", "0x207305113e614177", "0xf0df02f00192eddf", "0xff600010112d30d2", "0x1650f100faf02d2", "0x1133f000310ec100", "0xe13301ff102e0240", "0xf071f30f0075004e", "0x3170f3003f3cd161", "0x40061e00d1f47242", "0x5fee000fe222001f", "0x702d21f013222024"},
{"0xe001f00f011e22d1", "0xe023e1100e3bb21f", "0xe101ef10e1e9e10e", "0x5013d00f32f461e4", "0xc2c7eff0fde992ff", "0xc01fdf0fdef9cffe", "0x410ed10f061761c2", "0x31d5d110ee3ea20e", "0xa11ad0f1fff9bf10", "0x90ec000f2ec75f1c", "0xa0eb01f12ef71f01", "0xd07cf1101017f0b1", "0xa021fe0ff1d27121", "0x60f30001035411f2", "0x11f71100e009b0e2", "0x202cfffff1094133", "0x70f1f0ffd3499112", "0xf1d70001df099cdc", "0xe04c010f021ccbaf", "0x503000f12120fc10", "0x2fff1f00fffdbb0e", "0xa00af110e03eebb0", "0xeffffff0ef334be2", "0xe1fd0ff0ce12face", "0x912cfff1e2f2dff2", "0xa0100e00e2002d22", "0xf1100ff0e2ef0d0f", "0xf020d1012c1703c", "0xd0e0100fff0f9c9f", "0x511c0ff0c12fed90", "0x206f000f22b27373", "0xd0010f014ff0be30", "0xf09f0dffbe39b99f", "0x34020123067475", "0x306ff50021f71473", "0xe19d0f0f0ef9eb0b"},
{"0xdfdefe1110bec122", "0x21dcfb11c0fe0cc4", "0xb02e0ef0c1dc2eb4", "0xb02d0f0010b6b021", "0xc0eafd0fd016cbc0", "0xaf0afe0112c3edb0", "0x1073e40021e5de22", "0x301be2012205ded0", "0xb0f9f0f002c2ecdf", "0x4022fef021ab31ff", "0x70a50b00740d0e0c", "0xffc1c10f113ec99", "0x9029f00feb43d0d2", "0xf6bf40f01b07675", "0x11e6010f70c9ff0f", "0xb1d3ff0fe10efd1e", "0xe1110df00e76bfc4", "0xb06c000fd4ef4174", "0x903cf000fc40cd21", "0xa04bf0f0eb31cc00", "0x10ee0ff0ee14d92e", "0xfd0fe0fd43e0fbf", "0x30b40c0014b660ad", "0xcf020d003e07ffdd", "0x50ff000f23f27222", "0x7f420f1111327163", "0xf0def2000ea67142", "0x1000ff010f0010", "0xf1ff1f0f0010f010", "0xf00f0010f0000000", "0xf00000010100100f", "0x10111f10010000", "0xff1000f00f1010", "0xff1f01ff0f0000", "0xf0ff1f001f0000f0", "0xf0010f1010110000"},
{"0x2f2d1300f117d0ce", "0x7004020000334e61", "0x30e70001101a4051", "0xa0fdf3101f07b100", "0x4ffcf1f111271f7e", "0x6027000015ef4371", "0xc0f20210023e1f90", "0x9009f10f0e35d120", "0x2010ff100230f054", "0xd045010f10df02b3", "0x3a011031e6d3de", "0x1f09f000342723ed", "0x9f1af0010fb2d4e1", "0x91d9e10f3db5d35e", "0x1109e1002fc6d24b", "0x30f50f0f010df30f", "0x1f0dee100f1e5243", "0xf01cfff000094344", "0x901e02ff0ef1a0fe", "0x903d0f010de7e0f2", "0x71c20f1ff209312f", "0x9009f00f1cf7ae2e", "0x20f901002ef60024", "0x70e72100031a5f3e", "0xc0f9101f1d13fe24", "0x70d5110004fd4ef4", "0x7017120f020a6fdd", "0xff4b1e01cc11be21", "0xc10f0c0f9df11c10", "0xdf0c0300ed23c1ef", "0x203e1cffde0c0d52", "0xf0030c00aebe6920", "0xe0edf20ffdc10ede", "0x211002f0244f0273", "0xff7021004105b52", "0xf4f4f115f2eef1"}};



const ap_int<13> conv_1_inc[8][4] = {
{"0x56a", "0x3c1", "0x67c", "0x523"},
{"0x5e2", "0x759", "0x337", "0x486"},
{"0x2a2", "0x4e4", "0x566", "0x6a1"},
{"0x4dd", "0x7af", "0x582", "0x817"},
{"0x484", "0x3c7", "0x64a", "0x45f"},
{"0x4bb", "0x612", "0x7fd", "0x686"},
{"0x33b", "0x65e", "0x497", "0xbf"},
{"0x4b5", "0x50c", "0xa66", "0x781"}};



const ap_int<21> conv_1_bias[8][4] = {
{"-0x5ad5f", "0x218ab", "-0x58750", "-0x19876"},
{"-0x2067", "-0x3188", "-0x512df", "-0x6c12"},
{"-0x5af8", "0x647ca", "-0x2f404", "-0x433c"},
{"-0x6e8", "-0xaf82", "-0x3ce95", "-0x1d26e"},
{"0x5b65", "0x91238", "-0x1a285", "-0xb4493"},
{"0x59bee", "0x1189d", "0xbc73d", "-0x11312"},
{"0x7bbbb", "0x197f5", "-0x4641a", "-0x1ed7e"},
{"-0x881a8", "-0x2d6fd", "-0x29de3", "-0x9912"}};



const ap_uint<64> conv_2_w[8][144] = {
{"0x2c2f002bd0b11de2", "0xf0021efb2f340379", "0x10eabb9610a41305", "0x1112f61f1e73a4bb", "0xe5bc69f7709f7207", "0xf036f614d495124f", "0x2d2114ed2f0e0cf2", "0xdf2d3e0c00f0ee4e", "0x111cdadef4d3d1fd", "0x314f0ddaec32ecec", "0x4e16ce720912f01", "0xf037cff6c0212ea6", "0x2bcfe3e0ee7df2ed", "0xd1dcdf013bd1fdf9", "0x9e2fee4710fcf", "0xf12bf3dc0c0ec00e", "0xf20be46dd54fefab", "0x20f3ffbde67b323e", "0xff5214209dbafe01", "0x20010a3ffbf22fe1", "0x10602fc421ef2bd2", "0xf11b0d00e4f31395", "0x32caeca20fcc09d4", "0x201ba000d2f10ebe", "0xbe54041fdb25064e", "0x2fe01e13e9ef1fec", "0x32604216f2201014", "0xef976f3ff7c721c4", "0x710af904660efd95", "0x3fdd5cef274bf5ba", "0x9f4723ef2a74f769", "0xdf1d0301e90ecdee", "0xbd7114a61b771279", "0xe0e2244dfd9f0ee5", "0x4e5bf1f7ded20d16", "0xa66020d6c012fd", "0x90fc370399f33622", "0xf0f2f31061ff0ab3", "0xe0bef20dc1a61de5", "0xc026fe10e942b0cc", "0xe264232fb6cc6fb1", "0xd02041020c43f1ee", "0x91330a923947354e", "0xf2ef23f0920b0e4", "0xc0effe9fff233470", "0xe0f2d0000d1013cf", "0xff03dcefed0953ad", "0xd0e20414f1c504bf", "0xd2b1ee9c3cedfb3f", "0x40e101f5df2ed002", "0xd500a0f1e92e54", "0xe01521f7e1dd410f", "0x4032cef0de6949a5", "0xd1e00214c09131d0", "0xee510400dedc0eb3", "0x1fe3e0e02043002f", "0x444df2b493c9fd04", "0xf021fddf17467f96", "0x300efecc664fccf0", "0x104e01d1cd60c222", "0x9d0d10d247c100a0", "0xe1efed02311d2e5e", "0xcf0db793ed4fd772", "0xb0fe2c5f139932b7", "0xa1aef7a6573decf7", "0xf0401dffec0dfc3b", "0xe2af1e9230a1e0cd", "0xf007dff20ed0e3fb", "0x9293fb90eafb377b", "0xd005fbd5fcce1427", "0xd1fffd90befb35e3", "0x4030c3f30cc02fcc", "0xf2f71137dd4c77f5", "0x105f5c7532f21430", "0x17060257ef5976e3", "0xd1633d77ff24d644", "0xe7253fd7f32057c2", "0xef7c397d1fef0030", "0xd2d923e129a06fff", "0xf13f43714fe0cdfd", "0x270d64e70dde72dd", "0xd03342745de4cd10", "0x17ddf0e3d3c322a0", "0xa07d407a10d0ef00", "0xbe2a3e2e00d3e014", "0xd13de0ef04bf1fdf", "0xbe0df30de0fe0000", "0xe11412612fe3c2f2", "0xe5eb1f0604ed26b2", "0xc000f26d42e11315", "0x231d29ab9dec39cc", "0xef10d0e21fec1cf9", "0xe334f230f0504e0d", "0x10e220df1e2e9a", "0x14051e5d0d3e0a4e", "0x302d9201c440699a", "0x10c02dd0a100fefe", "0xe0323d231d2f4f39", "0x1237d4402775f51c", "0x14012124c121dee", "0x41240527b37f336c", "0x10e1222e0d332b9e", "0x42a03efaeeededf2", "0xd01ccd030d31401b", "0xffb4efc52233f114", "0xf1ee03f0b302d5f", "0x4ee0d0a4d1e12230", "0xd0212e3deb21e320", "0xde090b4cfba1b9eb", "0xd20cdd130a14f4", "0x9029e00012cf1b00", "0x2020c9fff3bf311f", "0xe2471364e74005d3", "0x13f7c220d210ced", "0x9e09cbf04ca0cac1", "0x2fdffbeeddafbdd2", "0x9c3c00f3000e02e0", "0x302f5a2b039e0f01", "0x70071611e7733721", "0xf14e40f25e5f412f", "0x9ef9eef4fbc0f9f1", "0x40d62b00f3f3cdef", "0x5d631f1e0ddf220c", "0x2f2f091d40ef2254", "0x23523f9e2044407", "0x2eee030d6f1c11", "0xf3ff0713127cfe03", "0x3015f2e0f0726fd0", "0x52e900cf3c2accf3", "0x20fe21e30ece372d", "0x3019ecdffc10eade", "0x1d3c0e3f9ef055e", "0x1100f3f4224f0242", "0x3fb512e2d15232d3", "0x22094fd35ddcedd3", "0x11e31fd3fabf46fc", "0x3e690b030da1d991", "0xd0b41fc4eaaf245c", "0x22fd1de201423460", "0x2fca2df0fc6132d3", "0x10db2eb614fc1624", "0xb01e14ed133f1c", "0x2f0d3ec752d0c0e1", "0xd0c41c012cd6197b"},
{"0xe30251f632103022", "0xc02153f2110f2f1f", "0xf226e067f107716", "0xe12264d36134e152", "0x6ef47dff3f354334", "0xef1d53e14941db9c", "0x1f2f1f5ee32fdc01", "0x2f03c99ff2ed5fdd", "0x1a231d2993eecdff", "0x41a1a991bd493bec", "0x2fbec0d992dcbddc", "0x30bba99aa01a10a4", "0xec9923ece031eed", "0x10ceef1a0b0bfe9a", "0xf1b9c1e020033bfb", "0x1004f72c06044112", "0xf3c1c01d300260fd", "0x3077044037d74270", "0xefe2310debce0e1e", "0x2fea12e00f11fb", "0xffc40223bfcc304d", "0xff2df1f100cf4eb6", "0xe6043131d2c03f02", "0x1063f2f1dd243ff3", "0xb1153eb6dbf20520", "0xf11cbfe3d002501e", "0xb2202ce32da16344", "0xc102e3f4c093615f", "0xe3102ef2e3fe2505", "0xe03793241c065c61", "0xe4e02fc0efddddb4", "0xe11d0ed5f0f1fd00", "0xd3406eb46ddd2223", "0xc03221d540a071e4", "0x4037d9d3fad35767", "0xc12c46f5fea27ef3", "0x2fc4dcd2c10ddec4", "0xfee10fefd12db", "0xf94dda5fd9facc2", "0xfba1d1eda39efde", "0x2f05efc6032ccca0", "0x102e2f420bcfd0e0", "0xfbea13ec90be1ecf", "0x20c0b0030c541cf9", "0x219bffcba69eec4f", "0x113f910314777992", "0xe0ce103e26bfab0e", "0xf02df215fc44d10d", "0xbe7df4b16cf3162b", "0x20c5a74e62ac22dd", "0xaf4f2c020b76177f", "0xf017726b479a4331", "0xd0e13f9e1e15d312", "0x30e50e0ff4cf1d70", "0xf0222fb0c4dc2c2f", "0x112fb3d2fedfe224", "0x42f411ed15df1f13", "0xf0c9ed3d1dbb0f4", "0x52f612d0f10d1410", "0x10ffbac3d4fbead3", "0x424101c60c0d52", "0x20e221e2f214e0d2", "0x63243b41660d4b26", "0x11320cd4e313b2e7", "0x6334ff2d532efe14", "0xccad31f1babe6", "0xc03134ece447d240", "0xf9f1fb0f012eead", "0x336f336112211a06", "0x1fc76ec2f11513b4", "0x7376225152301ce6", "0x126ef3f510f446", "0xbebc2c0d34bd49d3", "0x501e11c221112f40", "0xcf2f11d426ff3c02", "0x403c2190e00401e2", "0xc02e5cff52940cdf", "0x201320b2130552f7", "0xdd13bb0d70f2b10", "0x111f0fcefd431e3f", "0xaf534da527633513", "0xd03e04a00e110090", "0xef3af9da32a322f0", "0xefced2c330df21a6", "0xe160010975dcd0a", "0xff00f1ef20ff3b0c", "0xc157f402077cd4e1", "0xbf1df6012001e1eb", "0xfdfbe4cc4c32fde0", "0xff9000120ecdd19e", "0x20d4d2335ff11312", "0xd102104212231c1e", "0xd0a00ee47ad522a2", "0xf0e741553dd7ed7f", "0xc12203ee1d322f12", "0x10411631d111a30", "0x33d41e652e5f01cd", "0xe0107e412e14030e", "0xf0d32ed7710f10de", "0xb0e64e540cd61e11", "0x112320126d4f250e", "0xd10cf2244b020cef", "0x11335d20af2b1a00", "0xf4f2fe000d13322", "0xd30751530a091adc", "0x1122e9f5fbf44f54", "0x316726ed0ca4a49", "0x3039f2131e3c3245", "0xe11ffe0d0d5dfa7c", "0xe1461cde27e03d67", "0x12dcd5fc02d4add0", "0xf3eae0cdf4cb039", "0x1ff316de9f1c04e2", "0x31e1acf10fdd63d1", "0xe54fb9e17f2d7717", "0xff77633653910e73", "0xcbecc3ce1510cf2f", "0x314bec3c0b3099c9", "0x301224011cf4cfde", "0x109e09f000fd169c", "0x1534c1f1ffd116f", "0xd0330ce504426e64", "0xcbcbb0da47deee02", "0x4fbae5daed32a099", "0x116d22d01eefb0cf", "0x30acfc02de1e03df", "0xf1f01c3022961ffc", "0xf11ec0e10fe0ef3f", "0xb36c1725a2993f40", "0xcfd7931e36034944", "0xb29cd3e2f7b93114", "0xd0162c40ef404cef", "0xb2d0ff3312e0ffcd", "0xf015c0f5d5f2fc1f", "0x9160c5f46e2c103e", "0xffe4c52f300914d3", "0x91a9d497f0634173", "0xc1227ffcdaca2e9f", "0x407fe22e3c1df70", "0x400ee0f4d5cfece1", "0xb4f1dcbb1e1be07f", "0xffed02f2e5011302", "0xe3e4ca9ee0e02473", "0xff2a10f6fd1115bf"},
{"0xbabd1d13125fe7", "0xffe3433b7eb2b3", "0xbee9090b7dd9022d", "0xd00eb0e403ef42fd", "0xd1d00c2001e70102", "0xc005bae0e16fde72", "0xc309df414df50edf", "0x31e0c3f15c52bfa0", "0x95fb2e2479bd3dec", "0xf036b2f5eec22021", "0x9e5f1911d2b250f3", "0x20f30ee4d4700a70", "0x52e9eb1d0e15fff0", "0x31ff0d0f2bf50092", "0x94bc21452bf40bcf", "0x3034ff1513261fc2", "0xd0cd2c3feea210ce", "0x11ee1c2f0657ffdf", "0xcea001c63cad01c0", "0xed91100ee11c7f", "0xd3ef03f49fec60c1", "0x201fa0fe04362edf", "0x1ee037253bb5be1", "0x40539121e1072dd0", "0xf09dedc0211efc9e", "0xe0fc21f0e0f0fc2d", "0xb27bdf21df7c26bf", "0xaffc503d67ac4d1b", "0xc23ae570a27e046d", "0xa0236310e5457fcd", "0xefbce2eed4fd1ba7", "0x20f93111f39cff39", "0xf55fa0f154642555", "0xff1915433cb902ba", "0xdedd93cfa3604b7d", "0xf059030bfc2bcec0", "0x4014e2b0eed91ad4", "0xe00b101f21c2f010", "0xcdeff1e0ddc0bc1", "0x1000be00ea1fa039", "0xf1ce2fcef09e3e31", "0x6f109ecef2601fa5", "0x1e13feae34f229f4", "0xff0a0303012ef220", "0xbaeef6d313924bcd", "0x2fc094ff3950bb3a", "0xf22d31e7be354761", "0xef07223d44f079e4", "0x20b30fe1e1b2dda1", "0x30ffade412b3fd3f", "0xef03fcb140b2e49c", "0x2fe1ef0e2a91ef3d", "0xc230f0311e76077a", "0xaf0d5f2e2e9b7037", "0x9af6ef0e5d121e01", "0xe6371b4dd40fcd", "0x90321e4f7fedcc20", "0x3f27412e35173d00", "0xd1051e207dcebce2", "0xf053c2222f6f1f1", "0xfcb6bf0af617f21e", "0x100e020d20ed0a9c", "0xdfd2be2ae6f0eb0c", "0x2f0f32fce4ff1a9e", "0x22070041d30d2c0e", "0x2f3e360fe4e1d0be", "0xedfec20b1567a23d", "0x34dd3c0c0ecda2", "0xf13d12ef403d00e", "0xf20230df01dfaf", "0x2fe4ed3eeff10b1d", "0xfff2e41abf13b0ef", "0x22efd4d30fde2ec0", "0xc021cd003c9e132b", "0xa0440b0c197de34c", "0xb11e2cffff9e0523", "0x15be1d2223153305", "0xb02f6202cff2ef4d", "0x201fa3b0e39452ae", "0xf11395020d2cffdc", "0x94c7f03e4a466c6e", "0x9f15c306c0e20ca7", "0xd311fb31b7f21913", "0xc0230045ed56a17f", "0x507dec21d0c62642", "0x200f0100003f112e", "0xa12e0ef53c954f45", "0xe0eedbc401f10c67", "0x416ef1f564c02c43", "0xf1df0021f23c141", "0xcfd000f25def1aef", "0x3ff112110a55130b", "0xf5426e541e904cc2", "0xd023f4e2f0021501", "0x111332faf3f31f04", "0x1fd3f512102404e1", "0xfeff106ee01232d0", "0x20de01f42931fb2a", "0xf27f4435de13fe1c", "0x1d52ce24c2059f2", "0xf49337572c53fc33", "0xf1044d031b220c30", "0x4f213224fe051631", "0xff1dfc220b652929", "0x3d0d000f6b15d353", "0xf0f0ff3e2b54d943", "0x121bf7073edef030", "0xc0e0115e3a60107d", "0xcf00cff11b4b1fdd", "0xd1af4660115029e2", "0xc1ebded4e25f3172", "0xe064001f033a2d23", "0x5fbb14a23b4ef0bf", "0x112e94dff40ed1b", "0x15fd1cc67fb1fdcf", "0xfffc273010fef4ce", "0xc3f90be303ed6741", "0xf06e343147e93c71", "0x7d2afff0042f43f1", "0x1fd0112e2c31df00", "0x7e071f9d502ba1d", "0x2f109da2bb29f1ec", "0xd22d7419cfe0ea2e", "0x40bdea97df79d3b0", "0xed70742d15b53f3f", "0x1191f0cdcdf930a1", "0x1c19f4121a61d94f", "0x4f2f510ff0b5e332", "0x1f291f1b29e2d92d", "0xf1e399d01dc4151", "0xff0d1019eac2a9ae", "0x1cd199d1d1939d1", "0x2e3cf4d13d40def1", "0x20f0c0c01e41f34f", "0xdb1a04bfc4112ce1", "0x1c2d1ad1b2ceebf", "0x62f44103e7de5eed", "0xf021271fb7f1fea4", "0xf621de3e7d3f5d4", "0xfdc4fd1ec40ce01", "0x20e32fa606e53711", "0xe206ebf01ecfbf", "0x13276b2647df17f4", "0xd01720f1f3bf2210"},
{"0xde2ec3bdd2f05aef", "0x20dc1010e9e2ecd2", "0x613e60b7152457d5", "0xd0e3244362a21f40", "0x15222ed1571507d7", "0xb001000143f0101e", "0xf020bcd136d329ee", "0x2002f6111bf0e3fe", "0x626afd000315e659", "0xf2bffd63349e4e3", "0x2169dc22c445e47f", "0xcfd10ed1e32cf103", "0xff092341eb03bbf", "0x40df1420190e2db1", "0x3dcd2f229d1f96d", "0x2f0be1f1e1d1fee3", "0xc00aa234ebdefa7b", "0x201fee05f1c31043", "0xffe520d1332de333", "0xc103cf0ccd07f2ee", "0x12e2032df7ff1900", "0xef4bb10dd054e33b", "0xe2c3bf1c26be1929", "0x4c7eeb4fbc2d5", "0xc1ae6df7604307f4", "0xf1f1f1204eb422a4", "0x129331cf006f0914", "0x103b30131223e00d", "0xf2b2f1bcf0910930", "0x11f10224e11da11e", "0xef9e123033f7f4cc", "0xf1f4210f1fc0dec4", "0xaecb0bc26a7fd1b6", "0x2f1d72f11f92bed9", "0x1da0fece59ead922", "0x21123201d9d3ce5d", "0xce14d2cfb043130c", "0xf313201ee0dcd3f", "0x61571606d2531129", "0xe11d500fea2f0d5e", "0x33d4f7f6e54de04a", "0xe01e340f0c30ef6f", "0xef02bd1070d3231d", "0x10d2d3d32b0ee412", "0x9001020fcd012a1d", "0x2fe201ce0d12b120", "0xb3ef0021ee121c3f", "0xf01300fd2012f170", "0xf001ec507cff16f6", "0x3012b1e43ebd22d1", "0x9d0c003b19103a4c", "0x1002c2a21ea20233", "0x9f0dee3ebcb639fe", "0xe0f7ffbc23d1f17f", "0xb0eeff1c01bf4030", "0x21e0060e0f0ffe2d", "0xeec2ffefd3f230d0", "0xe0ee03302dfdf2eb", "0xfd22def3ea1d2ae3", "0xfd37421bdab2be", "0xcdc0fd0c0403342f", "0xffc0142f0c42331a", "0x2d0101e3b32e4ef0", "0xe0dd342e3ee0e2ed", "0xcf0e0fb73cf97905", "0xe03737562ab0a2f0", "0x3dcff9e005176650", "0xeffe776c0f5722aa", "0xfe0111b7130c75ff", "0xa12757532da7f520", "0xede0efc52d0171e1", "0xf147475559c7f10e", "0xe1b120424a1b0b01", "0x20142f3003e25fef", "0xfecfccee4db409c3", "0x3000116efc05ce2d", "0xaef00200ec2359fe", "0x604f164ff0f2c10e", "0xdc11320f490cf2", "0x103f153e15d22d0f", "0xfc90d1df1fffe9f1", "0x3f4b153fe933cf3d", "0xdce1d2f0d02119ed", "0x401be42f0b12c3ed", "0xce1ff4234bec3004", "0x2034153002a00353", "0x1f01e10daf1e29e1", "0x3f5a33ffffed002b", "0xefdf0731db2019db", "0x41fa05e2e200f4bd", "0xefed00dd2dbc004d", "0x101b0bef4ad03de", "0x1411002ce0dff31f", "0x1beb104cd12ff", "0xf22103d9b2aed0e9", "0x112baa1c4cd10cd", "0xdec4020d002ec159", "0xd0ded2bef23c1f2d", "0xff14e02ef23ef11b", "0xe0eecfcdf3411ff1", "0xeff0e21e1e1c100a", "0x1f20b1d0d1331f05", "0xa0e4c0fe0e43b929", "0x30ddf91fa4fe0eef", "0xc335f315ee100af0", "0x1035696dc4c70ce3", "0xf3300f241a217dee", "0x41463a4f6c97cff4", "0xf5092bdbdda3d9f0", "0xff1fffceed5ce193", "0xf11ce2bd5fbbadc6", "0xfc3341fd3213f90", "0xa101f5e03249d1c7", "0x1f27134125e3eed2", "0xd71033232691f442", "0x2060eef01b3ef326", "0x2fd2ec1f490cdce", "0x100da1bb1ebde1ab", "0xb0ad0200c3c2defc", "0xf0df0c3f20dda1ae", "0x47f6002530f13d7a", "0x202743150225f215", "0xf705e1512b03e25b", "0x1f23fbf101d42026", "0xe2d6fc26bad6a71b", "0x202c19b0eb2e019c", "0xdd1b04100c1ff1ae", "0xf10f0411e201de11", "0xe21fff2322db1e2", "0x1e1121ff1f0ff3", "0xf1c1c00f1f1203ff", "0x10ee4222e1ecef94", "0x2b5d05e200efe2b1", "0xf02051effea0c302", "0x4cdccdcdd51ccdd4", "0xefb02ffeeef1e3c4", "0x32999c0dc7fdcd01", "0xcff10cfd142e5dc3", "0xf14d211220340fe4", "0x100e4ffb03eed10b", "0xb40ba0f3234ebece", "0xf00ec5fd223e50fb", "0x97bedb1ee6e1f2fe", "0xd107d6f3d6227f7f"},
{"0x25fecec94903602", "0xcf0bff10e2622d21", "0x6f219fcb29b566f", "0xd139bf24e5120b15", "0xe4bfae1014eb34d3", "0xff2ab0011272e21d", "0x14cbdfb41db951e0", "0xd141e302f01de252", "0x36dc091fdbcd5f5f", "0xd136c10211c11370", "0xf59fb0041e5462cd", "0xe0510501032def71", "0x13ef5004a1c0cae", "0xdf14efe21c10d21d", "0xf029f3f1ca6de96d", "0xf0e4fdeee3c01f3f", "0x21d0cf2e02400fbd", "0xff013cef2d1def6d", "0xd31fc101f1d2e0ef", "0x1f71ff2f1bd0d0f1", "0xe21e0fdee29312cf", "0x3022ecff1ee2d0ef", "0xe330fd1121a703f1", "0x2f64f30ff515ffef", "0xf2ded0d42cfc69f3", "0x303f63f00e21dfc2", "0x25f14ea303cf7f00", "0x207d21013096ab46", "0xc5ff0ff14417f03e", "0xf7eeffe12579dfd", "0x93cc0ec4f0ee5a0d", "0x6f7f4511ed73dfcc", "0x25136ea66ef171c1", "0xe07575415a96e324", "0xe3a202e227274e3c", "0xa17054206c67bb1d", "0xbf4e3a252591f71e", "0xf003a011e37cf153", "0xd03ed4272c3f472c", "0xf1c2e22016fd6ef4", "0x3b2fd2403a436022", "0x202d34221ec2f2e4", "0xe6f412f2d1b121d", "0xffe65f224c5ef342", "0xf04124ee9397d21", "0xd62317270b0503", "0x1cb43129fce559e1", "0x3f010bee1c3c22bf", "0x1e0ee0fd0e3230c7", "0x5fbe30250a0dd0ef", "0xbef3111a9304d9d1", "0x31deedc3fde91e1a", "0xfb0decaa90c2a99d", "0x11a9cbdac4fe4e09", "0x514e3f045d5ce03e", "0xeffd5c000010d4e1", "0x5b74d2cd3b721f3d", "0xfc00ef13bb2eff0", "0xff7223f43e32707f", "0xf1e1f00e1dde2204", "0xf3361303323a0f2b", "0xd221401040dc4", "0xc131f5e40f7b2b3c", "0x21f1d2271cc52ad1", "0xe00404e4f3615f4e", "0xf003de333f052c25", "0xc0f50700037f320b", "0xf10c1214f0233d1f", "0xc0f007f6dc7f1f1d", "0xe210460bd449f2", "0xb0d31422c376030a", "0xe10d0b212ef60e02", "0x2001ea3ea6911e7e", "0xe1d41cf0f44f3220", "0x240df3e225b31dfe", "0xf070201e1e4fce02", "0x4e0b04a2dde5cd91", "0x2ffe1d2e19a0deb2", "0x3f9beb311f1bf77c", "0xe1de0020172b732a", "0x231902326551402", "0xe065403dc74eee7d", "0xbe0a34ef132ffe90", "0x1f030d3ce9f102cb", "0xc3cb1f4e4dcaf1bf", "0xf0f3cde7cf3e4703", "0xa7eac31a2d66493", "0x1f130715f223fa3c", "0xadb9f40051200a90", "0x5ffe0e4be903ae99", "0x19c1b49dceb313d9", "0x219a3f1e30cfbe9d", "0xfabd0f01fa1141ce", "0xe09122322cb0ada2", "0xfcdeae3b00ef09f0", "0x10cdf1ff02f0ecc2", "0xd9f2f6c55322270f", "0xdfdb2724016d0695", "0xd9ec0d0edd3135f3", "0xc09446052e23d2a1", "0x3e09cb2de0132902", "0x11ee0512f32fedcf", "0x7033c0367b214241", "0xd0f61f560047f345", "0xead4de7d2fe25914", "0xa60e11f0b3b1d1", "0xee3ec17be1ec2912", "0x21ff5deeedd0e0db", "0xb2ef04b2cd9e2cb7", "0xf15297f1eed3fffc", "0xb6c75efdc7e27f32", "0x20729621d3761fe0", "0x10bde3d3ffc11af6", "0x20dab02fddb2040b", "0x9f73e43d4c2b122b", "0x13d0f01dd2e2b1", "0x93334606d3721372", "0xb0e4310020522a52", "0x22f4ec4bccf6fec1", "0xd0eefed00f0f016c", "0xae42d92e79e211f1", "0xdfe931ed4ec0dcf5", "0x6bfde71e320e30", "0xd0095220ed51cd53", "0x1361393efed0e1c1", "0xe30ff1fdc11f0", "0x114af3ab400f6fce", "0xe012e2fe70bd1fe0", "0x9e1eb1f0f7d7442f", "0xf025e0b92f5aefa0", "0x901e1031f5eed1f5", "0x20f454d9bdfb9d93", "0xe1ffeea042301a0e", "0xf0ff001c20b00ef2", "0x1629cf02605e02e", "0xdf15ef1ffd70edfe", "0xfa60ac4e21301f1e", "0xe10225fd0e0eae20", "0x94fa00ed0fcef92c", "0x160a0cf0fbce1b1", "0xb5512dd22c391d7e", "0xf06d1705f4600155", "0xcdd6391eeb1e3a7f", "0xf02fd202f33fe177"},
{"0x9b1fe3c301cfaf1", "0xe0c363fe1b5624ac", "0xdd7bb5272474e1de", "0xf016406a7ec1c277", "0x2f4cf420e274d771", "0xd15bfd2243c92be4", "0x519ff2ccdffebdf0", "0x40010fdd45c0b9", "0x4ff09f761cfd09e", "0x122401e4be0a71d", "0xe65feed3ee26d76e", "0x113f0122630c01f3", "0xeb4efcaddd9eba1", "0x10e0d4d09cf2ded9", "0x61c43e9c13e9b9b1", "0x1101f0a2ac53135b", "0x35fee1ccdd9f93d1", "0x302df0c70e201e6a", "0x1fbfc6ebae3ec1fe", "0x1eb9ff0e01c13cb", "0x10d2f2de202220d4", "0x3fc105f20d50e1db", "0x120d3ec133e13f6d", "0xe1f62ed3b6bb2c67", "0xca99a22ba235aefd", "0x20b9bcefed1dc19a", "0xb22c5fe712f650fd", "0x65673bdd15c6d9", "0x62336ba76c9c77f6", "0xafe75015439e5e73", "0x2cdac3d9f3ee9b13", "0x3fbc0fdf0c3d901d", "0x3041ee32130e0eee", "0x3f3c04dc1132d40e", "0x2f11702fcfbce12b", "0xf0c0d1e3145f3e17", "0xc06cccf502601f11", "0xc01c022313f01f3f", "0x133e0677e30d075d", "0xc1e3464f17337ecd", "0xd19d11cd2cbef03f", "0xcd21102ffe2fb", "0xa5a0bf7150ef43", "0x301a00ef3df0a0cf", "0xe43eb5f31d7c717b", "0xf4c71212e2cd6e1", "0x20b203f3d1a0016d", "0x1f1ce1fe32edccf9", "0xae9af0bd229b3e75", "0x302cc2e1eed3fa51", "0xe3eeefa2029f3d63", "0x102cd3f30d62a974", "0x10ec0eddb4af4ed4", "0x40ea91d000c0fe2a", "0xcb40d2f1005b90d0", "0x20ed2d15ffd2cf1d", "0xbc6bc20de17aad2e", "0x2fca0aace622f1d7", "0x7d1f20c2c1f392ef", "0xe1ab2bf04bd9e33c", "0xcee3dfd53e0efdd1", "0xd0ddf4120e00ace0", "0xb11decdf00194cf1", "0x1054174137c56916", "0x2f9cdfa9d1dff92e", "0x5cba1dc432dedc", "0x3030110043d4e2fc", "0x212d10feda71a012", "0xa37f0ee4700a3760", "0x211625363fdf3235", "0x90f1c999054e3041", "0x2f407501101f0eca", "0x4dd913e12b0b4dde", "0x119ed6d20ccf35ce", "0xddd293c39bffbfe", "0x41bdf09de7dc3430", "0xc043ec14fefebcee", "0x214d2bdd011e5bea", "0xfce116c3dd01441e", "0x20c3252e0a3131ef", "0xfe274fc21ff1100d", "0xf13e1ede7f57035", "0x1066d3d0d2321e30", "0x30404e02dc353d29", "0xcb4231f1bec3f202", "0xb09c321dfa30d099", "0xe92712977b26f620", "0xd0d32f5a2ed53015", "0xbf303dece570103", "0xe02b3df00c53edf9", "0x60aff7c1cb431723", "0x10fb1e20039b1b0d", "0x2ee702df3f29320e", "0xf13f3140dd33c63b", "0xfd00a3f15979dc7e", "0x2fff3e315cd22156", "0x1fa101e0c5ef071d", "0xdef101f51010da", "0xea90cf0e91a92d1e", "0xf0c2113dfe31e30b", "0x9debb99c3be629ce", "0xeff14ce6f9b2e267", "0x2002f123d3ee070e", "0xfed21520e2000a9", "0x3c00ed05ebc90b05", "0xd0d0223ab2b1f5dc", "0x3dfd0d056f9329b4", "0xe0fcdf1fddc1017d", "0x41f44b0ee5b23dc2", "0x4f330300f02efdfe", "0x6e41c4ef0d1c132c", "0xb0291fd32b4e1e11", "0x60d017059f44ff74", "0xbffd62ef2b620ef4", "0xa2c13ef1d2fe2c94", "0xf104e1df3e2ee3e", "0xa39b009d7c0f123e", "0xf0101bf30911f912", "0xafdd00942e1c5b52", "0xcf221f13094eeb73", "0xa00e1e050ccb0efe", "0xfdf29e0c3d30b", "0xa2db3db72d9a261b", "0xb022c026eeef2b1e", "0x91f9ebb135ac2700", "0xb1139f12fb3f2960", "0x727cfd3e1c600761", "0xe1df6d4f04de0401", "0x2cefed00671e737", "0x20226f0fcb71d3cc", "0xd1c1ca0f7315e6ee", "0x1f230110e47ff62", "0x5f40c4dc3d50077e", "0xfff013213c0e547", "0x21ffb2dfd35d13e5", "0x1f2030150e42bfbf", "0x11a1010f614dc991", "0x203b201fc123db0f", "0xcd2ff3dedbbc3ae1", "0xc0f51ee112fdec43", "0xfbe902fd09d199d", "0xe12b30000b31c2ea", "0x14ede0013fbbc9a0", "0x21394effdd30deeb"},
{"0x11450b1b2ec6f9cc", "0x3051cf51f2e31e2d", "0xc10023deffbc0bcd", "0x10febc2f0fee429e", "0xf03e01d2dfbf4e02", "0xdf11de1110df4cb2", "0xed022aca4ff53bfe", "0x146d420e3e5217f", "0xfd32f11cf40dfb", "0x10de002f0dce319d", "0x211b00e01c15124d", "0xeff010eef2ba3fc3", "0xaede1ecb3d103f11", "0xf017c22de0f4224c", "0xefe0f3dca43121b", "0xf0f0132e3ec0130d", "0x201c0c4dca27f35b", "0xe010f2cf2ebbffff", "0xff2d1b321dcc50cd", "0xd1e7e033efd44b2e", "0xe5eb1dfe4201602e", "0xd02600530ec34c77", "0x11ea111d333ed9fc", "0x104f0b3d2f11f1a3", "0x22092105b4df4117", "0xf10e4cf003f06ee2", "0x52390d0320d05527", "0xe0ee0de3260c7cc3", "0xd139e21f622f20c7", "0x1f31de010df491", "0x6f6cba4ead1e2047", "0xf00e0030450d12ae", "0x62699c0eabc11c22", "0xf01e102c410aa221", "0xe22af02ee04110e2", "0x512e321dc1df9f", "0xb1c200420df1cc92", "0x10411eb3112dc1e0", "0xe2befe401eb4b01b", "0xff3fe96a00e1cf40", "0x31cfe2eef343a701", "0x4ee034f94bfbce", "0x11dfd20f1df5abaf", "0xf05b23d01c3d909b", "0x13c9e034731e9cfe", "0xff20eb4d2bca9012", "0x4d2e7425e2296f4", "0x30fc402d1fce20", "0x1411c93dd2b2bbc1", "0x1f0c21f0024cc1be", "0x3090f2056cf99ef", "0x210fbbfc1eebee0f", "0x44cd20535460941f", "0x1f12e921ebcdcd2e", "0x336b40ff19bb601d", "0xf10b1fef040054e5", "0x12f9fbc009ed0c32", "0xf0bf6d0cd1213d1d", "0xcf2a2dc3ea1f3bcf", "0x14f3fec0e01d34e", "0x947050a27a79f549", "0xe12c2be1f32b1237", "0x5e4bfdb10a645061", "0xf0ed5de10d201054", "0xed3c0e1d0bf06ede", "0xf4f0f0f1e21a03f", "0x92422d037b1a034d", "0xb03014f3e3130127", "0xee40fd10622f5224", "0xb022023030150267", "0x2e0dcc310ddf2efb", "0xf0aed0d2fcfd1a1", "0x39dfefdffd1f29b1", "0x41121e2c3bf1de60", "0x322e0056939b1", "0xf120263c117109b3", "0x62fa203c501bd93f", "0xfffcc0dc05e02cb4", "0x1e10fb9e0cf3fb00", "0xf0d6d2f1f22ec0d", "0x361f06f62cd040b6", "0xc1271764624621e2", "0x24b12d4d12df1500", "0xdf424b53cec53170", "0xdefb3cf012113311", "0xffb320c3e23fe1b", "0x140e1615325d352d", "0x20311f644171e4b1", "0xe0fb1d30fc10167e", "0xbff63c2131512024", "0x1e0decd4d0cb3da0", "0xff15340f4c212f5c", "0x1121ed23d314443f", "0xf05b153301001b31", "0x40db111029bbdf10", "0xf0fbf30eeedcefe9", "0x3d1ecfd742ef31b4", "0xf3557594e1ec34d", "0x123fc00735021726", "0xa035467f51ae0d7f", "0xf0a131e0f5ce1611", "0xb00c002e01690c3c", "0x301fd015740df1d2", "0x1060ff5930ddc10f", "0x101fd607240ee661", "0xbf4efe790fcdfdee", "0x11f13d2002de0640", "0xc011f24ef62fe0fa", "0x303c4f0c17e0fafd", "0x31e1fd1b3c5e00a2", "0x2115e4323eeee32", "0x1c60c714f29eac2", "0x3f13694d30102e16", "0x1fc2eb2e25392990", "0x62122e10e0bbc6d", "0x4ec1c1050c001f", "0xc1d76f1dea0bd27b", "0xe06e9a90f7da2dfb", "0x107e1fd0f0e557d", "0x41bcc0b7fe30f0", "0xd24004dfea1b2cf0", "0x3f3c00d4ccbe1725", "0x9e3c009e291cfff5", "0xefc42ea4ef9d5104", "0x434e3fabcd20dff4", "0xefe620e22ebe5615", "0xf1f1000ff00f110f", "0x100001010f101f0", "0x1f00ff0f01f0ff11", "0xf000f00001f0f0f0", "0x11110111001f", "0x10f11011011111", "0x10ff001f0ff000", "0xff1ff00f000f00", "0xff110101100f1010", "0xfff100000f001", "0x100010ff1f1f00f", "0x101000ff010f00", "0x10ff00101001110", "0xf01f0f00101100", "0xf0f0000f1000010", "0x11ffff10f0f0010", "0xf010011f110f00f", "0xff001010f1f0f1f"},
{"0xe6f3ed02cf27e1", "0xd01f92e10253d1fb", "0xe1fcdeb9ceca0d21", "0xf3f9193f2ede40c", "0x91fd1d0b942f000f", "0xe1f6fcd0c4f0011d", "0xf12ed5231b4f064b", "0x2f00acc03370047c", "0xadcee01e0a40da1e", "0x310dec9a0112f05a", "0xcf2e3f441e73c333", "0xf0140b1bf044276a", "0xedeb21ee3d23fb3e", "0x40bffe02df73fdee", "0xd9ee21d53decdae3", "0x1fbdeb99bc05f9ee", "0xedec6ff03ffdeef5", "0x11c1cade9a112eea", "0x60200fd74e1dd432", "0xf11004f213ed1e21", "0x20c1fce2703e0902", "0xf164772411b60f7f", "0xaeeccfda0020a9fb", "0x169212cfc43c3c9", "0x11427fe752d1273d", "0xd006022231d210df", "0xdf275ef07df57512", "0xff3447132de4fd3c", "0x9da9dd9b4f5e90c", "0x4fe906c9ef522199", "0x4f302efde32f06c0", "0xe0c0ebd3e1310f03", "0x4e3f03ecb30d62ef", "0x4fd1dbb1035f23d0", "0x1afeccf90c212bf3", "0x61bfb0deffeb1f9f", "0x1ed462000f6b2fff", "0x20daa2afe313119f", "0x10e010fd2dfbc9fd", "0x4096dba1c1121432", "0x11132fe0001d0b11", "0x1000cce101ce0250", "0x460043f50233d700", "0xe02b44420e0add61", "0xbfcb31ccdd1ef100", "0x10ba21ffe0000092", "0xc0f10d29cc393afe", "0x31fdfdc2cfd227de", "0x74fc3f631416d721", "0xf132ec3b32dee07c", "0x30e52b471e61704", "0xcf2be17230dadc1d", "0x9ecf7adddd5c45ef", "0x20d9f311de3def9e", "0xc1c00d0f20c90c0f", "0xe101205110e0e202", "0x1dacf2cf0bcd1903", "0xd120025e1fe5b0db", "0xdc9cd1fdf0a039ce", "0x5030de200dc792d9", "0xf51db3275f264f", "0x1030210f12520ee", "0x10cf0d9225f23a43", "0xdf3fc43ffd25e1eb", "0xf9013b536117941", "0x113f0232fa45b2f9", "0x11022cd4e643f72f", "0xf0e0e0fe11112ff0", "0xd1de2ac646102111", "0xff1fa0031b0610ed", "0x1eee0cb7540d5e41", "0x201fd3f1fd262dbb", "0x1c1f0e0b4bc2901", "0xfbaca3a120db36", "0x413f01f0e60ec32f", "0x41f99b93a44e1dc1", "0xcfdb05eeea5cc2d2", "0xd001ee03feddc16a", "0x934ef51727ff5b0f", "0xdfe727726ff731d4", "0xd4bee0e077302153", "0xf0772f440fd24bef", "0x2ef91efb5bc0992c", "0xbd01c1ec3ef4c9", "0xff3fce9ce64ce32b", "0xf072fee1b9fc7be", "0xd2ffeea2c2632752", "0xcf1064d0f19b129c", "0x4e2e1abd0d1ff5e2", "0xf1ccf3e30c315b0f", "0x2011c62129db11f1", "0xd001f6202ebe323d", "0x42107f3e3fa2e41", "0x203616ff1604232f", "0x3220f50dac3c1130", "0xdf473e022202331e", "0x91a21e095102e90b", "0xefcec1bfdafcc1cf", "0x93d1221d60750fe9", "0x50e7f0e2ef3222de", "0xb21e2009e954cdfb", "0xf10659fdeb1e36ef", "0xfd302ae003addbe4", "0xd0dfbacbe1f22ba2", "0x314ede0217c111f7", "0x19b995c1194092", "0x403deb32c79ed206", "0x20deb9a3defb3bc2", "0xf3d3e0e604750bdd", "0xb0c5213efe6ed6ee", "0x410eeb16103e17e2", "0xe0bb103125c9f1ee", "0xff1cb6ee326f1711", "0xf0351c2f0ff90f1c", "0x16ff5da342f69b01", "0x302711dceafad2e0", "0x34db7e1d5c99aed0", "0xef2b13d71229175e", "0xab422eebc2b276f4", "0x13225f700190ed1", "0x9e3b3e0fc2f02c1", "0x31e5121c2a931ccd", "0x2cced21f93cddb9e", "0x7f3100001e4bddfd", "0x3ced970ed4cfdf9b", "0x60f131190c2d1fbc", "0xf2ce22c40201e3fc", "0x1f0eaf0febb5fd09", "0xddbfde91ecdd2dc4", "0x1000b131db37ac19", "0xd05317f32370433a", "0x10f022e115401e0", "0xf22f1f23ef02111e", "0x1f0effe4d1c3eefa", "0xddef9bfcdde02aee", "0x201f0004ff55ddb9", "0x9f73e6077250443d", "0xf0d6366f34f3e236", "0x21001efc1cc0012c", "0xf00cde15c215ff11", "0xcf0aecfca0c2cadb", "0x401e11f10e14bc99", "0x1fdbe077e9023d1", "0x1257403291e701"}};



const ap_int<12> conv_2_inc[8][8] = {
{"0x357", "0x27a", "0x3c4", "0x40b", "0x3d9", "0x2f2", "0x2de", "0x18b"},
{"0x2ab", "0x258", "0x3b9", "0x168", "0x301", "0x1ae", "0x355", "0x3f1"},
{"0x270", "0x400", "0x397", "0x23d", "0x384", "0x327", "0x30e", "0x34b"},
{"0x2ec", "0x3d1", "0x1fa", "0x2ff", "0x191", "0x3c5", "0x39b", "0x5da"},
{"0x224", "0x24b", "0x2e8", "0x1ee", "0x3a5", "0x2cf", "0x715", "0x4ed"},
{"0x334", "0x2ae", "0x507", "0x33a", "0x271", "0x36f", "0x3c1", "0x299"},
{"0x2a3", "0x1fa", "0x398", "0x1bb", "0x2b9", "0x178", "0x2a6", "0xcf"},
{"0x4c6", "0x2a4", "0x26c", "0x38b", "0x4aa", "0x35b", "0x444", "0x22b"}};



const ap_int<22> conv_2_bias[8][8] = {
{"-0x18eec", "-0x16da2", "-0x1d420", "-0x54551", "-0xca9d", "-0x3ad4f", "-0xceb7", "-0x2abd"},
{"0xed4d", "-0x43a5e", "0x73f0", "-0xd7e2", "-0x23502", "-0x32446", "0x9196", "-0x510c3"},
{"0x12fae", "-0x476b4", "-0x165d4", "0x28cfd", "-0xaad45", "-0xb93a0", "-0x2e1f", "-0xef6d"},
{"-0x47258", "-0x1ba08", "0x1df9", "0x1ed81", "0x5d487", "0x35ae6", "-0x1bd83", "-0x213a3"},
{"-0x6ddd", "0x1208e", "-0x8809", "0x15b00", "-0x1a969", "0x2d880", "-0x117115", "0x2731"},
{"0x22b2", "0x3274", "-0x8f45c", "0xd230", "-0x13b6f", "-0x1d64", "-0x3fd7c", "0x905f"},
{"0x49c4d", "0x2f1b", "-0xbd21", "0x227c2", "-0x54c06", "-0x19caf", "0x1bf29", "-0xc8c8"},
{"0x1addc", "0x155d9", "0x9771", "-0x5a11f", "-0x38c8", "0xab93", "-0x33c5f", "0x1bde5"}};



const ap_uint<64> conv_3_w[4][576] = {
{"0xfc11eb1452ef9aef", "0xf142fda11cc37f3", "0x4bd22af120003021", "0xe0103ffb4f1ff0ed", "0xcffef34c420fbc00", "0xe11ef0bd0911c33f", "0xca12fc2cf6cee71c", "0x60e0010dff170120", "0xa4dd0e5c1ff44223", "0xcc0e40101bd20f5a", "0x20f333e991cdb5ba", "0xc0e20202b71df2da", "0x190dda0c3eefcfd0", "0xdd7f0da21c10fe1", "0xba2a390d261e2420", "0x701e300b0b309cc1", "0xe373eef2103d12c3", "0xeeef714f0af20021", "0x6212e2cc5dfd662", "0x70bfb3d001c5e2c7", "0xe7411d20f9e74100", "0xe13a102330beeb1f", "0x2005510fcfe2b03c", "0xc1d2e00107ba1ef3", "0xf71ce034d5230b2", "0xb2c42fdb34ffe20a", "0xd13f2ce1f2df25ef", "0x602f500f1ef1cbd5", "0xa45102c6de504fce", "0xf009032c3000df1d", "0xd62147f0d4fff451", "0x3fedc3e53fb4e2c1", "0x1311c2c0fb0621f0", "0x1eeef0102eafe110", "0xf9e0c7040f0e1ef2", "0xe0efbdf660f9fec0", "0x1af4dec3befd0ff", "0x2c0cde91df1f0203", "0x6fe110ee01f24fc2", "0x224200b0e51c1", "0x2eca9db4c12ad61", "0x1e6d0f311fb2e331", "0x2a332f0ea2d36710", "0xdf0a0fde120a0401", "0xe29d99fe0c23d1d2", "0x4f3f119350d2c534", "0xbb41dceecc24f20", "0xd00dfd142b520e", "0xe04312e2300a2e1e", "0xb100bce3b31e2d22", "0x3d5400cff6ea0501", "0x70b2c7fddacf3b11", "0xf0379954e0533e62", "0xdd1a33791faf2952", "0xdc7f54f5aee74fc4", "0x1fdbe3967290f67e", "0xe1fecda210424dde", "0x9e30041d7ffa5c13", "0x14e4f7d1b9e6f24f", "0xe00013fc6d31226f", "0x3e134a426fb4dc2", "0x34de21ffb2e20311", "0xb25e39c3d4eabf10", "0xe11593eedfbbceee", "0xdfed41415fc3141", "0x43a2d74dd4d23d12", "0xed404fe1b24fcedf", "0x9096efb77df1160d", "0xe0a204c3c73d6efb", "0x5d4e53fd0d0ef10", "0xd3b205effd24cc02", "0x32f1c0ea0d20e1", "0xef1f11fe20201f", "0x2ef1012f20dfd1e1", "0xe2ffef0ffd0f0cd1", "0xfd00fb100e11e2", "0xff03f001f1120ed", "0x20c0fecf11b122e2", "0x1101ce10fafc1bff", "0x1f9c1ed0029011d", "0xe000f1202eff112e", "0xffe30110f0b201ef", "0x3f2fe13db0d2b1f", "0x10fcf11e1129201f", "0xfbffa0fd3ffc003", "0xeefedc16cc1fdd", "0xe2e1eb13d94c1cc0", "0xeffc2e011fed21d0", "0xfdbab90a23db9b2f", "0x2300fcdab7901c3c", "0xae5f9dee9090f2d", "0xd1de249220f9c1d0", "0xf1ced0e1dfebde0f", "0x6fee0d1ac493ef10", "0x2cc3db11d9390b3e", "0xe1e911a21119e2b1", "0xc311300400dee2f", "0x2c11c1bddaf15dd", "0x4c214ffff4bc02fb", "0x501b15010f0d1fef", "0x1579775c02f144f", "0xc17c7064f9e9b77e", "0xb52c74226736d1e3", "0x11ec44645d161f4b", "0xe1d0dfe1f43300c0", "0xf22111044fba5d40", "0x25ed1f1d50c733d3", "0xd01ce0d314f5f17d", "0xb3c0c96e9a07fa2a", "0x50fcc6d0df24fde4", "0xc6415032cdc1c0cd", "0x4e31fe1dddd3bc", "0xe7c3bb30db07431d", "0x4becf631fff00be6", "0xd74122f7cba025fd", "0xd0514dae50ba1edb", "0xf1133d0be41726f0", "0x211ee7cd02d230e4", "0xc52212e3fbb0e5eb", "0x1142e9e430ce0cee", "0x331cad22a9210001", "0x4f0e0f0ee335cc13", "0xeee342fd0f1fb12a", "0x2fffff04fda0abed", "0xf1fdf31c2015f2", "0x5c13faf01512af54", "0xc1344f15e4073d5", "0x2f320ff6039ef931", "0xdce1c10dee4205c3", "0xfd00c0ce021fb300", "0xec4b222e1dee05bf", "0xf16f0be72ebeeb12", "0x231020f0e9c2ced4", "0x4715ec31017030fe", "0x4d1af1ce2c2cde22", "0x101fe106cf20fcdc", "0xff0f2f06fefcefe5", "0xf307fd60e15d021e", "0x3ccf02fd2e0c4c00", "0x60d2fed7bfaffcc5", "0xefce00ffdfcffdf", "0xeee2b05dde0cf40c", "0x1bf9100f0cf94ece", "0x20efe1c5afa0f110", "0x24f123f06f0fb10", "0xf0622d332f2e1e2f", "0x10d59c1e21f09d02", "0x10121d0c22314eda", "0x1122be0df6a4ac12", "0x1b2fd4cefe4e4c02", "0x2200dcf132cfa0ed", "0x11c5312b2310e0e9", "0xeeffb21794e7ef0f", "0x7fee07fddefecf14", "0x4946702c3344a121", "0x402e03f0ffa1dd4e", "0xf261101d2633e100", "0x206cde2000fd2bfc", "0xebefead51eff20f", "0x5142222e20d2102c", "0xdefe4fef40e3906d", "0xcd19ccdf0fedeb00", "0x1cf20eee5052f20b", "0x3003213134f11d12", "0x1c32fe32eeee911f", "0x2eccfecfcd009b05", "0xdd51457140721132", "0x502cc1c32101b156", "0x13d3fdcfbff332f", "0x24210ddd3b1f1bad", "0xfef122f2100e5374", "0xe1ef162700f011e1", "0x2a0f6ec15af2e353", "0xf3ec4c90dc2d50d0", "0xfa139f0d23327373", "0x1141f147c4c3ee15", "0xef3efd4c6903ee31", "0x3e9fa920e50f1d4", "0xf03c2162f1f16014", "0x303eefc14720a4d7", "0xdb23474f322d41ee", "0x2f93df0bbe52113f", "0xe120f6112de1e0", "0x170f00f1e2c2f7", "0x5352102121c7022", "0x40cd40312f537d2e", "0xd7c2f4e63eee9040", "0xb00133fbf904cfd7", "0x551d3ee3302f2f10", "0x5b011fbf13700afe", "0xffd23de614dd12ef", "0x100cebf00ff20cd3", "0xf05f630e504b301f", "0xcd05fe12226b003a", "0xefe30d213dcf5fc", "0x30e37c002d20b006", "0xc2242010cd00324c", "0xa4e239b3ef7e70ce", "0x901ff3f5f0cef6e4", "0xc0352fe17053fbd4", "0x714aa21d720a123b", "0xdad3deb03d62bb10", "0xedf42c2013c354a1", "0x32e1e3701fe942", "0xe03b1d0e2d1f4cab", "0xdf025c021a1de41f", "0x2c1077f9211d42fa", "0x3ff4dd24ff20f91c", "0xdc270dc1eff01dca", "0xf1c1910eebe9fbe", "0xe0fbf71912fa51f6", "0x402fe2173c2bf94c", "0xfee0f3be2002ff09", "0x1b030e03ec142dcf", "0x1fb2700130a51bc", "0x2012d2e361ed291c", "0x32f031ce20e12f2", "0x2ef2f00e200bdd2b", "0x23f13b213300fe0e", "0xd00fe0d2ee20ec2a", "0x11001effef1dc4ff", "0x2302f112222fde3d", "0xdd3e1fe06203631f", "0x1f21f10e0121df0", "0x3ddd14ff1210f0db", "0xe5fff2e2101ccff", "0xcdfeecedfd354ecf", "0xd0d0f0f3e1e1001f", "0xd5011ef105100f02", "0xfc01f022200ded2f", "0x37042013040dc110", "0xd00e0fc7af2e0dd1", "0x2fe132b3e22fe10e", "0x33512447236d4e2e", "0xffe101d031f5447a", "0xfe03dfdb007ecf2", "0x94c1400503cfc0d", "0xd141ce3a1100dab4", "0xc0e0cecf204f01c", "0x11eff0fefde2331f", "0xe56013421236d3f0", "0xdd0f64f051ffd10f", "0x410f510d43edc04", "0x30124217a03dfef2", "0x7f473673cf47f712", "0x17714bf7797b3163", "0xe730c441677727d5", "0xf152f16311770372", "0x3a0f34ec221c0cee", "0x71f0e5c96f0ff0b3", "0x2e0410c913d4122a", "0xf0e1a0bf31f7f", "0xe4e11a04223eeef3", "0x132f3cb02dbb0f23", "0x14120254f0c421d2", "0x1ede9f044fff4d2", "0xf1e21d12e23c1eed", "0x222efcc32ebbad03", "0x202fff0ffd4bda2", "0xd0fbdbf43f1df0d2", "0xf302133013203400", "0xf320f0c2dbebdd0f", "0xf311e102efd1dec4", "0xe0eecfed2e0ec2f0", "0xbe4010010fe2e2c5", "0xd0df3de02f1bfbff", "0x50ede32ff3b310d0", "0x40d2a90305a526fe", "0xde22dfe2fd0bd4be", "0xf2f21160fed9a9af", "0x1ee9a231dfdfae93", "0xd0af99f740bed40d", "0x10f4f2021f2f00e0", "0xe324e0f00beff9df", "0x22ceff0d0d1ded1", "0xd1949bfc30ded23c", "0xc12423372e03fff6", "0xfd040c71565d09f3", "0xe17121f6d051b1", "0x31f1f10262f755e0", "0xef0f2205fde0fd13", "0x916127dfb2ec9af", "0x3fd92650d5ed0b92", "0xd0ed9c9720df31dc", "0xcf42ff31e14fff1", "0xfe371f6d4e33dab1", "0xf2bf5421f0ee3c00", "0xf1c4cfb123c051ea", "0x40fe22bee3caddcf", "0xfbe42191b60de22c", "0xc491cca930cec1fe", "0x30132d0b3c10e015", "0x3c0f24f0111cb9f3", "0xed2441a0c03ddfd1", "0xd5f3fdd031bdb1ec", "0x10d00d11fa22a303", "0xd12e45c2024d1f34", "0xd0f2122fffffb123", "0xc53d04733115010", "0x30213fe46e00e046", "0x1df11dde34fa20ee", "0xff1101a2f5391f00", "0xc9c1100a15c407cf", "0x2015717cefd40f03", "0xeceb51ef0f0ddbf0", "0xdf201ea0124fce10", "0xeea121c044e241fd", "0x4020fd0cfc151112", "0xfff10fde2efdcc04", "0xcfe3e0ae4e0e000c", "0xe1ef20222ed1d00", "0x200b2ee2fd010e14", "0x1004d000bf032201", "0xb51a1579bd027df0", "0xdd76233b102ee72b", "0x2133230fd5d13d40", "0xd2ed31c103464ee0", "0xe30bffdb3f2e7d0d", "0xf540040c714245fc", "0x121421fe0c6412f", "0xfcfef4a0eecdce04", "0xbde1f09c6cfd1ff0", "0xe4fe01f03f1e5ece", "0x2c2ef10bf12cd1", "0xefefdab2f0ff03be", "0x740d13412ebde0e3", "0xff0213fff01e52d3", "0x3f3d2cb6e22bf1f2", "0xd2f6ed0fe91241fb", "0x430dec9045ad2ed0", "0xce012db1c2e5b241", "0x10fc0ff304cffe33", "0xe1f232e3223100f", "0x304ce4fe14bb3c44", "0x71d4efbf3c415ee", "0x20ec04bf0ee32242", "0xe220fe259d3e22e2", "0x3fef326eefd1a1d4", "0xb0f11721103bf0b2", "0xa0f102c7d319c2f2", "0x3f07de2fc10f211c", "0xd7e4cc13dc03deaf", "0xc3333772127414df", "0xb1fdfff7d0e6dc04", "0x1c0101fc5711f351", "0xf13f0e9f00db72cb", "0x530f30c2223240a", "0x1019cc9d13e1d121", "0xd20e1111f3003c31", "0x4025cca43c12ee1e", "0xcbee00fc234e529f", "0xec02eb551de5f4", "0xf20e3f2d200d2b31", "0xf00300b5db54c1f4", "0x1dc2f56c01434fb3", "0xf0c9e1d04042be11", "0x2f2240ed45f2ef31", "0xcf01ca95231e241f", "0xf41c3db35015c1e", "0x301abe00f2f3c0ff", "0x21c2300211dfd02f", "0x257c2075f40dff5c", "0xebbd0f0f70234531", "0xff1e4e0fe0e4192d", "0xcd2d42303fdcdae0", "0x3b0ef00be19f02af", "0x1fd1e900ea2ee9fc", "0xf1dafda4ddf900e2", "0xdefd0ef00f000ddf", "0xf1f2100fde930f0f", "0x32250f020d0cfa0f", "0xd1f01001d0fa0105", "0x7467e462f2372741", "0xe66a3c37297b3134", "0x97191555725747f4", "0xe06e027270471679", "0xcaff0e041cbf9c1", "0x3bd2eef9449931b0", "0x5de01efc4dc6ecfd", "0x10fafda2acfcea5f", "0xdeefefcefbddddee", "0xc0a4dfe0ef91cbee", "0x3e020f31cddc0dfd", "0xe0032f01d10a24c4", "0x46f0bff00e14226f", "0x32e110f3dd1030b1", "0xfe2de2eefc1233e6", "0xe03efd105041df43", "0xed01f0cf65dafec1", "0xf3e01efd23ec00e0", "0x210000ecb1b1fa0b", "0xf0390fbebefcfc20", "0xfc1ec00ec015cee2", "0xe3c3f31ef090eff0", "0xedeffedabeadeef", "0xd004eee10d19f4e1", "0x3926c3fa05e2e3e0", "0x1d197fc9e60fc1f1", "0xf1032ac2c5dfce1c", "0xf1fb1eccc1d3e3e", "0x192609fd132ce6f2", "0xf242740bdd1cf2e1", "0xb4f02c6234002ed3", "0x2fd14ccdce4d3d", "0x3f2637fbd630d1ef", "0x9def0da2de1aef2e", "0xf3fe2d17310e5df1", "0x41fac239fffe111b", "0xe4cf11a2efd1a11", "0x593b40ee1eed5ff7", "0xff0d1c33b6c2e2d0", "0x100ec6dc9deeee12", "0x4d3de0113a5119cf", "0x3f1210310cfe3613", "0x11901e3515ee4092", "0x3010d26ba9e2ed03", "0xf91400f0ec02e9e4", "0x2000eef0fbec5011", "0x61ad4b513fdbfecf", "0x4069f31be0f310ef", "0xcb2a151a7fc149e3", "0x1f062fee3b000e06", "0xace3e1f002efd21", "0xf3eb3e5ced00d32", "0x2df9f02e7cfbf901", "0xf134f1e00c4050dd", "0xf9ad464200011c4f", "0x21eed43e3b210ecf", "0xcecafe503d0239f0", "0x30379d2c4f3e66ce", "0x3b9c521020b10a1f", "0x3f6912201c02e226", "0xfd101c015fef1c22", "0x4f5f2f7de1efc22e", "0x4fa11daf31d0001c", "0xd00213e124c35022", "0xf1103de25f223c21", "0x7d4f0d60bcdef311", "0x60b21ab10c210dee", "0xef2006e070ee43f1", "0x30e02ae12b015e10", "0xe2e2c7ef90cf300", "0x6fb1fcc03ee2ee4a", "0x905f271172f202f3", "0x1fe20b0f700dcf42", "0x10410d4b033ee14d", "0x42a13eea1ff12210", "0xe02f070034e26042", "0x2ceeb1b5ff0ce20", "0x3c4fec3fc29cc020", "0x4ea00aba1c3d1efd", "0xc0df23e1e0da2fbc", "0xdd2c1c3d0ff020", "0x2b240d3fccffff21", "0x40a2eacc3d0dfe5d", "0xb0f0070f20de1bd1", "0xf0f01b4075eecc11", "0x2e520c1dec100f1d", "0x36dde92b2302fe3d", "0x2af6f2efd41110", "0x2f013b0b3f14a03f", "0x6c6cfd0df4bdfc5e", "0x4fdef9a9433fe1f0", "0xcf0df7e1e2bd3fec", "0xfee33e0f2212f24e", "0x5e70fd21dfecf072", "0x54911bbb5116113f", "0xd123b7fb1fa13fef", "0xff21c01d20d04e21", "0xee3e03eff0dcc1de", "0xfdcfbe41c3017aa1", "0xff0f1434e000311e", "0x23131112efb4601f", "0xe333e13001f525d", "0xf3b990ed72d0fade", "0x20bcf65f0dc3e9fc", "0x323d2efd0ec1defe", "0x2f2ff3cfed3ece2f", "0xbdecf6d42f000dd", "0xbf2fd20d07ed0d", "0xdf11140df9f4011c", "0xeeed12dc1adeb210", "0xdd0df00bee11c1e", "0x200f7f671f607deb", "0x2be216021a3905cb", "0xb6516bd7f9797253", "0x9719edab71cec7e7", "0x70e91f712b521efe", "0xeedf2eeeebd2cf1f", "0xdffef1f1f519f37", "0x2be90d0f34ed29ff", "0x20b03f950d05a0f1", "0xc0ef2f100be2c44f", "0x301df13ffe0fea12", "0x1bdcfd2004e21f0d", "0xcff24e00ef5f3fef", "0x3f02ee0e1d2994f1", "0x5c750c6f99793db5", "0x9c1f20c104e19626", "0x101c6e0c107200fd", "0x1bf1122fd0df1130", "0x1b3ca04f0d44a1b5", "0x1bec3e21e50f9b0e", "0xf0e2fec2fe553ecc", "0x1a37d04e0f3cf5fd", "0x9b4c6114fa6d9e1b", "0xc24e7522f425b7c6", "0x4fda335762620f0a", "0x2dc1d1edf7212f9b", "0x103ef2e33d7e5a0f", "0x11cd22e131074520", "0xf02dfdec4c039f7c", "0x12fef2ef4d002bfd", "0x111229560eb0f1ef", "0x7303dee3d131cbfe", "0xf0e0111bfeeb0b11", "0x6f3e0c3eb04c0775", "0xdb0e00210922ebf4", "0x2f3ae03013d2c1c2", "0xa01d5e3e77435feb", "0x7db4f31d650fe079", "0x2224fbd3ed63ebe5", "0x4ecb0eef6204f023", "0x402cf2135de6de30", "0x3e0043fd3e21fec2", "0xe2de0beff0eeef0e", "0x4ffbafaed10d1f1c", "0xf01cf1f1fbccfff0", "0x9da101b1ae134c1b", "0x20012201fc2f4603", "0x3c132c9fcf22101b", "0xff0110ce9dfee9b2", "0xbff1d4e12013d110", "0x1f1f1c3254df5d2", "0x4af14b9100e44e2f", "0x514f10e1afc019a2", "0xe0dfe0101d1011d1", "0xf4b1e0321fde0511", "0x4dfcfff0cfee2fde", "0x104ee001ceed20b0", "0xf030ee02c4feee3f", "0x1212017c02c000d0", "0x453d0123e1edfd02", "0x3fcd6ec2311b24df", "0x4e720d4ebe7ba761", "0xd25a210faa2eeee0", "0xf269317ff3a3e7a7", "0xee7f71567146da", "0x70b0d11f0419de5f", "0x56f2e2dda70ee07", "0x26e9fe202d271527", "0xf0f103f031c7967c", "0x2dd1bfe2ff1fe53", "0x1f22f31f20ca0cf0", "0x2fa11cbcfe4c3b0f", "0xc1fbfe0101af3d92", "0xb3ab190db2020476", "0xdc605ce2bf02cf3", "0xdc249bae9da2afd", "0xc0093fcb71ba30f0", "0xd29d021f13d0ed7f", "0xff4b2bef051b113", "0xebc35aab110bcd4d", "0x1af0a0f2a220e4", "0xdfa0eddf3dee10db", "0x2cde1ef1d1cdf322", "0x122f0112a5f43ce", "0x3020101cb0bf1aa4", "0xdb01b0e2ee05fa9", "0x62defc02d2902003", "0xb342c104da4e010c", "0x102a30c49dee0b04", "0xddbfe2f12321dfbe", "0x401d1d01f5ff1e13", "0xd3e210031f00220d", "0x21000ed2adb339c2"},
{"0xc0f4f4f13be0541b", "0xee231a2f1d407f0e", "0x2c3e1216f0243330", "0xd012cd100e1f9bcf", "0x2ee0fcd32a200f0d", "0x1012ef31fe6e4e2f", "0x2dfe423e000675f1", "0x200d220cef13ef1d", "0x1f2ec00c041dbc1e", "0x4b0b11315090f40f", "0x3f133e1b10efcdee", "0xfddbfcff3dd220c", "0x1e07ccfaa9d2c7d0", "0xc5e32b02bc2df9bb", "0x1a7e3033ab30b4e7", "0xf0e4eda7da6dbd13", "0x5ff5014be32204f1", "0xe22e22e1bd5912f0", "0x150c2de2d05675c3", "0x301b05ab00d2b131", "0x13fdd2fd15f20e4c", "0x2edce41f11c09411", "0x5e02ebac3e0f9e51", "0xf0bda2dad3cfd110", "0x3022ebfeefdec727", "0xe1f2be2efcad0ddb", "0x429bf3631bf251e4", "0xbfdc1e97fd2edd30", "0x711ff22b0011de20", "0xdfede0cf1be2e0cd", "0x42fb11102233df2e", "0x20aad4bdc1e1f32d", "0xe1ef02ece0021a1e", "0x1cf9b1dc33feb2fb", "0x1123ee9b110e9373", "0x3ff0dbc4cfe0fd", "0xdbfe507030b5bea", "0x22c27f32ed33356f", "0x10f02cf312f0f024", "0xe0e13ee1ee21f1e7", "0x36f132d20039d0", "0x2a3c21300e7c212d", "0xdfbad0e7f3b21bc4", "0xe0f45fd4dff7a1fe", "0xc2232f51a0e2dab", "0x1c311506607ee51b", "0x1ffdfe0dceb161f0", "0xd0e05cdf1c1fe1d4", "0xdf1dfe117fd03e1", "0x17e5301ddc54122f", "0xf252b1900dafb23a", "0x3f470d1101e0f41e", "0x1f041012a7b515cb", "0x60e0ff13e7fe340", "0xab2fd2a013b1ce1c", "0xfff70fd7d00100df", "0xfc1730221bf13ded", "0x212ded40151f03c", "0x1c4e10c1e0242e", "0xb023fffcf00d0022", "0x1040b00cef3222df", "0x91edf51e404010d3", "0xa44f94ff1bac1fb2", "0xf107ec023ef3e52b", "0x120dc310bc1f930d", "0xd7dce2a1245d02f3", "0x9ef1beff30c242d7", "0xe127bff20007d1ea", "0xf133e25ffdf2dc0e", "0x1f2ced06c3d40ef2", "0xeaf1ee5ffff302a1", "0xf0601a1c4ee3b0ef", "0xd12e4f123d5f011", "0xae6f6cf52f54e53d", "0x1f016fe1f520f7f3", "0x50b277fb02462dda", "0xd917f311d3f5d23b", "0xa57c0e55317eb162", "0xf2c030dd76f7772e", "0xc0ee1f3df027052c", "0xc00013f12bfe0c23", "0x1cf1fefff2e00dcf", "0x3e320e1d013f2d2f", "0xd10ddee0003c0ce1", "0x13ed701432216b7", "0xb0000e132d6b0fd0", "0xca70d320e2d3c604", "0x40f40f6170220ebe", "0x664eb6f1d02e3112", "0xd7ffefe71b7a22e7", "0xb239d6326fc61707", "0x7b1d607f27173b", "0xcc0f1100501e2af3", "0x4e01100e30dc0cff", "0x1e0d1f0c03f20cf2", "0xf019eefe023afcdf", "0xe2002e002ef2fef", "0xe001fd00f011f001", "0xe0e203f4d22f0114", "0xef001fd110ccd012", "0xe0201012ff12f0e0", "0xf10110d4f140fff0", "0x10011ec4df223111", "0xdfeef2ee0f1011", "0xed21f1e01dfef1f2", "0x1e1100f2222cffe1", "0x2210ecff1ef3ff04", "0x101afe11202a0d2f", "0x643f101e20f02ae2", "0x190e451eb1c3d1e2", "0xd7fecba004ef9243", "0xdf17ee1deb122fd2", "0xf64feff1bf20910", "0xd6433d0bd3dcec", "0xf1cceb150ee2e1d3", "0xd025def2eb216dd4", "0xf517e12dfa003b52", "0x557342d12f251a2", "0xeb1cf067012313e3", "0xff17cddf1c21eb35", "0x3f1ff14d2dc241e4", "0x1ddf3cffe00c120", "0xd2ff92be1fe3c04f", "0xf015e05bbcf4220e", "0xfd700d12ff123fe2", "0xc1f311ff1e01dcee", "0xa11cddf010d4f0b6", "0xf0030f1f1b362f40", "0x7774e15f1e447130", "0xdf5142150c16e304", "0xc17fdf46171440a7", "0x5ff1111cfe11fe5f", "0xf10322df9132100", "0x30141feef219220", "0xde1ec5be4fe30420", "0xf122ff1b1d05121d", "0x2f32edfc0c0222fe", "0xc5c11e0ede20021e", "0xebd0c13eece1e0c0", "0xa0f5d1212f030211", "0xff51ffed4cc211f3", "0x1f004d10ef12e3f3", "0x292eb301e5cf3111", "0x1d50e2f00032eed", "0xf1cfa00e1dd1f0f3", "0xe5e0cce12fb232bc", "0x222c042ef203bf34", "0xe00d33e1f1010f00", "0x2223ae2f1fd21113", "0x3f19510db011b1", "0x570d314d14ef9111", "0xd1fb0412e0f21d1c", "0xef00f3d4cae5e262", "0xdcf43ce353025201", "0x32e3231033e4001", "0x3100f10cfef52ff9", "0xd0029611e13550d3", "0xf3adff23524633a2", "0x663c24330fc2ef54", "0x201cf3d331d412f1", "0x16349703bd1470e3", "0xb2b34e32466122b3", "0x570ef45013b3c035", "0xd022bf273001ddd0", "0x16bfd703efd46421", "0xd7b12fb2537f64e4", "0x36065330d2246de", "0x1075ef612005dfeb", "0xe3f4c01f0121eee2", "0xe4bd3d1e36403fb3", "0xe74f1fffdcb24e10", "0x31ec501fd1d39", "0xf114912f1ec0f2e3", "0x93e41cfb13424cf2", "0x75e2f3bfbd252d5", "0xdf16fac72ffb1f04", "0x11eee14f031cde00", "0xd30029ec0f724ed0", "0xc77e7000ed0162ee", "0x100630e1231b10ff", "0x201c0d0f0011c911", "0xb50ccd1f1f5a04d", "0x1cee6fef00c033ff", "0x2f0b000514eff21c", "0xbfff10e0b11eadd", "0x1d2e1efffa50c20", "0xf42f03f1db1430", "0x50fe30f020ccd517", "0x1e60425f1ff73d1", "0x31f17332ee0b7ca0", "0x976f10172ec3cd46", "0xe0c1fb19eef0adb4", "0x202ced1214bf4e", "0x5352c00003e2de3b", "0x2dcf4eeb1fbd0fe1", "0x1fccf4e103ee01fd", "0x21c0b92030f4ee20", "0xffe0f1cf019fc93e", "0x1e3222ece1bde34e", "0xe5eff14db051e", "0xfdc1c9d7af2b05ac", "0xd7537d7091ebd9a1", "0x927ef0d3e672f717", "0xe0f10a174e5fe91f", "0xc40b2efd10efa301", "0x115fcff2f2e1033d", "0xfdeee0cbf1fded10", "0x302eefe2f2ef21e0", "0xd0f1dbf02cf4c10e", "0xfcd1fcee1ed1bddf", "0x44d10fe0d3faebfe", "0x10fd15cc412f2611", "0xd06efc5cdedb3dd", "0x2ddf610e9eca99c1", "0xc54e9711a31b30c6", "0x200ed3d71deff2fb", "0xffcce0e34401e5ad", "0x2be1feb30b27ff2", "0x27e1ddefa306e03", "0x7ff3520f1ffcf0e3", "0xdfa1ddf23401f302", "0x3c00d0b32927eff", "0xea2e0ec2d94e4cfe", "0x6f0061e0f2e93ef4", "0x1cf1dfd163f30410", "0xf2e102ed63c36c2d", "0x1ef03bd31c103b1d", "0x413251ed24cd3ff0", "0xf12c21c3254225c1", "0x2ce1fec21914dd3", "0x3f310f9adb3e0d11", "0x2f332ff0100c2103", "0xfd2ffb4041f26f0", "0x22a000eb04924de2", "0xfd320f9ecb6afe2e", "0x20e2001e04fa30f1", "0x203d1a3533025df", "0xf3ee021e22c230f0", "0x2d121faf1d2ef01e", "0x1130021d22ea2112", "0x43024c2251f2200", "0x31f00f2e01b063e1", "0xe473ca0eb1fcd10", "0x30253203f0dbe0e7", "0x21120c314f1200f", "0x3eefe43d05a45fe2", "0xfe152eb0dd5ce021", "0x10f2042104e90035", "0x22f4d1ff421f321e", "0xf222f450e4d641e2", "0x1fe45ca2ed72b044", "0xc032061c00ea5024", "0x1df4aa00d0e2af55", "0xd321dccff3ec2b22", "0x1b2102ed0bec2c43", "0x2021d12e122e0de1", "0xe1cdca2df2fec540", "0xf02dc0e102e03e32", "0xce4e46a1e7be04e", "0xe0104e40015e2fe0", "0xdcefb0d1ff1fd4e", "0x1033c3f0c1f11b31", "0xbbb1a2094d5e9e64", "0xe0f1102f1222e1fc", "0xdfb11fe2bce0ae1c", "0xb204cc03610f4e7e", "0x4af01229004d5f25", "0xef1e3511e1f01ddc", "0xedd31e2020e4a92c", "0xcd4cfdf420a1397d", "0xfd2d405d03422110", "0x19e1b0d0e30ccd", "0xc9a0fcfd2de62c00", "0xbe6c15d02db03a3c", "0xdefeff3b34040370", "0xc10c4eaf012010eb", "0x1e020705a00efc2b", "0xbc1023d71a41416e", "0xf023f73f2f3ef423", "0x411cf173cf073cdb", "0x2d123a0514c731cd", "0xd1fc20334d1e3b3e", "0x2b41f25ff32e2040", "0xe0099fc7c0a4ecf0", "0x2022200ed3075301", "0xef3ff6d30fda3f1b", "0xf342d26015456354", "0x210cddb101bdde32", "0xf1202bb24e0f2034", "0xf13e32c23ea2011f", "0x2102200ff23e035f", "0xf00b0c124f0b1013", "0xf2eff70faa3334af", "0xcff37fa41900c60c", "0xe02d1d2e01124d7", "0x1fd07141f1e17ad1", "0x300d3704b90304de", "0xd7d2ceb5d12b0b42", "0xc49c1cbc7f0671e1", "0xf05e0e3fe00fea21", "0x1e223d015e1c1d3f", "0xc131f16d1ece10ff", "0x220f52fce3d0e1ec", "0xfff9fddf1cce3123", "0xf000f10ddc79b3d2", "0xba2d19e3996991f1", "0x9f7ca71b01fed6d7", "0x40c97d5d27267e9e", "0x4c0c220e37491ead", "0xf22e0ce4bb69bed7", "0x9da912c06de2b602", "0xc07c0e4f1627d159", "0x2e1fcd4e2f202120", "0x3cf21403f2de100d", "0xb21f2125d04ebb", "0x10dfde451cdf01f0", "0x1d000be094f32122", "0x4f03ef61bbc31101", "0x5e3dfef404cf3ae6", "0xc0e27ffe15d3f2e0", "0x33412f55d26d3d", "0x2d030f00b2a7cd23", "0xbfa0af3e2e40c31", "0xfd2dd2f11070610", "0xff32f12edf11efe", "0x1d01fe2d01ec30f1", "0x12f2fee20e100a0f", "0x10e21f0301cce0ef", "0xefedff25f0ed1d", "0xf0ff0dfb1f9032dc", "0xf4d20901be0f4ad0", "0xc0f021b211a9000e", "0x103eef1d04ed2e31", "0xbf22200e02c1f150", "0xf1d11dff210ded5f", "0xd1e420df30b4d224", "0xde103ee02feafd0d", "0x5300de2cf4d000cf", "0x4f0ffdf1b4ee001d", "0xf000de32e2eafee1", "0xfe0ce70d620c0d2d", "0xbbe12b19fa9fe6cd", "0x3b206c0193e953db", "0x70e0531f2e397cec", "0xe57c773b55337f0", "0x927d7f37397de171", "0xa7f977e07737c705", "0xc0ed5c707147123a", "0x2f1f3d001ff310f0", "0x12f0112bf0e0e1fd", "0x1cc0f0fedffe031d", "0x1fe233efda1f1f", "0x1dfd1cfe610deef3", "0xdcaf2d290d9cb1e0", "0x2b70efbfa0aa3eeb", "0x303fcc2b0f593ce1", "0x1e0ded34e6644", "0xb2f0ede6fd6d1ca3", "0xb34bc23ff2f1f737", "0xd03f0d517247433c", "0x10f21111030e0b33", "0x5feddbd10321013d", "0xf0e962af00d7f1d", "0x60d004f5cf3225df", "0x1b2f0fd4bf3bffe3", "0x11e22f62d32f342d", "0x295fe51f0f3e62dc", "0x701dc137bef2f2e1", "0xdd162ee1f01905e1", "0x37e71d724d422633", "0xde5df316047160c3", "0x310fc1279112eb3c", "0xf0303435062cda20", "0x13fbfe9f04130e10", "0xee00d2bc00ffc412", "0xc03e230eef0025ef", "0xf2e0f1342209da11", "0x6ebe01dec530ef5a", "0x112db4eee021f5de", "0x1f1ee2e2e21e05e1", "0x2ff15fe03059bccf", "0x73c733f3ef3dd420", "0x1559c573d46f74c7", "0x301dd4f7bdf301db", "0xff1d4206331cec1f", "0x2f2ed3cc70102c0f", "0xf413711ce333c021", "0xf02dd21afc1e4303", "0x1cf0202250fff32", "0xff9ca6bd4410ce5e", "0x13031fd9b31ec2fe", "0xc0ee03ebe21e5302", "0xf21bb0fa0d11ee36", "0xfdd1f7e0fae6dd3b", "0x43211070ff019154", "0xfbf61a331274ce", "0xe03b9edae126edf0", "0x4dfdf92231fdeb21", "0xce31dffb1cb21c0c", "0xe0ef6fc5ef00feea", "0xd2e2fedbcee20fed", "0x632d092024e3cb04", "0x10e3d1ce2cc1ff1e", "0xf0f622132f2d32d1", "0x41201ee93cb0b03c", "0xd240bbec06f1e00e", "0xdee1edcd3fe30f2f", "0x50c37601121fd2ff", "0xf022be5d01120fe4", "0xe4afcb0201f7be4", "0xdc1bd0141ea6503d", "0xc03c60c150f0d450", "0xcdfecf9020e510e2", "0x302b1c2f210310f7", "0xf0f032b43f2e417e", "0xd1f4f311f1216dd3", "0x1d2e1dbe2014d010", "0x20ecf1df1fe2dc0", "0xcb0c2fd23202f25f", "0x3f1032ee1f1f10b0", "0x5fe31b323dccf350", "0xb4fee2efe0e7ff03", "0xdf41bcc4f1e0d0ee", "0xe0ef02fe50dd05e6", "0x3bf12dff3c10c402", "0xd0eed32f35eefff2", "0xe1fbd0030ee3f251", "0xf0221201100ef2e0", "0x91d2defe252d3d3", "0x303b246034dc4ebf", "0xd2fcd3123f03023d", "0xd020e23d40d310", "0xe1f2ea1f0b30ad1e", "0xd2f10131c1e1fd5f", "0xf0f200fedd215113", "0x10ee31243ffef11f", "0xcc0ead0d012bbc1f", "0xd32ef0edf544cdff", "0x1bc2edfd90f24000", "0x20011fd5422715fc", "0xf0f0fe11bef1fdff", "0x3fa02fffd1a2d2d3", "0x21fde149d1edcf3", "0xfffa0d23f11923e2", "0x124ed40031de69fd", "0x33ffff7eecd42005", "0x1fd6ee2d3d0f3c4", "0x10f214c1d1bb2d1f", "0x2467f471e1f0f233", "0x17f73753a0bfc1f", "0xd40f701e663ee3e4", "0x50cd351beea76979", "0xcd2031be24dfadf1", "0x5fd1cee323900dfe", "0x3cd03eef7bde1c0e", "0x20eceacf0e1f220d", "0x3f0fc2d1f7f270fa", "0x4211e1fe32a4e013", "0xe02ee0e0eda226", "0x1d501d3be2901d2", "0x14f0e713f12e44de", "0xdfef5fd62d6df1a4", "0xcd5ee5075f12f517", "0x20041e7e1c43f92d", "0xeff0c3ad67eddb00", "0x32d21bf5445d2de0", "0xe1ccb0096ce22042", "0xe15dec943114c540", "0xe02edf035f0f031", "0xc24f401f0f57004", "0x3e3322fdf011750b", "0x40f754fee22f4e22", "0x1feedf0c0f01df3", "0x92db430fee56204", "0x3d0015e11020551e", "0x41d3fd23f4042", "0xd2ffee16bc0f0f05", "0xea10d250e223e105", "0x1dfe4111eeff3f3", "0xf0361f12c4212022", "0xff1110111320fd34", "0x4a4fef233ee62ef1", "0xe12325d0131f430d", "0xe62f0ab02f3113", "0x1e55df46c11f6f44", "0x2e3e327deef24cfd", "0xfd5f52f1e1021203", "0x20151c01035d6054", "0x1376cc459efd0266", "0x173565fdf33ec2d", "0x91ee1453f2f6d134", "0x31f500e033110071", "0x1f0f3331f74ed004", "0x2efad432f3021e12", "0xdf0156b11d3e5edb", "0xfe52c3dfe120310", "0x3072fe16c53d36f7", "0xe1e157e2ed03dff", "0xc51f52d0e92f1dd6", "0x1103ef120f002056", "0x7552ad07a3024764", "0xb020057dfd333004", "0xa71133a132f2ef36", "0xf0e5fd0e3622de74", "0xefc126b100d2ccf2", "0x43d7cf54014feede", "0x21d94d53ed3a5cf1", "0x201bdb1bf200aed2", "0xf3f27f04000c100", "0x1f47127ffe7b21bf", "0x2fbef42712327f50", "0x40220c1f314ff305", "0x1a2d31f2411cfa0a", "0x2d0721404a7a022b", "0x11d3e227101d4ee3", "0x20af190c0f70c1ea", "0xfdfe22fbf20beef3", "0xebfddbf1ff40f2f2", "0x3b022ee3ff1e03af", "0x10c0dcc01250e3e4", "0x340c321030fb3db2", "0xede74ef23e721532", "0x30eff1953dffcc03", "0xe0a74ff6d03f220d", "0xf3fe2de3f02c1b1d", "0xc0f00c45f5db26c", "0x1fe1ef9f14f0cfa0", "0xc0914cfcd240d5d9", "0x2501d6d1efdd215", "0xbbca4094fd42350d", "0xd04d1d1e2fd2fd7", "0x60fde0e1115011e9", "0x33eebd100ff02513", "0xb41d0e902e1fe110", "0x10e39c9b0f9db2b7", "0x31071003046f3f19", "0xf3e14d10110fc300", "0xe509eea3571eeef3", "0x1fdcd0db0d91d3a6", "0x1ce3ff2110f29", "0x4f43f44cf3fb1e0c", "0xef42300ecfe1f06d", "0xd2929cf614d10fe4", "0x51029df02aa5dc62", "0x440304ff2f1dee1b", "0x2e50fdbe24ffdc3b", "0x3f5edf053c1f1c1", "0x10e2ffcf1c92db20", "0x121315031e5de00f", "0x1ecf19005efee3a", "0xe022af3e3192f1a4", "0x50102cbe4ded42e3", "0x3f6207120dfc5eec", "0xbee33321ed0321e9", "0xb3c2d24412f20a32", "0x20109e1219b6db27", "0x7543e7c310192ddb", "0x1c122fe11f4bd30e", "0xf7f3a1514751ebc6", "0x1f20f0df0992e944", "0x21f24701c259e3ef", "0x2a6effa210ed055a", "0xf5159f096692e4c2", "0x10e061d2fdaf3e42", "0x1d15f1e5fb1cf10f", "0xf2e652e2dd20511a", "0xd503d223dec0ee44", "0x405dfaf02d01ee15", "0x23032ed41d39eded", "0xd3233e0bcfbf20c", "0xe6c2be63bf042cd6", "0xd03e1f1e0cdc0af4", "0x25d21603d53c4fde", "0x2d7f30e24f4d3739", "0xd500922911a214e3", "0x204d22fdfca10f24"},
{"0xdc0c100fa2e2a0b0", "0x3301dddfaeed920c", "0xfa1ef0e1f5116be2", "0x301019063f30a20c", "0xfd50cdcf5fce9f01", "0xf51f5c70ecdd3f2a", "0xdd0f52adf4fc3dcd", "0x10de13f501ee2f3e", "0x2447f06f3ed99d04", "0x33001d7110ce6f0b", "0x100175b1516c0d0b", "0xf0bf32e4f0b23c5a", "0xd92effeba114e3f3", "0x30e5e1f1cc22944d", "0xfcf0313013f054fa", "0x10e1fc171210e2c0", "0xe046c540d23d33bc", "0xe0b31d001c1c465a", "0xd3d1311deb0fbd3d", "0xb1a210eefdef59c6", "0x47115413cffb1f0d", "0x2fab5f65413f1002", "0x7ece0d27f2e9c54", "0xb0d231fe990319d5", "0xfc000e11f133f0f0", "0xeb43f131ee4ee3ec", "0x5de21f321ad0012b", "0xf1af4e03210031ed", "0xb1e6af0ed13d44ee", "0xe00050cfe21a03ff", "0xa6020fddfc20b347", "0x1fc63b0c390e1dec", "0xecd10121ce0ef21f", "0x95013ff1432cc2c3", "0x941fdce2ccffc6f7", "0xe1771310f930dd02", "0x33020b0e4ee633fc", "0x27de000101ddf2f2", "0xf11df7ddfe15f34e", "0xc120f033940dfc27", "0x2550e21c2eff0adb", "0xe2e5f3f00e1004cf", "0xf4c0045fde254332", "0xe0fb4101b9402f6d", "0xd40efdd5cedf252", "0xef03dbbc4d11e134", "0xece3ef010f21f23c", "0x3090f20f1e4020ef", "0x3cb133dbbf9eeceb", "0xd7c4b2feccd7f243", "0x20fdc0321e36d136", "0xf0d1c3e20c10b512", "0x315d2feb0faf5d2c", "0xb3c204d1ec11e141", "0xdff61f23ef342103", "0x20f2f0ffe900d060", "0x3a4efe004cf43f2f", "0x1b7c600f2002cd03", "0xc1710aee3b31100", "0x10021d050fd11032", "0x2becd0dbc5aa392e", "0xcfa245d0d9d4d321", "0xe6ebfae2d02b9034", "0x1124d0e9cb0eab0b", "0x1d2b22d3339c5d3e", "0x2e137740ade2ae02", "0xb1123dd7c300e6a0", "0x10474520dd0fcdaf", "0xfa2dff107bb425e3", "0x1d3c6b6efec44ae2", "0x5f24210d120766d3", "0xd0c00d1700b0f110", "0x21fe200e4e41e13", "0x1ef22d111e25f3fd", "0x24f2d1d222fb4ebf", "0xb353cf10c31000", "0xfe0000e0f4e2b1f0", "0xf2efaec1c20fcc1c", "0x2dffefd0410f6d0c", "0x41d30ec21ee4dfe3", "0x135fe2fcaef0e20", "0xe011e2f21ec1202f", "0x111ddeffae321e13", "0x110f12f29e210", "0x10edd73d0b4ff6c1", "0xec0470c7f959c713", "0xbc3fc1f0310ca6d7", "0x709061691e2479a9", "0x9ed1602f70016f0", "0xe7ffdb07ee79cd47", "0xc6a914fd720437d7", "0xd01c1f301a47c23a", "0x40f2001fdf02e6f", "0x3b2f1f10f190202b", "0x3ff10130a02c2e12", "0xf006bc1f101910c0", "0xf1eefc011be105", "0x41f31e42fc2ce2f2", "0xb97cd0b0e1cf1ef7", "0x21127e0921425adb", "0xe1f3df11e1f93cf2", "0x42e0fb11fe4eefe6", "0xbbe93c00f2a6bf27", "0x17f3f211d17123b", "0xf1ff0100c13f42", "0xefe1051f393e11f", "0x102c1022213e3dd5", "0xf1f2efb2e1e91be0", "0x101001ff000100", "0x10f100f0f1000f0f", "0xff10f100010000f0", "0x11f0001ff010f010", "0x1000001f100f0", "0xf000010000ff00f", "0x1f100100010f01", "0xf01000000000f0f1", "0x1000f10f1000101", "0xf00000000f0f000", "0x101011f00f0f0", "0x1ff001010f000000", "0x101000f01000f", "0xff000000fff00f0", "0x1010f1f0f000f001", "0xf1ff00000f010001", "0x10f000100001f00", "0x100f0f0f000f1000", "0xf00ff00f0000101", "0xf0100000001000f", "0xf0010000011f0000", "0xf00000f0f0000", "0xf0f00f0f01000f", "0x1001000000f000f0", "0x11f0001000000f", "0x11000f0000000001", "0x11110100100001", "0xf01000f011f0000", "0x10f100f010f000", "0x100f00f00000000", "0xf0000f00ff", "0xf000ff000010010", "0x11f0010000f", "0x1000ff100001ff00", "0xff00010000001001", "0xf0000000110f0f0", "0x3d05e5ed32101ff1", "0xcf157bdc19ee275c", "0xfa3204c0202d5ff", "0xc0afe0fbf43f7cf3", "0x1e035015e2c4e321", "0x9f1e27423e04b304", "0x22e4c4494260c5c1", "0xe0d5d209b30d4cf1", "0x3d144d1311c0f04f", "0xb01331442ffcfeff", "0x1dd3ed2c442e3296", "0x20e9133cc23f1ef2", "0xfc07c40e4e0ed414", "0xd5f0e0c0ee9eee0", "0xe4cefa3120eff1e1", "0x30d50cfcc12b3a31", "0x2d3101402f1ed072", "0xfb51144917613ed7", "0xe1f4f2e72fff02b2", "0x30f7e30f934d4c20", "0x2f42e9314cbc943e", "0xff216d0ded6ffda4", "0xfbc0d9ff230ff0d7", "0x3002f421c20e0b13", "0xef11f1fe291e44f6", "0x5f41c1d0fdd1f22e", "0xf0b0912349c02ee", "0xe0031f0c111070c6", "0x4c20301a1a139f03", "0x1f50f1cdb37e6b2f", "0xd21b2d36009c2303", "0x1007ed11062d4116", "0x32fcfe0e39d0d61d", "0x33f04ecffd714e15", "0x9b309f20194e12f", "0x35154111e1ed0e", "0xd20c1c4115dc2f33", "0x150bef11b0fd0d00", "0x3ef03ee41eedc032", "0xe00fe104def010eb", "0xb2100000f5dd11f0", "0x7ef11131e110ee0", "0x2310eece20fad260", "0x10f3131e0c2a02db", "0xce32c230cdff0500", "0x175f01a10f332d2f", "0x11fdc9cff1b2d44c", "0xf013cee00e52d60a", "0xe10cee1110f92d2e", "0xf5ff2ff1c6ee0e0b", "0x6ee12cf4eaceaf71", "0xbf140103c0cefffd", "0xbd0b1d2323ea1f07", "0x172f205e02ea1a0f", "0x51ddfcaffcabd071", "0xb04201e1dfecf0bc", "0xb25ed01404090727", "0xf72e12513d045ba0", "0x11fbe9f00dbeb140", "0xe015fd2370f2170b", "0x4f2dece1e1ca0163", "0x13753240bdf04eee", "0x100f3e25ecd2b173", "0xb0f726dcfecdf300", "0x2fedf9d604ffd2e3", "0xe5713b21ef1e6cee", "0x3fe400f13bd4154d", "0xd143201191fe3222", "0xb2cc0bd7451fade5", "0xd51ced6233ba39ae", "0x13cb0dd21adeee03", "0xa05e42efcf0e0f1f", "0xd05ff00143444111", "0xb2d017131eefffd", "0xc201020ff0ff4eef", "0x312cd21cf0e05e20", "0xef203e0237200f14", "0xf03303301140e1d1", "0x15402e06e0f23010", "0x3034f12ede441de5", "0x2f1d0d1f3012efef", "0xd23fd231d47025d6", "0xed123ee0e2ef113c", "0x5011f50d0e3410f4", "0xee341b1e1321f221", "0x112d036220ceff00", "0xe1e1100e2e0c4e0f", "0x110ee11f0edf00d1", "0xce44c22ef104c131", "0xaf6f7420102f95e0", "0xf00031503f400e0", "0x71f37605b0660ddd", "0xe9d4f00da425b00c", "0xe57dde24227eb273", "0x21ef4fec64165219", "0xf0f1011fb1370512", "0xff11fe1e2201e10e", "0x11c0030043df1e15", "0x42df32dd112f4fc1", "0xd1ff000d0e9ff0dc", "0x117fd562eb1326c6", "0xdef242f1116e01a3", "0xde4dd443e3c2d304", "0x40e220675f025cda", "0x7f53d63fbe3220de", "0xe60ecdd7ef7fc2f7", "0x7e9c47172f6b1d3", "0xe15e3b541ce7150c", "0xf104e14eb632e70f", "0x3c0a509d2f21f111", "0xd4f4111e0ecffdbf", "0xfe2eceebfb02d1c", "0xfd03003194b7923f", "0xdfec1cee15d2fa05", "0x1de3e10e13cdc0bf", "0x62013ea3ef1d0d", "0x1e060a1f01f2c0eb", "0x63f96e9b1fe10102", "0x33c3c35f300f3ce", "0x20331120dbde2ff0", "0xe1f0d3fedf600090", "0xb01fc31f256a0300", "0xb5200271eab11292", "0x7111fd393f3050df", "0x411ee21daadfb1cb", "0x7fff9efe1732b07", "0xcaceee3f0d96131f", "0xd021fd2d36f492f2", "0x202e121fddf02f0a", "0x13e14ed1fd105132", "0xebe32d4cf0b71101", "0x102c0e50e9e0c23d", "0xce11d93f922dfcf", "0xb20d670ee0b4019", "0xf92cbadbe0be337d", "0xd03bbe2f633fe4c4", "0x2d01d692ebeab04c", "0x3713dc71e017bfd2", "0xe9fbafeda7912f42", "0xf0edbe1175f2d6f3", "0x20f2b2e072dfdb1a", "0xf406f152c235e013", "0xde0fbadcf1c5070c", "0xd01cd2143bc3b241", "0x10e51feacfece1d", "0xfbef3e440f2f141b", "0xf4facf15f04c7e21", "0x200ccd37ed2f31c5", "0x19cf2002d912b1b0", "0xb7002bb7ef7f3412", "0xd22ab417df411ce2", "0x113fbe72bb05bee3", "0x2cc0e96b5113eef4", "0xbcd0df1d2111c2e1", "0x140cce22d10f9e69", "0xf0d95203b22ff200", "0x4f01ff0a03cfe102", "0xcdfa3bb3f3f1c33b", "0xb463e40f322d5110", "0x11faf9060d50b0dc", "0x3922f01cee29f4d4", "0xe3490c92b03baecf", "0xbf4b9321e1315116", "0xfd1d023e64a531", "0x2cf12b6c16132edf", "0xfedaefe205cfe4ef", "0x61d012ed2f42aea", "0x401b541ff04ec301", "0x4dfd92bf3009a021", "0xd3f90ca00f02de4e", "0x24200f00112301e", "0x102f323230d0c3df", "0xd2d04ef0330e2e2", "0xf129ed924f2c9f3b", "0x152fb4010127412f", "0xf153114016d13f", "0x1d2d4f0ef555f0fe", "0x1ef9d0e334051331", "0xf101d2212011fbdd", "0x10ee310e133f2411", "0xfd110f0f36d3d5ce", "0x37fdce9132f2fcec", "0xdc2192fed10d7e0b", "0xf002ff340fe11db3", "0xe040d2cffc1e4fc", "0xe7f01dd1f1f3ff0d", "0xedcfbd4dff011fd", "0x110f111500c20ee4", "0x1202cee020f234ea", "0xb71f004ffd0fe4ef", "0xddedbb02db1fed2d", "0xd003660f00f02105", "0xed12f55021ef20bf", "0xe242ec95f27f400b", "0xe2fcf2d13d1f4121", "0xe02c105ccb45dfb1", "0xfe232e20cbdee1db", "0xf1222d1fa36ff92e", "0x13d90d2b1cef0e6d", "0x106e21fdc7ec25", "0xf20efd230c104cfd", "0xdb215e0d11e4c0c3", "0x31409a00daceed2e", "0x346df22f012c1e", "0xec1e57016b7919c1", "0xf9661ef7105961ff", "0xd22c31123edc4264", "0x19de7a4972f4c4", "0xeef3101fb1af912", "0x3942fdc0057ffd23", "0xc61c5e0e2ffc3ee5", "0xf06d0df13d105ff1", "0xf30001320ad4f9fd", "0xf93fee3e1ee2d203", "0x160ed0e11fd3bed7", "0xf0015d12f11f5bef", "0xf0ee5c232c0fc1ed", "0x102efe1ef3c32dfe", "0x12e0ec2cfc13dcce", "0x1dade1fc3dffcfa", "0x1e41d7431eef3d21", "0xccd010fec921d712", "0x11637de4241b2f13", "0x700163fde007ffef", "0xe23fd1fff4fe3d01", "0x43e1133df242ccff", "0xcfd00e0d1eeff2f", "0xa0ff0fd4def609d3", "0xfcc5ac07cd20bdc", "0x21fbce0edc0ccfe", "0x4fe2e2f9df11effd", "0xefbafdecb1feda02", "0xd71e764fe6e4727", "0xc07f7e06094af640", "0xfe5c7207474fe7f4", "0x70b155707f7721cb", "0x4e55e20c0701f13f", "0x2111b03d2c6deb16", "0xf6cb0333432206d2", "0xb011fbd75c27e07d", "0x3ebd20c03a141eaf", "0x40e29efedc202ee", "0x19d1d2bbfd0efb1f", "0xdf2afe2100ddd1e3", "0xf07003eef34d1137", "0x402f4e222d2b0e00", "0x1f3d1befe5ce4c2c", "0xe1100bf9535702fb", "0x24031edff0def6e", "0xfd2f10f1d11e03f", "0x30f12ddfe5edfd00", "0x410cdd0d32223efd", "0xf203efe1beff141f", "0xd33010f0203e300", "0xf0d0ffef0b101cf2", "0xf0d00f00e1efc0dd", "0xf3e31c02ff0002f0", "0x110f0220229edefe", "0x12f10df0ea2e2edf", "0xfae042e1f90e0d", "0xedeed2e10f1be1f", "0xfccff30f100f1ffb", "0x1102fb00eddc21ef", "0xd00612e2f122f030", "0x2ffd0d10cecfdf0", "0x302100e2e2df11f1", "0x10ff210dfb01fc12", "0xf0ffff03e1fdf1d0", "0xc0ee4af12ee2cacd", "0x2300cfed23922fde", "0x34e12f0ccddfceee", "0xefda0e05c1d911dd", "0xebf6a73fe3d00070", "0xe06d70f0cb5ed63b", "0xfd0073e63610050e", "0x41e4760d2f17f21d", "0xf01ffce1de0e0dee", "0x531f0fee02c02f1f", "0xde1d02edc010022", "0xe012eff2d2dc01ee", "0x1ffd5cdf41e3eadf", "0x3e3de1cfd9f1ece", "0x5f12e4e99bede92f", "0xfcaef9da0b900ff", "0x4e7f0762007d3307", "0xe15b5ee5f97cf514", "0xe17c34f7771107f1", "0x6045537c5e772229", "0x4de1ac13914fd0e5", "0xee6451fefffa0c1d", "0xc7634631122721e1", "0x309ed10e0fe6dc00", "0x2daf1ff2dffd11f2", "0xfb1e0faf064deecf", "0xfa543ddb1ddff0fe", "0xf19a0ff400e1e101", "0xf2d102e211f0f653", "0xf3deae233411fc0", "0x3f0bcbd021f10e2f", "0x1cbf1d32fe47eed", "0x6c0e26f3cd1a2dcf", "0xc34764551e797740", "0xa743e606f32652a2", "0x4ffde37b0f579b4d", "0xaeaf1fb1d1efa0d", "0x4c1301dbc32b04ce", "0x415fe9fc23404efe", "0xdbc1d2f1f5ac11", "0xfa1fff1e2b23f670", "0x7c4d2ed4f21edef0", "0xf42e0cd0f352403e", "0x2039d01e2f02102d", "0x52ef253f3d29ebb0", "0x1f3340032b1a44c1", "0xc730ab70b4e2cff3", "0x3f2ede6e5f51e30e", "0x29b9f02c60f2fe03", "0xe0fe1f3bc4fde40e", "0x6c10bda9f5e9e93f", "0xc0efd1c312e49293", "0x202d1ec90123c302", "0xf13bff20e40edd10", "0xd00f21dff2ee2ef0", "0xd03d2d0d4111fee0", "0xd93e072d350e6a1d", "0xff1e6d5fe0b1d6e0", "0x2dfffb10d20b3000", "0x700b23e0ced3242e", "0xf51202f3c7157bc0", "0x3f0d52113e332040", "0x31ee02e54111de71", "0xd0f0f0e1ebe5e9fc", "0x2ffefe3f16b3e", "0xc12f04012102cdd1", "0x19f4f23111f01e23", "0xf11ef001fe2bfc2e", "0xef21d1e06c0d0fde", "0x9aeb7e10f9ae13cd", "0x1a7fdebcde2d552c", "0x70edbe15fd3e02de", "0xcb379220c644469f", "0xc7d1ebb23b79eda1", "0xb5599321cf71b407", "0xc033cc172f659f7a", "0x332e20bd222d0e0", "0xeddef30df3be1cd1", "0xee0d12c2ce0eece1", "0x11200424f0fdec2d", "0xde20091d343cf104", "0x19d05221e2ccd00d", "0x41d0edee14f0fdfb", "0x3f09d2cb0320fe2c", "0x711f0aec053ef613", "0x1000dd21ae90ae11", "0xfddb017cb12ed2e3", "0xf1fcecd043ed06fe", "0x53f12010ad100efe", "0xfee30144ef91f11d", "0x1fbf2ec1ec312f0e", "0xe00fbe2e12fad003", "0x1011e212cded1e01", "0xdccd02eb55f001f2", "0x1e001d2e311f1ee5", "0x11e053f62ead44fd", "0x1e5317d303c470f3", "0x71df522b124b1610", "0x1efeefed2fee6eca", "0xd1f3f1e1e2e5eec2", "0xff2010a211e131fc", "0xe5ff34fd117f143e", "0xf1fea0ef70f1ee0e", "0xe0d5dd0dde27f01f", "0x61fef45d1d2ec23", "0xdcd13dc31e1c00e", "0x21d0eb2c2d1f0ee0", "0x400121e50fbd53cf", "0x1e1105d414f0f3f3", "0x51ee76201d6e2f1c", "0xd513ea50f603633", "0x4fa7dc62ae14b106", "0xbe310f40d1f12ee", "0x3701d0fded7b7450", "0xdce0e2930c47f302", "0xc1632e51a1279ef1", "0xe3001a540ce3fa5f", "0xfc3dc4f033c1da2c", "0x12d20db9121fcd0f", "0x30f5e20f03fd30ff", "0x1f40196f30eb9420", "0xf1d7ed1091df9eb", "0xfd1ffc0df170175f", "0x50f04cc4fd259219", "0x4c254d0e2f39f6ce", "0x220acb0ccc5cedfb", "0xdd54c1fbf07fc527", "0xf1d360cfe0f7b354", "0x311fc227fc4e210f", "0xcefef13e0c4ff10", "0x30212beffcf9043", "0x1fc1c1ed02ff3b0c", "0x37100727fc213c30", "0x10fef374efbf2dfe", "0x32e0aad03c109f02", "0xd121121ad30b291b", "0x31130e0f2bbb0e", "0x4431e67613e92ecc", "0xf75052c20ac2f", "0xe149ffd110000919", "0x1b2400dfdb2d2721", "0xcfcd2d96efa29240", "0xe511af0dfd9b0501", "0xf000f1cf460e31ca", "0xec21b3effe16f23e", "0x91dd2fa42f93ad20", "0x11ec9db1c99414b4", "0xf02cfbfa2759ee1d", "0xde1cf3e2f53efbf1", "0x130f67634edfc1e", "0xf3e130e00ca770bf", "0x793bdf10e13b40", "0x931f1efc0ef2633", "0xf01fc10d2beb331", "0x4943d22feff971de", "0x402f09df663e45d1", "0xfc12ddffadf2e55a", "0x912000ceb0c4fe3f", "0x79e196fed99045b5", "0xffed3920663e34f1", "0x2b41604014130b2c", "0x9e20ef02e3b1ff20", "0xeb0b01cf0c672b0", "0x49ec2e25b23e44"},
{"0xf91134e13e0b4e10", "0xfef60b4152d164d0", "0x6fe4fe31034bd720", "0x10f1e2fdebef1ede", "0xef20efbdcd3f3611", "0xd31f3fd010c0e60f", "0x44c1f241efbd22ce", "0xd011e4cae11231be", "0xbbd3ec0d90f4d11d", "0xf7e1fbef15940244", "0x213e43101cd110ee", "0xb0f3c21d044d21e0", "0x3a4e62de421c2ae3", "0x4b2e2f0d24eef0fb", "0x7e0292def72c132c", "0xf1efb3e10cdf0d1f", "0xca5effb29d6f1423", "0x1b10d5720fe2e209", "0x60d00442c7dcd1a0", "0xf003e11b525173bd", "0x390b0e319e04f75c", "0x26e30e000df70d02", "0x5cdae131fe95d7b5", "0xb0b6b632556006fe", "0x2c0045044b2c13e1", "0xed0ef0c5341fd2f0", "0x4fe1d0bfd24cda52", "0x1aa2c4c3df4ce2", "0x1bd150e00d4020f0", "0x2c11f6b3423b1cff", "0x5de2d0ad2e5d1e42", "0x116aa33021d130d1", "0xb90d2edd9e19255e", "0x21f304ec14f6cccb", "0x4bcca2fd1d1b1231", "0xf100b61443ff3ea1", "0xee2d2cff200e3dcb", "0x492db2fed10d9e1e", "0xe060bb3111de42d", "0xf0e3fefefecd01bc", "0x40ed30d0221323e1", "0x7f0311dde2f0f22c", "0x2e17fc113fbf3331", "0x40045c1c12dd5cdd", "0xe1b0ad4f2100dce", "0x42b3c0ca00f1f4fe", "0x32f12f3dd34020", "0x1002f1e60ffb1f2f", "0x2f201dfc4fef4520", "0x1b2cebeeece0cdfe", "0xfd03dde0f73cd459", "0x1f1117edddef14de", "0xecddffb02e10f4d1", "0x201920c2cbed404f", "0x3224f3fe1d0f459", "0x4f7ffef410200d", "0xacd0dc421f420dbb", "0xefebecbe11ccdb1e", "0xee09335aaff11c4c", "0xbf0f22b4032dafef", "0xde755df02e04e365", "0x4e1160d1eeee0a02", "0x45319f2b35d5000", "0x2f0ad61b170005e9", "0x9c17d030dafee4b5", "0xa4cc7b61f2dd2bd2", "0xd0125561addbd3c3", "0x1d03fc6406eb293", "0xe0d6ad709ee01fa0", "0xe0f6193fbf01e9a0", "0xdffeb24dbcceaf97", "0xc0b3b42f3fe1c6", "0x3ffdd92d0fd5fe2e", "0x53f112c5ebb1f03e", "0xee2175c223ec1fdd", "0xa0d024b7015af0e3", "0x2fc0090df1131bff", "0x6edee3a60192c04c", "0xf9215cac0cfe113d", "0x900f24c1e56904df", "0xd031bd1100602f4", "0x203dd25364d11b1b", "0x1ab14194c6f3633b", "0xcfee20e1054b15d0", "0xe11cee3e1423d1ef", "0x13046492faadff0b", "0xf50146eef1faeae2", "0x1ce05c5257a33b0", "0x42d3cf6decd7112b", "0x11110fa43ba3a03d", "0xe6ee05dd040c9fb7", "0x91f3c2253770101e", "0x42e61b254eb5312e", "0x24f2f3e131dd6e1b", "0x1dfef40d0ff264e1", "0xe0e0b443f514e061", "0xd00f961e5611fffc", "0xf04fc21e19fe4ee1", "0xe4abf315f1fdaee0", "0xf04c3db404d13e5", "0xfece965ee11e2d19", "0xe0cd04f41ef3100f", "0xa6bcd2f72bed9cd7", "0xd0c7c35a7573e7d3", "0x5392d1643c90ee2b", "0x25df3e2f4b5d0edf", "0x101eb1f5ffdfe201", "0xf011e4651321d1dd", "0xe42112220002fdf3", "0x3b2f1652feebf9c2", "0x23207c03eed1c011", "0xd0221229c21f3c2c", "0x63d23111af2ffd0", "0x3c3d011131391abf", "0xe0111ef22ec30e40", "0xc0200d10f1361c7e", "0x1e0c6f2f21f1bedd", "0x3a4feeffce2ee002", "0x1d211cfdf0270e20", "0xd1e560e21241e232", "0xf41e1705bf245fde", "0xfcfa41343d1cf2d3", "0x35412c951b14bb10", "0xcfdc447d9224ddbc", "0x130d2303922222bf", "0xf42d5e23f1791ce2", "0xf05c0ddd2df76f3f", "0xc02b0f24c047993f", "0x4f0c1f0d41edd0f1", "0xeb103defbd09f5f3", "0x10231cfefe016001", "0xb0bf2ef0e03e9300", "0xd021cd419142e2d1", "0x300d6ea1f04e1fe6", "0xb070b2fefd02e5d1", "0xc0d15053167fe40b", "0x5f0ff04f041bf5d0", "0xe1110cd29e6ddec7", "0x957fff0edce765c4", "0x7c10f72017916e", "0x22f03fb076f04625", "0x1cd2130db20e20c2", "0x2c246efff0fb7f0f", "0x10ddcdf5e22fcdf2", "0xefffe3d5a0157110", "0x3d3ee27b4fb331e9", "0x2af3121e14352a2f", "0x400ebdbf429b6fc1", "0x344d63dd0730572f", "0xf339e5123fbf21fe", "0xe17126203173503d", "0x302fd1f03e0c405e", "0xebf2ffcf02fff0fc", "0x33fdfffdaf0df0d1", "0xfc00d1ce2e2edffc", "0xcfdec2df2a0fed23", "0xe01cfe0e1f4b35f4", "0x1e0f01fdac9bffff", "0xf0e00239ef437c0e", "0x4fd1bbfc6eee4f12", "0x2c3fd9f31c3423", "0xff0cf3de90dcc010", "0xe00def594d0d104f", "0x402eac2a111df22e", "0xbd9ff0003bded43c", "0xefec0dfe2edcf20", "0xca04c1191efdb000", "0xd0fbde0ecf1f3cd0", "0xee0d31eeea494606", "0x191d104190ec00ec", "0x34d1133ed3df6b30", "0x202111dd1fe0602f", "0xd1dcffacc02e14fe", "0xfe2e0021afeffe0d", "0xfefff1ef0ee1f14f", "0x10001c1cb02cf00d", "0xc2efc1e2ed0c02e1", "0xd00ae3fbefebf00", "0xde0ff1fee2f0b0cb", "0xf0ed201d0dfffbbf", "0xce22bee3ff0090e", "0x4f22dd0311fdd07e", "0x2d215e1c5f11c0fe", "0xf0cdde0e21ef44a0", "0xf9e2fce12cbab7c", "0xe1512af241cfbf5c", "0x2c415a2d4edf03fd", "0xd3749c1fc3f0d0", "0xcadf45ff43feac4c", "0x2b6f291f22b00e4e", "0x5c02faff70203f4b", "0x20b0ef9f31009fc1", "0xe203eb10c10f31d2", "0xdf3c2f1f01f1e32f", "0x342e0f4e10cfef15", "0xc00adacfcc2b33fe", "0x3b64f764bd651755", "0x925d73d62960c770", "0xe21216e34703e7e6", "0xf0f5f7c70563fdb", "0x29d514c237e5f43a", "0x931ffdf63f4bfb76", "0xe7edddf971073401", "0xf03edff050f7a571", "0xe0121cee1ef0c310", "0xfb111e3fe1410d0f", "0x230c1231e2e00ef", "0xf11add15ceded0fc", "0xf3eb0ccffe1f0404", "0xff121e1c207d0bfe", "0xdd4525111e0b23c1", "0xf02f6c2142f301c1", "0xdfdee0df2efde21f", "0xe23ffef9e12d3ce6", "0xccd0edfeff1cf23a", "0x304d00f52fa4e3ff", "0x3b05ccffa0f02115", "0xedfaf9390329910e", "0x3e61d90050de9d24", "0x10d1f3bc522f0b3e", "0x25ef1e11bf017102", "0xd40c1faa0effcff0", "0x4e41c03ee413101d", "0xe1c2e592714e273e", "0xfd30359314fb7cb0", "0xf03cfdcb04f26012", "0x5bd525f0e2d250ce", "0xe11416ee32e0fc4b", "0x1dd0ed5be2d31eee", "0x3b90da4bede3c302", "0xe3e2df4b0cde9d6f", "0x10310ebed3003fee", "0xe20226bc601d621d", "0x3ee23cce10f5fef2", "0x2bf3a1cd3bb9cc23", "0x1f05def0411d4ddf", "0x1f0424a5500d70dd", "0x3313c20d25e17a4d", "0x2cc302cb60da10b2", "0x135e5c0f42c70cc", "0x143be12c5c03401b", "0xeaeefae01d060de7", "0xd7f243c2c103f203", "0x40742d1e3e1ef2c3", "0x2cf196df6e22eddf", "0xcdbf0fd1ede5e9e2", "0x2cf2011ad0c7d35", "0x20302eff0efc12d1", "0xfe0235952e51faad", "0x3df6e3e200e339fd", "0xf2ac50eeddea7c0a", "0xf051b1c0f00d7edf", "0x60bf1fe3df2cef0", "0xc121e2feeef0d002", "0x210d6cfdcee022ef", "0xe0ed0ff111ee0f3a", "0xfd07f76bb5d30623", "0x922170722d44c452", "0xd1ee74fe351207a0", "0xff214fdcf173119", "0xe0221f01f4e1f023", "0xf0ddcd521f13da21", "0xe11d01eb3013d70f", "0xf130ef140cc77f0f", "0x52ed560e4e04cc22", "0xf0241f0acfaeb3f0", "0x4d433b1ebff05cd2", "0x1012ffaef5ba3000", "0x1ef4076e953d45e2", "0xd2f60f54ec7d95f2", "0xa0411747530126f7", "0x4f5fce7cda771e3e", "0xe0210db1d73ed2f0", "0xe2b4f240126fc030", "0xb0d0132e2e0e22f4", "0x1065d1d5cd952f00", "0x320d1e0f62e40001", "0xfb2125e0d4ffd2d0", "0x4c14ece2efc44b1f", "0x30242d0bf20a1f23", "0x10497bee02f02e", "0xee130fbca3000fe0", "0xa130df02c5b5302f", "0x1115cbd4005f2e6f", "0x421ff1003151f00", "0xfd1e4daf0600001", "0xf3b610c1f1c35e1d", "0x10f7bdd4013b1c23", "0x70bbf64102d400d", "0xe2ea5f4dfee19aef", "0x4043efd61f0bb230", "0x6f4f14d5dfeea007", "0x260dbe54eb306ccc", "0xa19df654fcebbbf", "0xf4ee2df31330be45", "0xe03ef2c4ffedce1f", "0x26c3bff5b94e45be", "0xf21cf230423bf1ed", "0x2403321f4d0ed235", "0xd052a101dbd4fe3e", "0x34413d0f2f1e5f3d", "0x2b1ffdd103f1c116", "0xd2cd43e112fbd21e", "0xbec6f2f03fd2e0", "0xfbfdeec13c32000f", "0xfcb2ab9612d0f103", "0xf00172cd10ad1a1", "0xefddfdb6f25bffb3", "0x3f41e0f1df2203e2", "0xa93ef3d6fe2fc0f0", "0xeed653503e1201e5", "0x1005bfd220024ce2", "0x19f03d0e0c05bd5f", "0x623f3ce41d1f1f0", "0xe00bf14e04eb7c94", "0x2fd91e2c6170f4c9", "0xc9ce19cdefe09f3f", "0xf4a2d2bc31aff2ef", "0x4a2f12ceda296dc9", "0x41ca33c0107bd3cf", "0x9323e1cc020bb42", "0x90f3f1f31910a102", "0xeeefc22123ec5ed6", "0x10edf1c0716513cf", "0xcedf13f3133b17d7", "0xa5edfeae3ffbe309", "0x5f15609e0dc3fd3f", "0xc04fedfdf0c0faf4", "0x43614220b26d7747", "0xd22ff5e24b01100f", "0x34203e7131d002f7", "0x1152004c76002224", "0x74de31f3f22e22fe", "0xf530f1cff31c511f", "0xf23e521f32220304", "0x101e01d41e01d35f", "0xbfcb03b20f3af49d", "0xe2dd0fdfe0ec13e1", "0x502de19edcc2feb0", "0xef4efdfdcecedcef", "0x9db046b3fe3e40b9", "0xf1fef3c2510b4fbe", "0x103bc920eb20ed2", "0xf15ffdedffcebd6", "0xc1f342d3fd3141f2", "0xef33d501346b5cfc", "0x2b3efb9f0ec400b2", "0x32ef1dc2fb0cd4", "0xfe0012e0c42b52d4", "0xc1030342c01200ff", "0x31ff9efbb0ff14", "0x3c1eecfebdbc0e", "0xe2120200224e12d1", "0x9110f734df1de2ec", "0x401dfea2ef302df1", "0x2f121f13f10cfffe", "0x40342d1d24f3fc1", "0x9253d436f3392e1d", "0x403f3bcfe1f54de1", "0xa040f13ffefed100", "0x1c44addbc10f2140", "0xb0123e9c10fbeec3", "0x21d02d113060e1cf", "0x30b0f3a1beef13f3", "0xf030eefa0ff1200f", "0xe0f01e93100a9fe3", "0x2e09bde02e53d426", "0x40ebe442a130ffe0", "0x1f11100dbbb19cd1", "0xd7fff992613bfcb4", "0x3febccf0ea460273", "0x20cb2643c122d4eb", "0x3914cfe910ee006e", "0xe0124dfd21092dcf", "0x32f1d463224130b6", "0x1000a1cfdd0f0ee6", "0xf13ceda01d4e10d", "0x30e1fb0104f1d00", "0x7dd211e04e230232", "0x4101c55d145212d2", "0xdd0f20ee1df3cebf", "0x4fd2e910f20eefe", "0x3ae3009f2cf4ff77", "0x21fbf034e15240de", "0x952bebbe101f21f", "0xcce10fd24e1f4c0e", "0x23ead2e4ef011cdf", "0xe0f1ddbce4cef0e3", "0x4930001c5117df3f", "0xd23f0c932e005cfc", "0x41e102c21cf32b0f", "0x10fde1db3301f016", "0xec01002131f5df0d", "0xe11419911cf21b0d", "0xf0f011004c01fb04", "0x31d0ffed1f621de2", "0x2ef02ac310fbe20c", "0xd6d10aaf02a60211", "0xe30edc2ebed2e01", "0x100c3f0e32fbb2d4", "0x31ff4122efb2329", "0x12e13f4dd5d7f205", "0xfecedbf1c00a1f3f", "0x202af2d102ddc2e5", "0x30dd42213fb22e9", "0x3f400e51ffff3f12", "0xe1ee3def0e1d3cdd", "0x2040cde4f1cedf23", "0x1431154cbd9116b", "0x97307eed1fd6c550", "0x1eef1f300ff0bfe5", "0xf0b420d44e3d1d5", "0x10f3f422d2dce129", "0xb673e02043344b23", "0xedbe3fec5227440f", "0xe02c9d2d32f7d37f", "0xe0d202323ef3f1cb", "0x5e4ffa10e0e30404", "0xed3401ef3c2f0d", "0xf00cdf22ffef1f22", "0x211df557a90d6f2e", "0x93f71df1ed46a731", "0x10d3e0774304ce97", "0xe0ce026d3517e024", "0x7cffe42005fb2279", "0xb427de1e23734327", "0xfddf421e7204e2f1", "0xe060913370c7d15c", "0x2a2d222e3ee6e3eb", "0x1b000e10c2e1a62e", "0xdab102cf005c100c", "0xefcec23ee1ced2f0", "0xff100f00f", "0xf1000fff10101f00", "0x100001ff0001000f", "0xf11001ff0ff00", "0xf0f011000000f010", "0xf101100100000", "0xf000100f01", "0x1010000001000000", "0xf000001f0f0000", "0x100001ff00000", "0xf0f00000011f", "0xf00000f0f01010", "0xfff01fff10000", "0xf0f10000110f0", "0xf0f011f010f", "0x1000f00001f000", "0xf000000f0001", "0xf00011100000f", "0xf0f0000011000f1f", "0x101000f00100110f", "0x10101f0f00010001", "0xf1100000000101", "0x10f000f000f010", "0x11010f01000f000", "0x1001100f010010", "0xf101f00f00ff101", "0xff0f0100000000", "0x1000f010f011f00f", "0xff0000f10000f01", "0x10100001100", "0xf00f0001f00000", "0x100000001000f00", "0x1000ff0000000000", "0x10000000f1010f", "0x1ff1000f0000000f", "0xf0f0000010000000", "0x922d73fa03507e1", "0xc72073c5d05d91e0", "0xb10306d21172373a", "0xf1e5d6db046ef4d", "0xffd2efe071fed0f", "0x12bfff0b03eeb025", "0x30c1cdf90e2fecee", "0x1e2acc0f4010e", "0x14033c4f30f0fb1e", "0xef3c0e4df3b13f35", "0xf1c12e10f0ef2e11", "0x30f410fe045d430c", "0x3353fb6cde2f0733", "0xd16bf2e0ad539ffd", "0x111e057027f007f1", "0x20c33e3f33770729", "0xf3104ee126102a2e", "0x5eeff04c02d5f40f", "0x4bdfefcee3d0312f", "0xf013eb151125e439", "0x32022bf0f90ff13d", "0x2d5ed14b01d124e3", "0x12932114e22d1326", "0x10e7d112e329302c", "0x170d001e21142330", "0x1a0cf4b142f300fd", "0x2de0cdcd3e9d4101", "0x40c11c112d23fe2d", "0xe432131f52f11f52", "0xfd03dde045b2033c", "0xcc0ade1d0ea0300", "0xf11f56e00d5f0f", "0x30f411e20eff021", "0x2f1fd40e000e311e", "0x1ed0f33220ed3314", "0x213246ee0e1001", "0xfced4bf39403d1e0", "0x413cededdf014dce", "0xf1f0c0f01e21d0fe", "0xd0bdde01e0fff1e3", "0x2f204622b6efd0ef", "0x40121ddbd2523294", "0xf433fe0314cd4f20", "0x21e501ef0e10c213", "0x1ee0f212acfee410", "0x3d6f0fe0c210ffd0", "0xfe20d00ef13dbefd", "0x1be00ed2e20f0ef", "0x5bcfeffefae0ae4d", "0xba2309eccbf2d11c", "0x1f747fbf94db42bd", "0xefe664c42300410d", "0xae4e3e0ded2ad3f", "0xa07f4d2112a3a37a", "0x3a015eee7523751d", "0x1b56090210713f0", "0xfffe22f109ffdcf1", "0xfb311ef4f214f2fc", "0x2f1320da21f51ddd", "0xe0e2f0dd22511ee1", "0xdd0ef5f07e4ad5f5", "0xb931fb0ec9f2e3fd", "0xc01c5e2a1f9e03c", "0x50c20f49614d7aec", "0x613007f000331503", "0x953e0d17197cbf67", "0xd7f904e77204c6d7", "0xf0132d427327274b", "0x1f0e33f31cefd3f2", "0xfdf40e3101fff1f0", "0x2d0d10000104baee", "0xf1e1102ed04c1d11", "0x11eef2f01e2fd00f", "0xb1c1f11a0f9e0def", "0x131130d0feed1ce0", "0xef0130f4d3195cf1", "0xead4d6239133d11e", "0x916f6df3dd7cff5d", "0xbf2f43042170e510", "0xeffe413f0577b20f", "0xd1feef0315edebec", "0x2ec11f19e2e134d1", "0x10be09ae2bd1e90f", "0xef0df3cf0eefaff0", "0xec5ffdf0312de1e1", "0xd1e14f391e9a1edc", "0x2e2f12a1b29d0aef", "0xf02f431d3f29100b", "0x7077c200a07ef761", "0x906b3cb3b97ead03", "0xc639d3664105d7c7", "0x21217477770779", "0x30bdd20f16dafade", "0x33d2eb3be40012e3", "0x1de00dbff0f4fc0f", "0xe029e2adb9a3bf4f", "0x12d01ede0e3010ff", "0x3d2134f1cbc30d2", "0x31010dcc1bf031ce", "0xe02dd33f2ebad0f0", "0xf5d2d3c1ad13436f", "0xfec0e4e02a34fe2f", "0x2bd109dcdeb21ffb", "0x1f11ff1b45972fd4", "0xffe1bf106e1fefe1", "0x11d01ee024dd0ffc", "0xffef1dddb12f21de", "0xe0090e02bc9b20e0"}};



const ap_int<11> conv_3_inc[4][16] = {
{"0x248", "0x27e", "0x221", "0x226", "0x2a5", "0x244", "0x173", "0x14a", "0x277", "0x205", "0x19a", "0x1d7", "0x15a", "0x339", "0x1f5", "0x1c4"},
{"0x1bd", "0x316", "0x1a2", "0x196", "0x113", "0x2cb", "0x20e", "0x165", "0x269", "0x1cc", "0x185", "0x31d", "0x24b", "0x17f", "0x298", "0x131"},
{"0x255", "0x223", "0x2ee", "0x34", "0x2bb", "0x171", "0x142", "0x28c", "0x24e", "0x2cd", "0x192", "0x225", "0x23f", "0x1d8", "0x254", "0x266"},
{"0x1d0", "0x297", "0x193", "0x179", "0x260", "0x1df", "0x2cd", "0x23f", "0x317", "0x17d", "0x3b1", "0x169", "0x6e", "0x1e9", "0x251", "0x1fe"}};



const ap_int<21> conv_3_bias[4][16] = {
{"-0xdfc6", "-0x1fdb1", "-0x4efe", "0x12c29", "-0x85fe", "-0x2c2ea", "-0x141c4", "0x3d2d", "0x1b3c9", "-0x3fc17", "0x5090", "-0x84a0", "0x79ea9", "0x42fb", "-0x6d3a", "-0x6110"},
{"-0x1466", "-0x52642", "-0x367fe", "0x34d4b", "-0x26a93", "-0x3def6", "0x65fb1", "0xa649", "-0x31b8d", "-0xda9d", "-0x12b8f", "0x4850f", "-0x5c2cb", "0x8ff0", "-0x2fa7b", "-0xe7f7"},
{"-0x450c2", "-0x26a9d", "-0x75079", "-0x3312", "-0xaed35", "0x31020", "-0x2b7f1", "-0x534c", "0x146a5", "-0x297f9", "0x695f", "-0xd51", "-0x9afc", "-0x308da", "-0x3f5e3", "-0x25bb4"},
{"0x492b", "0x136e7", "-0x8694", "-0xa51b", "0x55f6f", "-0xbd4a", "-0xa87f", "-0x8d766", "-0x25cbd", "0x3c18", "-0x68e8f", "-0x10ef2", "-0x9dc1", "-0x2f396", "0x28de7", "-0xaf6d"}};



const ap_uint<32> conv_4_w[2][2304] = {
{"0x10bdd45c", "0x2070eeef", "0x20d1de3c", "0xe9dfcfd0", "0x1f2f15f9", "0xbfd20a0a", "0x4b210633", "0xa05d03ad", "0xdff235b9", "0x704e37ed", "0x3a30e4de", "0x3ec9afbf", "0xed590056", "0xe1dde2c", "0x40c115d0", "0xaffb659b", "0xed3cceda", "0x3f14f3ef", "0x39f4b5ea", "0xd97fe3c0", "0xec99130c", "0xb03e9e69", "0x30561ed2", "0x2ecf15b9", "0x25ec1f1a", "0xe171f1e9", "0xed1ff1f5", "0x7bc41cf0", "0xa1bcf47d", "0xe0aefdbc", "0xc0406f4", "0x4d01e39e", "0xe1b21ef9", "0xb04fd77e", "0xe5fbc0bf", "0x67ca36d3", "0x6d6c110d", "0x101d42f0", "0x511011df", "0x402ffe91", "0xd130abb9", "0x20731ea0", "0x6a0e9eea", "0xa4e4210", "0xf00cfae", "0xd14e2232", "0x26402da", "0x3e012dbe", "0x26dc2240", "0xd07fb22e", "0x17fe3f20", "0xcf222494", "0xd2295fa3", "0x3e76302", "0x21a1fd3", "0x2d74c4a1", "0x64c5bf3c", "0xf41d06e", "0x51eededf", "0x1c6c3e26", "0xeff03ee", "0xdc9140d4", "0xe10903d9", "0xccbcd0a2", "0xfedeec1d", "0xcfe41f5e", "0xeae0f6b9", "0x6b5e2da3", "0x6fe3e1dd", "0xfc911ed3", "0x5764ff99", "0xf07df91", "0xf4101060", "0xeffb69f3", "0xca5fe954", "0x3b4737a5", "0xdbec34ae", "0xc7c20452", "0x1d0cf160", "0xe12de340", "0xc1c42d4d", "0xd0113dcf", "0xc0ee4c40", "0x43eec9f1", "0x3acd052", "0xf94e7dd4", "0xb10e53", "0xf3a1441b", "0xc7101c0a", "0x5fc24f5d", "0xf1a94921", "0xa3ed5c0c", "0x4a99fd1", "0x50f2ea1a", "0x71c309a2", "0xf40f1612", "0x221ff5fe", "0xf16b4aa9", "0xce23233f", "0xfd900bbf", "0x69c9cf9e", "0xdbf513ca", "0x1adfeeb", "0xf4094130", "0x2ad1492d", "0x4fa030ec", "0xbed11d12", "0x5e24e32c", "0xcfa9f11e", "0xdc326c95", "0xf3d3060f", "0x10ed2e01", "0xf4052e0f", "0xe0244bdd", "0xb5dcfa56", "0xb0310cf9", "0xe1d907e7", "0x121ae9e9", "0x1ce109cf", "0x909d6e19", "0xf0e9cd00", "0x1f9def1a", "0x3ff32033", "0xffee311", "0xcd01c2e1", "0xfc0f0de", "0x496b0099", "0xbc00f50c", "0x2dbfdd01", "0x605120eb", "0xd2140e13", "0x20f3fe2c", "0xdc0e34f1", "0x302f1fed", "0x3e6d0ee3", "0xbce1e03", "0xeecfdcf1", "0xd0f4fefb", "0x13dd5c25", "0x2fc03f", "0x2d165721", "0x1bf09d91", "0x3d2f0c17", "0x4eeb1ad0", "0x9c2d03dc", "0x20ddc0ee", "0xef94cff0", "0x409130a4", "0xe0e13ced", "0xf6fed20f", "0xe1920239", "0x40fff0ef", "0xf1ff247e", "0xd0b3e2e0", "0xe223f22c", "0x5ffa00c4", "0xcef1ddee", "0x4c22dfe6", "0xde24fe3c", "0xf11e52e4", "0x2f4b312d", "0x41aa90fd", "0xbc0dbc44", "0xbebd0f93", "0xdee0e22d", "0xbedbf125", "0x2ed1009", "0x41cbdf1", "0xdef3e5fd", "0x2fa12000", "0x254360f", "0x40d4e161", "0xaf6ae1ef", "0xf3fef72c", "0x134500bd", "0x52d2271f", "0xe0000370", "0x11334375", "0x11012ef", "0x2a1e1072", "0x1d1a100c", "0x4e21f7f2", "0x1273fdd0", "0x262162e3", "0x3cf11b0b", "0x2121edc0", "0xd0de1cd0", "0xe2a1faeb", "0x400fe0f3", "0x1ff0f02d", "0x1ffdfebd", "0x32d04003", "0xafb2d4ef", "0x50b2ef0e", "0x3fdc9fc0", "0xbbcc19e", "0xdf1dd4d0", "0xc21eff22", "0xf29e0009", "0x2f4faef1", "0x2de2e04f", "0x2044e021", "0x4d4ae2ee", "0x1d3d00a1", "0xfffe0fe2", "0xfb3c3d3e", "0x50210d1e", "0xf73030cc", "0x1f1e2ed5", "0xe0ebde0e", "0xf06cf01b", "0x2bbb3193", "0xd323dc5d", "0xdd2f21e", "0xf2910d19", "0x2ff20110", "0xaba1944b", "0x4012ff4f", "0x192be0ff", "0xed151b0f", "0xe29ff3e9", "0xf4dd1dea", "0xdd2022f", "0x4df11a4f", "0xafbd01f3", "0x10314e2d", "0xef9e041", "0xddd6f23d", "0x2690351a", "0xc1ee29ec", "0xabd04d1", "0x33adc91b", "0xd123d6c4", "0x903d3411", "0xd46e1edd", "0xd6100db", "0x2c73d2ed", "0xc11a125c", "0xb4630eed", "0x14acf010", "0xcfa420f4", "0x30e10e0f", "0x14ef1ef2", "0x1014ef9d", "0xbfef0acb", "0xf3fe520d", "0x3cf1be3", "0xf9aa6c5d", "0x91b03219", "0x11f40ecf", "0xc2f19d7", "0x6d11c919", "0xf0e02dee", "0x53c49ee", "0x2cdc0ee7", "0x40f51fee", "0x61370454", "0x103bf6f1", "0xc771247f", "0x4f7bb131", "0xd74bbe2", "0x2ce0e631", "0x17630e29", "0x41492753", "0xfc0febe2", "0xf02fe021", "0x41303fb2", "0x3cf20ebe", "0xbb6e2de0", "0xf12f44ff", "0x11401fe0", "0xe0af421e", "0x3c4ec20", "0xf00ea521", "0x4f714de2", "0x3e4bc7c3", "0xeb6ee37c", "0xb21cf160", "0xf4f1140d", "0x1e60e77d", "0x40c53a25", "0x3053f1f1", "0xbe4f0446", "0xe60d15ff", "0x3bf502d1", "0x3eeae32", "0x14f3059b", "0x22321620", "0x332f4277", "0xd0cdce3f", "0xe1fc9e15", "0xfedc3ea9", "0xd73e706d", "0x20b24bec", "0x5ed00fda", "0xd0212930", "0xc052f022", "0x4fb25421", "0x34e9e000", "0x32dfb30", "0xcd947e35", "0xad0b495a", "0x7a300d34", "0xb551dd9d", "0xd23910", "0xc0eb920d", "0x71901227", "0x117f1f47", "0x19f20da2", "0xbd365f14", "0x2aed0f3f", "0xeffdc30f", "0x21901136", "0x906fcf1b", "0xfae327d6", "0xe0f00dbf", "0xb3503921", "0x773024ad", "0x51510eb2", "0xe12e200", "0xf13ff1a7", "0xe0567fef", "0x2f10777e", "0xb72edf", "0xb9e47d21", "0x2f0009ea", "0x4ce00b03", "0xd6f30041", "0xef219beb", "0xf0f3f30f", "0x4f9d25d7", "0xef209f57", "0x49075c37", "0x2c42cfe7", "0x93e0d42", "0xf4f3a2a3", "0x3acb2235", "0xa0601e0c", "0x1a00209f", "0x3673951e", "0x2e76d9e2", "0x1257f2cf", "0xfdd10eff", "0x41612be2", "0xfdd0ffe0", "0x9006e00f", "0x3dd137a6", "0x3142e12c", "0xc02269cd", "0x2d4cd2dd", "0x4e21fde7", "0xe42f39b0", "0xefdbd1ac", "0x30430204", "0x29c0e42f", "0xe713c0cb", "0xe9423923", "0x43b3efd2", "0xb9e40c1a", "0x12240c04", "0x6ffa02c1", "0x204bdc3d", "0x454520d6", "0x1d1faf4b", "0x100fff13", "0x1632fec3", "0xd0130f5d", "0xf1fff2fe", "0x300a1303", "0x40ce0d56", "0xe46457a", "0x603c017", "0xf625571d", "0xe1dd5eac", "0xf6130d0e", "0xf10f6e1a", "0xc02d2e0d", "0x1ff15040", "0x63dd2dee", "0xa3131fec", "0x61164b0e", "0xecde19be", "0xf9eb1f35", "0xf1d92c", "0xf2f20cea", "0x1ff0bf2a", "0x17130fe3", "0xfe10de2c", "0xe03def45", "0xd3110016", "0x401003c1", "0x9ee0b020", "0x14137cfb", "0x102d672a", "0x405e2490", "0xc20410a9", "0xdd172e1f", "0xe042fd2e", "0x45e50f10", "0x7fc702f7", "0xb3eebb60", "0x20f1f1cf", "0x57faf411", "0x9002b364", "0x3ee220be", "0x1a521930", "0x41fa0cc7", "0xb1b9ba03", "0xf7e2a0f1", "0x15331a", "0xa93dd3f", "0x501f2fd0", "0xf0bddae1", "0x10efc9e7", "0xcdb41342", "0xb42e5c0a", "0x3d7390ee", "0x10052c9", "0xcbcbfdf", "0x2d493f14", "0x4fd09a93", "0xecffb9a0", "0x991e023f", "0x90131a29", "0xeb21ce9b", "0xe062d12a", "0x10dfd23d", "0x2133f5fe", "0xbbafcf", "0xe9e4ff2b", "0x903ef096", "0x970a4cf9", "0x3b3004b", "0x602ebeed", "0x1b2f7de1", "0x344b5a0a", "0xfa20a243", "0xfd2510c", "0xe19b0f34", "0xd24df74f", "0xd4dc302c", "0xf20322", "0x1157390", "0x552e4d20", "0x7e1dcb5f", "0x36ee1d11", "0xb3970126", "0xdf6b350e", "0xf952d024", "0xd10cf2e4", "0xa1fd32d1", "0x7556f1e3", "0xdf39df", "0xaf412f70", "0xdc10c2f", "0x1a7f291a", "0xb3d4dedf", "0xefb1ef5f", "0xfee67015", "0x17cd5f32", "0x2e139f05", "0x6507e344", "0xeecc1d1f", "0xed92d02e", "0x27c70e26", "0x90f5fef3", "0xf5e661e3", "0x66d5e52", "0x3916fe25", "0x1ef5e2ef", "0x4d270d11", "0x54e13fa4", "0x4b1f2326", "0xcfa37b01", "0x30239010", "0xff0e4cb2", "0xfbeffaff", "0x3a134f45", "0x11b00be1", "0xe4134f11", "0xe293dee5", "0xd1002221", "0xeb3c4c01", "0x6ebe0ef6", "0xc94e9d3e", "0xe4dee36d", "0xdaff521", "0x19444f0", "0xb6a510be", "0xa0b4ee00", "0xec256dcc", "0xfc1e9363", "0xce062ce5", "0xdc07c51e", "0xfacefec0", "0xefa16e5e", "0x6091ddcf", "0x90a5710f", "0x3fbfdae0", "0xacc2a291", "0x94d06531", "0x31d44e4b", "0xf92114a1", "0xd5b55010", "0x93f5ff05", "0x503eff0e", "0x9d2b361f", "0x4454de5e", "0xd9e4122c", "0x5409a031", "0x2c9fcfa", "0xf9cd9530", "0x2141513e", "0xd01efe21", "0xee3ff309", "0x52e4ed5e", "0x5e32dcf0", "0x27fec11e", "0xf219102d", "0x20edf420", "0x2a7c430c", "0xcf00ff41", "0x2326264c", "0x53209231", "0x6dfcae93", "0xf11e3b23", "0xb3a1119", "0x1dfddc60", "0xa4159aef", "0xf0fea012", "0x917ced53", "0x49522d71", "0x1be41fc5", "0x1e1a1632", "0x32ebf03f", "0x1ac4e102", "0xf04c3e01", "0x212e1fe9", "0xdf5617e9", "0x1f22c3d1", "0x9eadda2", "0xef0fc0e1", "0xc2902fa", "0xb2ef074", "0xef29ed5f", "0x2094e211", "0x2f03cff4", "0x222b9ec1", "0xe91103dc", "0x140cefe0", "0x91ec03c9", "0xdcd0f92b", "0xff449b0f", "0xf01f32d", "0xbbf2b192", "0x19d99e7f", "0x7fe4430f", "0xc1d93d5f", "0x1be1160", "0x1055057f", "0xe5fe92f2", "0x7f6bd23c", "0xbc005b9f", "0x3bddd17c", "0x4925514e", "0xb001b212", "0x4df1f3a", "0x4d0eff30", "0x309ebfc4", "0xf01e421f", "0xef0119fb", "0x3e53b370", "0x6b120ff5", "0xf0dc121f", "0xe50d0ce9", "0xf932bec2", "0x3d32c00b", "0xb1ccacc1", "0xd01c6dce", "0xdbdcace0", "0x694b630", "0x9b7b9b3c", "0x44221311", "0xcb10e0bf", "0xdd5fe1ed", "0x50ef930e", "0xcd0c2d1d", "0xad039071", "0xce06d5df", "0x2d0cd173", "0x525d1200", "0x3c21e5d0", "0x4a0bcf3d", "0xaf69ec26", "0xca7eecec", "0x19f112a0", "0x9b0fc62a", "0x5c1b4f33", "0xb0b0d26", "0x4ccc15df", "0xcee50ced", "0xdfcdf5c3", "0x4ef97cbc", "0x5bb91123", "0x5403e609", "0xf21a1421", "0xe0be01ae", "0x31036613", "0x20ead050", "0xe02dcbce", "0xb53d11d0", "0xe9ce1523", "0x2365d04d", "0xcfe9f030", "0xfdfd04b0", "0x10e1e690", "0x702cb141", "0x1073231f", "0xd676024a", "0xf9f29d1d", "0x20a2130a", "0x4d9b5707", "0xe73ff4c1", "0xd40c72f", "0xd232a293", "0xff0fc71", "0xcefd7cfd", "0xe5ea3d22", "0x70f1f709", "0x3f020fd", "0xc29c05c1", "0x3a012e04", "0x3135edfd", "0x404006af", "0x14b2e04", "0x9ae443b0", "0x72c315c", "0x20f5250f", "0xfee00410", "0xfd5d4ae3", "0x59100dfa", "0xb06daaf4", "0xf62cfe99", "0xec17c7de", "0xf3e93b2c", "0xec22213", "0xd13d0d20", "0x29729f9f", "0x401ff05e", "0xf7ce3fd", "0x62d22270", "0xe9eb475e", "0x1733077", "0x20c44317", "0x6265173d", "0xde6f40b6", "0x1024be1e", "0x1015dff", "0x131f07dd", "0x4e22f0e", "0xac9f2013", "0x69213de2", "0x67b007fa", "0x5fc22913", "0xdf00d0f", "0xbfcceeff", "0xe6c0f009", "0xa0fe03f2", "0x5ff0102e", "0xee44ebb1", "0x2fea0c3d", "0xff040b07", "0xd32c41", "0x7d0623", "0x2744521e", "0xff570977", "0x52b56f57", "0x522d4507", "0x63470f65", "0x3e2546b7", "0xfe11dff6", "0x1b3e1cc", "0xe3106a5", "0xd1030d3c", "0x1e912d9d", "0xe9124aeb", "0x149a044c", "0xe1b2c3d2", "0xc4a1afd", "0x11cc3b", "0x219bc32b", "0xb1d42dec", "0xeb0f1b9", "0x9b03dc0d", "0xdec00e2", "0xef4fec0f", "0xc9e4036c", "0xd01fc37c", "0x3d34372f", "0x5125f96b", "0x43d60b5e", "0xfe123ac4", "0x70540f63", "0x453ee192", "0x2d1f2c11", "0xe1a1e101", "0x4ef1d0d", "0xd2e34049", "0xe4ce01a0", "0xe0f26a26", "0xcec01dc", "0x92e0dd00", "0xfc5e1eaf", "0xf00700ef", "0x30ebb12c", "0xb427ae94", "0xe1ba1dc", "0x94f2613c", "0xda1b191f", "0x111cdc4a", "0x3d49bccd", "0xd0a1d123", "0x260f35c5", "0xd3ccf025", "0x32e9fee7", "0x2f1d3722", "0xbeb013c5", "0x1c9fe2c0", "0x23d2f2e1", "0x10defe1", "0xd13624ff", "0x1fc0fc1e", "0x17a024c0", "0x3024056f", "0xcdc105f2", "0xcee3b2b1", "0x3799f002", "0x9021ddd3", "0x36f06e0e", "0xee5d4472", "0xf24ab110", "0xf2e4550e", "0xd3ee0416", "0xf0f7d1e2", "0xf02ccb21", "0xe0c1ae21", "0x2a3f0cbf", "0x9170053e", "0xefe32cc", "0xfca5ecc1", "0xd2230ae2", "0x1b2d40bd", "0xe7e09c74", "0x310acd13", "0x3a331c93", "0xabe12324", "0xd720bf0f", "0x2f6e1ee", "0xb2e103e3", "0x2d7211fd", "0x21b0fefd", "0x3070315d", "0x551d6dec", "0x99575bd1", "0xe5cdfaf4", "0xc0d701f1", "0xa5e60730", "0xd170f29f", "0xfe329e93", "0x10d2df0d", "0x35ed62e", "0x42f26c21", "0x60e373f9", "0x52f5ee01", "0x9ddf0fcb", "0xbdb5ddc1", "0xf410c1c3", "0xd0d7d335", "0x100027e9", "0xce24fe0", "0x32e3fc1e", "0x6ed73d00", "0x5e6b013d", "0xedf11fff", "0x33176caf", "0xb121ab12", "0xf4020ec9", "0x9e173404", "0x33ddf9f3", "0x10d72131", "0xdfff1614", "0xfe3e07fd", "0xdf2441b1", "0x7091d42a", "0xf6ffdf93", "0x190bea9f", "0xd0bedefe", "0x9bfbddec", "0x4e1f0edf", "0x4ccb4ec0", "0xef5f2362", "0x30ef00dc", "0x14f42d0f", "0xdd2b2b2c", "0x121c9d1d", "0xb30260ba", "0xc526fdb5", "0xf1eb39be", "0x21e00290", "0x205f5e31", "0xee07ec30", "0xffdbed9c", "0x1e19cbe9", "0x51c3e2e3", "0xcf300dd2", "0xf6fbf90c", "0xaf12fed3", "0x2ff49d21", "0x129bcde0", "0x1f0eb091", "0x5efd0de4", "0xbee90bd2", "0x3cef19bb", "0x4e9de2fd", "0x12302fa1", "0x46edbf", "0xd29b4e62", "0xb07f1d71", "0xf10de70d", "0xd91d7fce", "0xfbd31995", "0xb0f37c3b", "0x254f2f0d", "0x317e2f30", "0xbe12fcaf", "0xb2faeacd", "0xe31bb0c2", "0xb22112c0", "0x34defcda", "0xc2f4c023", "0xb696f0e3", "0xf000b970", "0x4ec4cbd4", "0xed1f42a9", "0x4c35e3ff", "0xaf20d00c", "0x33a90f0e", "0x27006b23", "0x52c23230", "0xb053a9ef", "0x319f2df1", "0xd0f4335f", "0x5f20e72a", "0x49609ef5", "0x3f4a1b07", "0xe5506d21", "0xce99f401", "0xd0be1f2e", "0xfb071fd3", "0x44bbb2cc", "0xe43f93fc", "0xc1e9cd3e", "0xebdf0b19", "0xdeb0233f", "0x6909cc90", "0xf0905c42", "0x21eb7cae", "0xde9d1e9b", "0xbafb29da", "0xee4ff79b", "0x22ad090a", "0x3fbc507d", "0x5ecd459f", "0xe0ef0d", "0xd132642f", "0xffc0e9e", "0xdd2c1dbf", "0xd0e9323b", "0x20e10ddb", "0xef93111f", "0x3b12f10f", "0xa19edd33", "0x1b56702", "0x2ce93093", "0xb40706f1", "0x21ea1ef2", "0xdbb1fe29", "0xbddf3c21", "0x29fdeae9", "0xf002f05f", "0x46edaea4", "0x9de6afbb", "0x5fc01b02", "0xffef21ed", "0x6f1f0db5", "0xf0b13420", "0xcdbcd07d", "0x2f3066da", "0xd4f30601", "0xde43ef70", "0x2112ce00", "0x302463af", "0x3e270be5", "0x51e3d123", "0x319bc235", "0x12c1f1a", "0xd016c771", "0xec00111e", "0x43f32f13", "0xe0204215", "0xef30f00", "0x23f2fe4", "0xdbce0ab9", "0x21fdb439", "0x9ecebff5", "0x715efcca", "0x6ec1f231", "0xfe04060f", "0xf9c30d4f", "0x6e213fd2", "0x19fefcc9", "0x300126cf", "0xdb2ec43", "0xf07e122f", "0x59e1ee1f", "0xf235da1", "0x1a05ff26", "0x1fc4fb14", "0x31eed1c9", "0xf17a2122", "0xacdee905", "0xb43610cd", "0xe0dfd91f", "0xcd1f2f2e", "0xcf60c0c", "0x4f236b23", "0xeb3c1500", "0xef01eff2", "0x1aefe14d", "0x2507d621", "0xaf31eff3", "0xcc039e1a", "0x602d00b5", "0xde6359ff", "0x253e24b1", "0xff02e1e1", "0x519c4ecb", "0xc3231352", "0xcd01d02e", "0xede3ba3c", "0x5f2d0927", "0xd2f61901", "0x6109ce23", "0x11450de0", "0xf1a1d450", "0x24cd1405", "0x9cfea1f5", "0xdd47d0c2", "0x3b7d0114", "0xfaf30414", "0xeb0544f7", "0xb01532c3", "0xfe91a64a", "0xd536ee13", "0xe22fa4e", "0x1fde9c1f", "0x3e53fcef", "0xb3f34c4f", "0x320ff292", "0xc12c6243", "0x62e4d6e7", "0xf01b3f33", "0xecd99ff", "0x79cdfaef", "0x1adc095a", "0x2f935e11", "0x521bfbe3", "0x7f211f3a", "0xf12d9642", "0xffd2205e", "0x99a0ebde", "0x5ced1906", "0x29dffcdf", "0xfdf544c0", "0xbfe0127d", "0x21c43fd0", "0xddff0106", "0xcb2dcd13", "0x1e015933", "0xbfc66d06", "0xf341962", "0xd733440e", "0x13900e05", "0xff0d1e1f", "0x93d35fd7", "0x12ca0c1c", "0xdfd0dc00", "0x12272d0", "0xdae10ccc", "0xeb9f2bbe", "0x16adef31", "0x504212f5", "0x234fe001", "0x5f0c2c0d", "0x1d025a25", "0x15f5741b", "0xfc910133", "0xf0d1121f", "0x700b72b1", "0xe0357d21", "0x4004fd52", "0xe27a37e1", "0x1100fbc7", "0xa1e2c13", "0x791df079", "0xb6f504f5", "0x2de324f0", "0xef22616a", "0xef31cd36", "0xf1ea3e3a", "0x77b20fff", "0x9030161", "0xb14010dd", "0x743604c7", "0xb624c29e", "0x30011a91", "0x93310cdd", "0x39d03b0", "0x12ed0205", "0x3fffdd41", "0xf93e00ff", "0xe10211", "0x7df0e0c", "0xbfe10dc9", "0xf26117c5", "0x32a7f3cd", "0xb0941102", "0xbdfc04e", "0x21a702d2", "0x3d9c959a", "0xf6e0ff7b", "0xc0d0beb9", "0xbc51e7ff", "0xad9e3e5a", "0x133613c2", "0xdf40293", "0x1d1d149b", "0x9519b5ce", "0xd5d71d3d", "0x1fcf0fa4", "0x4f323721", "0xfa17244", "0x7fc041c7", "0x693d0592", "0x939010f", "0x46d551ae", "0x440561f0", "0x201c0c30", "0xab91f50", "0xc15127d6", "0xd0deeb04", "0x10225dd3", "0x6f051317", "0xf4d06fdd", "0x12f4203e", "0x3feeac9f", "0xde5a352e", "0xcf454714", "0xcda0b046", "0x9310db2", "0x1a1003f0", "0xc7f237f1", "0x36e4e1e1", "0x3113aeed", "0xc275c77f", "0x6dc57432", "0xd3ede297", "0xef0ca1af", "0x2443151c", "0x1d3ac79c", "0xce2c032c", "0xb16cb241", "0x231e9b7d", "0x4b17c110", "0x9b201c61", "0xe2f1340f", "0x7e350213", "0xe7b32ae6", "0xf0cd1133", "0x907cce1d", "0x7b0fd200", "0x1dd5a9cc", "0xce2ceb4d", "0xb105222f", "0x2d15041e", "0xf5110cfc", "0x3ed2913", "0xf0600132", "0x704bdaf5", "0xd3f4c1ed", "0x9d46bb13", "0xf11074eb", "0x4bea07c9", "0xf4945634", "0xdbfb1514", "0x900c1f21", "0xfc11b22d", "0x2b15f01a", "0xea141d4c", "0xcec00f1b", "0xeb5f09f2", "0xf10d39f2", "0xcdf912e3", "0x505a530c", "0x4d07e5ed", "0xfc21035", "0xb2ef137e", "0xc120caf", "0x1be70dee", "0xe5c20ef", "0x210d6f3c", "0x6fe1fa", "0x3fc4c6fb", "0xb1254a2c", "0xee11b31f", "0x2dff4ddc", "0x1e930634", "0x23c10db0", "0x3bfc4d42", "0xb00c3622", "0xef262019", "0x56fb3d0", "0xeb177d41", "0xe0c4a02d", "0x90060e00", "0x2b922b03", "0xe3d0db1", "0x313c3103", "0xc4f7ee69", "0x1e3d01ce", "0xf6e22331", "0xdde04c", "0xcf051003", "0x1ed24cee", "0x374975fa", "0x61efe392", "0x3292de29", "0xd76d1cc2", "0x9713e313", "0x6de1f0fc", "0x10bf0f27", "0x6dc51004", "0xe4337031", "0xe0c250dc", "0xfc04e0e9", "0x30f10f41", "0x3f14b454", "0x213f121b", "0x13cdf5dc", "0x1c3c0cd1", "0x47301e36", "0x30df1071", "0x9d013603", "0x36e3ce31", "0x42e1a27c", "0x332e5244", "0x152b012b", "0x54c035b2", "0x442ef9cc", "0x306790de", "0xda5d7d00", "0x7bf5a091", "0x50f1a1fe", "0x9ab21231", "0x4c4e01f1", "0xc5d93e9c", "0xfcbc322d", "0x4fff172d", "0x20add57b", "0xf490c524", "0xf03f9c7e", "0xd0cfd230", "0x6706032d", "0xe1590e92", "0x5fe93fc4", "0x3fff26f2", "0xb9efe425", "0x32b51dfc", "0xe6cf919e", "0x1fc5330f", "0xdf030420", "0xfc6a4e9f", "0x5ff09fcf", "0x10549d2d", "0xfef06d12", "0xec33f312", "0xc6139fef", "0xee0032ef", "0xfc1f06cb", "0xa4e3a9d", "0x40de2643", "0xe19e40e2", "0xa02eeed1", "0x9ee106e2", "0x2f3e272", "0x6d3390df", "0x317c041f", "0x5a311a95", "0xdebad72e", "0xf0c21444", "0xe33ff60f", "0x6ddce304", "0x12fbb24f", "0x74d49462", "0x7d370071", "0xf240d19b", "0xe10fd39b", "0xf1d0e43b", "0xd33f43ce", "0xe015d527", "0xd2d19fbf", "0xf473de71", "0xdd1e106a", "0xb934dca2", "0x2e5bfe00", "0xf102bf34", "0x70a233ac", "0xb222a133", "0x43fd3bea", "0xe13e021", "0xd05c005d", "0xea7d1f2a", "0x5efeebf1", "0xd0cd2c0f", "0xcc43241f", "0xf0b0fb5c", "0xff3e6ed1", "0x4fa3122f", "0xecf9fffd", "0x2eb014cf", "0xe2bfbbe6", "0x10321920", "0x6f53701", "0xcc3dde4f", "0x1a17731e", "0x641201e0", "0x9c190d10", "0xce4de031", "0x2fed5d17", "0xf050be22", "0x441e63c0", "0xa2ffa15d", "0x1f1d30af", "0x1113e233", "0xc15901c2", "0xcecd146e", "0x5f347a24", "0xe0334915", "0x104f162d", "0x9777ed3f", "0xb12115f0", "0x1eb401ec", "0x9e7902ce", "0x2296d6ff", "0x43ec3a73", "0x502329ee", "0x2c0f47ce", "0x9724eb3c", "0xc9d23720", "0x5232de24", "0xc2d90de0", "0x11eed073", "0x40fce13d", "0x3f9030f1", "0x103ceacd", "0xc0399d3d", "0xbbf7fe10", "0xc50dc30", "0x3f1002eb", "0xc7f03e2d", "0x234c4a01", "0xf1424212", "0x32dd1902", "0xb15af9e9", "0x3337f0b7", "0xb2f4b0a0", "0xfee901c3", "0xe247fe31", "0x1043e2f2", "0xd125015f", "0x11f11da1", "0x203a29f9", "0x4f23edf1", "0xc0f0c01a", "0x21de03d1", "0x13562e25", "0x1112b76e", "0xdf331b91", "0xc7114f41", "0xe2453fde", "0xf30f5120", "0xec143add", "0xe9bb1092", "0x41b1a204", "0x12ef27e1", "0xf1023cb1", "0xd367325b", "0xe12069", "0x5efe5ebe", "0x130e1b3b", "0x4baf003e", "0xe5afd02c", "0xd0cb7dcd", "0xd023e696", "0xd7e74ac7", "0xb2034067", "0xf0be2190", "0x2ccb120f", "0xd03001d", "0x1ead9331", "0x637adc7b", "0xf1e5f9e0", "0x2d40317d", "0xd546e04e", "0x90a77e1c", "0xecffffc9", "0xb31b1997", "0x60e39e72", "0x47f9c17e", "0x9102094e", "0x502f5f12", "0x33d96d61", "0xc1427a0c", "0x74011331", "0x4bf21f13", "0xf79ca0df", "0xef96be5f", "0xd1111cef", "0xef5261df", "0x792d427c", "0x11d46194", "0x1f110433", "0x3e96011c", "0x4f1da15b", "0xb21cc04b", "0x50340ec3", "0xeea0fc7a", "0xa04f29dc", "0xb4d5750c", "0x4e21e261", "0x20550df4", "0x3075eb21", "0xe11dd24a", "0xef0e1bee", "0x7a0d6d23", "0xfd095b1c", "0xbfe23f1d", "0x13d32f0c", "0x960022e", "0x1f5c194f", "0x2cbd01dc", "0x30da0f00", "0x2f2b0095", "0x30fffe6c", "0x5ecee21f", "0xece333cf", "0xc9a2f140", "0x53dfdb1e", "0xff20e0f", "0x101020f0", "0xe00fff0f", "0x1f0ff1", "0x1f10ff1", "0xef000f", "0xfff0021f", "0xfff0ff30", "0xef01001f", "0xf0ffff1f", "0x1f11002e", "0x2010f0", "0x300fffe2", "0xefd0", "0xef100020", "0xed02f210", "0x1fff001", "0x1fff00f", "0x12010f0", "0x1000f0ff", "0x100012f2", "0x1f00e00", "0x210", "0xe02f011", "0x2000f11f", "0x1000f00f", "0xf100010", "0xf0102fe0", "0xd10000e0", "0xf10ff", "0x11f01110", "0x100f00f", "0x2012f021", "0xf10ff100", "0x112f0011", "0x101001f0", "0xe3f001f1", "0xff0ff020", "0x11f00f0e", "0xfff2f001", "0xff00000", "0x1ffff", "0xf01f0f1f", "0xf120ff0", "0x1022100", "0xf00100f1", "0x2000001f", "0xf011ff12", "0x211ff02f", "0xff0d000", "0xff01100", "0xff1110f1", "0x101f0f1", "0xf011f011", "0x101101ff", "0x10001", "0x12f00010", "0xf110fff0", "0x1ff000", "0xff11fff1", "0x11f1f2f2", "0xef0f0f1f", "0x1f1f01", "0xf0f000", "0x10f01010", "0xf000000f", "0x10fff10", "0xfff201f1", "0x11f1010f", "0xf0110000", "0xf0d1fff1", "0xf0001f10", "0xcdf2112d", "0xf0c6421b", "0x139dd0fc", "0xd670e1ff", "0x24d904d3", "0xed392e6e", "0xc1f219e6", "0xf1f3f34e", "0x1eddffac", "0xf1921e20", "0xeec4ec31", "0x21574110", "0x43b0f09", "0xdffcc2d", "0xcd670e34", "0xe12970c", "0x40cd0fbd", "0xf19532dc", "0x2eef110", "0x26f010b0", "0xe719031b", "0x7c0afc3f", "0xbff50fe4", "0xca06cf0d", "0x52925f1a", "0x3f9150c2", "0x535c1acc", "0xd714c4e3", "0xbe1b0eec", "0xdf495dd1", "0xade09ae", "0xcc90514d", "0x627abf71", "0x6001daa2", "0xca70c940", "0x9d3195bd", "0xb0f030ba", "0xe909f60", "0xff111ffa", "0x2902af42", "0x5b0e43", "0xb0a21bc1", "0x720099c2", "0xde2a1292", "0xd12a25f1", "0xfe10ccd", "0x50d40eb0", "0xcbd4fc61", "0xaf925f20", "0x6f6d4c2c", "0x520494b", "0x2051f1f", "0xf2ee01bb", "0xa05164fc", "0x4d3a1df0", "0xdb11e91", "0x317cc241", "0x6f35cb9c", "0xee0ff94f", "0xeb1fd9f1", "0xc14de603", "0xa4e41202", "0xe4b2fd1a", "0x1fdd0fa1", "0xf1105271", "0x4042eade", "0x340f993b", "0xd0aac201", "0x1e19d7d1", "0xee42f331", "0xfd6f0de0", "0x40a35de0", "0xcdf1e0c3", "0xefd4af1c", "0xfa54b250", "0x319ff765", "0x6d52e613", "0x23ef107c", "0x1f1f10dd", "0xe90bf232", "0xed4ee1bc", "0xe1231f3d", "0x4ecb4346", "0x3727c4de", "0xd59bc030", "0xcf112cf5", "0x36df1520", "0x7b3fbd1e", "0x2adcd302", "0xc04215c0", "0xe0210053", "0x17e2971d", "0xa23fdc04", "0xf1edf369", "0xfd4714af", "0x4131e3ef", "0xde097d2e", "0xf1ce144a", "0x4bd77de", "0x706c030", "0xee02e22f", "0x2a970d7b", "0x770400ea", "0x3d10ec7d", "0x550d72fd", "0x1021f350", "0x7dfa11c5", "0x37100b39", "0x26c34c41", "0x622ca4f", "0x7ecd0111", "0xfca6ab53", "0xf093c2de", "0xc0eede3f", "0x91130003", "0x7eeeec1f", "0xe0975260", "0x3a9eddfe", "0xfcfc0f42", "0x2bf73161", "0xdea61f15", "0xa0927f03", "0xf1d9ffd0", "0x261eadd", "0xf4edbc", "0x973cb930", "0x1940fa44", "0xbdc7ed71", "0x1fb7c312", "0xc04f3353", "0x141e05b4", "0x12ee29bb", "0xf162d0dc", "0xd670b42b", "0x1df0ff45", "0xebd51340", "0x3f06fbb9", "0xfd512f", "0x2326d71e", "0x30ff2ccd", "0xdfcae0ce", "0x3a259f99", "0x13fc1f0f", "0x21954471", "0xefb0190d", "0xe05b9dbc", "0x62f0e9d", "0xf4cb9eb9", "0xfc012e11", "0xc539ff1e", "0x1203f1d3", "0x737411f", "0x55bd96b", "0x1032aec3", "0xdfddad", "0x131d9322", "0x1dff32e5", "0x13e11124", "0x44ec04d1", "0x35015125", "0x110aff2e", "0x212df121", "0x2dd0906f", "0x1d60e00e", "0xf91d76d7", "0xc310dd", "0x634a020c", "0xe3a5cced", "0x3000f94e", "0x1070e5f2", "0x7705a9d", "0xeafad663", "0x3f0e2bf1", "0xc21a2315", "0x3ffe0734", "0x973d350e", "0xf3f469a0", "0x10139d04", "0x1721edfc", "0x931cff64", "0x4d1a0db2", "0xf1454304", "0x26d90652", "0x1fd53402", "0x271441c4", "0xd0fe1a32", "0xbe2eaf6f", "0xded0f2ba", "0xe93c4513", "0x21f7ffb0", "0xb6cf10ed", "0xd0ad1ed4", "0x70a05b3f", "0x907f710e", "0x9c7bffeb", "0xf022e145", "0xd99fdcec", "0x9ebd100e", "0x1f1d1ee1", "0xe02ee6a2", "0x4e12eca5", "0x223210", "0xd07b103f", "0xe12710a3", "0xf91e3cf1", "0xf022c122", "0x1e2d1a2f", "0xa1402f3b", "0x20063b91", "0xd0360533", "0x2a029750", "0xef07ddda", "0xcd215d1a", "0x7de310f1", "0xdd040cdf", "0x3b9e1b92", "0xfce50d19", "0x1051a0f1", "0xf1cfeee0", "0xc22ffd4e", "0x1b33422", "0xdd02c9ca", "0xdcb200ec", "0xc41c23e0", "0x31e02150", "0x401dc0e5", "0x4e561cc", "0xf0cfc12a", "0xf22b4fe7", "0xd122019d", "0x3d24f223", "0x1f147f14", "0x11e11d30", "0x602cd4f0", "0x534050b0", "0xa2c2dc09", "0xf9bddf07", "0xe056e0ed", "0x31920d63", "0x330f13e3", "0x91929205", "0x1c4dbff", "0x53155037", "0xe17ffe50", "0x23e73df0", "0x40e33bce", "0xce12f25f", "0xb7be7ce", "0x2394cce6", "0x31660b0d", "0xdd0507c2", "0xe220f25e", "0xd3d645fd", "0xde0425dc", "0x32420ccf", "0x65972c1", "0xf06bf7", "0x60152e5d", "0x20e007bb", "0xdfd3ad76", "0xae75273", "0x7d170b06", "0xfea003f", "0x619d79f", "0xbfcb90fe", "0xffb3d11b", "0xda473023", "0x5e503e0e", "0xffb7ee2c", "0x1f967b00", "0xbe1603fc", "0xfcbed34d", "0xf3c270b7", "0x50904e0e", "0xbda2b2e1", "0x10e1f011", "0x4320ff32", "0xe1d25ef4", "0xc01210d1", "0x73f5d22", "0xf394e1e7", "0x30a31dbd", "0xc9cb13f0", "0x57de1051", "0xdf23e6e", "0xae2d41ed", "0xfd100a43", "0x47c31052", "0x6f034a40", "0x1112534b", "0x26191020", "0xb30f49ce", "0x25a270d2", "0x39e1e903", "0x132f04a1", "0x744320e2", "0x2c44f1dc", "0x6033e161", "0x632f3434", "0x134a52d7", "0x13ccf9e3", "0x11cba91e", "0x9920133f", "0xd0252704", "0x3d161dbf", "0x90a29cb3", "0xdc0c1e4", "0xd2205dbc", "0xfeeafdd4", "0x100e9c11", "0xdfcc04b1", "0xcbfcfcef", "0x5f26d03f", "0x707c54a6", "0xf3f9e40", "0x2d40e717", "0xc2ce520b", "0x20e1ea45", "0xad70014c", "0xa7095f0c", "0xbee04b7a", "0x70401779", "0x701d11ee", "0x6b2fe36", "0xd490077f", "0x4f151064", "0xd2031101", "0x712071e3", "0x2b2131d0", "0xefd29994", "0x60b322b1", "0xa30d00b4", "0x1c60fcc5", "0xeb4fcffa", "0x30cf1f3e", "0xca4f15d", "0xf72e14e", "0xf14f1262", "0xefa4be7c", "0x2172fdf1", "0xb295c1ff", "0xd9fea90f", "0x2d530d9d", "0xf346cb47", "0xd23e1c1f", "0xe0c2ded1", "0xf2124702", "0xdc7a2316", "0x4cece2ae", "0xe703fdd2", "0x7bdd1c06", "0xc0d41324", "0x1ef6b3c2", "0x60b02211", "0x7b2d51be", "0x7451c5a5", "0xe373fa64", "0x6c66f601", "0xc5130e7d", "0x22c5522d", "0xefff34f1", "0x4f020040", "0xd937b62f", "0x4d5d4e76", "0xe9319ef5", "0x5201e652", "0x7133034e", "0x61e1cf34", "0xfc0251df", "0xa04c3fff", "0xfed191bb", "0x12d01e76", "0xd0cd9e3", "0x3052220e", "0xee3af30d", "0xf7a1a90c", "0xe3ce3715", "0xd0303f1e", "0xd012a723", "0x5001e1ff", "0x1a5deebe", "0x221e0613", "0xd61f01d", "0xcde9112", "0x3f3114ff", "0x40d72f00", "0x3d32f352", "0x111fe36e", "0x1d0be391", "0x3f05110f", "0x5d2d01ff", "0x41ddb6e1", "0x2d240cfe", "0xc05b2fd0", "0xb150ddfb", "0x41f217f0", "0x22f911f0", "0x501c5df9", "0xe1ed0b2a", "0xe50091ed", "0xdd4ff034", "0xf0094e54", "0xf004232e", "0x14bbe6b6", "0xea2514e0", "0x23fdc453", "0x20fd004c", "0x2bf1cb32", "0xbf0ac0c", "0xe1e7f24e", "0x3920f672", "0x74251604", "0xb21e41d5", "0x12cfe070", "0x6d11f23f", "0xed10c7c2", "0x1263ef1f", "0x10dfae3f", "0xedd3526f", "0x735f1e4e", "0x32d25630", "0xcb11c30c", "0x16e50222", "0x1314912b", "0xeee40cc3", "0xdf0c7001", "0xc9f13f7f", "0x751e0ef1", "0x2d2476e2", "0x5edbc052", "0x50d90d6a", "0x27b10912", "0xc6e32045", "0xf4c162", "0xb051fdb1", "0xbb1e6503", "0xffdb5dc", "0x2dc33a7e", "0xefc0e01", "0x61e11145", "0x4fe73e20", "0x3090ecd9", "0x9e1ecdbc", "0xfdd73211", "0x1b5a37e", "0x29325bc3", "0x4f091f91", "0xd3dea2d2", "0xf0c6ee0c", "0x3021e19d", "0x51dd0fd", "0xabd13ef4", "0x4dff2421", "0xdf20126b", "0xd04c02b6", "0x12a3d2fe", "0x54705b6", "0xf0300315", "0xdcc3d105", "0xcb1b402b", "0xa11bfe9d", "0x19c41f19", "0xdf6a0eb0", "0xc20d1e6d", "0x45d57fc0", "0xd01f69c0", "0x37019f70", "0x90d634e5", "0xf017d0a5", "0xbef1500", "0x1b7900bf", "0x14079c13", "0x30e7feef", "0x30dfc12b", "0xb1e11f", "0xb2a65b0e", "0x2c1731e2", "0x447220c5", "0x59eb02f1", "0x7de739d7", "0xa41f15e2", "0x302edffe", "0x56c1fa9f", "0xb0e9ea79", "0x3fdbffbd", "0xcd4339d9", "0x2a50ffb1", "0xff2df369", "0x4dd03d9", "0x30fded73", "0x3e02fc04", "0x9139da2b", "0x7cda3fb3", "0x92094999", "0x290005bd", "0x3213c402", "0x40d4eba3", "0x7f270d0f", "0x5550f0e4", "0x1e0e3160", "0x3ce91eb7", "0xaf11f13a", "0x4d0103dc", "0x91b113d0", "0xe0d90cf3", "0x90a4ce3a", "0x7942eeca", "0x5b9ff14d", "0x20c9b0", "0xbc15fd49", "0x4df9063c", "0x9c293be9", "0xfd1f11e0", "0xd1a3afe2", "0x5912d902", "0xade0c17e", "0x2dd13fe3", "0x63c134e", "0xf2bf020c", "0xeed07e19", "0xd010b0dd", "0x404d9522", "0xc9751da1", "0xdbf1cf70", "0x1114da00", "0x63420ae0", "0xe15c1a46", "0xdcfdf4d2", "0x701df2ff", "0x9fa0ea94", "0x1da241ae", "0x19bfb21c", "0x175f3347", "0xd5e31fe9", "0x150f016", "0xd92941c9", "0x3fddb41f", "0xc0df43f7", "0xddfc1340", "0x14c3102", "0x34de4c05", "0x2cef414e", "0x23f701e3", "0x5c6c500a", "0xea6bffee", "0x510cbf59", "0x74f1b39d", "0x11ec2f71", "0x1db0dd5d", "0x5b400efc", "0x9e1f01de", "0x2f9943e", "0x1436634f", "0xbf191f5f", "0xf7ae176b", "0x3e0f0a1", "0xd7e02262", "0x5ed04df5", "0x12f133c", "0xe46cdeca", "0xe5654f0", "0x90705e55", "0x6704a77b", "0xc7b212be", "0x274472f2", "0xde1e5f4e", "0xdb511420", "0x11d12f10", "0x634111f", "0x4b35f7", "0x47539161", "0x27f02f2e", "0xe1c04c12", "0x24df0060", "0x2406f101", "0x5f2c15e5", "0x12220f9", "0x33f99f", "0x1e9a42ef", "0xf44427f9", "0xa1000f2d", "0xb72ebc3c", "0xe900f005", "0x9fc492cb", "0xf025c0bd", "0xc0212593", "0xf2e142e2", "0x346129be", "0x91943ca1", "0x29022e4b", "0x1497130d", "0xfc04edc", "0x1111fcd9", "0x606f2f42", "0xd0290f1e", "0xa4a450f4", "0xfa13c92", "0x3dcc1a19", "0xbe2d0d0d", "0xe2223ebe", "0xc5c3f3e9", "0x30213990", "0xe20dedff", "0x4fc142ed", "0x201d3e5a", "0xb621c911", "0xd9240541", "0xced6e0ed", "0xde13bcb9", "0x30a0d072", "0xafdcbeb2", "0x461f7900", "0x195b1ab", "0xfaf15915", "0x471504d1", "0x624f73e6", "0x10f31faa", "0x170224f", "0x7240fd4f", "0x43327d41", "0x14413462", "0x1fe6c729", "0x93740c31", "0x72f151cc", "0x64c61060", "0x214421f1", "0x2761af1d", "0x2ad1d101", "0x4f2fdfe1", "0xe0f104c0", "0x4e2fff3", "0x71e174ef", "0xd0002b31", "0x192f100", "0xd6f41e6c", "0x9fd1421f", "0xa01c3", "0x90fd03f2", "0x330ef0bd", "0x130cf132", "0xfe3b034f", "0xd0efcf4f", "0x9416dcfa", "0xa2432210", "0xf1d020ff", "0xf342fae3", "0xcf3d00f5", "0xd211b001", "0xf0b15e29", "0xf0a3e1a0", "0xeefa761", "0x2f0ad6f6", "0x3f02e237", "0xee2d7c5f", "0x2d7311f1", "0x9e23fee", "0x21c5e009", "0x30d0df31", "0x7cf5b77f", "0x651cc241", "0x104fe2b0", "0x11403e40", "0x26413fc", "0xa91e57f2", "0x51070e10", "0x2092cef3", "0x5ffcc0e0", "0xaf4a1cfc", "0xb5fd03f3", "0xffeab5c", "0x6ffc0d1a", "0xeddd77ff", "0xd2b1095d", "0xdff0dfeb", "0xe014190", "0x63ee0f93", "0x39b14da2", "0xdeef2150", "0x1fc1cde", "0xf94f401d", "0xf193ee1e", "0xfbd0f1", "0xddf729c", "0x771dd35e", "0xedfed3b4", "0xb4ed020", "0x2ee00c31", "0xf93f7f2e", "0x1414ebc1", "0x40d01d1d", "0xef2136da", "0xf26be09e", "0xcffb25fd", "0x1fb0bf5e", "0x4d000d69", "0xd24d5ba", "0xe06edcfc", "0xb17e02a2", "0xeddb1d95", "0xe5d12dfb", "0x41de39db", "0xaeedb22e", "0x11df1f02", "0x23e372d1", "0x262fbe69", "0xf17ef0e2", "0xd0f0299f", "0xf23fc5f", "0xf20fba0", "0xb241a3b5", "0x2607f2b2", "0xa00c374c", "0x34715950", "0x501d17ef", "0xa5fdfe30", "0xf02d0e9d", "0xceb6bc0", "0xd3edc6d0", "0x25a0f4d9", "0x22e544ff", "0x2e1f3100", "0xd0fdecce", "0x333773af", "0x1f20330", "0x6255b363", "0xf216c7df", "0x7411001", "0x3412e7cc", "0x2f1fdd50", "0xd020d42c", "0x5425692", "0xfeecfd0e", "0x26f1d59e", "0xe5efd9c7", "0x6000007", "0xe1d2b1ec", "0x2f0bae0c", "0x1045f105", "0xc5ead2c4", "0xed5eeaf", "0xfb5e1ee", "0x3eee31db", "0x7f3d0c3c", "0x31ce4911", "0x221a6502", "0xf0cc9f23", "0xeb022d9b", "0x1f2a4d59", "0x5efbdf12", "0xcee7cf1f", "0xf3ff020c", "0x3fe4ccdd", "0x5fcfc7b3", "0xe03109ee", "0xdf2d271f", "0x4ecacf3f", "0x427933ef", "0xa33433e0", "0xf05d1fbe", "0x95acd5ff", "0xccea9d9d", "0x1f336430", "0xdcf2c67d", "0x20f0be95", "0x4b19e5d9", "0xc1e17100", "0xb3f7f4fa", "0xf20bc24e", "0x2ddbf5e6", "0x20cffce1", "0x201334f3", "0xb3fe17d", "0x212c0fb7", "0xcf001efb", "0x3fdc0d00", "0x9f39dc39", "0xa0d7efe", "0xf13f3bb0", "0x225f0541", "0x4416b475", "0x21df3f4c", "0xb1ff023e", "0x4bee0ee1", "0xb0bcbbfa", "0x2de9a221", "0xf02d65f0", "0x1dd3b47e", "0x571797c1", "0xbf06c461", "0x4d1ef05a", "0xe5e202bd", "0x72e01baf", "0xcce11d29", "0xe0fbe492", "0x550c3290", "0xecc121ff", "0x2159ed59", "0xf7bfe71e", "0xa27f40a", "0x6f224f4e", "0xbb522179", "0xe0f227e2", "0x54cee50d", "0x9dde5dfc", "0x14ceef09", "0x50fcefdc", "0x2df705c4", "0x2fbe5b43", "0x2c162b1a", "0x70e3175e", "0x25cff0e1", "0x50ff4bcf", "0xb0e99ee9", "0x6293d4fa", "0xe9070430", "0x5d9e4f52", "0x434de2f", "0x4f2e50f1", "0x409b24cf", "0xdd0c4d4b", "0x12cb0d3c", "0x3defaae", "0x19a70bdf", "0x6ced3d33", "0xee34de34", "0xcd2256", "0x16efd0fb", "0x205257f3", "0x10e47ce2", "0x23b00cda", "0xdade0f77", "0xcbfc39d0", "0xdcc52c40", "0xf0cbd0c4", "0xf00af9ab", "0x20903f42", "0x4c0d32d0", "0x31c030d0", "0xe04c1f71", "0xbdcdedee", "0xd551e4e5", "0x30213ded", "0xc50943c1", "0xde2c7b10", "0xb1132d22", "0x34d1342d", "0x1d6a1ef1", "0x300c121c", "0xe201a5e1", "0x50f52402", "0xbe1aed5f", "0xee47349c", "0x2d27410d", "0x2ed3e3cc", "0x4d100efe", "0xcfede101", "0xc2f6003d", "0x103ef31e", "0x2a02e239", "0x6c475cd4", "0x3dfffc4c", "0xaad7e2a1", "0x5450d5d", "0xfd301ac2"},
{"0x1f1101e7", "0xf0e3ad2c", "0x271e32b4", "0x7f9e6bf2", "0xd2b02ebb", "0x2e1dd2f9", "0x3b1b0f40", "0xc1f9be39", "0xd27fd5d2", "0xa0012e51", "0xc1e120f9", "0x615ff0b1", "0xfe6b4d11", "0xb71db179", "0xf25af361", "0xf31d0ec9", "0xfb6c2721", "0x6f943edb", "0x14c41d50", "0x317f00f7", "0x64405f77", "0x7d1ef115", "0x2a2d0135", "0xb37e17e0", "0x3d1f01c2", "0x1f2e1e1e", "0x1c0e4203", "0xea116bf", "0x2ddefcaf", "0x326f2029", "0x3d2e0014", "0x5bdf0f0a", "0xfd220794", "0x70e99d", "0xb315b314", "0xd5c2394b", "0xe1015701", "0x2d0fe339", "0xef210f11", "0x51cfb11d", "0x532fc354", "0x702f26fa", "0xdd100e6b", "0xf1ea1d24", "0x1fbf54f5", "0x3a1dffff", "0xfda41453", "0xd1769ec7", "0x4e3fbb12", "0xffe200c3", "0xcbfaec01", "0x726f20f", "0xdb0129cf", "0xef22f26b", "0xdfd100ff", "0xfef22d0", "0xc23f2eb3", "0x13f902c", "0x79e0cbd2", "0x1fe4ff5c", "0xfa0333cd", "0xd11d0db", "0xd0b90f91", "0x16ecb5ed", "0xf0fcdb0", "0x1112ddec", "0x9d01cfe", "0x2fc31f39", "0x1346fc3", "0xc013c2e", "0xba001ab0", "0x11f43bdd", "0x99ddccef", "0xbf3edf03", "0x39310c39", "0x6c6646f1", "0xd60fd1db", "0xbec0c19c", "0x406d1e1d", "0x3d40693d", "0x1d3e4dfc", "0xf02c0eee", "0x4700f02f", "0xfde3390", "0x15c343e", "0x94f13dc9", "0x16b6f40f", "0xee3020ce", "0x7b475b26", "0x30da4f52", "0xdce49c3", "0xf232bf7d", "0x2127d33d", "0x13e9150", "0x64ea02ed", "0xe3d062a0", "0x9be9d0a6", "0xc1d353", "0x19d10929", "0x200514be", "0x441001c", "0xcc111cb2", "0xe14d00fc", "0x1abbb90d", "0x9de9c320", "0x2ff2f21d", "0x4a0c200f", "0xf202f2f0", "0x1fefcb0e", "0xb11f49a1", "0xcced00ec", "0x1d4e1cd1", "0xd1265116", "0xf05c322e", "0x641f400d", "0x3d1b5d71", "0x51052bc4", "0xb32bc2c5", "0x30591305", "0x130516a0", "0x9ffaa20d", "0x3101e1f2", "0x111ee17d", "0x3c94e01f", "0x1f3277d0", "0x12220e5", "0x92fcfd5e", "0x196c9db1", "0xa40a150e", "0x31c1afaf", "0x14ed707e", "0xd1b69afc", "0x91f440e5", "0xc7fd3f14", "0x91ca0ef9", "0x1b4b1f04", "0xb12cc343", "0x3190e1fc", "0x122e15c0", "0xcc0d6f7f", "0x20f3b3c7", "0xd757cf30", "0xe2fc1475", "0x10ed3243", "0xe00120da", "0xf10df11e", "0xd1e0d133", "0xcf115a1e", "0xdc900d91", "0xe0d51144", "0x1f3f1e30", "0x555df950", "0x2ed4e9eb", "0x30c10363", "0x152f052", "0x1eebc7ff", "0xe471ed22", "0xf605fd4b", "0xd0ed034e", "0xe02db6ed", "0x1d049a5e", "0x3f40ead5", "0x1b0f107a", "0x1121f12b", "0x21f3d912", "0x2cf6b05e", "0x507905dd", "0xd3bfdfec", "0x40202301", "0x400f5a0f", "0xba4fac51", "0xde312e7d", "0x2d9b2c9f", "0x23b6eb1c", "0xa2de0e2f", "0xe9ecd0", "0x9cf2e9f9", "0x307bc463", "0x46e029a3", "0x7b1c240b", "0xc24ff1ff", "0xe6cf14e9", "0xdc5f0155", "0xee2f9b4", "0x9c160caf", "0xaf20737f", "0x13cb19fd", "0x6c413949", "0x64b31f91", "0x9962ee27", "0x7dfff1e3", "0xfdc65aa7", "0x23217531", "0x50335cab", "0xc4100101", "0xcfd0ff3d", "0xd1fd0bee", "0x1da30e0f", "0xef0efde3", "0xed0cefd", "0xee1011e6", "0xb122ce", "0xe5e4b1b", "0xedb343fc", "0x1fb0cb1", "0xd00e9c", "0x21eb13e0", "0xbe3be9ed", "0xfb12b12e", "0x20212fb1", "0xdd54397a", "0xbca72276", "0xc29c13f0", "0xeabd22fe", "0x9f3c07fc", "0xa179abfa", "0xe2310503", "0x20dfcc9c", "0x9ca5f212", "0xf21fc1c0", "0xf51d9bc9", "0xf49ed714", "0x4fe01ca", "0xed229c04", "0xf20737e1", "0xff343920", "0xb0d13c6a", "0xbf3007f1", "0xa1100a0f", "0x7151a263", "0xfd5f0940", "0xe263cc04", "0x509ff60e", "0x41c4b436", "0xf433e31c", "0x51dfe5d4", "0xce25e96e", "0xd13c9546", "0x46c701f6", "0xbce712b6", "0xe43706eb", "0xe094fd9c", "0x9cf3d1e0", "0x270af196", "0xa6c01fdd", "0x402dff0d", "0x1fc002ba", "0x190ec261", "0xe146c71e", "0x1f222ec9", "0xb0223630", "0xf2aa09df", "0x231a1c0b", "0xef1f11b0", "0x905712db", "0xe12ed730", "0x90e0a7fb", "0x2f2e47d9", "0xc37fd0f9", "0x690e5b93", "0xb20ae13c", "0x90db0441", "0xf3c70111", "0xe363a320", "0x3c291301", "0x40b104cd", "0xc2353120", "0xe62922d3", "0xb43eb2f2", "0xd22212ff", "0xe33c040d", "0xf4efaf21", "0xc19ba03", "0x3cb2fb", "0xc15165a2", "0xed493252", "0x1003d430", "0x2f10606", "0x1f131699", "0x160e1151", "0xc00d9f42", "0x2f1ac02d", "0xf5734291", "0x2f0f53a1", "0xff62d0f0", "0xf01442f2", "0xe01f0490", "0x1c2261", "0xb314d23f", "0xd001f62b", "0x44f5fb56", "0xdbcfcd42", "0x7ff6e43e", "0xea51c0d0", "0xdf110005", "0xde5eacbe", "0xd2fff7d5", "0xe02d3943", "0x2be17e76", "0xa210dd32", "0x720cf2fd", "0x432c3310", "0xb16b0063", "0x237f29ee", "0x1d9a9796", "0x716029e2", "0x1e0bf936", "0x9716d9fe", "0xd0fdcc7a", "0x7e2a303b", "0xa1bffedb", "0x140e3f1f", "0x1f25f60d", "0xf0be63f7", "0x540ebbe0", "0xdda1c206", "0xb3072b21", "0x3d029ee2", "0x334fdf2", "0xec902df", "0xbbfd0304", "0xef1c02fe", "0x1cadd222", "0xa1bfbf40", "0x442322e0", "0x2d111bdc", "0xeec2f1e0", "0xae0339f0", "0xc39f1394", "0x70f52d9e", "0x6eeecf1b", "0xd1362efe", "0xa40e0969", "0x7dc0fdd1", "0x9f910fcc", "0xf3dd134f", "0x1932b0a3", "0x90e00d64", "0xc025d5ff", "0x2ed4fa0a", "0x5d050303", "0xba1caae", "0xb9520e01", "0xf1cecc1", "0xbe6a23e4", "0xb0725344", "0x4faa95fe", "0xe1a0efec", "0x3c72f65f", "0x22c00ecb", "0xdbc00123", "0xd2df7a42", "0x91001d94", "0xef5d4474", "0x3dff9ffd", "0x35e57bff", "0x6fd1114b", "0x2ac131eb", "0x2f300afb", "0x19b1013", "0xb01d1931", "0xdf4e1ea1", "0xc4e4be", "0x14100f5c", "0x4a0f100", "0x3cd21a0e", "0xfdd10fc3", "0xfa2de449", "0x15b31e1b", "0x6ef2e", "0xd3c0fe12", "0xecf32cff", "0xa3a1f122", "0x5e161fd4", "0xdad0cdd", "0xa3fdcfa9", "0x32f4102d", "0x203232cf", "0xecb97df3", "0xcb20d33e", "0x71c9414", "0x91745de4", "0x2ff00e91", "0xdfded96b", "0xc2519033", "0x2fc2bb9f", "0xb303421", "0x210be19f", "0xe00d072d", "0x2524e10", "0xfce0f09b", "0xec4ff249", "0x77434de2", "0xf05d3ef2", "0x202052cd", "0xff643546", "0xecd19414", "0xf33100de", "0xe3290da1", "0x20e3c1bc", "0x76264de7", "0xdf0f7911", "0x2730f7e1", "0xc3412577", "0xfb36cff7", "0x7e73e206", "0x603909c0", "0x3e97ddf3", "0x12522d05", "0x114e0d", "0x1bc395e0", "0xcfddfd7e", "0x10eae11f", "0xdff95eeb", "0x64d20c9c", "0xd2e0f10d", "0x13c510b1", "0xc04c2ebc", "0x450c411", "0xc1a2ef2e", "0x2f00dbd", "0x1ec0c0ec", "0x71e90fbc", "0xfb60cd9e", "0x216f3d7", "0xc1126c24", "0xc403b631", "0xd5d1a431", "0xc057cd2", "0xf00c9de1", "0xfd090275", "0xdf76f1a0", "0xfe2af743", "0x117ebe9d", "0xdf250e24", "0xef2e00f9", "0xc1fdeef0", "0xef307021", "0xdddb0392", "0xe2c0c63d", "0x41c0574", "0x7f520f0e", "0xcd33db0f", "0x1e1cd960", "0xaedbb3b1", "0x2cf41cc6", "0xaefe016e", "0xd66b9149", "0x26ae2733", "0x20dddcca", "0xc20f0fa0", "0x9d2dea7b", "0xe11a25b3", "0xf62ed30", "0xb9091123", "0xa31d920b", "0x1efb522d", "0x1161211b", "0xc0034931", "0xdfe0199b", "0xccedff4c", "0xecff0d1d", "0xcf9019f", "0xdc5f044", "0x25272400", "0xf5f6f35", "0x7d77f611", "0x7e10e72d", "0x32342432", "0x16d007a6", "0xe37017a", "0x775fd456", "0xe00e301b", "0xf00de299", "0x9377f2df", "0xaaef496e", "0xd400296", "0xa059faee", "0x9a11294", "0xa6c9b919", "0x2fda1ef", "0x20c2f094", "0xaf40f911", "0x9cdee5e5", "0xf21e3dfe", "0x3f31d3d0", "0x9d3bfa02", "0x511f04e1", "0x73e05ff2", "0xc0e0f99a", "0xc420237e", "0xcff3d6f1", "0x2c5ef059", "0xf522312b", "0xf01cfeac", "0x21c591fa", "0x2fed1210", "0x109071d6", "0xa00f13f0", "0xaf032406", "0x46b2efb6", "0xb9de4a47", "0x6103f131", "0xa1695d51", "0x4125b7", "0xd04b0f1f", "0xee3e45ef", "0xfffa0ee0", "0x4e201acd", "0xa10fc53d", "0x2123022f", "0xd04d613d", "0x1f4131f2", "0x200aff10", "0xf12fa2fe", "0xfbc1cf9f", "0xe0112d11", "0xcffff302", "0x11400111", "0x5e2f1f", "0x1310320d", "0xe00ff3f0", "0x102130d", "0x30cedf91", "0xab024d4f", "0xf01e02f0", "0xf0e10fff", "0x23540ef3", "0x1dd14fef", "0x20d91f1d", "0xfbdf13b1", "0xf0f20424", "0x122e0f2e", "0xfff2c2f0", "0xff23f2c1", "0x571e011", "0x1f3040ed", "0xcf30e2ee", "0xbcd0cfdf", "0x3efde100", "0x1a3f2e00", "0xf211ef2f", "0x1fde0110", "0x370e1f22", "0xb0e3ede", "0x113a40d", "0xe13edef", "0x2f0ce302", "0x2c1c02e0", "0xf3ed1f1e", "0xfe00041f", "0x51cf010", "0xccffadd2", "0xaf9edde1", "0xcf4f1def", "0xdf300002", "0x71f14f27", "0xe102cee5", "0xe040023d", "0x2240966", "0xccd2fcdf", "0xf0d5011e", "0xefedcb2c", "0x21221e21", "0x2ff11c13", "0xdedec003", "0x3e0e110e", "0x4e0041", "0xe1e0ff1f", "0xfee1f2", "0xde11c6c", "0x52122323", "0x3fdc4e", "0x13c10103", "0x12b01f2", "0x126dbc1e", "0xf00000", "0xf000f00", "0xf0fff010", "0x101001f", "0x10010110", "0x101", "0x110f100", "0xf010f0", "0x10010", "0xff10", "0xf00f1000", "0x10f00000", "0x10100001", "0x10ff110", "0xf0", "0x1fff1", "0xf01f1f10", "0x10001", "0x10ff0f0", "0x1ff0ff0", "0x10000f", "0xf101", "0xf0f00", "0xf0ff00f1", "0xf11ff00", "0xf00ff", "0x1ff", "0x1f00000", "0x1f00001", "0x100100ff", "0xf000000", "0xf00f00f0", "0x1f000f0f", "0x1f010000", "0x10101", "0x10f1f0f0", "0xf0100011", "0xff00f000", "0x110000f0", "0x1f0f", "0x101", "0x1000", "0x100", "0xf111", "0xf0f01010", "0x100f100", "0x1010001", "0x100010", "0x111011f0", "0x1f", "0xf11010f", "0x10000", "0x1f0f010", "0x10000001", "0xf0f1", "0xff0111", "0x1f00f", "0x0", "0x1f1f0010", "0x0", "0x1f01000", "0xf000000", "0xff00ff0", "0xfff", "0x1000f00", "0x1f1011f", "0xf01001", "0x10ff010", "0x1f0000", "0xf000000", "0xf00000ff", "0xf001010f", "0x5302fc75", "0xd001f0d3", "0x30d907b1", "0xfc16d335", "0xac17f926", "0xe056f051", "0xe1420017", "0xc014e39e", "0xdd0acd11", "0xd14713", "0x62f929a7", "0x425101c3", "0xe515a243", "0x111670d1", "0x43070102", "0xadb03ec6", "0x241bda74", "0xd0feff2f", "0x203ec4d1", "0x3f07d340", "0xee121b24", "0x3fe2fe02", "0xf1440247", "0x10f001f1", "0x3aef151f", "0x607f633f", "0x59cc15f5", "0x41de00f1", "0xf01f9ef9", "0xef555c41", "0x19160132", "0xaf21e2c0", "0xcbac000b", "0x1d33e0", "0x92dedd3", "0x7f36fed3", "0xb70c9179", "0x1fc64241", "0xbaf70603", "0xa7b119e", "0xd6c1ce23", "0xf03cf0ef", "0xda6247b4", "0xdf1012f0", "0xd3031b20", "0x13c130ff", "0xd22d0507", "0x3150d301", "0x35d2f44d", "0xd0d35d21", "0xcd2323d4", "0xd4eaa342", "0xef6292e3", "0xd2e1663f", "0xf2ba0fc3", "0x1e1929d", "0x324c756e", "0xe1dde60d", "0xbb56573e", "0x163c5226", "0xe23e92ec", "0xb2904420", "0x35cd14b9", "0x34c6e4a1", "0xef1cd005", "0x1f207cdf", "0xe37003f1", "0xfffd10a2", "0x2cf2c1de", "0xd2e225f4", "0xcd99f1f1", "0xd0d01f04", "0xef5de56", "0x6000044f", "0x65170e41", "0x25e9ece3", "0xf3174522", "0x1e4e0216", "0xb606f926", "0x35de3700", "0xeef02a6", "0x90d14c07", "0x2300cc2b", "0x1f327cdc", "0x13a902fd", "0x9f1923dc", "0x36991ff6", "0xc4fe061b", "0xf04d121a", "0x40f71ee9", "0x6401ca01", "0xc4167cd3", "0x1fc15421", "0xf2cd19de", "0x11b60950", "0x47eac7d0", "0x7013f705", "0xefaee150", "0x290e799e", "0xce3de022", "0x375232e2", "0xc75dbc02", "0x2dc1f9a4", "0xd0f3d1e4", "0x396576b2", "0x406274d0", "0x76cfc179", "0x5d563427", "0x17ec5323", "0xd9f1154a", "0xb704093c", "0x31ce4639", "0x1fc405a", "0x2f422339", "0xe1fe2ed0", "0x941f4e5f", "0x43063202", "0x1eca2b04", "0x1edf0003", "0xf10fb7a3", "0xa310be", "0xb1de4172", "0xdc2121ec", "0xfe2ded", "0x31e70201", "0xecd0c053", "0xf30703ff", "0x4f3f5a14", "0xcfcd0ff9", "0xd13ecf14", "0xc99ff6f0", "0xd1de4313", "0x61cf2202", "0xd9cb6932", "0x1a5f00cb", "0xa03f002f", "0xd0dd50eb", "0xd159ea9e", "0x91d02ea9", "0xe00f51e4", "0xe5c00520", "0x49f2321f", "0xbc2c0d2f", "0x102e4e4d", "0x6461e223", "0xdfe990d0", "0xedf5dd1", "0x1030c7e", "0xff5ad9de", "0x6120c0e", "0xfdeefd25", "0xc4fd701f", "0xd4412f01", "0xe1ddf25e", "0x2e923c2c", "0x4e121b2f", "0xe1e1ce0", "0xbb20ebf9", "0xacecf123", "0xffede969", "0xee0054f3", "0xe02de239", "0x6a9dfb69", "0xea12ba2c", "0xcefe3b0d", "0xcac6e23b", "0x90713e2", "0xfe07b10", "0x534a6e72", "0xdf5a5770", "0x71d9c009", "0xbe6f432f", "0xdc72a909", "0x44e32710", "0xd454f0f4", "0x79a21cf3", "0x562e6f13", "0xb02f79bd", "0x40bdd139", "0xbd1245dc", "0x2b202ec3", "0xfeed3c21", "0xedf9f33d", "0x9e26aeed", "0xc04c2f3d", "0x14d5740", "0x6c94a2e2", "0x7f1df311", "0xf54e2ce1", "0x3d0c3f56", "0xfc5702f2", "0x5f0e7fe5", "0x409d4f6f", "0xd01c101d", "0xf5cc11fa", "0xe1d21d97", "0x2c011dfb", "0xf091f24f", "0xf5f001a2", "0x1d1101d2", "0x710d2fbe", "0xc1da23de", "0x30c9010d", "0x93e0d0ed", "0xfccbf09f", "0x4aaead9", "0xe3bf0143", "0x91124cdc", "0x241beeed", "0x10224f13", "0x12fe9e01", "0xf14d27fa", "0x25ce4310", "0xafedd2a", "0x952f717", "0x12303a03", "0xe46d3ac", "0x717220ef", "0xcf52dc64", "0xe0c35d94", "0x2de4171a", "0xfdedeb1a", "0x94110011", "0xc53f159e", "0x34c70011", "0xefc432c2", "0x5e0f1fd4", "0xed7e0dd9", "0xdd9c00ec", "0x1de3adee", "0x322df343", "0xafc31e90", "0x139630c4", "0x6f975b11", "0x31f0f102", "0xd1dc2eac", "0x9ec34e20", "0xea3f9a00", "0xe1790f45", "0xe2c72eaf", "0xb91fde9", "0x212f6c93", "0x4bc3ada", "0x92b25ac3", "0x52e902bc", "0x2b0b93f3", "0xaba60021", "0x73300900", "0xbc70fcd", "0xff32fca1", "0xe3770be7", "0x9d3069b4", "0xc009fb91", "0x310e92de", "0xe13c1fc1", "0x24cf6700", "0x21a70c4f", "0x21c7bd93", "0x2e4769f1", "0xa1d45ed0", "0x4ce46eb0", "0xf01ff0a0", "0x23eb0fe7", "0xb65c1753", "0x1d1955bf", "0x102c11af", "0x322e5b91", "0x91eee652", "0x732a2240", "0x5cd96f0d", "0xcce60f03", "0x44e25e12", "0x11225df", "0xef304af7", "0x2cdd07cf", "0x9fef5adf", "0x1b2c3ee1", "0x14cb0e6", "0xe0cf0e23", "0xd2024f33", "0xcdf1e0d", "0xff93ab01", "0x700d6590", "0xfd1efa04", "0x401ad343", "0x7a00e49f", "0xe2fde3", "0x4f1dc427", "0x65f2af93", "0xeffe7120", "0xe7e163e2", "0x64fcb103", "0xed14cd22", "0xc20feecf", "0x54c7043c", "0x4d9e17bd", "0x5113f112", "0x2fedf3e2", "0xe0c0ecb1", "0x15f011c0", "0xecf03ed4", "0xfedffbd", "0x45a614c0", "0x5913dee", "0xe260103", "0x21102e0e", "0x205419fd", "0x7210d503", "0xd140c24", "0xbe1bb492", "0x20d511fe", "0x16ecf39b", "0x2c4ee400", "0xbfbe4af3", "0xc00e0bc2", "0x3421d9b0", "0xd24b9bf3", "0x32df131f", "0xe1fd0e20", "0xbb3f20cf", "0x5e2414cf", "0x90f5615d", "0x70ceb7fc", "0xd2e40eaa", "0xe0fffe1f", "0x2bc0d0fc", "0x40160d21", "0xb0424a91", "0x4f1e39ef", "0xff935124", "0x2df01bb1", "0xf25db1ed", "0xc222d205", "0x126dd1e0", "0x4fbe0902", "0x24d3fda2", "0x21f173c3", "0x30543ff4", "0x31be9e6", "0x3e3c0eef", "0x315c4105", "0x2f0f155c", "0x217f1035", "0xe010f70e", "0x7d39020c", "0x1021f29e", "0xf27067e", "0x54e722e5", "0xc4b7e07e", "0xfb0a5e29", "0x3257fa9d", "0xf400a33c", "0x2b19e312", "0xef142121", "0x3f006171", "0xaf2cf2b0", "0x923c4dd7", "0x54293ce1", "0x7cdc1147", "0xf5390f3", "0x14f567ef", "0xd06229fb", "0xef55b4cc", "0x4003fdc0", "0x19c1ea93", "0xe1eef501", "0x4bdb0f4d", "0xe12f440d", "0x213332f0", "0x3339df", "0xa1c2d6cf", "0x1fdfb000", "0xee1edec2", "0xb10f45f4", "0xe90d0b1c", "0x460c3942", "0xa10faf3b", "0xf00e1bef", "0x2bf02006", "0xff13fe1f", "0xdf93cf22", "0xeef2211d", "0x2de3f1c3", "0xee0095c", "0x5ded1cae", "0x915f2e1c", "0x6740de10", "0xc092eec2", "0xfa013292", "0x1ecaa0e2", "0xc191dd9", "0xef932ff", "0x51b50653", "0x3f7f09fb", "0xd607367c", "0xb5ffa165", "0x63fc1403", "0x401e9ee2", "0x96bfbef", "0x47790529", "0xcff29f1f", "0x40a0ed5d", "0xfffc7af6", "0x4b00e0f3", "0x7e1c0f23", "0xd45f16f4", "0xd1fb0b53", "0xdf2dda49", "0x7b997d0d", "0xd024dd14", "0x21e1ecbf", "0xc2ceb043", "0x1e2adb0b", "0xc16697f2", "0x65da00cc", "0x6ef167d3", "0x10bb4c7d", "0x794990", "0x9c3cefb0", "0xb14eaf21", "0xa1ee1516", "0x3de59504", "0x3e3f00ee", "0x52c67202", "0xb4b1997c", "0x30c5fa09", "0x92f3990", "0xeeddcfe2", "0xeee7f27f", "0x4c22e4b5", "0x621e0ad1", "0x5ded23c1", "0x31fd6a25", "0xdf0e63", "0x21ce1c2e", "0xff2a421d", "0xc011112d", "0x5e0fedc5", "0x79691e2f", "0xe0672917", "0x1dcf29ee", "0x1053df49", "0x7c045240", "0xc32019fb", "0xfe90db41", "0x69fdd0d7", "0x7e3511bc", "0x3173d937", "0xec2d5d03", "0xcf2f2179", "0x1f2ca0ec", "0xb3f3f40b", "0xf023ec20", "0xe2eabe1e", "0xdf3211be", "0x53312b4d", "0x6e53c3fa", "0x10dccdd4", "0x2ec7ee2e", "0xce2b4d01", "0x20fee412", "0xaee7a90", "0xc0ff02f1", "0xdd24e45", "0x1ff5f219", "0x1f5b2fb4", "0xdd62ccd", "0x345cb7de", "0xf70de12", "0xd70c30a9", "0xce77fd52", "0x5dc92e1a", "0xced31ddc", "0x20fde7ef", "0xf43ebaef", "0x5f3339d0", "0xb4af0bb7", "0x790b11d6", "0x2f9601d0", "0x3a15f00", "0x252c202d", "0x300d0fdf", "0x74fb539", "0x91c402fb", "0xdbdf0c7", "0xbe0eefdf", "0x25d10ddf", "0x5d53d915", "0xfe2cb11f", "0xf7cfb", "0x477062e", "0xe2f0d6e", "0x3e919353", "0xc9ed20b9", "0xc2d5ff5f", "0x2e04c21d", "0xfee03279", "0xe0acd221", "0xce3720db", "0xfe06131f", "0xfea495d0", "0xcf4c1ece", "0x37e71f34", "0x101dd246", "0xe3eeccfb", "0xd00c3a22", "0x101b1be2", "0xf12f12ff", "0x5412b32", "0x442d1113", "0xbdbafe25", "0x5fe30bd2", "0x42a190da", "0xf0145ed3", "0x2dc9a20", "0xe00ba1ca", "0xfd1f1eb4", "0x2cff3e32", "0x3990b06", "0xf22adf0", "0x50f5f11e", "0x3f444dc2", "0xcd13bd62", "0xa234010a", "0x3354ba", "0x1dcf1e0e", "0x11e0fd12", "0xce6410d3", "0x21f1c50a", "0xc0079e92", "0xc1732901", "0x7ef2d506", "0x35d4e297", "0x902a0f21", "0xf761017f", "0x9161d74b", "0x3c91ec7f", "0x20d7d4df", "0xe3010a2c", "0x291ce120", "0x1f470f01", "0xa9dd632f", "0xe7df004d", "0xde75a10d", "0x12d20bd2", "0x4fff7123", "0xefdfcb00", "0x40fc0dc", "0x2b431b", "0xf1e9512c", "0x34200d01", "0x509247e7", "0xb97a9e0d", "0xcf3ed1ff", "0xdc0c39be", "0xc91ed3f0", "0x135e4730", "0x9230f061", "0x32f7fd9d", "0xf0ec3412", "0xc9fbf4c", "0xd03f72f4", "0x33cc3ebd", "0xe97ef6d3", "0xc10e1ffe", "0x9b0e6eca", "0x642f0dce", "0x21b21a39", "0x5fbdddd5", "0x70717d24", "0x17914c7e", "0x9e4d1d01", "0x930a4faa", "0xe2a3fb3", "0xde20cae", "0x6fc22df5", "0x5ebb241", "0x101ece9f", "0x946144cf", "0xc0e1fc70", "0x31d1c1c4", "0xa70f0f24", "0x9cd2ffc5", "0xebadb0c2", "0xe500c4d5", "0x1fa24397", "0xa6d056b1", "0x13ff04c1", "0xb2192edf", "0x66fdf72d", "0xe3df03e3", "0xc9c15cd", "0x2f3ee3f", "0x90036bb2", "0x97a95eb0", "0x2a031ca3", "0xdaca20ef", "0x9dea3220", "0xee00e07", "0x11a103f5", "0xf596c352", "0x1ff1b017", "0xfc666633", "0x3060d423", "0xcf13f3d7", "0x244406f3", "0xf43027c", "0xa6c20ae", "0xeec295c0", "0xc005df5d", "0x9fd47400", "0x51ac1d5b", "0x6d1a4ef7", "0xfe4206d7", "0x4c7b0b2f", "0x2a44edf6", "0x9c5eb4bb", "0xf040699d", "0xe6a901ec", "0xd9310ed1", "0x42c933dd", "0xeff1149", "0xf9c21b62", "0xa77320bc", "0x2b93b61d", "0xf074ba90", "0xd9e1ae2f", "0x4a17c129", "0xb2f30eb0", "0xd13fcf9", "0x3bbe00f9", "0xbd3bb31b", "0xbcac2203", "0x207ffecc", "0x3bd5161e", "0x2fd1fcfd", "0x540c1f05", "0xfef2dded", "0x76140244", "0xd1390fcf", "0x9b5abbc9", "0x26a03e", "0x4cd1d446", "0xb32441c", "0x4d0945e4", "0xa19122df", "0x49211e60", "0x3ff3f2", "0x27e21d5c", "0x6fb2e144", "0xd3f7fcf4", "0x2f5c12f7", "0xa0231a54", "0x12401dd5", "0xb0ddfc6e", "0x35b42011", "0x71a43d96", "0xe1ff6c99", "0x3af00c72", "0xcbf103c9", "0x2309febf", "0xcc3f1fee", "0x1ab90fbc", "0x9fdfd91e", "0x12cb4a9e", "0x40513fcd", "0x2b0cc033", "0x7e1e22cb", "0x15e9f3eb", "0x71ccf020", "0x193001d2", "0x5df54d2d", "0xd515f0eb", "0xf0231e7b", "0x2e023210", "0xfe2c7543", "0xd26e013e", "0x97f0e6df", "0xd33e0f3f", "0x7255a107", "0x3a914cfa", "0x20aee7c7", "0x96bcfdc3", "0x9abf73d1", "0xc41d00a0", "0x302d3bd3", "0x3d531224", "0xc2ee3d12", "0xfed2bbb", "0xf533bc0", "0xfceecee1", "0x9d024b1a", "0xa90f9c", "0x3dde19f9", "0x2f2e0fd1", "0xb291295a", "0xb5223553", "0x419e4605", "0x1233f53d", "0x14eff246", "0x3144f03", "0x4b3a0fb7", "0xb5af0271", "0x323eee4b", "0x3e7f2d6", "0xef5f0a40", "0x716e1f52", "0x790c7d3c", "0xd07ed03f", "0x9d20e7ae", "0x1dee046f", "0x6d1f9431", "0x31160027", "0x1fc12070", "0x4e301ef7", "0x39030a75", "0x3eb4b3ab", "0x92110c7", "0x341c0642", "0xfe3dfe12", "0xc30e6f13", "0xf0f02b11", "0x42e3d23a", "0x563a07e", "0xce430cc", "0xfc1fe2b0", "0x20000e25", "0xd3d5fcf2", "0xf20efd1b", "0xaff0afc5", "0xed712957", "0x19010e0c", "0x1f3ab007", "0xd342f423", "0x307fe23", "0xeb311da3", "0xd51a6240", "0x304ef10e", "0x9117954e", "0x401dfd70", "0xc0b01ccd", "0x41fe41c4", "0xe443f22e", "0xc60d9dff", "0x2ce0c57", "0xf054be14", "0xdfdbc03", "0xf702330f", "0x3e04f173", "0x3013401c", "0xb7be0e3d", "0x54e5b223", "0xf5ffaa6b", "0xf0ed9e0f", "0xc27319b7", "0x69ad0a10", "0xc001c271", "0x2674777", "0xe7d71356", "0x7e31d3c4", "0x7ec5237", "0x21fff23b", "0xac7ffc21", "0xd513f227", "0xb042737d", "0x2410243f", "0x7f70013", "0x174ec3c1", "0xeeafd2f6", "0xf0460d2d", "0x1ab0a9fa", "0xc9310cb1", "0x3dfb4ded", "0x1e1f5cee", "0xd0a902ca", "0x9d5c0d1", "0xdf9cd300", "0xa0e41af0", "0xbcaf2fee", "0xafd0504", "0x6e3bb003", "0x14d13f1f", "0x4eca00ee", "0x3b23bff7", "0xd1ec66ff", "0x91432ed7", "0xdd0f7dbf", "0xedfae525", "0x704bddf2", "0x53463f1f", "0x200f0155", "0xe5d6ebc4", "0xa732036e", "0xa042222f", "0xf130ec05", "0x95167c6f", "0xc1c3d3b0", "0x63fb7172", "0xfdcdfa0f", "0x491e2712", "0xf5eee3c3", "0xbf05e3fe", "0x3437f23e", "0xb43cb0b", "0xe2efeffd", "0xb1f3e3a", "0xe0461de2", "0xbbede219", "0x34ff1fe", "0xe0c4f20f", "0xef63107", "0x10360001", "0xeee0d202", "0xf26c4f51", "0x640e1a", "0xc930c1de", "0xf2c4493", "0x30703b5c", "0xe202f61d", "0xe93c013", "0x4209ebe1", "0x90097342", "0xdeeefb70", "0xfd60fc01", "0x12b11fdb", "0xf3c32ff", "0x7cde20d5", "0x3ae7d01d", "0xc2c10b0e", "0xd0e02e21", "0xfcdcfd03", "0xcbdbbf0d", "0x461e05f1", "0x10151fde", "0x5d01b746", "0xc0e2b431", "0x9e1e3fe0", "0x53f23c20", "0x2d220301", "0xbfcc2d12", "0xe049f12f", "0x5f7cd00e", "0xc211c32e", "0xd9bfe4f3", "0xd11a1124", "0x90ead0b3", "0x1204f997", "0x260d452e", "0xce0a61fd", "0x404c36ef", "0x1e1e12ea", "0x40ec6193", "0xf9fe9d9d", "0xbed13244", "0x24f9fc03", "0xaffeff2e", "0x341c61ee", "0x201f2021", "0x2cf2c239", "0xe00f12b2", "0xa90d2099", "0x2020104d", "0xe30d02c0", "0xfa135942", "0xa0efc201", "0xaec121", "0xf1401a01", "0x6a70d2f6", "0xd33fcd10", "0x6ebdf304", "0xde590ffa", "0x402deeae", "0xe10fd430", "0xf0323de0", "0xeec239f9", "0x2d24ce6d", "0xbf11010f", "0xee2e5beb", "0xfe5e0ef0", "0xebdd5ded", "0xd0eef173", "0x109f3ffa", "0x140b23cf", "0x14b1d1c3", "0xe1bd750", "0xad491c91", "0xc5bffde5", "0xf21901dc", "0xfe63d352", "0xf2fc1f", "0x3906dc7f", "0x3a37bf90", "0xeffe30f2", "0x39a1add1", "0xd0f20ffc", "0xdf720c5a", "0x1fea1002", "0xb01c5b30", "0xd1cf0c0f", "0x43319b90", "0xf0dabfff", "0x6e1e6ff5", "0xfd620de3", "0x7d0430e5", "0xffcc1231", "0x10db2cd1", "0xb6e90fa3", "0xc1aa0c9f", "0x11eef209", "0xbf49fc9f", "0xebf1a33", "0xffbff231", "0xbb4f0e09", "0xd0dddf01", "0x29de19c3", "0x59d792cc", "0xde32316d", "0x2dbec211", "0xc939122d", "0xdd5f1ecb", "0xccde35b9", "0xe04e64fe", "0xd4db5f2e", "0x2532ee2d", "0x232bbf99", "0xefcb7e0d", "0xbe24fde5", "0xe2f24262", "0xf3e0c600", "0x4fdae319", "0x6e1af1b3", "0x193afbc2", "0x21ce57f", "0xdc4d90ca", "0xbbb104ef", "0x679616f7", "0xf2405c5e", "0x50e0e103", "0x1f563f2e", "0x200ff2ce", "0xb9b4fb5c", "0xffed030", "0x42f13ee", "0x11701213", "0xfee11a4e", "0x20e302f0", "0xe102abfd", "0xc403fcd0", "0xd097c0d9", "0x162f090d", "0xd62010d4", "0xeb1f005d", "0x1fb4f510", "0x2020f103", "0x2232eaef", "0xe2f2f1fa", "0x2120e02f", "0xfca4f2fa", "0x1043f00f", "0x4c13ff16", "0x10e9190a", "0x10deeaa4", "0x930b2ce1", "0x99cdb901", "0x2c921457", "0xda33176c", "0xae9039d", "0xffc20bd3", "0xbdc0d9eb", "0xb0feed79", "0x2d5dcb02", "0xaf9219e9", "0xac16d34c", "0x9bd51139", "0x34ef049c", "0x7f2292e7", "0xdd159745", "0x60d4060c", "0xfd27fc3c", "0x2fa2ef09", "0xf050b11c", "0xf4e536c4", "0x47f7143d", "0xd270e704", "0x24e7d24c", "0x40314467", "0xffe90c7e", "0xef6ec71e", "0x9a710e24", "0x473f1316", "0x74020e72", "0x3ee06c21", "0xcfe5be0d", "0x30df3627", "0x1099c9dd", "0xf04b1414", "0xe961bb23", "0x721333b1", "0x63210c72", "0x21fe7d14", "0x9ff12912", "0x30d02292", "0xef2fcff4", "0x2ec45eea", "0xf9de2f4f", "0xe0f1144f", "0xf5100d61", "0x310fd06c", "0x1e956112", "0xa0043c6f", "0x44ae000e", "0xc43e2e5", "0xc350ea43", "0xe404f1d2", "0x2d000079", "0xeb9f622f", "0x3a049e", "0x901362ef", "0x3e9cd497", "0xcee9df5c", "0xe051ac71", "0xacd5dcaa", "0xf2d711ce", "0x32936b62", "0x10d925db", "0x23672a", "0x19c110ac", "0x1501e51", "0x4111c0b", "0x6be09e12", "0x1115032d", "0xce9e6bef", "0xc0d5f311", "0x7044d3f2", "0xd220752f", "0x9101ff5", "0xc1fbb21c", "0xb203a210", "0x4f4055a", "0xedd1e7df", "0xe24cfae0", "0xe027e0bf", "0x1e9f34d7", "0xc71b0a1", "0xd0ecae39", "0xd0e79ecd", "0xe05310e4", "0x4a951615", "0xe10de769", "0x9110c742", "0x1b70737", "0x7030cf11", "0x3169e54f", "0xad45b033", "0x2c36fbce", "0xfc90c220", "0xf0e0ac54", "0x107603d3", "0xb41e2cca", "0xb9e102b6", "0xde935f", "0xdc3c4d2", "0x1ee0129e", "0xfd4336df", "0xf31cfed0", "0xf05f2002", "0x1fac0b3d", "0xd9ff90d3", "0x6e95225c", "0xee70a01b", "0xf0270224", "0xf0747c04", "0x41e216a", "0xd0040416", "0x20de0eee", "0x1fcc7d0", "0x6516b319", "0xb023aee0", "0xc9401304", "0xed3fd2d2", "0xe3f0e03c", "0x71ee17c4", "0xeeb31f1", "0xebafe222", "0x3274e216", "0x904f121d", "0x531010b2", "0xb0c274ee", "0x2dc2a306", "0x40400ec0", "0xe90ecbd7", "0xf96f1f2a", "0xf20cdfcd", "0xc230d0df", "0x296911e2", "0x9251e6cc", "0x3eaf1f01", "0xe02314a5", "0xdb409ffe", "0xea002c61", "0x2722da01", "0x54929bef", "0x32640c12", "0xf4e464ff", "0x13c0cc4d", "0x7049337a", "0xd20b7e72", "0xece23c2d", "0x3db62403", "0xadfad44e", "0x7b0f15f", "0x72c66ee7", "0xdec103cd", "0xff611092", "0x1eb21907", "0xf92df521", "0xf3670e21", "0x4722265d", "0xd47f02c", "0x21b46ad9", "0xeec23502", "0xc02cd570", "0x31beea11", "0x3595269", "0xf5e71bf3", "0x72d4d313", "0x737f00f2", "0x15142b12", "0x1345c20a", "0xe0397daf", "0x140d7b21", "0x1bd72acd", "0xea0b7215", "0xcf1de1c1", "0xd6be0b4f", "0x12124d11", "0xa2fad3ca", "0x209dd779", "0xe1e77e2a", "0x504e4c32", "0x301ba5ae", "0x4d3110d1", "0xc393012c", "0x7e1dee20", "0xba41f3a0", "0xf0ed1ecb", "0x13e47b5c", "0xce7f400e", "0xa1e9dbdd", "0x1d3204d0", "0xe051f11d", "0x9f5d33fd", "0xf2fd3f42", "0xf15c1317", "0xa6dfa002", "0x4e023331", "0x317e4764", "0x27f4e552", "0x71120ef1", "0x31b3e702", "0xd2e103ff", "0x3f9c03c5", "0x11b2d30a", "0x7e100727", "0x637614f2", "0x70d1e7e7", "0x17af0e6d", "0xbd23e302", "0xe420e22b", "0x40afbf12", "0xf5b72313", "0x3f43ea55", "0x52f216d1", "0x543c3ae7", "0xfa3025f", "0xbfd921d", "0xe007dce3", "0x913472ff", "0x7cf1c66f", "0x7cfc263d", "0x5e0d23ae", "0xbdef5613", "0x2747fe6f", "0x4eaf07ec", "0xb5f9190d", "0xff9faf4f", "0x9edf12fe", "0xad9bc0f7", "0x1d9d010f", "0xce3de92c", "0xcdac0b90", "0xbfbecde2", "0xc22af030", "0xf0e0143f", "0x2b0442d5", "0x609ce2f2", "0xff45e554", "0x19d512", "0xf5b500db", "0x7bacc6dd", "0x1df2bbe", "0xa04d3ca7", "0x3c9e431", "0xefe00631", "0xf19dfed", "0x139d35f1", "0x10600c14", "0x4cd2ec0a", "0x11f30f93", "0xffd27770", "0x7ccb2b36", "0xc3d4ff9d", "0x9f7e30bf", "0x440d949c", "0xd2250d30", "0x6b5b79c2", "0xbfc10304", "0x1ef3472", "0x19101b14", "0x4fcbfaeb", "0xc42c2230", "0x10f9cfd4", "0x1dcc0133", "0x207f2fe2", "0xb40f2ae", "0xdfff3bea", "0x31f410c5", "0x15304afe", "0x74ca2cce", "0xd35e33c9", "0xcd09f40d", "0xf0500f7a", "0xff0f02f0", "0xa04adf51", "0x50ef0eae", "0x34ffff50", "0x45701d13", "0x303d1716", "0x2c2bf23b", "0x7e713140", "0x1a19c3f1", "0xe0df4abc", "0x3d91ecff", "0xa37303fd", "0x33d90e5f", "0x4ae4bbaa", "0xcbda1ecf", "0xf6dcfc7b", "0x30010afe", "0xf0fd4b93", "0x5e9940e5", "0x972336ff", "0x14bb322e", "0xab504c99", "0xba261e94", "0x230edc39", "0xc03b243a", "0x60fcfdff", "0xdb9e37d3", "0xc4cd2dd1", "0x71beff5c", "0xf262593f", "0xcdc0fe1b", "0xa242d12f", "0x1b63fbb3", "0x3024cfbd", "0x4d9b3fb3", "0xd722dbed", "0x5fecab1e", "0x1db0cee9", "0x942b0091", "0xb13e026a", "0x42d43ed3", "0x62b9ef", "0x16951b2c", "0x943efb7e", "0x73002010", "0x9d5e5d9e", "0xce52fce6", "0x4d060ae9", "0xe3a3accf", "0xf0ed2130", "0x3e90124d", "0x97dbff19", "0x93c73fd2", "0xcccf5cdc", "0x9f1e1e9c", "0x3e3bf505", "0x1f2e0f0c", "0xf0dfa9fc", "0x51af94eb", "0xa100bd61", "0x1db99ec0", "0x2b4edd00", "0xf41912c1", "0xd9eabe09", "0x4451ff", "0x313ca169", "0x1b22f270", "0xb3f1b149", "0x3f70e211", "0x31cc0f42", "0xde1ffafe", "0x227c94e0", "0x2b7b2f0e", "0x103d733b", "0x3daac02f", "0xe53edfbc", "0xf65a3f3f", "0x5dd0ea0c", "0xfbf2ffa7", "0x1be4fcec", "0x2179d2fc", "0xdf557144", "0xe00eb37c", "0x13ec3090", "0xe90e51c0", "0xbe17cff", "0xe5101f11", "0x1ed2f337", "0xf9303cfc", "0x20fc9ce4", "0xf0ffdac4", "0x7d5754a4", "0xf1beecd7", "0xfb00b43f", "0xf0f20320", "0x4c33dfbe", "0xf97a3ee6", "0xa02d710f", "0x96fead6b", "0x41520b7", "0xcf4d40a2", "0xb1fb0b19", "0x25db090e", "0xb29a5011", "0x20792f32", "0x1326d49", "0x23250034", "0x70410dc9", "0xf2dc770c", "0x3a2f564f", "0xce4af9be", "0xbda292fe", "0xcd2db60e", "0x3ff47dff", "0xfc122b3a", "0x326fcb1", "0x1e9975e3", "0xd92c41f1", "0x30aff31d", "0xee2fdb43", "0xfbf94dd2", "0xfe36b1a", "0xee31325f", "0xf7012f93", "0xe0d47422", "0xb33acd29", "0xb09e03e1", "0x6ec29fd", "0x2e2924dd", "0x40e020bf", "0x1423f105", "0x242fd07f", "0xb4da739d", "0x6cf31345", "0x39ea1511", "0x96b10a34", "0x9ec0abd", "0x10f5f1f", "0xa10d00e", "0xece7ef31", "0x4de5e21e", "0x42fad3e0", "0xc4d13f2", "0xd0b003fb", "0xed035bbf", "0xc030effd", "0x4e021b1", "0x2df5e0d1", "0xdc30d0d0", "0x24fee3dd", "0xd3310312", "0x3d20ee1f", "0x5117e042", "0xc02f1dd1", "0x3f910e0", "0xdff3c2e3", "0xfd132101", "0xc11d1fdd", "0x3f3101c0", "0x5214f370", "0xbad66dfc", "0x43e3f", "0xebc092ed", "0xdb19344", "0x2fcc21e1", "0xe00c2125", "0xe2f0e0f", "0x11bdefb", "0x2113d3d1", "0x1fc0ccfd", "0xeedfdd1a", "0xed26c3e0", "0x1d1e1fd6", "0x2b41eb", "0xa2f4ff15", "0x30f0e0fb", "0xfe2501f2", "0x11eef21", "0xf0c1ff2", "0x9f2cf100", "0x2d516dd0", "0x31d30c3", "0x1110ff2", "0x2f051fd1", "0xcf147e7f", "0x42ecc", "0x2ff9045", "0x1f20f23", "0x42f3f1f3", "0x3f1edfff", "0xa2ff1b4", "0x320f01d", "0x26372250", "0xd1bfc10d", "0xa0b001f4", "0xfc263ee1", "0xdd23fe5", "0x3b7bcf60", "0x244400f7", "0x15f2f2c0", "0xd347117c", "0x90d000dc", "0xe31adb9b", "0xfc6c4ee6", "0xffe44e42", "0xdfcceef2", "0xb2c20ef1", "0xfd05c3d4", "0xf0101ccf", "0xd0ca11fb", "0x229ae7e2", "0x24e65f4a", "0x6fcd221c", "0xeea4ea9a", "0x29ef0ea2", "0x47efe40", "0x2e05051d", "0x401f6cec", "0x61a76ce", "0xe4f2e1a", "0x21105631", "0xaf51dcaa", "0x9911106c", "0x14f30639", "0xdb21ec24", "0xf02a1322", "0x52b33da", "0x93e00c", "0xe0011612", "0xc40c0490", "0x770dfcd3", "0x72321416", "0x217d221f", "0x14f1dd2", "0xea9e9367", "0x921313fc", "0xe19ae7ad", "0xfe14c91a", "0x214b0ab3", "0xe1ea512f", "0x5f1b0459", "0xfa42fe2", "0xfcc90ee4", "0x961fc7d1", "0xb59ff41d", "0x92339dd", "0xea1d09bd", "0xe7fb012a", "0xcfbfde1", "0x404df004", "0x53392213", "0xf21f4fb1", "0x350f4224", "0x521df39c", "0xdd7f1122", "0xe4d0e1f9", "0xdc1ae0fe", "0x302eb533", "0xec9ffd16", "0xb1f2ef2d", "0xf43da3e2", "0x52210ba0", "0x5b4f1dd0", "0x3dda5af3", "0xd0a5f209", "0xe0fc273f", "0x7fa92752", "0x241be102", "0x13bc2f9", "0x4fdef591", "0x4b330ffe", "0x74c30b1d", "0xd11d9202", "0x10052ecd", "0x43225372", "0xe1f2de3d", "0x932effff", "0x230bdfbe", "0x594c041c", "0xd109ff5c", "0xfce30d1e", "0xdfc32c10", "0x2f0aa100", "0x30a91f2c", "0xca3c3409", "0xa0437fdf", "0x4fad0c6a", "0xec9d123f", "0x3fc1dedd", "0xdf42f272", "0x110ee393", "0x5fe23f52", "0x10ed24fc", "0xbb4305e0", "0x4e3c1231", "0xbe9e1e3c", "0xfebff3b0", "0xd11221e2", "0x124cb14f", "0xec50d413", "0xe4e526eb", "0xde1033ae", "0xc231525", "0xbdd2c03f", "0xdc122cbc", "0xd1bdfdf1", "0xcf420eec", "0x10cb11b0", "0xbed2c", "0xe20c6d0f", "0xef9dfee9", "0xd19c2dfd", "0x113109e", "0xc0024f34", "0xe2df211c", "0xf1221cff", "0x1edcfef0", "0x7e00df0f", "0xe3de1cee", "0x1d013a2a", "0x211fd393", "0x20c23dbc", "0xd50102f", "0xaafe2bdf", "0xaef1d1d0", "0x11131ee", "0xee9e0f1e", "0xef914131", "0xb9fee7ee", "0x30fd6eee", "0xb9ebc56c", "0x6e206994", "0x54d59b2b", "0x1bc3d7f", "0xcd37010c", "0x4f241521", "0x9174f59e", "0x601c12bf", "0xcfff367c", "0x31402901", "0x34aba21d", "0x5a9130bf", "0xc12417cd", "0x13712535", "0x43411b6", "0x40d17ce0", "0x1034700f", "0xdc241b23", "0xcfd9e507", "0x5e27ec40", "0xc2cf13ed", "0x2d90f52f", "0xf0e2ed01", "0xf1aef346", "0xcef44e29", "0x5a32b6f5", "0xc2c46d1e", "0xcabd9235", "0x4530f27e", "0xd9de5dd2", "0x1231f30f", "0xefdbf25f", "0xfe11e2d9", "0x2eead446", "0xd2e7fedc", "0xc0e2055f", "0x45270d52", "0x2ce0d424", "0x43410113", "0x407ce20f", "0x9ed944c2", "0xe2622efc", "0x4dd490cf", "0xc0eea13f", "0x41300df2", "0xef1437f2", "0xd2110fa0", "0x1039e792", "0xbd9c90ce", "0x1b1213d2", "0x229704b9", "0xc9d0d22d", "0x1125f509", "0x2cd17fcf", "0xfec957f9", "0xd10a4fe1", "0x7f9ba12e", "0x7f9935c2", "0xce70a079", "0xe71fdc0d", "0xc9f70d72", "0x3c57eef4", "0x4000009e", "0x307bf73e", "0x9fbed7f3", "0xd4653eec", "0x50a4909f", "0xeeebcf7d", "0x4e2714a1", "0x90f25ff0", "0xf2c104f", "0x7d9463", "0x159fb05a", "0x6d1002cf", "0x313a9f6e", "0x21d1f425", "0x1ef6f01e", "0x5be5f24e", "0x103100fe", "0xd03dfd1e", "0xffae10b", "0x3d113cf1", "0xd123d172", "0xeefeefdb", "0xcf14fe40", "0x3c1fc003", "0x1e1eb4fa", "0xd02ed54d", "0x31d2319", "0xf30052de", "0x21d19f0f", "0xdff50eff", "0xe5094f", "0xca50f00c"}};



const ap_int<13> conv_4_inc[2][32] = {
{"0x2c2", "0x311", "0x557", "0x20f", "0x31d", "0x263", "0x312", "0x2ef", "0x296", "0x1d7", "0x20f", "0x426", "0x36d", "0x306", "0x213", "0x316", "0x253", "0x2c7", "0x26b", "0xc4a", "0x2e6", "0x1fc", "0x282", "0x260", "0x1b9", "0x251", "0x239", "0x203", "0x26c", "0x33b", "0x213", "0x28f"},
{"0x223", "0x2af", "0x2a5", "0x26b", "0x2ff", "0x2a5", "0x1de", "0x3d4", "0xf", "0x258", "0x1e7", "0x28c", "0x263", "0x23a", "0x2d4", "0x25f", "0x2e7", "0x287", "0x206", "0x1f8", "0x2e3", "0x2e1", "0x212", "0x296", "0x215", "0x1e0", "0x2b3", "0x217", "0x43b", "0x25a", "0x348", "0x316"}};



const ap_int<21> conv_4_bias[2][32] = {
{"0x1046e", "0x35927", "0xf0a62", "0x1d52e", "-0x3cdfe", "-0x1b6f8", "0x37b66", "0xfeb8", "-0x773", "-0xc5fc", "0x45a94", "0xaad57", "0xafc14", "-0x65ff6", "0x2b3eb", "-0x22fd3", "-0xb04f", "-0x66b2e", "-0x22066", "0x622ef", "0x6155d", "0x233f6", "-0x25eea", "-0x31bc8", "0x27ce7", "-0x1eada", "-0xc0d9", "-0x81d", "-0x1ae77", "0x76184", "0x1804a", "0x22cb7"},
{"-0x18485", "0x17b24", "-0x4b92c", "0x66df1", "-0x14b92", "-0x3b4cd", "0x24f90", "0x10636", "-0x2e85", "-0x36e33", "0x16fba", "-0x2e767", "0x3cc43", "0x47e7b", "-0x187ae", "0x1f475", "0x290b", "-0x209d3", "0x1a0d0", "-0x27bb5", "-0x441c1", "0x7b573", "0x47713", "0x1207", "-0x33a5f", "0x772fd", "0xe585", "0x91d2a", "-0x68ae1", "0x7b2a", "0xac0ef", "-0x9076"}};



const ap_uint<32> conv_5_w[2][2304] = {
{"0xb43b3fc5", "0x2936225c", "0xd0d23af0", "0xe20ff30e", "0x113f02e3", "0x11d190e1", "0x44f71fbd", "0x23c0f075", "0xf6fc3231", "0xb394619e", "0xd53fe201", "0x4e01fbcf", "0x610f36d7", "0xc5d037d3", "0x62fe0f2d", "0x3dfe2c23", "0xcecddd14", "0x11032520", "0xf120b51e", "0xed2760ff", "0x340b71", "0x4e54dd13", "0xd220e2ed", "0xec5a3506", "0xc0c95be4", "0xbb42b05b", "0x7f5e9f0", "0x1127a9e6", "0x20b362ad", "0x30d11b62", "0xc1029b4c", "0x6ede0241", "0xad09223f", "0xe0e711e4", "0x20e3f11", "0x2a090903", "0xdf5152f3", "0xeeb3faf0", "0x112e1c42", "0xa22fc14e", "0xdcc99263", "0x1730f6b7", "0xff314105", "0xb357de02", "0xaeff5136", "0x2d125e2a", "0xb1724d13", "0xf97902d0", "0xf113713f", "0xe395b929", "0x27c6d909", "0x27c01c06", "0xb0aeeffe", "0x4bdb7b72", "0x310fee3f", "0xfb0660f", "0x94c13d4f", "0x5d3f4cd", "0x1146190f", "0x4f99fbf6", "0x4ff13d0a", "0x1d513ed4", "0xdf22d22e", "0x7eff212", "0xaf27b1f0", "0x30cf62bf", "0xf364af03", "0xf1d12f2d", "0x3e24c3ba", "0x632005ae", "0x3c324db", "0x1ffbff1e", "0x5339f114", "0x34e13216", "0x2307703", "0x7b225dd2", "0x1f334de7", "0xe223de00", "0xca1c1b00", "0x21dfc413", "0xf42e335e", "0xae1a1f", "0xdf7a715", "0x4c2c2de2", "0x14e3e3d", "0x15c34c2f", "0x1ecbfed4", "0xdf22ff3d", "0x4674311", "0x25b143cf", "0x2df0b401", "0x5c004eea", "0x22b13734", "0x1012e003", "0xcb2fcdd", "0xcaf1170e", "0x3dcfb75e", "0x2031d716", "0xdeb35601", "0x1c42f319", "0x303f33f4", "0xff6f1f14", "0xd37d6cda", "0xb10e02f", "0xfad6e14f", "0x1cefc1df", "0xe0f41307", "0xde35ad09", "0xf051ad70", "0x3db23e0d", "0xfc332fc1", "0x14b31109", "0x3417b91f", "0x2c04e003", "0x20e30fd", "0xc0223db9", "0x21c3d23e", "0xb20fff3f", "0x323f702b", "0x3244430b", "0xed0e9754", "0xf3cdf717", "0x1d34a701", "0xf7032f64", "0x2f667502", "0xe90565b0", "0x1253ad7f", "0xf3ca1033", "0xe302002d", "0xfd2f4ec6", "0x3e111c07", "0xf24b9020", "0x3ff5e129", "0xec67c7de", "0x2c9014f3", "0xefd7a2d0", "0x4535bdcb", "0xd94e4101", "0xe05bcef0", "0xb0d9e0eb", "0x1fbf6c0", "0xbed226b1", "0x369bd031", "0x5d1ef4b3", "0x4c31c0ad", "0x42590fff", "0x6cb6707", "0xfaff3f92", "0x40092e20", "0x216774fc", "0x150227f1", "0x4f2e367c", "0x3227eeee", "0x1dde5ba0", "0x390ad60a", "0x2d9ee490", "0xd1c11f0f", "0x90263221", "0x1d69cf1f", "0xfcb4d0cc", "0x66272034", "0x1d13feef", "0x29b30b09", "0x60b0d09d", "0xffdcf193", "0xfd07f53f", "0xb371510d", "0x37b22cdc", "0xdff31dfc", "0x23942e1", "0x14190106", "0xdbf5d19e", "0x200a10c9", "0x37323bf0", "0x61a13705", "0x3227f27f", "0xc9e30005", "0x491c16f5", "0x7a1b9e1e", "0x103db7ba", "0x90afe313", "0xb3e2e2b3", "0xf4dd0193", "0x2c90971f", "0xec955200", "0xd09f7c3", "0x19a20f1a", "0x2a00c2b7", "0xf150ce7", "0xc0f5e07d", "0xb64eca4b", "0xd7efb32e", "0xf5502a", "0x2f1c5254", "0xdd2e200b", "0xed35c9a9", "0x602b04f9", "0x24262d99", "0x11e0d1ae", "0x5de130e3", "0x9fc04e41", "0x241ef1e5", "0x2dfde40b", "0xcf403269", "0xb01b05c1", "0x95c1b39a", "0x4133fa9d", "0x3c1ccfb6", "0xb79dee21", "0xb42ad391", "0x46e04d0a", "0x9cf1d965", "0xb0261297", "0xcc170ad2", "0x4c20dbfa", "0x6e659fc2", "0xfc0547a0", "0xad400bb9", "0x6e7ddfb", "0x471d390d", "0x7074b33e", "0x5d305e33", "0xf37d34a1", "0x6fd2f06", "0xb3ccd037", "0x3bd0709", "0xa091d2f0", "0x10a6bb1b", "0xf05d30", "0xe27f3d4e", "0x1f4db06e", "0x6a20a341", "0x114f1d0e", "0xf723cffe", "0x3102bb0f", "0x921f0ea3", "0xf0051f74", "0x12d0c0ce", "0x5356fa3c", "0xea362020", "0x39e717dd", "0x24643fcd", "0x37f10009", "0x66007d9a", "0xf03fdb6e", "0xf41037f3", "0x97a390f6", "0x33e26409", "0xa13f41cd", "0x229eee29", "0x96530fff", "0x909fd909", "0x7060fc51", "0x2f7d50e3", "0x5a12dd", "0x1e4c1df4", "0xbd1329de", "0x270960b", "0xd0f2d209", "0xabb1a23f", "0xbb3323", "0x2771ded2", "0x702ce412", "0xf3c0f1d", "0x6cd70621", "0xef77ff3c", "0x2451f510", "0x416221d5", "0x3090f0fb", "0x47d2341e", "0xa2a76f1e", "0x4dc5051d", "0xe00c169e", "0x2d6dfdda", "0x504fd4fd", "0x2f3d7da2", "0x100dfd65", "0xbfe711bc", "0xfce29f1f", "0x23134112", "0x91014190", "0x1cc196ec", "0xece4b1f4", "0xacbc0b56", "0xa027f4", "0xeea66fc5", "0x20694ee", "0xed4dd232", "0xe2f1fa39", "0x3e3ddaf0", "0xe1a12200", "0x2b100fc", "0xcfe74930", "0xbe307319", "0xf4f0efff", "0xbbf3fa33", "0xf220bf40", "0xfd0bb13f", "0xf3ecde00", "0xe3023eeb", "0xe0d3fe3b", "0xc0fd0e19", "0x6cb4befc", "0xa9741b11", "0x3721f221", "0xeb2c9126", "0x1001d90b", "0x5010d95d", "0x21ecf345", "0xcfed2129", "0x19b523e0", "0xf130c91f", "0xc0b4bac1", "0x343b9bc3", "0x9ffe2c02", "0xaeff9ba0", "0xf14140c2", "0x5d7ccd16", "0x2d252175", "0xa322102e", "0xc300fcd3", "0xd6d039e6", "0xb3f53a0e", "0x115dec09", "0xe031cb9e", "0x6febc2", "0xb132fe3", "0xdab1f1ef", "0x27292a47", "0x1e3f0f24", "0x23b1e011", "0x55293a19", "0x2fc4e129", "0xcf204601", "0xed0d2ade", "0xe0f13090", "0x299d36e", "0x5d22b0ec", "0x2a00f210", "0x2242ec94", "0x40e7cffd", "0x1bbebbad", "0xc0bd7957", "0x32050f1d", "0x4c22c401", "0x301f0bb", "0x122600d", "0x2a4709dd", "0xf2131ee3", "0x1e11a91", "0xcef7902", "0x12e5d00b", "0x73027fa6", "0xe0114c6c", "0xcd1c6e1e", "0x5f6f4d7e", "0xf1e051b5", "0xd53c0fa1", "0xfa117cfd", "0xdbb92c1f", "0x26d91305", "0xe4f13279", "0xf0969ff0", "0x21d12f02", "0x4004dcea", "0xdf0edfe4", "0x3aebdbd2", "0xc0262e5f", "0x2051206c", "0x1172e035", "0xfc67fbf4", "0x372f222f", "0x501e4fdf", "0x27125e02", "0x2f14001b", "0x5c3d0d5e", "0x4cddfe3c", "0xffa4020", "0x9ffe306", "0xe43744eb", "0x1071fe4f", "0xf10c2a00", "0x112d71e7", "0x2a9aacf7", "0x204a2d00", "0x9fd41efd", "0x1325ee04", "0xcea33000", "0xbfc4dad9", "0xd2029ee0", "0x4bf394d9", "0x1247fc41", "0xd13f3a2", "0x4e42f5e7", "0xad3e190d", "0xd1ee4193", "0x2f991e05", "0xec909a34", "0xc179d60f", "0xa12b1e11", "0xeaf3403d", "0xef7370a2", "0x29cbb701", "0x11130fca", "0xf4fbe24", "0x23fe013f", "0x4d3b5279", "0x7496e022", "0x7f3c0c3e", "0x2ef1d93b", "0x7f3efbff", "0x3c0dfb14", "0x11f10241", "0x3111fa12", "0x2ed4bdf9", "0x6f22df0", "0xf44111c", "0x110521", "0xe1b39d14", "0x1c44cece", "0xcfafb155", "0x9121b631", "0x21d3d5ea", "0xf15c0f12", "0x541313c", "0x242e45dd", "0x2d0fe01d", "0xfdd1b129", "0x50141332", "0xf4367103", "0x1cf06f1d", "0x519b6041", "0x900f09c", "0x300f0e21", "0xdf9bf11c", "0xe00702ef", "0xf05edd40", "0xe9c357c0", "0x3e4c60d0", "0x40ceeeff", "0xacd1fd9d", "0x35d1f12e", "0xcfdc03", "0x1ccf6eed", "0xaf004f0d", "0x9c67e122", "0x10791530", "0x23fb2fc1", "0x21064b92", "0xe3f699ea", "0xeed0d11f", "0xb390d3e1", "0xfd360c3", "0xd323a41f", "0x5f0a07f1", "0x3cfeeff3", "0x7d16fcb1", "0xc94659ef", "0x3fd32a12", "0x6c06db71", "0xf1fae2ec", "0x42626622", "0xbf3ba2c9", "0x3c3230e1", "0x6107a2ad", "0x2f7337c6", "0xdc2ef90e", "0x731b023a", "0x51ca224f", "0xa49ee036", "0xc1339fda", "0xd30f1c2e", "0xd227a39c", "0xf2b3a05b", "0xd315ef02", "0x731bd1ea", "0x1ff13f70", "0x5f9b3424", "0xc3643f41", "0x11d9eef3", "0x5f713ef2", "0xe70e20cb", "0xa5cb1d1e", "0xd6f31a43", "0x1022d3f9", "0x7297cf3d", "0xf6207fce", "0xe96c5f00", "0xbf3013c7", "0x531aed6", "0xcc2ed404", "0x25226e4d", "0x429e10cf", "0x53bf5f56", "0x63b5dbb", "0xd752a911", "0xe4f1c393", "0x41f3a4d7", "0xc9005403", "0xf746be05", "0x40cf0a0c", "0x193afe04", "0xaf199ff", "0x615ac0f", "0xd6fcbf6d", "0xfdb35f11", "0x14406ef3", "0x2a31acd3", "0x3ba0cd", "0x1f1de3d4", "0x9a0bc13d", "0x35e7f0e3", "0x50faae64", "0x1aba4f02", "0xe1514a01", "0xeadb5f1b", "0xfe426c0f", "0xa3dfcf04", "0x2b4ed1c4", "0x11f9c1e1", "0x5ceeb609", "0x5b345913", "0xea13e704", "0xfbf37bfc", "0x415429fc", "0x1bec25ef", "0xff2c95e7", "0xd92bf5e1", "0x41b2113d", "0xe9bcb40a", "0x261c0f", "0x6930af1a", "0xff31cf0c", "0xc01e444", "0xa2b5dce2", "0x17debcf1", "0x239bf640", "0x213ee290", "0xecced00f", "0x5ebeee19", "0xaf4e59ec", "0xb4fecd2e", "0xf4fe1d0d", "0xf4b69513", "0x54ba145a", "0x4f0f9916", "0xdd32cff4", "0x14ceda35", "0xbf6eec54", "0x32c309dd", "0xcf2e27a9", "0xfdffcf12", "0x20b2320d", "0x417c9169", "0x7ebbe70e", "0xe941e61d", "0xc06fefa5", "0x4226ffe9", "0x721a5c90", "0xca7e4db0", "0x9fdf90f3", "0x343c019", "0x7fdb4e0c", "0xbee2e40", "0xdffc90b2", "0x241ddb20", "0xee1de4cd", "0x29330220", "0x63e4bb21", "0x13ed9ef", "0x6ca25007", "0xdcc73c12", "0xff4dfea0", "0x5be23d1a", "0xd43beacf", "0xd0316051", "0xe03bee01", "0xfda0fe4e", "0x11c0ed0c", "0x114fb53f", "0x2ff6d14d", "0xd043f1ef", "0xd01f2234", "0xff2e5041", "0xd1feff0e", "0x33df4f02", "0xb621fc00", "0xe67cf224", "0x3f6dc510", "0xd390f4d0", "0x301f322", "0xecda0c30", "0xd1facdde", "0xf6f13221", "0x4625d4f4", "0xe45015f1", "0x1025ff43", "0xf42f31d2", "0xf4327104", "0x2c2c4cfe", "0x1c37319c", "0x29d399fb", "0x96e4f201", "0x20954bd9", "0x9f7de951", "0x993e16d", "0x46107f4e", "0xcd35192f", "0x1b577206", "0x4d05d9c1", "0xe4aa1100", "0xa39b4bbd", "0x90af0002", "0x2970f22c", "0xef257c29", "0x21033042", "0x1d477ee2", "0xe44527d1", "0x216dd603", "0xd09d5d13", "0xb14220bd", "0xe97ec901", "0x2bb02379", "0xe572ad12", "0xafc390c3", "0xdd423d2", "0x22f10400", "0xfefb0ee9", "0xd04e9bd1", "0xbf0eeac2", "0x31033600", "0xc3e1d9fe", "0xdca10ed1", "0x4a4e57fd", "0x20e1fafc", "0x17a1fd1b", "0x1f50da13", "0xe25cfd1d", "0x21bce723", "0xb00970dd", "0x60df71a1", "0x2d21ec1f", "0x4496c010", "0xf696c1f3", "0x5fd31be6", "0xdaf1b1c", "0x574212cf", "0xf13f7e4c", "0x31edee30", "0x45146ddf", "0xfcaaddfa", "0x354411cf", "0x3fc206b2", "0x1ed67cf1", "0x5c9d032e", "0x194ee35d", "0xc1901fdd", "0xffeb2fc4", "0xcffdcb0e", "0x24127450", "0x40fc32dd", "0x52422deb", "0x14c0b251", "0xbc1753da", "0xd0b00420", "0xeb02e5d3", "0xdfe24204", "0xf0233641", "0x511153b4", "0x2d1ddd0c", "0xe0beeabe", "0xd4b534df", "0x2e073ccd", "0x11ec7ae0", "0x1cd23d09", "0xb1e2fb72", "0xef2f2493", "0xe4c5abd", "0x4fcfd706", "0xfc6bd5db", "0xb5f6ba44", "0xee095173", "0xa0f3fbfb", "0x122f9270", "0xf012339f", "0xd243ab9f", "0xdc31d320", "0xe1f0eecc", "0x9521ff36", "0xd001e160", "0xe1ae000d", "0xed29df61", "0x205311dd", "0x1d75bf3f", "0x4f2f29f2", "0x2b443fe", "0xf9b5dee0", "0xf27e5df2", "0x5a02600c", "0x607c240", "0xaf6263f3", "0x10f7ec04", "0x127d0213", "0x44e9900a", "0xbc0fef5", "0x2c331f14", "0xf0096ff2", "0xc7bee7e2", "0xc1755b60", "0x9f22ddf4", "0xfc3ef1cc", "0x47dbe3fd", "0x9df0f124", "0xdd100d30", "0xc1092012", "0xdebb1ecf", "0x21db5dcc", "0x9f26b23f", "0x3d3c1b40", "0x45d110ec", "0x2ceffbde", "0xc7ad304c", "0x7026440d", "0xe0f1cfcf", "0xefed1bca", "0xf5b52cad", "0x1dfe0129", "0x41c63396", "0xce503fc3", "0x1fcaaf51", "0xb1acf0f9", "0x3ed4fde0", "0xd1e1cac0", "0xb000e00b", "0x3212ece2", "0xd21f6606", "0xc70be5", "0x6321feda", "0xc3e300a", "0xea029ce", "0x31fffb1c", "0xf1b2f0bb", "0xd47e102a", "0x12a133d1", "0x10be21dc", "0xbbe30fb0", "0x11e71c09", "0x53ec3f90", "0xdfbf1", "0xd6e245e0", "0x5a01e312", "0x142e71c2", "0x2fe925d1", "0xd09f0da6", "0x17d91302", "0x111939b2", "0x110f2312", "0x432603db", "0x72953bed", "0xf2443fbf", "0x763d1213", "0x153b209f", "0x151dc31a", "0xe4ff29ac", "0x500e0f2c", "0xee910bad", "0x1c41df5", "0x33dcc3cf", "0x1f7e1c4", "0xfd49a0a9", "0x9a0e41f9", "0xf253ffce", "0x50ce3b12", "0x42f020e2", "0x294cf1fd", "0x127b74dc", "0xa031ed3", "0x2bd140f", "0x91ead30b", "0x1ed5eecd", "0x40b93f53", "0x6fd23d1e", "0x5bf2300e", "0xb9192bff", "0xd15d52c1", "0x2eb273f2", "0xf100ab00", "0x14e20d20", "0x41cb04e4", "0xc205e00f", "0xbc92954f", "0x7fd2d503", "0xee04e75b", "0xfec3d103", "0xd6e110a", "0xc0ff4ffb", "0xef304bbf", "0x20e5bdfb", "0x1e21eb59", "0x515c9fdd", "0x4942c022", "0xe4e121c6", "0x192f60f0", "0x37012091", "0x4012505a", "0xe5f2f3de", "0xf1c1f021", "0x329c3f0c", "0xd233b34", "0xf6e070d1", "0xb20e30e", "0xd62f30ac", "0x1fe5ed1a", "0x92d36d3c", "0xdede2310", "0x22fd234f", "0x1bd1a021", "0x1ff00303", "0x40321300", "0x3ee4c69", "0xef020abc", "0x70ee3d0d", "0x355f2f11", "0xa073fefd", "0xfd21e2e2", "0xe4bbf1c3", "0xfafc3d11", "0x52c0f21", "0x4001b219", "0x6f6ae6df", "0xe2cf20c4", "0x40f95e20", "0xf212e013", "0xb0c24be3", "0xc20f2c01", "0xa759110f", "0x100212fd", "0x11bf1d2", "0x3504dc", "0x12fd3ee6", "0xbd0aeed", "0x6d0fdef0", "0x33670406", "0xc1e7c", "0x400ff0fd", "0x3f3f4ced", "0xe32d4f01", "0xb340e40a", "0xedef0f0b", "0xd5dcd0b0", "0xaf32cef0", "0x1cafe5d", "0x4fee1e", "0xfe1fc5c0", "0x951dff11", "0xe2cb2ce2", "0x31b23c1f", "0xe4c6de03", "0x46151b00", "0x7dddc02", "0xb1d1eedf", "0xe0e41efd", "0xe23d274e", "0xee0cf301", "0xeecafb9d", "0xdd91cdd9", "0xf6a6cd00", "0xcfa09145", "0x7fbf2c4e", "0x5e71102c", "0xd16426e4", "0xd14a4007", "0xdf4b0914", "0xec75101d", "0xaff02c15", "0x7fcec213", "0xd0505ec9", "0xf7ddb022", "0x76f9a364", "0x79c10e5d", "0x1112efe1", "0x401c0a54", "0x503e1f1", "0xddc02f21", "0x140b1f", "0x40fff7f5", "0xf231e240", "0x9e0cadde", "0x4c7939c", "0x1bd2f2fe", "0xa51f000a", "0xb20e2092", "0x3e3df974", "0x4e30f21b", "0xf3309e03", "0x939f3417", "0xfa744a5c", "0xe0ee5019", "0x125f7e16", "0xfcd0cb01", "0x50930ef5", "0x16c30935", "0x2940a614", "0x72099229", "0x54c74497", "0x13243f40", "0xf3d1d0fd", "0xc1d20f07", "0xff63f9a7", "0xd2cbe4b1", "0x33d75070", "0x973eb2f5", "0xe032c5a6", "0x313e203f", "0xc4f2f213", "0x6d60004b", "0x1fef1e6f", "0xf1304721", "0x6b456c35", "0x56e12ed2", "0xbf1367ce", "0x2ebf0ed", "0x6f5be2f0", "0xd1c2aaf6", "0x7f7f1ec3", "0xfffb2c3f", "0xe5bba17d", "0x1e1e4419", "0x13e2001e", "0x51c21b4", "0xf3e12cf0", "0xfe03f26", "0xab0be3", "0x1e16b217", "0xe3251b2d", "0x43f0e754", "0x527b6f07", "0xb62cd221", "0x1eadfaf9", "0x5194f619", "0x2030afea", "0xe637b102", "0x1ac37caf", "0xd1d6fed7", "0x395e1cee", "0xf92c901", "0xefda3c04", "0x2de1046f", "0x20f45000", "0x2d23021f", "0xda2c3ed7", "0xcbcfebe2", "0x1cf435da", "0xdec31ce3", "0x5017ee0f", "0x5faf3727", "0x40067dfb", "0x29e33120", "0x14cf4097", "0xbdfbe500", "0x517b0112", "0x22c7c56f", "0x3f437df0", "0x209f0401", "0x6206d20d", "0x106643e0", "0xef376fe3", "0xf02f0f25", "0x5cee1d41", "0x12173241", "0x22f93e14", "0x1e9d0fc4", "0x71ffd1ff", "0xf1d35139", "0xf410600", "0x47a6efd3", "0x4dfe5372", "0x1c020ed6", "0xf3050e01", "0x3fc006dc", "0xf205f51e", "0x9aced61", "0xe3f092de", "0xe12ffe10", "0x754c19f7", "0xf461143", "0x4d064313", "0x23a1213a", "0xd1e4053a", "0x722626b4", "0xcd370d93", "0xd29a0ac0", "0xb0e16df5", "0x25bc2203", "0x120d6301", "0x14cc0ed1", "0xa192a01e", "0x3e00f13e", "0xd1d42b1e", "0x16ff1ef2", "0x9fe16ee6", "0x27f1c5d5", "0xf4fb0d0e", "0x545f412", "0xf01501f5", "0x40011076", "0x5206afe5", "0x770d3dff", "0x7407f07e", "0xffffc2d1", "0xe64e2f06", "0xa064af20", "0x1f9dd131", "0x3347212f", "0x3b7c531f", "0x3d0deefe", "0x7d94f56e", "0x410d1c40", "0xad3d0f1f", "0x132271b9", "0xbeebce", "0x91944f51", "0xddfcc711", "0xfddfce3e", "0x1973e70c", "0x401b5511", "0xd1cf1910", "0x50e5fde9", "0x30c6d26e", "0x291252f", "0xa902e22c", "0xa0b0fe30", "0x9127763c", "0xc703b171", "0xd5f41f1a", "0xcfd4db17", "0x1fae0151", "0x10053add", "0xf6fd46d", "0xccf1f3a3", "0xef2f3405", "0xe047a347", "0xb3ffc0a", "0x6c40ce0", "0x129b1d04", "0xbffb0214", "0xbb2e0711", "0x3f93d213", "0x20313361", "0x13623c6", "0xfdd05e10", "0x42f19df9", "0x11c21513", "0x2f10f24e", "0xf93ba3a0", "0xb4b44d0c", "0xe624e3ef", "0x4b20031", "0xa7473b0b", "0xee5fa417", "0x609f2f3f", "0x2d459df", "0x1df40e2b", "0xf675e305", "0x10a2323", "0xf41ff1e4", "0x9d03f401", "0x71dfb3d", "0xfcfee4f", "0xf260e221", "0x2125cf3", "0x11c71efc", "0x902b4796", "0x22e0d1c3", "0xaf90f404", "0x56b4fb24", "0x10c30e14", "0xc52d7001", "0xc4503b03", "0xde02dbdc", "0xadeafe94", "0x9d42feec", "0x7bf9a1a", "0x6ed7e140", "0xaf1e1ec0", "0xb391525d", "0xb95ef592", "0x40a0ba30", "0xace2cb9d", "0x10f109fa", "0xc0be1d00", "0x21de0a42", "0xcfb0ebf3", "0x3ec26c60", "0x5375157d", "0x1e1b241f", "0xfb21fac1", "0x1e01c21", "0x234b2506", "0x1ec3e513", "0xe9f2a0e", "0xe032efc2", "0x33f93a5", "0x3fe054f0", "0x7069fcaa", "0xe9f60c9b", "0x37062a0c", "0x420e9c3e", "0x4095cfbe", "0x62f4d41f", "0x3fd0c049", "0x6026fe25", "0xea76f7e7", "0x3052f2ae", "0x96ef3913", "0x11effbe4", "0x1f9a504c", "0xf732f917", "0x433bbbb4", "0xe23abd07", "0xac3e34fe", "0xf10cbfa", "0x37322d0f", "0xd0ebbd1f", "0x10363a05", "0x229fd070", "0xdafe0f7a", "0xa6900229", "0x3ffe12c2", "0xe41d9e5f", "0xf5e5f3ff", "0x5fc10e1f", "0x1c2b010", "0x101cfe03", "0x21ee0c9b", "0x13cf30e0", "0x2d631122", "0x662b536", "0x46a2e102", "0xd3e71eb1", "0x192dd24", "0xec1f3ff5", "0x1d32affe", "0xf312130e", "0xbfc7e4ef", "0x13d5fc0b", "0x130bd005", "0x3dfe1132", "0x120d01f", "0xf200ed14", "0x19273fb3", "0x1de1f19", "0xb55be694", "0xdd757cb5", "0xbe05cb0d", "0xe1f03b5c", "0xa14d22ce", "0xf6cf4f76", "0xef2db1f2", "0xdd200d04", "0x99fd90ad", "0x1e3ff3cf", "0x6233ef05", "0x322ed2fc", "0xff207c5d", "0x136c7d16", "0xf221c29e", "0xe1021ce4", "0xa9afad21", "0x292d922d", "0xe0239314", "0xf301fdb0", "0x104e4a7b", "0xd441fd75", "0x712f9ccf", "0xfe57fc26", "0x34395d25", "0xfd4634f3", "0x4f243900", "0xee0afc32", "0xe0e640a3", "0x1573b3eb", "0xd0f57031", "0xbddde11f", "0xcffab304", "0xc423711", "0x61635302", "0x6d2f1c5c", "0x1f5e5d5", "0xc13c02d5", "0xc30442f2", "0xfc7912e0", "0xabb90052", "0x2941c106", "0x2fe70a06", "0x1ff44ee2", "0x51b64224", "0x2cd43e3f", "0x29503f90", "0xfa442cf7", "0x7c5c7ae4", "0xf99da250", "0xf1192a1a", "0xc492e00b", "0x4119e6e0", "0x3cc2ee3b", "0xf610e2b0", "0x1d0fc0ea", "0x49fcfd64", "0xf30fc66f", "0xe909050d", "0xe12d0f2f", "0xf0f112f4", "0xbdfef320", "0x3fcf610c", "0xd7ec3dc", "0x1b9ff013", "0xf02f2042", "0xacce3a01", "0xd0f07ccd", "0xffddf033", "0xc12c909", "0x721fbc00", "0xea121b0d", "0xd5fcc0ec", "0xf1ad74be", "0xece3e713", "0x50f0c9", "0xf4bea3c", "0x297472d2", "0xae3dcf65", "0x4e0df0e", "0x27c2ba74", "0xeddd6e10", "0xe22a0efe", "0x511d72e1", "0x9e9c6cee", "0xcf31dedb", "0x4dcb5309", "0x10322d0b", "0x3ef03070", "0xe1ebe304", "0xf255d0e", "0xbb6e72d2", "0x1e01ac1c", "0xee422f9c", "0x10203d6", "0x210b0c11", "0x12be0201", "0x1dbf6bdc", "0xd20f0703", "0x520201ef", "0x9fe1de1e", "0xf5dbedff", "0x51efc34d", "0x6cfe9e4", "0x39663c7d", "0xd2d9a61c", "0x164090e", "0xd2091693", "0x90951009", "0x39599df", "0x21d7b137", "0x3bf9a03d", "0xfe4d710f", "0x21d2b20e", "0xf9ae10f1", "0xce75a090", "0xb1e2fded", "0x331f6209", "0xa92429f7", "0x3f9ef256", "0xcded214f", "0xfef09a94", "0x1226f202", "0x221c453d", "0x91d99efe", "0xc2c030d", "0x790e0b0e", "0xf672b1df", "0x2c901a75", "0x29bacbd1", "0xffc396f3", "0xb063f101", "0xb0d7c0e1", "0xceea3bec", "0x33d6dee", "0x247fce04", "0xfbfbefec", "0xd391ee13", "0xe1101210", "0x2246be1d", "0xf11201fe", "0xa7ed03cd", "0x1e35d101", "0x13d33d6e", "0x16f94f50", "0xef4e0eed", "0xfe7ce701", "0xbfc291f", "0xf1071dc9", "0xa543ddac", "0x216ecb00", "0x29631b13", "0x523cf675", "0xef0f04c4", "0xd97f5102", "0x70592a01", "0xf0bf3bea", "0x31b191a6", "0x3effabdc", "0x161fdbdf", "0x7dbe913a", "0x751d111", "0xee534000", "0xf1515f0e", "0x20321ef3", "0x20ae5eff", "0xd5722c21", "0xe423f2d2", "0x4722ed5d", "0xe7320f3d", "0xbf50600", "0x123a9f5f", "0xa13b4ff3", "0x10bd1d2e", "0x1b91051a", "0x2dbaf3f1", "0xfc240e22", "0x3ece3d3", "0x29b3501e", "0xf21ed16e", "0x41e43296", "0x31de9ce4", "0x1fcf7db1", "0xdd0b1f0d", "0x1107f015", "0x131e13d5", "0x3b5efdfa", "0x1972e275", "0x4110e9e2", "0xed25c321", "0x513773d2", "0xe0563115", "0x322ce299", "0x4ee240f", "0xc227540e", "0xb6c6213d", "0xd12a5121", "0x3ae3da0", "0x31ef297e", "0xdd5243bf", "0x720b109d", "0xc4fdc0ef", "0xfde7d00d", "0x4c2e110", "0xf1433d94", "0x1194fe94", "0xec1b0f3c", "0xc4e3c14", "0xf3eef942", "0xc20d094f", "0x517500f", "0xe12f231f", "0xf00f0f0f", "0xe24f3dfc", "0xd9523be3", "0x21505c02", "0x32521d43", "0x2942fe01", "0xcc6fe30e", "0xf9f1f23a", "0x11fa5c0e", "0xc2c4b42b", "0x70dff91e", "0x3fbd5ef1", "0x71019d52", "0x2f129e90", "0xed1eff0c", "0x7c6f6af0", "0x7ff304db", "0xe01cc9d", "0x34701923", "0x3e0022d1", "0xcd1fd13", "0x5d0a9dd1", "0xedf3eff", "0x322e3f23", "0x2f2db051", "0x9afd9bac", "0x11b0a90e", "0x21111144", "0xc6e34ea2", "0x1f7eac31", "0x4ce3c50e", "0xc515daff", "0x1d0c22", "0xb0069e11", "0x6c10591b", "0xe7502411", "0xe3f0a0f2", "0xf4ee9f37", "0xe151bd0e", "0x171d0ecd", "0x1151c1ea", "0xf10799db", "0xcf169b2", "0xb0c0c701", "0x34b0def2", "0xfeca9e0f", "0xf22c30f2", "0x412c1d03", "0x4011be2d", "0xadbfabcb", "0xbf0fac3", "0xe991f3ff", "0x130f52b6", "0xe31becc2", "0x20060913", "0x92f7096e", "0x107926f2", "0x3cc799e7", "0x6c2c770f", "0xfe3de55b", "0x23cded0e", "0x14eaaf01", "0xb1e0c0e", "0x1acd7c10", "0x314240ac", "0x4fd6ed02", "0x1900553d", "0x32c3f21b", "0x64f31dfb", "0xdd3db1fb", "0xf491005", "0x4d25903", "0x302f0dfa", "0xe4f10f1e", "0xcd0fb13d", "0xdad351ed", "0x4d03104b", "0xe4f34c1c", "0xccf6e0a", "0x201b205", "0x792e1f", "0x29f9b5b3", "0x55c9a331", "0x63eab6ce", "0xdfeaa1ff", "0xdfe3cf02", "0xf0c0f11b", "0x3ffe2224", "0xe12dbef3", "0x1929df3f", "0xc1ccee30", "0x4fecfece", "0xe134ea5f", "0xe10aa107", "0x3fe30d1b", "0x20fd2411", "0x303ff212", "0x6459ff55", "0xd3efdedf", "0x2429002f", "0x3f42cf07", "0x3731a020", "0x439dbd19", "0x404b61f", "0x22e1f3d2", "0xdba973d2", "0x67a0a0e2", "0xda1b9ca1", "0xf13daf14", "0xf322ad93", "0xc2fef30d", "0x200f90df", "0xb1690294", "0x4cca11a2", "0x269ac0c0", "0xe14200df", "0xdb1d96b", "0xf3c4ac45", "0xd04d0c1a", "0xcaf14ec1", "0x11fed2cf", "0xff3be531", "0x7edf0eef", "0x23fe4c44", "0xdd6240f5", "0xe074c1ed", "0x3e1ecbf0", "0xb000111c", "0xbf0fe373", "0xc594e22", "0xc7ee36e1", "0xeace4e1", "0x2f156e2c", "0xd12422ef", "0x921f2a04", "0xd2c11afa", "0x10006dd0", "0x103373f4", "0xa3e11405", "0x45b0c15f", "0xf4f2dcea", "0x10a2bf01", "0xfd010ff", "0xe0142cfc", "0xf0fc0ab", "0x3f65261c", "0xf4c092d4", "0x7100144a", "0xedd9a5b0", "0x32e30ff0", "0xc4cc51e", "0x4dc53c22", "0xff136cd1", "0xf4ee3f42", "0x1ded2e0e", "0xf11e11f2", "0xf59b920d", "0x7ef3b0e", "0x120ed1f0", "0x2def3f02", "0xa0f13fed", "0xdc013e03", "0xdd3d141e", "0x1e4a0312", "0x212ab11d", "0xa2fb2029", "0x1bfffe0e", "0x153f9e35", "0xc10202fe", "0xe61ffabc", "0xd2e9fc19", "0xf792103", "0x2497fde1", "0x24b32f6", "0x51f00bf3", "0x213f1152", "0x32b535d3", "0xe40eeef6", "0x4ea912bf", "0x71421334", "0x45d7907c", "0xe3f12500", "0x17c41f01", "0x227feeb6", "0x1f97e274", "0xf5cdd0e3", "0x14637dd0", "0xbafcaae4", "0xec1794bd", "0xdd9cdc2f", "0x919b5e09", "0xd72ca69", "0x50b15035", "0x37b445ea", "0xa0790f11", "0x99b19a51", "0x14621c10", "0xf39cf315", "0xcf26c30b", "0xdd9cf633", "0x312112bb", "0x4c0fe567", "0xda2f1cfe", "0xed5f510e", "0xe664f1e3", "0x5f034704", "0x31e2f5f1", "0xa05ac4f1", "0xb191c2cd", "0x2e202e02", "0x1f172cb7", "0x102ba0ff", "0xff519daf", "0xe20ef006", "0x3e79ea01", "0xce19bf6b", "0xf10b09d", "0xf30e33bb", "0xdf54f23b", "0x19199bb", "0x2bf025c3", "0x53daec2d", "0x12e2dd11", "0xc291c06f", "0x10c0fff0", "0x39435cf7", "0xd443e0f", "0xad4040c", "0x53306e75", "0x2273bc5c", "0x1ef2ca04", "0x27d2b294", "0x30209f", "0x31dd3fc3", "0x3dc504e", "0xecf2ced1", "0x35112442", "0x16120ee2", "0x4ee6b901", "0x23147195", "0xe1e59100", "0xe0135573", "0xc40ff71e", "0x1a1f31fd", "0x2ddf9710", "0x97d1f13", "0xaf3eeb0b", "0x3d397224", "0x407b2045", "0x2fc1efd2", "0x5067ab59", "0x50236702", "0x12fdbf6d", "0xd19d0379", "0x21daa705", "0x32cc9443", "0xf0df3724", "0x1f25647", "0x35d4211", "0x41fe9ed2", "0x302fbfd7", "0x1451e012", "0xe10bd200", "0xedc13694", "0xf12034f4", "0xdc215706", "0xebdbe45", "0x94bdff1", "0xde661060", "0x37d20d2", "0xd224bf1e", "0xf1395364", "0x40da0ccd", "0x75d14e30", "0x1f23ab5c", "0x4ed2d62f", "0x1125012", "0xe090fb3d", "0x1f9ec50e", "0xe2f44d05", "0xf7eb230", "0xf21c443d", "0xce5020fb", "0x93d9ceeb", "0xaeb3c10e", "0xff3203d", "0x1ec73302", "0x199bdcc4", "0x1c07151", "0xaaf21612", "0x2320ac1e", "0x960eec15", "0xe34cac6e", "0xe711dfd3", "0x1f66351d", "0x2c91cbf4", "0xcfed51fb", "0x6c04222f", "0x1f295070", "0x1ea72dec", "0xe0632205", "0xcfe2b05", "0xf99d6101", "0xfacbb7df", "0xd01113cf", "0x2ebf023b", "0x3c0c3a05", "0xcffff4d1", "0x24d73e5d", "0xdad04bee", "0x191162fb", "0xade1ce97", "0xf1b0b4a", "0xb01002a0", "0xf02e5caf", "0x329033fe", "0x25d90a50", "0x310fb3b3", "0x7ee19ff2", "0x45cbbc9b", "0x100eb24b", "0xae33624c", "0xeecc4927", "0xde937322", "0x1f53e529", "0xd53a0db0", "0x6f203d02", "0xfcef696", "0x306eef2c", "0x49173fd1", "0xbf40dd1", "0xbc523d33", "0x51c2e13d", "0x99ebe17a", "0x112ca100", "0xe0e9cf97", "0xd05c2c1a", "0x30f41101", "0xfeff1ce2", "0xfec2e7bf", "0xaf19217f", "0xf4f2202c", "0xcbd9cc01", "0xe3ecac94", "0x10a22d10", "0x911e133a", "0x79031332", "0x7efa3411", "0xf02225f", "0xde6f03db", "0xdf901f", "0x1b549a92", "0xff3f4100", "0xc637032d", "0x717c32d4", "0x2a73ffe0", "0xfea3ae3b", "0xe9ea1339", "0x67ccd60b", "0xfc3ebdcf", "0xaf225103", "0xe6772113", "0xfd3cf2ad", "0x2e16f5fd", "0xf11913e3", "0x1091246", "0xd03f3ef4", "0x20a423ff", "0x761e3", "0xc912522e", "0x477c33cf", "0x713bd400", "0x2efe2322", "0x67f049d", "0xb426f507", "0xde7ffd56", "0x51c532db", "0xce3f441d", "0x213d41d3", "0xfe1a2431", "0xfc49c1b2", "0x47340b", "0xdd2f1305", "0xc7e2ba9", "0x60c245a9", "0x27fa5501", "0xb4bccbc1", "0x99571163", "0xdd77df3f", "0x353aed13", "0xae2d4e04", "0x2ea3f430", "0x10ff09ee", "0xe2d2edcf", "0xfd3dd1d4", "0x6ef9e4e3", "0x1df4f133", "0xdffc52d2", "0xf5141b11", "0xf931b405", "0xaffb0c0c", "0x52d00f23", "0xb34b01e0", "0x544ad00f", "0x3a4936d1", "0xff40de41", "0xcdd4da02", "0xfb72f0b6", "0x1c304ea", "0xd44b1433", "0xc2630f01", "0x22b7b3e5", "0x9950f95f", "0x2029d0bf", "0xfbdadf1e", "0x6ce50f3", "0x209f09db", "0xf113f0d", "0x34d0f202", "0x7e9d1ad", "0xeb032e33", "0x14123fe1", "0x41daf1c", "0x3cf34fb2", "0x4eb01f19", "0xf5fef70f", "0x2600d131", "0x37395e1f", "0xb23b035f", "0xf212fa73", "0xcd9ed11d", "0x2fbc5d9c", "0xf1ec352a", "0x240ef193", "0xdff0e90e", "0x47d0754e", "0xff3bdddf", "0x105417ff", "0x49ff3b01", "0xeeffe10d", "0x4140356f", "0xc2e324d4", "0x503f6ce1", "0x240d09e3", "0xeeab41c1", "0x21931793", "0x4ffdcb09", "0xf434c35f", "0x10991211", "0x214ed3ef", "0xa04311f3", "0x7cb1e", "0x41e3ec2", "0xd9d12bf", "0xcf70931f", "0x7f632515", "0xf1ee9332", "0xc1c9c79e", "0x13559a7d", "0xf1ed6f9c", "0xdd0422e2", "0xd0945c52", "0x316412f7", "0x40461f2f", "0xd026353e", "0x94f1303d", "0xfe3df94b", "0x37c765dc", "0x20a91ec9", "0xf3bee3a0", "0x29f12c09", "0xfe2d1f30", "0x4030043e", "0x5bd41401", "0xbe94ddb1", "0x91f61fd7", "0x47702aa2", "0x204001d1", "0x2df3a51c", "0x6c0cf06f", "0xa1afccae", "0xf660c4f1", "0x4aac5524", "0x63f2542e", "0x7ff32022", "0xbdd51f1", "0xf3c9ed1e", "0x91bcd6e0", "0xf152110e", "0xeee0f5c5", "0x6d3b7167", "0xffe10321", "0x21eef3fe", "0x5ea17e00", "0x9bc1e30d", "0xf3da9fdc", "0xb04ffc2f", "0xcae747fd", "0x7d129266", "0xfcd72143", "0x53612e20", "0x41137502", "0xbff4ab0f", "0x1c2fc0c4", "0xf01db2fe", "0xfb113131", "0x93fcd737", "0x39b1101a", "0x10010000", "0xff10f0f0", "0xff0f000", "0xf1010f0f", "0x10f110f", "0xf0000", "0x1001", "0xf0f1f010", "0x0", "0xf00000ff", "0x1101000", "0x1010001", "0xf01f1", "0x1001f110", "0xf0101100", "0xf0000101", "0x1101f0", "0x1001f0f0", "0x10001010", "0x10ff10f", "0xf0", "0x11fff1f", "0x1100100", "0x1000ff00", "0xf0000f0", "0x10010", "0xf100", "0xff01000", "0x101f0101", "0x10f0f00f", "0x11f1f11", "0x1f110100", "0x1ff0f001", "0x10f00000", "0xf01000", "0xf010f0", "0xf1ff0f0", "0x10f0001", "0xf00", "0x1001ff00", "0x100000f1", "0x1100", "0xff0fff10", "0xff10f00f", "0xf0000f10", "0x1000f000", "0x1ff0000", "0xf1010010", "0x1000001f", "0x11f01101", "0xf00f000", "0x100f110", "0x100f0", "0xff010ff0", "0x100f010", "0xf001f0", "0xf01101", "0xff0f", "0x11f00", "0xff0f0000", "0x10100f01", "0x11000fff", "0xf", "0x100f000f", "0xf1000000", "0x10f0000", "0x1f11", "0x1000f0f", "0xf000f01f", "0xfff0000", "0xf", "0x0", "0xcd5ec2d2", "0x233c0c4c", "0x1b0fd106", "0x72e40040", "0xfac01c2", "0x3ef62c1", "0x7edf9942", "0xba231cd", "0x39ff0dad", "0x200ebc29", "0xa0000df7", "0xdf2dd024", "0xc1a35214", "0xf2e3e1e3", "0x4f4d9dd2", "0x2fbb4ebf", "0x5b9455ee", "0x30e3fb29", "0x23d3fe04", "0xdb1b6326", "0xd00c000c", "0xd1b33e3", "0x1dd99cbc", "0xb9974c5", "0x9ef7339f", "0xe636211d", "0xfab25ff", "0xc5f5c031", "0xf04ba0fd", "0xfb023a15", "0xe30cfcc7", "0xcf23f02f", "0xb025ce92", "0x2c22cf0d", "0x21aaeaf1", "0x102ad33", "0xc06224f7", "0xfc1f19ee", "0x1ef0413d", "0xee01f026", "0x1c7599c", "0xe2e5e239", "0x33fde20e", "0xb7f67416", "0xd02fb001", "0x1e2d0da0", "0x613df2f6", "0xb491f22", "0x3e750df0", "0xd3d316b5", "0xf041c0c", "0x71521922", "0xe005dfff", "0xd45709ae", "0x2416c403", "0x2201b514", "0xcc22adeb", "0x2c1f0023", "0x6fe2fbfd", "0x12fc41dc", "0xc0602705", "0x9dfd00a0", "0xb1220ffd", "0x63dd5c33", "0x96b6dea5", "0xd6d33f11", "0x61f1260f", "0xd4f33302", "0xd1fb4307", "0xe2abea0c", "0x1cc43f0f", "0xe634234e", "0x30fc9e2d", "0x1fdf0e2e", "0xc9d59201", "0xd55c253", "0x907cc177", "0x1ba1c672", "0xe5e55b4", "0x1fe02923", "0xbd9e214", "0x27c35c5", "0xa00fb01f", "0xdd3baa40", "0xdf5eeebf", "0xa1f3b360", "0xbc40efba", "0x3fc70914", "0x99deac97", "0xe2ef45c1", "0xcc466f0a", "0x3db22e09", "0x3ff72f66", "0x21d2fa53", "0x1d716244", "0x14d7d951", "0x6f1db0dd", "0xa2b39be", "0xd0d9c01", "0x11505061", "0x1efdc5bd", "0xd4a12ff2", "0x3f3051d6", "0x9eacad03", "0xfc4eedee", "0xfef9070f", "0x9f2efe1f", "0xf9ca097f", "0xaf2f01b1", "0x1d01ebf7", "0xdd7f644", "0xed20ffac", "0xbad0afa3", "0xf14dd70c", "0x4e25131d", "0xe960e61", "0xeff7e7de", "0x4c1f14e4", "0x4d190373", "0x45530bd", "0x21f01dcd", "0xc2eaf94e", "0x330b9f05", "0xf1203dbb", "0xaf113fd0", "0x140fc33", "0x6dc31ab6", "0xd4c32dd0", "0x41ee0f96", "0x730bcf2d", "0xc419c1ff", "0x4f3d9ada", "0x3f312f31", "0x524dff01", "0x4644ce36", "0x3df1df0e", "0x1bce5f4", "0x466c9dc2", "0xec1b6e1c", "0xfb0de59", "0x30f14a0f", "0x3fb051df", "0x3d51d120", "0xa00eb72f", "0x2e37532c", "0x37445143", "0x1f7241f0", "0x1d74f57", "0xcebffc12", "0x1b13d441", "0x711d2752", "0x3f404e3", "0xa5cdebb3", "0xcf1f7237", "0x2f240f02", "0xc411f076", "0xc037e507", "0x491edf3e", "0x72f32423", "0xa2cf6e05", "0xe436bd62", "0x1c560677", "0x7016b00c", "0x445ed365", "0xb0359601", "0xa01fd341", "0x723001b3", "0xd70ff233", "0xcbf711e0", "0x701515d", "0xf1f2df00", "0xecf771a5", "0xe0f4511d", "0xde3ef01f", "0x44ee13ff", "0x4e5223ca", "0xe1fd7cf2", "0xbdd4fc2", "0x3bd0130f", "0xe9f0c019", "0xee03ff0b", "0xdac0fc3d", "0x7f40031a", "0xffcb7e10", "0x40f60732", "0x2a4ca120", "0x1ee5530c", "0xb2fcc45f", "0xf0f43cb6", "0x3e2ff152", "0x4b9031b1", "0x6152ef", "0xbce21301", "0x75202e0", "0xbb43f604", "0xdc307f06", "0x40e6f01c", "0xee40dce0", "0x36b9f6f7", "0xfe35e240", "0xc2e9a0f4", "0xf2ebe0d3", "0x2adc54f3", "0xfb4f02ae", "0x4e42f111", "0x2d2a72f", "0xc23efce1", "0x39625ed3", "0x51bee052", "0xae9ae7c", "0xafee7706", "0xbed34c6", "0x15a2311", "0xf3144017", "0x45e63e01", "0xde7262ec", "0x62f3e1f9", "0xf7c73db3", "0xeedffb0f", "0xe1bf9ff", "0xbffbb62a", "0x1d1505f0", "0xc40bdeee", "0xf305ea22", "0xf1e69ead", "0x20e053d1", "0x621e920d", "0x4a34132", "0xc01cd0dc", "0x57342cd4", "0xbe5c306f", "0xefbe402f", "0xde9490ee", "0x11e7120f", "0xeee6b00e", "0x2e6cad3c", "0x40b4ab", "0xe620e0e7", "0xd2c1374", "0x42a9f531", "0x3f1309f9", "0xe791f0c1", "0xa5d9ce04", "0x150b1a4c", "0xe2b9519", "0xfbf0e2d", "0x1912f59d", "0xe7bc2efc", "0xe60590e0", "0x22c1ff1", "0xde14940c", "0xe294e454", "0x9f3907fd", "0x4ff2dcfe", "0x19301bdc", "0x259d1f1a", "0x2a290b0", "0x2c07ee35", "0xfb29119", "0xb40fd3ee", "0x2f4323d9", "0xe5b11beb", "0xe9fbfd6d", "0x379e2bdd", "0xdf0ef13a", "0xcebab19", "0x2de3e0b", "0xc1940ffe", "0xbee1790d", "0xd53f715f", "0x21f3f0ec", "0x20d4703c", "0xc7e14f13", "0x2df4c91e", "0xcbc41103", "0x392ec12", "0x1f0153c5", "0x246ddc1c", "0x71d94132", "0x2da479ff", "0x911f15a0", "0x33aca953", "0x6dca0f0a", "0xf39532de", "0x3f16fb0c", "0x16e2f96c", "0x795f4494", "0x719e7aed", "0xafe132b3", "0xc3e1d5d", "0xee9dc709", "0x1522e65c", "0xa035936f", "0x2ffb1d97", "0x13ef0b0", "0xecc6b600", "0xe2ddf09e", "0xc4460d19", "0xb501fa0f", "0x44eb7df0", "0xdff0a431", "0xf21f2120", "0xf170174a", "0xfd4d420", "0xf7b3ccde", "0xf1e52dfe", "0x314ec314", "0x25fd0161", "0xfff3f12f", "0x1540c9d4", "0x156111fd", "0xe1d93c02", "0x1b7040ce", "0x931010f0", "0xc412b110", "0x1dc7cd02", "0x92913d", "0x201590fb", "0x2fb5e35d", "0x1d1e1101", "0xa96101c5", "0x12e42dd", "0x213d7d0c", "0x1facb056", "0x71e0a47d", "0x33ef193e", "0xfe52b73", "0xc922f3", "0xc2a53d17", "0x1113b723", "0x32bdb107", "0x9dee96e0", "0x6fbd5731", "0x50fbc4", "0x3c0efa1c", "0xc499f2e2", "0xb351de5", "0x1cb6dbd0", "0x1b00030c", "0xf3bce1ee", "0x3ef2c92e", "0x6d11d360", "0x12dc2e91", "0xd76f1d29", "0xee021a0", "0x47b2e9d2", "0x33f06412", "0x359e3117", "0xc0ace9ef", "0x5afd1a30", "0x47fb09bd", "0x27217434", "0xcd503e13", "0x2ec09201", "0xce2c1407", "0x14909ed7", "0xbfcc2a0f", "0xee62ca65", "0x3fd17cf3", "0xb1ec71ed"},
{"0xefc01dc1", "0x43103a1c", "0x3d2e4f05", "0xdd1f0dfd", "0xd120eff2", "0xc0055d4f", "0xcfe1f1c4", "0x3f169f2a", "0xfbe7d00c", "0x151f1a2a", "0xc3c40b13", "0xd07144ed", "0xc03fda57", "0x9ce14d16", "0xdff900cc", "0x3dfc0c3e", "0x7a9e0e1e", "0xfe1d659b", "0x5022d11", "0x1d66c4b2", "0x27b250", "0x2e2260ff", "0x13b04f60", "0xf17adc46", "0x9172bef", "0x2aeb1252", "0x3d11110d", "0x123ecf5a", "0xc2172b", "0xe21ce94e", "0xd1b5f31c", "0x5c0ed002", "0x19279e3c", "0xb05a730", "0xddf1f91b", "0x417234b1", "0xf1d90753", "0xe44cba60", "0xf059767", "0x20ddddbe", "0x4bd71bff", "0x1474e53e", "0xe7d57e04", "0xed77f104", "0x10c5dc34", "0x21e14119", "0x5274031d", "0xe40f3959", "0x193f21fe", "0x3e0d9423", "0x160dc10d", "0x26b4cb2f", "0xaee92559", "0x31fd1f20", "0xdeffd59", "0xd71f40ff", "0xa410165", "0xa102f6f3", "0xd4bbd20f", "0x63be951f", "0xafc936ff", "0x631c0523", "0xb070ebe9", "0xf6ed3fe2", "0x7d02274e", "0xdf44ae51", "0xb2a3121a", "0x5c1e02e", "0xdf33ae1a", "0xf93dbfff", "0x6b315219", "0xc7e53ab9", "0xbdee12af", "0xafc06036", "0xbc13b5ff", "0xc0e4ecdf", "0x7f13d153", "0xfffe07e0", "0x613ee0f0", "0x1de011d", "0xbfebcfdb", "0x9f10efb5", "0xea2524f6", "0x33d30bc1", "0x31111c02", "0xd7221013", "0x50fd2f2", "0x41260f41", "0x9c120e9d", "0x3029044d", "0xfa12c402", "0x63e19edc", "0x2e4b12f", "0xff40d512", "0x50fa40e2", "0xf3b24c3d", "0x5f044373", "0xf2bbbe72", "0xf0f1e900", "0x9535ce0b", "0xbf5aa1d5", "0xeadfd1ff", "0x1f0fe1c7", "0x4b1b9ddc", "0x37e6eece", "0xed41b42", "0x7e715dff", "0x1d12bb94", "0xde52cc32", "0xf104cf10", "0xf0f94c37", "0x443e2d0f", "0xb0202d94", "0xee000e", "0xae2c7601", "0x13fcc2a", "0xd0dfcb39", "0x94f1ab1f", "0x1e04ae32", "0x12ed5d0e", "0xf6ff2421", "0x3259f124", "0x59797b0e", "0xe0c0d309", "0xdf721ff4", "0xbe4ddda3", "0xff2912b6", "0x3f51b5f5", "0x470234ee", "0x30de013", "0x69ef2ff5", "0x3be4eee", "0xee32fc3e", "0xca23a2fd", "0x950f6", "0xfd1c2406", "0xf0714724", "0xe30ddc1c", "0x3ffb1d00", "0x3322df4e", "0xf1f4cf51", "0x3d00ae2e", "0x9dd7bf6", "0xabf0510d", "0x30c7ca9f", "0xb299bbe7", "0xe1f9be03", "0xfb56149f", "0xa049e0a2", "0x1df0db55", "0x2f5e1f94", "0xca3ec5f2", "0x4a45fb2", "0xf3d1c010", "0xd2e2acfe", "0xd242ea0e", "0x911c32cd", "0x3cc3ab10", "0x4d3b0fe3", "0xf3ecb7ee", "0xd701444d", "0x2002fcc2", "0xfc9bba1a", "0x1dd00d3f", "0xb00c3750", "0xdddbf14", "0x3640d32d", "0x90ddf12c", "0xf937d22c", "0xdccffe44", "0xb20ace0e", "0x1af2dfb5", "0x103c1f0e", "0xe050eacc", "0xebe2b322", "0xdd3dd600", "0x1ce64601", "0xedf23e34", "0xb1163d01", "0xff01d49f", "0xc0feeff1", "0xfe03fede", "0x40fc933d", "0xd312e7df", "0xbb10231e", "0xd1c1ee1", "0x2a9de00d", "0x30c40fec", "0xee2ec2", "0xebf1b0c4", "0x515f2223", "0xd40124f9", "0x1ed6e34f", "0xfabb5d00", "0x741bf61f", "0x1c3d9437", "0xdfb4db6d", "0x5019420d", "0xa0caae02", "0xcd5bc3ee", "0xe9f4e70f", "0xfe1cfd12", "0x134cff3", "0x2aea964e", "0xe191ed3f", "0x5e091492", "0x264da110", "0xcd661cbc", "0xf0fe32ce", "0x1feceefe", "0xf54ffa05", "0x2c1b2d29", "0x2f92dd12", "0xdf7ce710", "0x5ddde37a", "0xfee03ff0", "0xf1deb20b", "0x43e11cda", "0x3049090e", "0x2e076cb0", "0xbf0decab", "0x2102ec41", "0xc0feddab", "0xf2f23f0", "0xc4d5f41f", "0xf43e39fb", "0x3500fc02", "0x11362df", "0x305ef0da", "0x611b2f14", "0xe13befa3", "0xef2de122", "0x9b169cdb", "0xf1b6f03b", "0x3311f101", "0xfc0ccff1", "0x30fdfeec", "0x12df140", "0xadddaa4c", "0xcf2d6533", "0x21bec00e", "0x516e5990", "0x39227a0c", "0xffed3502", "0xef5de1d7", "0xe39c2971", "0x93fe062f", "0x7f453c0d", "0x55f3305d", "0xe3c952", "0x75f5ef1a", "0x13f14712", "0xa136df57", "0xd3ed0915", "0xe47e7117", "0xbdd10e23", "0x2b00d41b", "0xdf0ddbe1", "0x71beff01", "0xfb2113f4", "0xcfb2b431", "0xbf00791e", "0xde5fcddd", "0xe92c2b13", "0x9b2b2db5", "0x6cf441c", "0x49407611", "0xe555f10d", "0x522e0314", "0xee2af1e", "0xb1c44123", "0x1eb29c23", "0xe4f7b1c4", "0x1e62640c", "0x1f20c7fb", "0x2574e65a", "0x1233a5c6", "0x5540dace", "0xf2cde43f", "0xf6cd9eb6", "0x5ed562c1", "0x1a3bc224", "0x51443616", "0x4010c04d", "0xf0471225", "0xf3fd3eef", "0x2403dfd", "0xe77bdac2", "0x9347395e", "0x2bc07dab", "0x17e7f615", "0xe614cbbf", "0xf2415f1a", "0x12d72d2", "0x15e0de00", "0xc25301f0", "0x3f03a3c", "0xbd1f321", "0xf3061705", "0xdf1ee1de", "0xe1672b", "0xfd0c3000", "0x2ee23a2", "0xff32914e", "0x37043367", "0x2be622b6", "0xd31d4df1", "0xce79d4fc", "0xcfd037ec", "0x532c0222", "0xee101fac", "0x20ef740e", "0xf2096c20", "0x40571de1", "0xa4ed5c00", "0x4704dc91", "0x21420e32", "0x313b1036", "0xd699d7e7", "0xfe5002c1", "0x5ff9b047", "0x531af2d0", "0xb5140cfe", "0xd00e4edd", "0x5053523c", "0xffe0200a", "0xac9f11ab", "0xad13feff", "0x37e93f75", "0xf9e9c232", "0xde262104", "0xd3b00e39", "0xf1100a", "0xf6fda295", "0xca1f11ca", "0xcd04511d", "0x1afc6256", "0xf374afde", "0xed12321e", "0x65bb479c", "0xc21e72fd", "0xe37100c7", "0x454465d4", "0x5ec5e5dc", "0x27fd2e15", "0x33f250bb", "0x14025efb", "0x2e0a5ebc", "0x207039fe", "0x705c310a", "0x71c24db1", "0x5b0541e9", "0x2415547c", "0xfa3fb3c1", "0xeeca9d0a", "0x3f436934", "0xf1c442fc", "0xc0b11091", "0xcf174f32", "0xb721d1da", "0x14fef2fb", "0x13042613", "0x1b00cf1c", "0x2ff9540", "0xa02f40c2", "0xf3f37020", "0x1c55e477", "0xc1c1d32e", "0xe057e2df", "0x4c09720", "0xd3e2dd04", "0xdecd0bf2", "0x11921c31", "0xf35fbfd2", "0xbfed104b", "0x13db5a19", "0x44e7d300", "0xf1d02173", "0xf4f0b009", "0xed90e271", "0xe0710ee4", "0x2c9d923c", "0x36d006cf", "0x3bb72ff1", "0xc6db01dd", "0x1ff311fd", "0xec9dfd10", "0x70929c5f", "0x600f3cd5", "0xf5ec026f", "0x4b793f1d", "0xea9df030", "0x1e054f92", "0x1ec9fd5", "0x94710d0a", "0xf1ee1e20", "0xc0fe3a0d", "0x92bf99f4", "0x213eef97", "0xc400dbe2", "0xd2061d4f", "0xedbf693a", "0x4621f700", "0x720f2c11", "0x50c0c00f", "0x2bedfb34", "0x11e3e117", "0x4f006db9", "0xe92a05d1", "0xf393feea", "0xb3f13b12", "0x3aedb63", "0x4f94e3f4", "0xc14dd9f2", "0x762f9c59", "0x5475d1fc", "0x1f03e137", "0x232cc603", "0xefee2d01", "0xb0e45fc0", "0xb2fe1f0e", "0xd9de2be0", "0xf9453b93", "0x911deed7", "0xf0f54d3e", "0x3a44ed2a", "0xf270d2fb", "0xa24dfe04", "0xfc0b1a6", "0x7fecd021", "0x3a4a673", "0x5ef4612d", "0x9d12ef90", "0xcc33bef2", "0xf3afe91f", "0x24115d1f", "0x90322eed", "0xd70623a0", "0x512d221d", "0x6db0912f", "0xc310529c", "0xd6a20e1b", "0xd044d302", "0xf1bdc301", "0xcf304a51", "0xfaef2f6e", "0x9240a420", "0x9c292fe1", "0xcec2c2f4", "0x31d6323e", "0xd11f9fb", "0xdfcff401", "0xe0f51c10", "0x6d14f20c", "0xe23ff", "0x4ffe2301", "0x4a7419e5", "0x34e02fc6", "0x23f39901", "0x73502962", "0x21b4c34a", "0x242e3f47", "0x2df3e449", "0x7be1a039", "0xfc97e491", "0xf2fee1e", "0x59a0f010", "0x9232fccc", "0x412d5975", "0xb1a1204f", "0xc57decd3", "0x9019ecb7", "0xbdd3d290", "0x1002033c", "0xd43d4cf1", "0xdfa2012e", "0xa0b1faa1", "0x20e1deb1", "0x5dfdefd1", "0x152d4e1e", "0x49515d16", "0xe991bfe0", "0x13f3cf1f", "0xe0ab3eb3", "0x70e0be2a", "0x3c1ffd71", "0xbcfcfb12", "0xaf317029", "0xdfcfc49f", "0x200f9efe", "0xe0fd26f1", "0x397105c", "0x40fd191f", "0xa1fe02a9", "0x4a56390a", "0xa453e317", "0x6522e91", "0x11efd23c", "0x2001ee00", "0x1d12cc4", "0xd51cf0", "0xe2caeb23", "0xfcb02eef", "0x1e604203", "0x103fd1f0", "0x4f2dadc", "0xfedec90e", "0x309ccb1f", "0xdff52c11", "0xbaf4452a", "0xa7004420", "0xdda9a9e3", "0x4d079dbf", "0x3e04ebe4", "0x1d91f11", "0x151d4caa", "0xde240223", "0xc9f73e6f", "0xa530055f", "0xfd4c01e2", "0xe6316bf", "0xcbcfece0", "0x21c9900a", "0x5d3b3fcc", "0xef95c56e", "0xcbe47d1b", "0xaef3f6da", "0xda12ce31", "0xd093616", "0xdee9fdf1", "0xd3255903", "0xb3ffec2e", "0xd02b1c23", "0x40ff42ed", "0x4f4de215", "0xee139ef1", "0xede0be42", "0xd505192e", "0x140f0001", "0x5220c0d1", "0xff91c04", "0xf0dd3b00", "0xef1e9027", "0x4bf331f3", "0x1ec9bc6b", "0x102d49cd", "0xbb901b0f", "0x1a0aa20d", "0xfff0e402", "0x17054ceb", "0xd3b41251", "0xf37030ce", "0xe49a052f", "0x31512171", "0xec556a06", "0x940aecaf", "0x21d9292f", "0x43e9bf37", "0x4e9449c", "0x1e4602f2", "0x16d6cc6c", "0xef1e493e", "0xe1b62a00", "0xae51f79d", "0xa129c3f0", "0x1c29daf7", "0x45ee73e2", "0x9165452", "0x1305fb01", "0xcec56bce", "0xfedc4009", "0xac77053c", "0xc010a017", "0xe2ee39ce", "0x2200b12", "0x49715a50", "0x9e123cbf", "0xec6040a4", "0x77790202", "0x5da01231", "0x503c009f", "0xd1152ad9", "0x1ab566a7", "0xf151f7ef", "0xa9ee7e3d", "0xfcfb1b9e", "0x3903dd0b", "0x760ee542", "0x212931ee", "0x9bb4dfde", "0xe1db1fee", "0xf4032411", "0xe0ad4079", "0x4ac32731", "0xeb104a1a", "0x34b3da1d", "0xd01c03c2", "0x3507133a", "0x1dd1113c", "0x345d512f", "0x6fcbff02", "0x14f09d3", "0xf632ceff", "0x31cb4e0a", "0x6f473409", "0x9433c209", "0xe4d0ef91", "0x2fe4fa04", "0xfb19c0e", "0xdb093f9f", "0x4d0db91f", "0xf1ff770b", "0xc059f2bf", "0xbb0e3ed0", "0x23fecfe2", "0x275e43c3", "0xe090a96e", "0xaea65b0", "0xb0121afc", "0xf2551f62", "0x200312e1", "0xc0160fc2", "0x7f12d312", "0x6570ce32", "0x2a51cfad", "0x1c01b501", "0x704ad309", "0xe1dd1ff9", "0xdcf14e", "0x3cf106aa", "0x225dd5fe", "0xf912e100", "0xf246c905", "0x9a00fbf", "0xa6dfd109", "0x24a71d0a", "0x91a9c3f6", "0x1f3f2412", "0x31bda4e2", "0x2cc9f3b1", "0xadf1b7d", "0xd20060c3", "0xd7b01e09", "0xce124f42", "0x60ad139f", "0x246e3ba", "0x273e09cf", "0xfa42b1ea", "0xf3ff2f0f", "0xec16fec4", "0xf1c2e17", "0xd9b3aff1", "0xe0d24e33", "0x1c12ff2a", "0x1f2516e9", "0xda0ee2e2", "0xe0200e51", "0x3dbd3e94", "0x524d211d", "0xcaf2f49", "0x9fed7a11", "0xedbfd402", "0xfec0e6bb", "0x720c55f2", "0xdfdfec70", "0x2cfe2ef6", "0x19700f1c", "0x43fa5c14", "0xa0a7e01c", "0xda134c01", "0x12f72db0", "0xc0312f4", "0xc77c6cbb", "0xfdee3424", "0xfbdf5d06", "0x122fdef4", "0xf0ec3ef0", "0x7c27a13c", "0xdf00000a", "0x4afa33ed", "0xdde0f92d", "0x25ec63c7", "0x334ff011", "0xef45241", "0x91d47fdd", "0x71e93f4", "0xc5d211ce", "0x713fa7bd", "0x59ee3b53", "0xec7e49c2", "0x2110a909", "0x567b1204", "0x919394f0", "0xdc9c1c1c", "0xcbc10abf", "0xed4d02fa", "0xd2fb302a", "0xf2b5237e", "0xcff0e41c", "0xdbe021f1", "0xf09230dc", "0x2e12ffb4", "0xeb0f0d3", "0x9415eed", "0x990eddc0", "0xc711a62d", "0xcf3e3df9", "0x414e72c", "0x210420cb", "0x6fe1ed45", "0xcf0012af", "0x1d6af216", "0xf002f974", "0x9f2cdb06", "0x1fc6f200", "0xd5693613", "0xb19fafaf", "0xff91fa", "0xdfab70f", "0xae91eec", "0xa321f229", "0x2d025042", "0xe7d5940d", "0x40e1c2f2", "0xefadd522", "0xd3e35fbc", "0xa42c1fd3", "0x11010031", "0xa52e9c0f", "0x244f1ffe", "0xdd0e900e", "0x43f2230", "0xb22dddef", "0xe1e5ffb1", "0x117060b0", "0xa41620ee", "0x94c3fb32", "0x2f06fbe", "0xc4ea9d1c", "0xddf3cf3b", "0xc0e60ed0", "0x75f34e4", "0x16ec9351", "0x9a774eee", "0x5fc7f2e4", "0xd12a57a0", "0xb1c2c6f4", "0x24cf512a", "0x9fb12144", "0x1eddb29c", "0x35cfcee7", "0x5cd0cf0d", "0x9fa3b04a", "0x2b2b635f", "0x40aea109", "0xe340d347", "0xc1d79527", "0xe5d2a0be", "0xd9322f23", "0xb2e25f2b", "0x9a0541fc", "0x122f0d63", "0x36eca110", "0x9536afd2", "0x1bfd1ef", "0xe1c21d6e", "0xbc2d0064", "0xd0b31bef", "0xe709d0c1", "0x710d9bc", "0xa40fdd02", "0x5dcf06e3", "0xcf34e906", "0x7220901b", "0x5560072f", "0xeb7c033", "0xc5dd13f2", "0x104d0d11", "0xc7aeb001", "0xf2f7334d", "0x3f0da0c5", "0x27131d4e", "0xf02d63d2", "0xce0040dd", "0x5eff7310", "0x37432ff4", "0xdf1bdc07", "0xf24760a0", "0xf4b1ce5", "0xdb20196e", "0x37bf4ae1", "0xbadff0dc", "0x7337f413", "0x37b5ab19", "0xada23d06", "0xb02c7b06", "0x7f79fbfc", "0xdaa203e6", "0xe4091260", "0xa1d320f4", "0xcd37a393", "0xfedfb209", "0x9ce055f0", "0x35eb0bcf", "0xd03c19e9", "0xf51d4ce7", "0xdc0fc660", "0x47eb3100", "0xcae32f95", "0xc0adedcb", "0x1bee9611", "0xe0f2d2ea", "0xd0300db9", "0x32517322", "0xe1bc9f0f", "0xdeddd211", "0x52366e5b", "0xff6f060", "0x21f03bf2", "0x611f6f27", "0x3093fbe0", "0x530de9ff", "0x142525e3", "0xdbf395e7", "0xec34479d", "0x31264e", "0xd023510c", "0xf30d5f05", "0x110c3d52", "0xf6ed21c4", "0xcb02f7f3", "0x1a92e455", "0x12eff59d", "0xc4b90e7a", "0x29d0b701", "0xf52e001", "0xd1d3edc4", "0x33903f04", "0xaaa29c3f", "0xc232c2ee", "0xac1f0002", "0x15bbfe00", "0xcd4e1d07", "0xe2131efb", "0x200e2f21", "0x52b5fe5e", "0x5d4ddeea", "0xf3f130c1", "0x3e54fabe", "0x10d21293", "0xa410b104", "0x11401a5d", "0x31acbc22", "0xfe60ffe", "0x6f7e5221", "0xe3c2ef39", "0xe5e1e596", "0xdde91b0c", "0xbd25240e", "0x5e66dddf", "0xdff72a01", "0xe1c2cf0", "0x2d670eee", "0x122ad309", "0xbb060fdf", "0x44daccdb", "0x7af1a40f", "0x320d404e", "0x51eba4d9", "0x56f29db2", "0xd2d0f4a", "0x70753ed6", "0xaf07c397", "0xee0fcb3c", "0xf346e10c", "0x33f2f401", "0x31ca91f9", "0xe201be10", "0xc11f9a94", "0x604f5f2", "0xa001cc95", "0x1d21f5d9", "0x34a34d0f", "0xa1b1eb3c", "0xff0032e3", "0x1d0dfd1", "0x203d9d24", "0x90f01e0d", "0xdde5cb2f", "0x2ceeb23f", "0xe97f2200", "0x30fd5fd", "0x61edc29a", "0x43221fdc", "0xe7ea2ec2", "0x2df3b76d", "0xc317b1f3", "0x1e0cbedf", "0xdc3e10c", "0xaa562593", "0x11a2ef2f", "0x494ed3d0", "0xf113791c", "0xc7642721", "0xfc90f1e0", "0x1d7bd5ee", "0xf77e2319", "0x9fd59c2", "0x6112e25b", "0xef1241a1", "0xbff1dd17", "0x54911b4", "0xd2533200", "0x19214450", "0xe9def015", "0x1e65ee0f", "0x206dc55d", "0x2f1ff4", "0xf5ac1b06", "0x113b2a02", "0xd11705a4", "0x3b2007b1", "0xadfda0f0", "0xce6df1c6", "0xd17c5ac3", "0xb120d101", "0x10a0d9a7", "0xb11dd25d", "0xce34241", "0x2e50c124", "0x145f010b", "0x7134fde4", "0x5f00ca1e", "0xb34fc7c4", "0x20ffb6e", "0x10fbdee9", "0x622d30e1", "0x354fd0d9", "0x5300c50f", "0x3f215501", "0xd0c39b3d", "0x5f75469e", "0xb02fed6", "0xd3fe39e2", "0x44ae2d4f", "0x35219dfe", "0xf0e1a30a", "0x24237bc2", "0xb1cb0d0e", "0x3ef740ae", "0xfb9ae1df", "0xf232ae4", "0xec635622", "0x3df3bbeb", "0x2ccad61e", "0x54f0b01e", "0xf15a0a3f", "0x6c1ef13f", "0x991a23d", "0xdd6e5f35", "0xd409ff20", "0x3f1f9d6c", "0xd20cf31d", "0x22ff5f0e", "0x7117aa29", "0x4b211f93", "0xcc24f3e", "0xe4a2099f", "0xc24fd16d", "0x535993eb", "0x20131010", "0x20200cfa", "0x20f4591c", "0x3ff6bf", "0xc9a04321", "0xd25c9ed1", "0xcf2fee96", "0x222ebfed", "0x3c251ff", "0xbd011f9", "0x1f54d01", "0x4eed90d0", "0x29a1b110", "0x937a61c3", "0x6421feb6", "0x1ccf9de9", "0xe32fa02", "0x49c131f2", "0x51723eff", "0xb9f040c2", "0x95daeeb7", "0xf47bc9e", "0x3fefd3e1", "0x6cef9409", "0xcff36b1d", "0x2b5b52aa", "0x51b5014e", "0x193b1333", "0xaa20e20e", "0x11029ddd", "0x32dcfd5", "0x50f5d629", "0xe3df3e01", "0x9c344e36", "0x2d020f1", "0x19ad2141", "0x1cf0f662", "0xdc551c07", "0xd41376e4", "0x4633e43b", "0xeb94411a", "0x54ad0345", "0xa22fceb0", "0x6552e9c", "0xcef1e2f3", "0x109400ef", "0xd213d345", "0x14e7030d", "0x3be1df2", "0x20ef272", "0x511e04f3", "0x156fc60c", "0xe9ccad29", "0x5cbe16d0", "0xdec2b21c", "0x6610205", "0x74a54605", "0x4e3360cb", "0x6f62f021", "0xdf2ccf42", "0x1fd1a22c", "0xee1fc501", "0x444772e0", "0x6403ee7f", "0xfcbc390f", "0x37f0131", "0x2f7b1119", "0x9037e49d", "0xa64be2ae", "0x5fc165de", "0xe4f7b1c3", "0x174261e0", "0xff00f00b", "0x2c60101d", "0x2f26023b", "0xa2e2cdcc", "0x52dfcef3", "0x17f2f31e", "0x1c97d1dc", "0xf2ee6a12", "0x4245e002", "0x43017b0c", "0x5ee7cc17", "0xa1ff4cdc", "0x1f5e04c0", "0xb311f102", "0x7053e22", "0x313b2f51", "0xd04e0e11", "0x12535f15", "0x706e0143", "0x12411e79", "0x345e0f15", "0xbdeb02dc", "0x2792ef31", "0x1d02fea5", "0x3d40bbfe", "0xe5125cb", "0x317fe04d", "0x134deb43", "0x924d02f4", "0xb222c041", "0x5602aef9", "0x26502be7", "0xf91ee202", "0xf2437450", "0xef143c40", "0xc4102c01", "0xd4c9e3dc", "0xe351feb0", "0x904f5a", "0xd0fdecf1", "0xbd120903", "0x301e2904", "0xa0d26cf7", "0xe77eae29", "0xfeee1990", "0x51a1dd9e", "0xe1a3eedc", "0x1e049bc3", "0xb9fa2f10", "0xf5021993", "0xdff45e21", "0xc4ff3fef", "0xedccd1eb", "0x606fb9ef", "0xdc60f0f2", "0x5c2fd1a", "0xebde3500", "0xe01635eb", "0xe1bf7f7e", "0xf7efeeff", "0x1ee24cf3", "0xfe7cba2e", "0x2102c202", "0xeb219b7e", "0xbc212bfd", "0x31cbd56", "0xffe7d0b3", "0x1441f162", "0xe122630f", "0xf95712af", "0x5c4110e1", "0x1ac5a453", "0x97c7501d", "0xc320e1f", "0x41a0a02e", "0xb21f0f55", "0x1000214", "0xe9da25f1", "0x3d1dcd12", "0x23cfb4fb", "0x2b033002", "0x3d5f0379", "0xa0fcfb1f", "0x41ecf3ad", "0x3073392e", "0xd913121a", "0x43404ce0", "0xeeb10e6b", "0xd337d213", "0x1e9f7592", "0xdf31140c", "0x13172242", "0xb03131b", "0x9dd320dd", "0xfc3c31db", "0x15bc3f4d", "0x7f73202", "0xe1ba76cd", "0xdff2ca19", "0xf1444d00", "0x1c67aa0c", "0xdcc01f1b", "0xf01f44c3", "0x3302011d", "0xa2d31f05", "0x1bac55f9", "0x20319aee", "0x5cc072ce", "0xe6757f1", "0x1cfc1fd", "0xd12a0512", "0xdd099f19", "0x3cec7f05", "0xa2aa009f", "0x7fc60b2a", "0x2b30bb09", "0x29b1def", "0xb4f102aa", "0xdf69de7d", "0xfaf991c9", "0x4cca700e", "0xd1abcbf7", "0x51c7baae", "0x4ddd1c09", "0x52cc335", "0x1ee111dd", "0xedcd3f5a", "0xfbfce3f9", "0xdd06712", "0xdf1be237", "0xe1dd9b93", "0xfded4c9a", "0x24d6a4e0", "0xdc0e672c", "0xd2e0d324", "0x59e49fd9", "0x6dfd5c13", "0xffbf5193", "0x4fd6f9ab", "0x222e3dfc", "0x330f2de1", "0x1522d9f1", "0xf33f30f", "0x9d39ee9", "0x21e05f0e", "0x1aec1a95", "0xf00309d1", "0x4121423b", "0x735c41fe", "0x4f610dd4", "0x3b14143f", "0xcaf1e1c9", "0x19c47300", "0x1ab939e7", "0x4fef2a94", "0x2fefdf0e", "0x4423f000", "0xf140f002", "0xb210cf45", "0x9e1c13f", "0x63b4e20f", "0x4232d33e", "0x401e0fdc", "0x7f20c2bb", "0x13dceaea", "0x30f1cde1", "0xf112f031", "0xf9c120c9", "0x6d7cf03", "0x320c3def", "0x20352c25", "0x7c01f5e9", "0x4fe91e0c", "0x36c0a9f2", "0xf0ff320d", "0xe9c370f9", "0xcef6d207", "0xf2b9e00", "0x4f0f0102", "0x7cb5e3bc", "0xeebe00fe", "0xb4d1b901", "0xdfb2dff5", "0x4324f723", "0xf0e1060a", "0xfd3e12c4", "0x507f9024", "0xf56ced3d", "0x40ef0d74", "0x5e20df73", "0x3a47fdc5", "0x301fb92e", "0x2cedc0b", "0xee1dc2f0", "0x21522c16", "0xd40efff", "0x1cffce3f", "0x53431ee3", "0xa93fa0d2", "0x2b4ead22", "0x31dbd917", "0xa1d43c", "0xe11fe034", "0x12d6b10c", "0x3990ffed", "0x7604011e", "0x69dcca70", "0x25ee47de", "0xd119c71b", "0x2b5b1d54", "0xd00df4f2", "0xd550001b", "0x12dc1f3d", "0x27c12d1c", "0x2c4506cf", "0x55330100", "0xa5baab0e", "0xcebf2201", "0x400c43e1", "0xe2b1530", "0x3b092b41", "0xf14e531", "0xedebc0b1", "0xea4b619e", "0x460210f", "0xed9e93f9", "0xa10e0e40", "0xd1a1f13a", "0x3b92c029", "0xfcb6b9f2", "0x42f4b1d0", "0x59217d1", "0x1d5da704", "0xdf6f75e3", "0xf15d5d2f", "0x4403090a", "0x9190eb75", "0x22b1422e", "0xcd6a3d9", "0x11d4febf", "0xf1ed56fb", "0xf6d600cf", "0x60f3ff15", "0x21a04e51", "0x9b1ccd7e", "0x41f3400e", "0x9ae4c2a2", "0xe2f0d30f", "0xb14b3f02", "0xd3a6b29b", "0xb00d11fe", "0xfaf5ef5f", "0x3c66924d", "0xd3d2f9ff", "0x75f4045a", "0x379fd0c1", "0x297c5610", "0xeb03101f", "0xf0c35126", "0xed3e2f15", "0x3c34341", "0xf9e010be", "0x4a13de42", "0x6e7e2d77", "0xf01f6012", "0x41ee2bde", "0xcf204ae7", "0xf59c71f4", "0x5edd6011", "0x45c3104d", "0xbbfa9fad", "0xac2fea71", "0x21540bf7", "0x6b2c1f01", "0xf01e0a2f", "0xad1e5d0d", "0xde766f1e", "0x519c0ff", "0x90263f9d", "0x27d447e2", "0x330fef00", "0x4320400c", "0x311f53d6", "0xed239901", "0xc21f30f6", "0xe310307", "0x2dec7b", "0x14113127", "0x155bf10d", "0xd7ef22df", "0x701cf313", "0xe71eec13", "0x91d40e10", "0x400dc24a", "0x1113d106", "0xf63ab24", "0xc49fae04", "0x13140fc7", "0x40f1dd7d", "0xcabc0dea", "0xbba061fc", "0x963450f1", "0x3fd7c909", "0xc525a71c", "0x5a3fe001", "0x1167632a", "0x1063e064", "0x9ff32dd0", "0xe6ff000b", "0xc4121f4e", "0x2fe2f332", "0xb1f79045", "0x354df1f", "0x42dff53d", "0xc10f0c6f", "0x60111321", "0xccc9fc9a", "0x309f6101", "0x7bf2d012", "0xdd32c303", "0xddf12a01", "0x299bdcc2", "0x9fdfca4b", "0xeec6693c", "0xda1c1de3", "0x6e043dcd", "0x44d62ff0", "0x32494e29", "0xdad3ac0c", "0xcc9cfb1f", "0x90fe071a", "0x33eeea17", "0x3203102e", "0x6612904", "0x3be3fea1", "0xe0c92afc", "0x9634def4", "0xbe11212b", "0x9fe7e00c", "0x72e19fc3", "0x23016092", "0xd74e2f36", "0x33e1b203", "0xffae0ce9", "0x4405ec01", "0xcb5451ec", "0xb0572c99", "0x5c4dbd32", "0x2f0b1f96", "0xba5bbd1c", "0x3fe510fd", "0xefdf5de9", "0x20fb9f11", "0x11b29e9f", "0x1f14dd12", "0x51eb2f22", "0x22f1e74a", "0x433feae1", "0x7cd70ee2", "0x13ed1d14", "0x12040f1", "0xadbef3d0", "0xb0dd6e22", "0x20f2b041", "0xfe1ff597", "0x762ed03d", "0x76d6e000", "0xfbdf4fbe", "0xe0c0e100", "0x4bdf53a0", "0x21601e11", "0x5fd17b7f", "0x3e01f1b7", "0x2e0f0a6f", "0x7112550c", "0xca93239e", "0x1b392a0f", "0xa7f39c9c", "0x2ffed375", "0xef0e13c", "0x5400c2bb", "0x9efce", "0x7ea21a1b", "0x31234015", "0x2b1bdc0c", "0xca1521c9", "0x11ddcdd4", "0xdcaab5dc", "0x20c90d2", "0x43d007dd", "0x72f6ed3f", "0x1255dc5", "0x207a550f", "0x9d015ca", "0x1433345", "0xdf4463", "0x2da0dd6", "0xf1b04d1f", "0x2e9be0", "0xdfcef9ad", "0x4171a1e", "0x45321e3d", "0xc04ab129", "0x2d3490e4", "0xce79f19c", "0xd530fa52", "0x1b424cf0", "0x710bab0", "0x2f14ba0d", "0x220ef9f1", "0x3f1f90fb", "0xfcb4db4", "0x4c7ce6cd", "0x96b0e095", "0xde5ff2eb", "0xdd7ffb00", "0xb1b6acfa", "0xf069b5d0", "0x40faf20a", "0x10ee41f4", "0xe32a9f02", "0xf6be61e5", "0x2f3ca01b", "0xf2971d20", "0x101dce09", "0x6d23cd02", "0x1f959eb2", "0x9c2e5a05", "0xd9d032aa", "0xf2191940", "0x3d0e36fc", "0xc5622b0", "0x643192f2", "0x21d5a9c3", "0xe050fb01", "0x43453db3", "0xf513fe13", "0xd6fd0ef3", "0x10f9f0be", "0xa274c1e", "0xef31b0f1", "0x2f4cce12", "0x31f26170", "0x2ead432f", "0x740f9e33", "0xae91203d", "0x311fb0e3", "0xfee0904f", "0x29391c03", "0x4fedf1f6", "0xf115cef0", "0x904da35f", "0xf041f7ad", "0xea1203ec", "0x9927c6d2", "0xeabf11f1", "0x700bee0e", "0xfeec2f12", "0xc2eccf5d", "0x913cbd2e", "0x74241d2e", "0xb979c1fd", "0xd1dc421", "0xcdb103c0", "0xe0a6902", "0x1512e062", "0x11c0210", "0xc6c3f6a", "0x732660d1", "0x9dec4fe", "0x300a6a7e", "0xde622e06", "0xd66f3bf6", "0xcf566d1", "0xce307e9b", "0xfa02bf1f", "0x9ce2b03f", "0xe2e2af01", "0x1d240fa0", "0xdfbc511", "0x5f9f650f", "0x3f0f1401", "0xd12b72db", "0x2e9c6ff7", "0x2f2fe317", "0x9aba2703", "0xdb9e09c0", "0xecee09d4", "0x1abf3f04", "0xffc23410", "0xf07422b4", "0x1e0912f2", "0xce00e73c", "0xbbfc4550", "0x42f41dc1", "0x4609e1d", "0x6f531e17", "0x2fef1401", "0xdfe4612b", "0x6110a140", "0xef3dc22e", "0xbb270211", "0x4b261eb4", "0xd7ee9f50", "0x2bf1c403", "0x70b770bf", "0xefc0ea12", "0x5dc2fcff", "0x70165d2f", "0xaf0dc6d0", "0x4df211f0", "0xac63d05f", "0xf3dc20e", "0x32ad10e5", "0x32c13b42", "0x6b2f407c", "0x4dc56df6", "0xac5b47e5", "0xcf02c331", "0xeb29e10", "0xe3fdde0b", "0xc2904df1", "0xf071311d", "0x1bc0ef31", "0x36f36b71", "0x19e0e203", "0xd254f247", "0x22f794db", "0xf311c4fc", "0x9e9b7ea3", "0x1f933921", "0x530d1705", "0xb73c3f3f", "0x1ff4f745", "0xc0ff2ff", "0x1d14fc90", "0x21125d03", "0x9d9b3115", "0xe19abc41", "0x63bebd1e", "0x3036afdd", "0x1f22c294", "0x650d0d59", "0x21e7acd1", "0x9a4f010e", "0xf2f409b2", "0x9faf5beb", "0x61023fd", "0x1c53a20", "0x13f92ffe", "0x43efb5fb", "0x193ec943", "0xd939e100", "0xc33df900", "0xb1fd2c00", "0x5092fa40", "0xf407ec33", "0xe34ec033", "0xfe4ee499", "0x9ceb014a", "0xbc23e00", "0x23d7000", "0xd21f0e5f", "0x220cb14b", "0x315411f2", "0xe3a2d572", "0xa09bfdbf", "0x27499916", "0xd91d1e02", "0xc402c977", "0x9f63d3", "0xc14c20c1", "0x4b59c499", "0x69c19e94", "0xfeacb411", "0x15cf9903", "0xac99e010", "0x741009c3", "0xb0a32f71", "0xe0990a02", "0x9cd023ee", "0xf90a9a40", "0x400f92a0", "0x2bc933ee", "0xfcbbce00", "0x2d3dcb31", "0xf2e1c70", "0x25e9c4c0", "0xaaec3de3", "0xebbcdd0", "0x93bc019c", "0x16429b7c", "0xcbf750f4", "0xc07159c3", "0xe0e3beb3", "0x352f7ca2", "0x1c35d31d", "0xd9c0b9e6", "0xc01feee2", "0xd056f377", "0x3f977103", "0x7e19fe", "0xc1f3f0d3", "0x35dd323", "0x1f470d22", "0xa91e1afe", "0xd151bba1", "0xf29c351c", "0x94d05c1e", "0x5d7cdf11", "0xe00f2402", "0xe0e923c2", "0x7e52fe37", "0xed030a4d", "0x1f1100", "0x100f1f0", "0xf0000f00", "0x100010", "0xf0100101", "0x10f0f", "0xf00", "0xff100f0", "0xf0000000", "0x1f100f01", "0x0", "0xf010f00", "0x1001fff", "0xf10f1111", "0x10011001", "0xf0110100", "0xff110", "0xf0fff0f", "0x1100011", "0x1f1f0", "0xff0f0", "0xf00f101", "0x10010f", "0xf000000", "0xf000000", "0xf100000", "0xf1101000", "0x101f01", "0x1", "0x10f0", "0xf1011f0", "0x10000f0", "0x100000f0", "0x110f000", "0xf00100", "0x1100010", "0xf000", "0x10110f", "0x0", "0x1f0000f0", "0xff01000", "0x101f0111", "0x100100", "0xf10ff00", "0x10ff00", "0xf00001", "0xf0010100", "0x101", "0xf00f11f0", "0x1f10f", "0x1f0ff", "0xf0000000", "0x1100110", "0xf1f001", "0xf00000f0", "0xff0", "0x1111f000", "0x1f0f000", "0xf01f0", "0xf11001", "0xf00f0000", "0x100ff01f", "0xf00001", "0x10ff0010", "0xf1f00", "0xff00f00f", "0x1000f0f0", "0xffff0100", "0x1100000", "0xf100f01f", "0x1000f00f", "0x11010100", "0xfd311190", "0xf1b4e2e0", "0x42ddf312", "0xd1f19053", "0x10c27eda", "0x7195372e", "0x61159a06", "0x4014d2f0", "0xeb021592", "0xdd35d005", "0xa14ec102", "0xdd110cc", "0x5a6c31", "0xbfe3e57c", "0xe71b94cb", "0x235e4043", "0xf1014e01", "0xe3ea6bd2", "0xffcbef0b", "0xf02d5f73", "0x1fe0fcef", "0xcc331322", "0xe22de53e", "0x6c1456e4", "0xfe1a033a", "0xf911d4b", "0xe0ff3d1c", "0xdae1db44", "0x40abb2fe", "0x7013a5e3", "0x737f0f20", "0xa05d02d6", "0x3d7e3005", "0x227d37cc", "0x1f733c0f", "0x7314bc10", "0x91ee01b9", "0x5ce0ff6", "0xee17922e", "0x7311ef1b", "0x49703b0", "0x1c256de2", "0x51c31303", "0x9fd01e6", "0x7fff4517", "0x21c1ff32", "0x15dd33fc", "0x99e1e3e7", "0x247c3f5d", "0xfdd690c", "0x409fc90b", "0xcf2c5221", "0xf349cef", "0xe06de760", "0xf3a0ccde", "0xf173030c", "0xbe1e4993", "0x3750422d", "0xef01490f", "0xedf03a50", "0x310f06bc", "0x5acec06", "0xc7136c1f", "0x2d93b5c", "0xbac691ff", "0xfe271ff0", "0xed010710", "0x4de22b2", "0x20fcb51f", "0x3b2ea1f5", "0x34f00f39", "0xc4b1a162", "0xdf19f6e7", "0xa1addcf0", "0x50f0b104", "0xdec4f25a", "0x2faebcac", "0xb27eeef", "0x4fa46265", "0xffbe3206", "0x2277c104", "0xce30eb29", "0x4b23ef0", "0x13af0fd1", "0x20304a14", "0xe13e12be", "0xd1041d2f", "0x7dbe37f6", "0x1f3bde6", "0x307ee69", "0xc2eb44ff", "0xd0f21db2", "0x51f90c7d", "0x2edf139b", "0x2dc32ddb", "0xf5c0d07f", "0x4e7b30c7", "0xc4b1efa2", "0x7ddf241e", "0x1aa34329", "0xb1411d0b", "0x9a6d4b6", "0x9fb73d7e", "0xf6010e13", "0x155233c7", "0xc07e909", "0x1c2d5e1d", "0x60d94e6e", "0x617041e5", "0x11a34bb2", "0x5ced3d32", "0x22daaf0f", "0xe6f1e0d4", "0xbc365a6e", "0x2f307503", "0xe1a06f03", "0xf59ed11", "0x520d0992", "0x7dff6ffb", "0xd00aff7e", "0x1ada50c2", "0x9db09d", "0x1f50c07", "0x11d3ff0c", "0xf41fc0c", "0xaf919deb", "0x4560a9f9", "0x1340a05d", "0xbb1d4324", "0xc5c21929", "0xffb1f2f0", "0x13b5d0df", "0x30dd2c", "0xd0fb32ec", "0x742f0dfd", "0xf30dc63d", "0xdded2b0f", "0xbc0250e0", "0xc430d03", "0xdc21012", "0xf0694d3", "0xa2ec4cee", "0x31019e0b", "0xf51ba750", "0xcfd520c0", "0xbe5bed0c", "0x3053d500", "0x91d00411", "0x1f93b270", "0x1b0ddc0f", "0x4435ee22", "0xff27e3f4", "0x9ddd2090", "0xfc11e949", "0x212fea00", "0x93d723c4", "0x9f9f2022", "0x1b7023fd", "0x2d2d1cb3", "0xec31a30c", "0xda004f55", "0x2e402dcb", "0x331ee902", "0xd0f720d1", "0xaeeeb10e", "0x117b54d4", "0xf9eaff10", "0xed1160e2", "0xd341c92", "0xbccd1aed", "0x4e3cf90b", "0x3a34bf22", "0xee910dd", "0xacf3c11d", "0xaeff94cf", "0xeffefb", "0xbc45ca9f", "0x4b6273fb", "0xb64d4a00", "0x7bfd4c54", "0x2f2e4", "0xb191efe0", "0x42fa9140", "0x70195df1", "0x99f7f9ef", "0x42691b", "0xc2f5e000", "0x29ac0f06", "0xd0923270", "0xf6f1ec15", "0x7f5cb146", "0x3079f01b", "0x6e2d3adc", "0xe492215e", "0xd4e31a03", "0xdfe04d40", "0x10ff46dc", "0x7620dfe5", "0xd710fd0b", "0x15156dfa", "0x940f43f", "0xf7e1f630", "0x10bd211c", "0xaf0d010e", "0x309ee4fd", "0x5121ce94", "0x20121bfc", "0x303fdea3", "0xfbf05692", "0x5e1fe5cf", "0xe14b301", "0x6c11200f", "0x4131ef71", "0x62210e09", "0xd2e55c1b", "0xe132cfcf", "0x90afed01", "0xe44d139", "0xd1f54a0e", "0xedd7c524", "0xf0f15dc0", "0x406007ec", "0xfc53fa6d", "0xc0150ee3", "0xdbd2fe4d", "0x663b2917", "0xcecf7a01", "0x4d54bd7f", "0x9fb47ad1", "0xe0020320", "0x4f091e02", "0x2003fff3", "0x10fc6422", "0x331919c4", "0xc19e550d", "0x7e4e6a3c", "0xc1ce0b0f", "0xee55e923", "0x334e05", "0xe1cef4e1", "0xd0c93a2d", "0x2ef3f1e", "0xd3603c03", "0xde3e0cf1", "0x3c343f", "0x65614523", "0x10390c59", "0xceee110e", "0x4c9aaefa", "0xf0502347", "0x5050fbf1", "0xe11647fe", "0xa11132a4", "0xe33de9b7", "0xfc03c242", "0xa2019e1d", "0x6909c1bd", "0x9ed7025", "0x36151c0e", "0x4c751711", "0xe0e63542", "0x1afb22dc", "0x11dafbd3", "0x50d0dec", "0xc23f14db", "0x37b03f79", "0xb761c3f2", "0xe010fa14", "0x7fe99c10", "0x720b335f", "0x6c437100", "0x39936102", "0x9dd20fcc", "0xf12d10f2", "0xff309f11", "0xefc055cc", "0xa1cbe64c", "0x5c431f07", "0xcf24f5eb", "0xdc409f0d", "0x7fee12fe", "0x2ecd1235", "0x1cd62d0e", "0x4b6f41fb", "0xa0ff500b", "0xec3952cb", "0x13102d02", "0xf9f2bc0d", "0x9c247cd7", "0xe0436ac1", "0xfbdda01a", "0xf011fa2a", "0x3032d11a", "0xa2f1deb5", "0xfc13170f", "0xc31aff12", "0x9c250d00", "0xfdd423ec", "0xccaac09", "0x42d41f1", "0xa01da2c6", "0xfdbd5bf2", "0x17e6fb", "0xe1f13dd3", "0xadf40ae0", "0x1ae3bce1", "0xfd0f5c02", "0xe12ece6f", "0x10241017", "0x9df0de63", "0x95696c2", "0x9fd7f927", "0xf9303d5d", "0xfb23149f", "0x3aecc1fa", "0xf44093ee", "0x20414de9", "0xf3f5ccf4", "0xeb4391fa", "0x5e69edf2", "0x29c5ff41", "0xcd1275e1", "0x5c4a971a", "0x73419027", "0x91a93717", "0xdd6f154", "0xd3a012f", "0xe359c23f", "0x3fe19a3e", "0xd9242ee2", "0x900cf01", "0x79e39ea7", "0x6fc0ef47", "0xecf30d73", "0x9952af1c", "0xc041da0a", "0x3b05e6b6", "0x1e32e3d1", "0x11a41ffb", "0x4f3ac124", "0xbf1d1dea", "0x49335e24", "0xe30eadd5", "0x2c21ceba", "0x26c73690", "0xede55f15", "0x42edf91d", "0x742fe1e4", "0x913cd204", "0x5ddb5d22", "0xc3ebeb61", "0xd45350ec", "0x2ae4ffef", "0x3b02a402", "0x4e1fee05", "0xff2fefd2", "0xefdc31e1", "0x92feceff", "0xd60e9b0c", "0xeb14ea32", "0x7776017a", "0x310152d2", "0xe15e1f02", "0xe9f1c9fe", "0xb1b3709f", "0xf7c6e011", "0x1feca29", "0xbcffe33a", "0x6927cd71", "0xe24e0f97", "0x5f5ed2fe", "0x5e2f3351", "0x1e0efb3", "0xfc9f1bf5", "0x25d6f590", "0xd13203b4", "0xea2e0e5e", "0xed2bf056", "0xcd9bef1e", "0xf252ea6d", "0x21a79f53", "0xd1d11b7c", "0xbb74f1d3", "0x9e0d1e01", "0xb2421d09", "0xd45f9403", "0xf051c402", "0xeb51d031", "0xa1c01410", "0x3fde0214", "0x1011c13b", "0xf970a20c", "0x31e2d923", "0xa13ea126", "0x4042b314", "0x1f32e7e4", "0xb2edc09c", "0x1d2ee430", "0x3f936310", "0xd9c995af", "0xc0f92451", "0xcc005ef2", "0xe2fd2e0f", "0x3e72c307", "0x41339d1d", "0x7b514d19", "0xadee1eaf", "0xfb201f1c", "0x9323114b", "0x2fb19d10", "0xd1aff1d", "0xce3100b1", "0x20faf1fa", "0x1efe04f", "0x9a2e90db", "0xf964e0d0", "0xaec3bf52", "0xbab09211", "0xbd02b000", "0xd25db2c0", "0xc2f5309c", "0x50cdf0d0", "0xaaa1c3ee", "0x4de3b3cf", "0xdaf91d22", "0xbdc2dc02", "0x990c701c", "0x1e7ec11c", "0x910f50ea", "0xeffde2cb", "0x1a2dfbed", "0x5a26cf19", "0x9fca24bd", "0x4473dbfa", "0x3d4fef3", "0x2ab9f903", "0x90b3259c", "0x25aeff40", "0xfb0e0fa3", "0xe306bcf6", "0xadead4c6", "0x177e6fc2", "0xf2c30cf2", "0x192dcd4c", "0x9f0565a9", "0x3f3d47f2", "0xde61c1f1", "0xc7232df0", "0xeacb9bd0", "0x67eff19", "0xac173e01", "0xebbe29f4", "0xbf002049", "0x4c737335", "0xee74302a", "0xd5553223", "0xf2966f3f", "0x3f11fcaf", "0x53d4d902", "0x61ed3b01", "0xe0bb6a9d", "0xa22c1e4f", "0xafd0cd0f", "0x1f7210d0", "0xd092a363", "0x3d6be9d6", "0xd11b1a0f", "0x435fcb1", "0xf14469a3", "0xe4fd2706", "0x16aff906", "0x2262e32c", "0xe6e4ed31", "0xd01a1e01", "0xe3c25f01", "0xded4d9c0", "0xf45e35", "0x10fb6300", "0x1d0cefd0", "0x94ea201e", "0xce94bf23", "0x41fc3f2e", "0x1d5eda01", "0xa2ce5a32", "0x30be4a03", "0xe0130d43", "0x39dafd2e", "0x2fffd20c", "0xc1e43d4f", "0x2cecd11", "0x96392f0a", "0xdff2fd0c", "0x10c4fa52", "0x93fe11ff", "0xd10a2341", "0xb7ca2d1", "0x12272f6d", "0xdf090031", "0xc7ffef00", "0x34e5bc20", "0xd1b07ee3", "0x96f9323c", "0xe11b3f40", "0xe17db34e", "0x1651de90", "0xf9e2e0b", "0x6792ce00", "0xa00f30df", "0x209093b3", "0x52fccb1d", "0x30125162", "0xacc041c4", "0xf436002f", "0xb941afdf", "0x93f32bf6", "0x3e332ed", "0x71b2cd3f", "0x3f5f9cef", "0xf1de9d15", "0x23e14120", "0x1d04e41d", "0xd0b20e2d", "0x5932e001", "0xefb06e31", "0x141fca4", "0x359bccbd", "0x6ebe7362", "0xa7e0ac60", "0x67fe94", "0x925345f", "0x33d2fa01", "0x10fb623f", "0xaf71f42e", "0x224f2d0f", "0x24a59243", "0x4411f2da", "0xc1e733b3", "0x2923bf49", "0x11ace007", "0x51c29062", "0xa031e146", "0x3fafbd93", "0xd1469fdf", "0x2ef1f49c", "0xf127130c", "0x4b40d3a", "0xa66ce2f0", "0xd09d5f13", "0xfdfdee4", "0x41eef9a1", "0x7e232ff2", "0x5444cd2f", "0xfd012c94", "0xdef50b1d", "0x1cd4e00f", "0x12e601ec", "0xa01dfd60", "0x49d4222b", "0x733ed7f", "0x616450fc", "0x210022a1", "0xde319bd3", "0x1cdfff00", "0x109e3fcf", "0x10d03d7b", "0xe0e9a46d", "0xb3d6103d", "0x300151ed", "0x3eb923a7", "0x35259e10", "0xbe2b1504", "0xf2a2bc4e", "0x1f015a54", "0xae2b0c2e", "0x72b1cb19", "0xe7f111e2"}};



const ap_int<12> conv_5_inc[2][32] = {
{"0x218", "0x213", "0x2df", "0x1ad", "0x31b", "0x1b5", "0x221", "0x224", "0x21c", "0x2b8", "0x292", "0x31e", "0x224", "0x356", "0x248", "0x265", "0x233", "0x19d", "0x26d", "0x33e", "0x2a1", "0x285", "0x207", "0x2e5", "0x316", "0x1c6", "0x9e", "0x241", "0x22b", "0x254", "0x2f7", "0x213"},
{"0x22f", "0x29a", "0x2d4", "0x1b6", "0x2be", "0x1f2", "0x31b", "0x236", "0x269", "0x2bc", "0x25e", "0x1d1", "0x1e1", "0x2c1", "0x272", "0x325", "0x4f7", "0x20d", "0x22f", "0x20b", "0x2cb", "0x220", "0x302", "-0x25", "0x1fd", "0x2d3", "0x260", "0x33a", "0x253", "0x28d", "0x32d", "0x24e"}};



const ap_int<21> conv_5_bias[2][32] = {
{"-0x2b8fe", "-0x257f8", "0x43aa4", "0x2d8be", "-0x8cc6", "-0x3a4c", "0x19cf5", "0x4c996", "-0x1e362", "0x24dc9", "0x4bc96", "0x20c04", "-0x9b33", "0x74995", "-0xd6d9", "0x14ec6", "-0x414f4", "0x846df", "-0x63742", "-0x9e7", "0x4528a", "0x3687d", "-0x7ba0", "0x7594", "-0xe25e", "0x35825", "-0xadc0", "0x15ae4", "-0xa60e", "-0x38fd2", "0x3b25b", "0xed46"},
{"-0xad4f", "-0x16042", "0x75c65", "0x201a5", "-0x4e542", "0x44060", "0x3fba1", "0x56bbb", "0x2bdfa", "0x5be0c", "0x9f87", "0x2b6b4", "0x3d028", "0x3c65c", "-0x2674b", "-0x336c9", "0x14288", "0x5fa9c", "0x11baa", "0x8546c", "0x228f4", "0x196a", "0x3e7f9", "-0x256e", "0x126d6", "-0x11635", "0x205fd", "-0x6460e", "0xac9c4", "0x87fc8", "0x34e7", "-0x8c64"}};



const ap_uint<32> conv_6_w[2][2304] = {
{"0x25e5fe01", "0xe2141301", "0xd4552cc9", "0xd009c32f", "0x22e0d50", "0xff0e19d", "0x145120e0", "0xf04b50be", "0xf070afef", "0xbff6eef0", "0x13f12f0c", "0xbd2a112f", "0xcbf5fd2f", "0xfde1fbed", "0xf35fc3df", "0xe31c021", "0xd1101d3c", "0x1ff5aadf", "0x2e4332b1", "0xdf0f0f62", "0x1b133f5", "0x205f1fe", "0x3520a222", "0x4f0b23cb", "0x1d51bfe2", "0xfe0322f0", "0xe5bad2e2", "0x9e43a424", "0x7e11b375", "0x102930f3", "0xe340bfe0", "0x120e643e", "0x2b6dd3dc", "0x1ef7e91b", "0x341e3651", "0xd544ff19", "0xff23d76f", "0x14690f3f", "0x1f1fd4dc", "0x2441057e", "0xdf0ee91c", "0xef55df64", "0x436b2e06", "0xde3efd20", "0x41bfe703", "0xe7dd010", "0xe31f32e5", "0x7edd750e", "0x7b60f052", "0x4c145c4f", "0x91fad0f0", "0x1a302f10", "0x33ffaed5", "0x550190d", "0xfef0efc1", "0xe51f336f", "0x3f7e2a71", "0x4bee4933", "0x9a110f7c", "0xc046f29", "0x124c91da", "0xdb052", "0xdc10bccd", "0x3e4c052f", "0x2019fd2a", "0x11f0ee21", "0xa4a51d0d", "0x1ae24e19", "0xec0fdadc", "0xe4bf5d1", "0x42cfff10", "0x9102502", "0x4ec05334", "0x3fc74701", "0x31f4115", "0x561242ff", "0x12464ec1", "0xf25d0531", "0x3d2143c0", "0xa4e332ef", "0xed15e123", "0xbf94cafc", "0x37103", "0xeadf5f6", "0xd2070922", "0xff3fcf33", "0x3621c97c", "0x522271ef", "0x5353ffb2", "0x172257f", "0xd2f4b032", "0x64e32f2a", "0xf0c466d0", "0xf2651ff1", "0x1190d495", "0x1ce07d2f", "0x2ff2212d", "0x2fe319fe", "0x75f201b0", "0x47b05ca4", "0xc10151c2", "0x573f100", "0xe0f00f21", "0x5d916f0d", "0x7e0ee6e1", "0xc1035642", "0x553e6f09", "0xbb60727", "0x1143271e", "0x117ef0b3", "0xe4c02d71", "0x3f957d64", "0x7d72fa95", "0x22fbb53", "0x9ef49e00", "0x2ef20719", "0x90eefade", "0x1265f2ff", "0x30b0a690", "0xad92622f", "0x1e9220c3", "0x3e2132fe", "0xa7b313e0", "0x4ff06e0f", "0x204ef005", "0x1755ccf", "0x9c012013", "0x6bbf710f", "0x11d030cf", "0xd0216531", "0x42dc21dd", "0x1c165020", "0xefd11c31", "0x27dfacb", "0xd1b11fd1", "0x1aaf2132", "0xa63ad2e7", "0x12192d", "0xe030d204", "0xe2e1fd6e", "0xe3ccfec", "0x3f1cdef", "0xefe0cf2d", "0x1e0a6edf", "0x1003e4a", "0xbccdaed4", "0xf04f3f14", "0x42e73740", "0xc072a00c", "0xe5ae6bd", "0xcff05ad0", "0x37d0b1f2", "0xd9e255c9", "0xd000e0ce", "0x5b1b22ca", "0xe7f7f7c2", "0xff300b71", "0x22d120f", "0x112fe97c", "0xbae0713c", "0xee1210d", "0xefc44ff1", "0xffce9ded", "0xce1127f4", "0xdecd4324", "0x3341101", "0xd1105460", "0x61a021f0", "0x27f9e526", "0x62ffbcd", "0xe12efe6", "0x302424ac", "0x2fd025c", "0xbc9dde3", "0x67007b2", "0x105b3fe", "0x17fee7e5", "0x35c0ca16", "0xaae45fdd", "0x40d4504", "0xc93f12ce", "0xdefbd11", "0x21a0f97d", "0xd6d75030", "0xbc3011a5", "0x2f42b910", "0x10ccb1af", "0xd1e2e479", "0xe9be09f6", "0x93d2e5e", "0xa0d1f113", "0xf2d20ec0", "0x31ff71b6", "0x13f43eed", "0xd22ed050", "0xfd4ddc40", "0x13d2fd12", "0xfa1a131f", "0xfbe1d0b3", "0x4f4c2521", "0xf1c42f6b", "0xf115411e", "0xbdfd231c", "0x5d6edef4", "0xddf1f46b", "0xe2bf3ef", "0x5040cb2e", "0xff6325e0", "0xef210f32", "0x6113fc30", "0x5ffec20c", "0x5c6c9ca1", "0xda0b0940", "0xf94d21cf", "0x557f25de", "0xd00f22d0", "0x110000f", "0x0", "0x10001", "0xff1f111", "0xf00f001f", "0xf100f000", "0xf01fff", "0x1f100000", "0x101ff010", "0xf0001f1f", "0x100", "0xf10ff0", "0xf011f10", "0xf0000", "0xf1fff000", "0x10f01001", "0xf001", "0x110f1ff0", "0x1f0100ff", "0xf11f01", "0xf00100f0", "0xf00", "0x1100000", "0x1f1f00f", "0x0", "0xff00110f", "0xff1f110f", "0xf10f101", "0xf0f00", "0x1f00010", "0xf00f1", "0xff0f0000", "0x100f00f1", "0x1f00f01", "0x10011f00", "0x101ff01", "0xfff00011", "0x1f01f", "0x1101110", "0xf00001", "0xf001ff01", "0xf01f0f10", "0xf1f00f0f", "0xf11f010", "0x1f1000", "0x1010", "0x11f01f01", "0x110f000", "0xf1f00fff", "0xf0001000", "0xf010000f", "0x1f00", "0xf0010f11", "0xff0f11f0", "0x10f00000", "0x10", "0xff0000ff", "0x1f01000", "0xf000f00", "0x0", "0x10000fff", "0x10f000", "0xf0f00110", "0xf1f0f11f", "0xf101010f", "0x1100f0", "0xf10", "0xff0000f", "0xf00000", "0xf0001ff", "0x1f0", "0x11f0ff10", "0xb96e1f0f", "0xd002fbff", "0x43eea344", "0xc41e9ee2", "0x43cd24ef", "0x1ea4ea5", "0xb2f12df0", "0xc91324e", "0xf032c4f1", "0x1b5df0d", "0x2dded313", "0xb405bedf", "0xe01e4109", "0xeb3dfac", "0x12dff00f", "0x22c3c3ff", "0xf17ed2fe", "0xf3e9011f", "0x3e11", "0xd2cfd2cd", "0xf0f2ef0e", "0x1c63092", "0xaf0040fb", "0xff1cfe0c", "0xb90efc72", "0x10112baf", "0xd09c3ad3", "0x2fa1caed", "0xd4e40eff", "0x1ad931fd", "0xb0f10042", "0xd2e243b9", "0xbfef02b", "0x54160fff", "0xcfff2363", "0xf336d94c", "0x41e6d2cd", "0xdfdc0f2", "0xdf200e21", "0xf4ffd14d", "0x35ee32e", "0x3c0013", "0x9d3d721f", "0x70c0ec1e", "0x31d0ce41", "0x1fe3e6cf", "0x90410ea9", "0xfa414ec3", "0xa1506b1e", "0xff4e2d4d", "0x66efe3d1", "0x2b2a1a3f", "0x221c0c4f", "0x1cee0615", "0x9e2fedf6", "0xf1324c0", "0xc020e0df", "0x33d6c0c", "0x40dedf2f", "0x301efa1e", "0xf110fd21", "0xdd20fb0", "0xb0c1d2c2", "0x2f2cb0bc", "0xd370ffab", "0x13027d4f", "0xc4ed10de", "0xee1e1e2f", "0x11ffec0f", "0x16e23e10", "0xbef01dfb", "0xea452205", "0x1e2afebf", "0x43421fff", "0xdd49e129", "0x3d1d2402", "0x6ffbe9f2", "0xfd9bcf20", "0xf410f102", "0x195d92ee", "0xf10c0b9d", "0x37a40bec", "0x900f00da", "0xca3cf51e", "0x1d7baf0", "0x1f92cff0", "0xf75092e0", "0x797db31b", "0x2c1d09ce", "0x55021920", "0x9ee5dd0e", "0xea5a32e0", "0x11c2d2f2", "0xf116103e", "0x6fd2df", "0x197d9e0a", "0x2d334f00", "0x51e52316", "0x4e41205c", "0xfe7cf035", "0x2452f01", "0xf4d12d0a", "0x4700f320", "0xd12e25e1", "0x4f14e313", "0x4d464fe7", "0x6051712a", "0xf71e63d5", "0x2103f306", "0x7cf22d", "0x5070e34d", "0xb70c5eb5", "0x5f234f54", "0x6b12f624", "0x6f3f7f44", "0x170fdd41", "0x32e2d027", "0x107a0131", "0x4e00201f", "0x6ff0cb0", "0x2dd5e230", "0x4013fff1", "0x61314fed", "0x5f0f21f", "0x1fc2d20b", "0xff11e3f3", "0xf3022fe", "0xf1ff5cd5", "0x4d1e0221", "0x1115e131", "0x64d132d3", "0x5ccf341", "0x30d0dee2", "0xf02203e4", "0x201f2b", "0x4422df2f", "0x3002f350", "0x2d2f2174", "0x240e7e04", "0x3ee00321", "0xc0e21f11", "0xf42dd300", "0x4ccf1f4e", "0x2373fc0", "0x3b26441e", "0xfefd340d", "0x4c4f2cb", "0xf305d912", "0xfc3ccfbf", "0x12ea0eea", "0xf130b0e2", "0x9eb14000", "0x39241c10", "0xfd91e05", "0xc4134f01", "0x2e15cb13", "0xf34dd0b7", "0xf95dccf", "0xc43047df", "0x3fe55fd4", "0x4efdcf51", "0xdcfed0f1", "0x23efa020", "0x2514cedf", "0x20f3d13b", "0xf11d42cd", "0x10f1ee0", "0x31a051d2", "0x57542fe3", "0xef2f02e1", "0xf6d2521d", "0xd4e20b60", "0xef06c70", "0x10c3e7ec", "0x20f2ecf", "0xf1f17a1f", "0xf2137d6", "0x1300410f", "0xa3ee1f02", "0xb0dcc130", "0xe210e014", "0x10356a2", "0xdfe00edf", "0xf5d57f5b", "0x2e61511d", "0x12111ce0", "0x134dbc2d", "0xc5eee224", "0xe121f035", "0x2394ebf", "0x13efef11", "0x7ffe70b1", "0x324b2f1c", "0xf03d60e", "0xe4021172", "0x42030d1c", "0x14032273", "0x13f10f1", "0xd220140e", "0x12bc3f4e", "0xa3bf660", "0xdf3e0e4b", "0xf2d3dc07", "0x5f16120f", "0xe3e00e75", "0xfdef2211", "0xad2f02c2", "0xf1932d40", "0x2231142d", "0x2f20a23", "0x720ef40c", "0xf2e50001", "0xffeade72", "0xefffe3c", "0xefe16d0d", "0x7fe0db1b", "0xd33027d1", "0x40ee1f12", "0x56535df2", "0xa1cf049", "0xe232f216", "0x1ffdfb", "0x9bc15e06", "0x4fd1d334", "0x1451d11f", "0x96512333", "0x2eed1105", "0xd70f309b", "0xe15e342e", "0xf0c1d024", "0xc0e101e1", "0xc142cd31", "0xb4e2de22", "0x120e4366", "0x7e1b756f", "0x14cf261d", "0x1f5ab411", "0xeb0dff2", "0xedf02c0e", "0x2dedd0e1", "0xe21b4310", "0x3314f10d", "0xe610de50", "0xd1fa0e9", "0xf2b0d11", "0x13eeddf0", "0xfc20400e", "0xfae9ff3", "0xbf235221", "0x21000dde", "0x2ff5ee41", "0xd1ddf1ee", "0xc34fd412", "0x14e425c3", "0x92d0f50d", "0xfe900f92", "0x2feeb1d6", "0x4d1e565b", "0x1ed037e3", "0xd6e0d111", "0xf209142e", "0x1ab1b3e", "0xcff0fdaf", "0xeef1c123", "0xf222d16d", "0x22a2fd1e", "0xcf152754", "0x201c6a4e", "0x1aef0f55", "0xfe914ad2", "0xe9e0e303", "0xf313f3e2", "0xf40a1b3e", "0xcc04010f", "0x2c019feb", "0x23b30f1d", "0x1d00f06d", "0xeff45e2", "0xb9f0ff32", "0xbdf125de", "0x113dd003", "0x1f304fda", "0xfd22f000", "0xe4bfb212", "0xf0ba1e1", "0x110f4335", "0x9bbfbe0d", "0xef0c32f0", "0xd7e2eee4", "0xeefffe52", "0xc3f10bda", "0xebd22f01", "0x1093920d", "0xddbd0ff", "0xff000a02", "0xfe5fcf43", "0x2d205d4", "0x1bedbf03", "0xd3ebe2b4", "0x1d023501", "0xd4cecd11", "0xf1c522d2", "0x1100edee", "0xee20254b", "0x22bc0bae", "0x2b0c0e2e", "0x35ceea00", "0x2110612f", "0xc4e5ef67", "0x3151212", "0xc5200b90", "0xee6ef003", "0xf02d31fb", "0x5ec309b0", "0xf10a000f", "0xde40634", "0x51f1ce31", "0xdf217c", "0x7040e652", "0xfb2f551b", "0xef5e0f9c", "0x3f549f3", "0xd323111e", "0xb04f742e", "0x204336d5", "0x9f2d0c0", "0x4f301e5d", "0xa90b754a", "0x2e00fa9d", "0x7325fe40", "0x62417222", "0xd7122f2f", "0xf54fd311", "0xf531c1f2", "0xb990f04f", "0xcc09fcc0", "0x32f2b2c5", "0x779016f5", "0xd403129", "0xc2526d13", "0xb6f30bcd", "0x10e10ed0", "0x4fc1f4b9", "0xd4b76a0", "0x127400b1", "0x7b3136d4", "0x2cfd20d9", "0xa73f4f62", "0x12b0b0a2", "0x13ceb03", "0xdd0eaeb", "0x32fb5494", "0x40754b1e", "0x7c091037", "0xed9f7c59", "0x1af2f220", "0xf5e0a09b", "0xe7abd23", "0x52d1ed2e", "0x2fee6193", "0x96c9fce4", "0xd9010fe9", "0xf1724a0f", "0x2c49e4ef", "0xfc9bbc6f", "0xfb5f5f4", "0x3450515e", "0x622146c", "0x94ef0302", "0xd5d4fe9d", "0xee010cf1", "0xe93ab6f2", "0xeed5930c", "0xfdb0ee11", "0xe4016d49", "0x6231cded", "0xff0fec45", "0x7a70c94", "0xf3052c2f", "0x136046ee", "0x330b33ee", "0xf26d2963", "0xc01f0069", "0x32fdff0", "0xd5a93c90", "0xd640034b", "0x3cb2f1a7", "0xef6fc1e6", "0x7ce15d2c", "0x4b20dd2", "0x15c001f6", "0xd01f737b", "0xf3b06f04", "0xce115c02", "0x110323", "0xd0266502", "0xd433d4d4", "0xfd32dd3", "0xf1b0242f", "0x30ecbb10", "0x6e140145", "0x375701ef", "0xc21421f", "0xf137f7df", "0xd5e11432", "0x17c0c45", "0xee2f0360", "0x36b4e9d9", "0x61c91bc1", "0x5e261154", "0x3c71f1ec", "0xfcf91f40", "0x3f7ef423", "0x120f1fb9", "0xd1114ef0", "0xc1e21c1", "0x3e3ff1c3", "0x41c1c323", "0x426043e", "0xbd1602d", "0x1fe5a013", "0xf3feab2", "0x32e0fb00", "0x5600e332", "0x70230724", "0x571ed51a", "0xc413632b", "0x427fd4fb", "0x47c09ed2", "0xf12f0e3f", "0x15d0fc6d", "0x4e61fee", "0xda14dccf", "0x52f5b2ed", "0x410f4f1f", "0x1d2e16e4", "0xfcd03032", "0x7adfb1", "0xef0f5e5c", "0x1fe3fcf", "0x26ed3792", "0xd13e7430", "0x10019e2f", "0xd2ef020e", "0x1f99dd0e", "0xe077bcf", "0xdb00d595", "0xa453932b", "0xce1c2b23", "0x2d9260ef", "0x4f0fe3e1", "0x9ffc022b", "0x30bce300", "0x1a99e92d", "0x102f0300", "0xde34afd2", "0x1033f41e", "0xf1c22cf", "0xada2e1d6", "0x3ad63114", "0xf4ff30b", "0x220e6ed", "0x2ba02d51", "0x2310bc75", "0xf61ed5a5", "0x133d49f3", "0xa0029020", "0x37a41539", "0x21e3033f", "0xf0f36ce0", "0xd12fb790", "0x9012a0db", "0xc9ff1e0c", "0xb4de75d0", "0x5ee5b301", "0x65961f12", "0x442e772c", "0xdb9ace1", "0x11201d60", "0x32e69a04", "0x11df23da", "0xdee0fa21", "0x7bf3a1a4", "0x2f0dfcc0", "0x34edeeee", "0xdb04cf0", "0x7f201100", "0x331ed356", "0xde1edffe", "0xcfd2eaf3", "0x6afc9eef", "0xd03010fe", "0xd23ce53d", "0xfce9b40", "0xc1110de", "0x901de0fe", "0x2edecbcf", "0x9f14fbde", "0x19d49bf1", "0xed00e3e0", "0x4e3a3ffc", "0x3d03c12", "0x134f40ef", "0x3ee2c07e", "0xa1bf53e4", "0x31d2dd0a", "0x20dc3fdd", "0x531c9dfe", "0xf23d97", "0x1d0b9e31", "0x67406f0c", "0x9174e106", "0x3e26bff6", "0xfce213bd", "0x60ee00d2", "0xdd39976f", "0x5b4eef94", "0xf2cac14e", "0x3ec094a9", "0xf352fd67", "0x1fc70bde", "0x1f07f331", "0xec0c0591", "0xf0cec3b", "0xf154a9", "0x4f1e710", "0x2b009ebf", "0x265bdc12", "0xe5ce521d", "0xd2e20dfb", "0x62c02101", "0x450eafc3", "0xfbd4f9a1", "0xf31a2c2e", "0xd740eb3a", "0xb6d2ff0f", "0x1ca2f6e3", "0x91f2ff20", "0x515c3a22", "0xe1c5f6f6", "0x1a0b9393", "0xda52092", "0xc0c194fb", "0xb4b03a6f", "0xfe013d02", "0x9f3491e5", "0xf144dee1", "0xe0e2ff29", "0x4be76a99", "0xfd9e2764", "0x1ff0ad1e", "0xe70f11da", "0x1a070b3", "0x143afe0a", "0x71d97fc", "0x3293f755", "0x540140bf", "0x43aca41", "0x91b1106c", "0x1a41b0ec", "0x709a439d", "0x2213e1db", "0x44deff1", "0x10d7424e", "0x3ea47205", "0xff0d21b2", "0x94100d06", "0xe311e01d", "0xb91f399d", "0xb103cd4", "0x1feca4ff", "0xe2dffa2f", "0xe2a22b3c", "0x5dc2eb7", "0xdb0f0cd3", "0x17062bf2", "0xeff3f209", "0xcde1dddf", "0x5142a40a", "0x33bce9de", "0x2099a0cc", "0xf31de0f1", "0x9d007de3", "0xddd3c921", "0x2bd1440b", "0xa31bee9", "0x522b0bde", "0x65c9f2f1", "0x1efdf9e0", "0xf3201203", "0xd2ffe014", "0x3023ce1a", "0x1354ec1f", "0xe132e2a", "0x44e39c91", "0x6239dabc", "0xfdb926e2", "0x1d91c315", "0xfe3f6c1c", "0xe03aa12", "0xa5be2dfd", "0xe1ffc3c", "0xf0d4ee3b", "0x349df9ff", "0x51204fc4", "0x4d3bf41", "0xab70703e", "0xbc4f9102", "0x1cbff7fc", "0xea1311fc", "0x1f02de19", "0x54f6a272", "0x6cfd3790", "0x6271e1", "0x69f04b12", "0x92cec04d", "0xfcb3beae", "0x3d230ff", "0x5651fa19", "0x51e11b62", "0x9210f97", "0xd51712f", "0xe9c13cde", "0x594bfa5", "0xafefdfaf", "0xff003101", "0x7015a022", "0x4fe21fc0", "0x27efbc1f", "0x11d60043", "0x402129a1", "0x23d6cef3", "0xd1222f4b", "0xfefeff09", "0x75d0c2d1", "0x33a4944e", "0x315e57be", "0xfe532f1", "0xc0f13d0", "0x694da1f", "0x9911cb0c", "0xb41ddcd9", "0x23f9dfe2", "0x6502090c", "0x61442cc0", "0xbb4f59f", "0x9df1419d", "0xae910917", "0x6ddeb4aa", "0xf9f1e5ae", "0xce33b041", "0xb9ca50cb", "0xadcdf2ee", "0xf2f29fbe", "0x972011d3", "0xb0fe400", "0xff7c301a", "0x2de010e0", "0xdfd2c363", "0x921c0bdf", "0xc0dd60e0", "0x104a0f1", "0x930104e7", "0xe1a2434a", "0x113d4799", "0x70033e01", "0x4bd2e571", "0xa1bf49be", "0xa0bde435", "0x1b1ef0d", "0xe5f025e0", "0xec940ffb", "0xee1ed2e9", "0xaeefe52e", "0x30e3bd40", "0x1c919cd", "0x99e00de1", "0x5fe2f", "0x171ffcd9", "0xdd10d70d", "0xdf7112d9", "0x4e1d03e3", "0x5aff9f70", "0xc3dec962", "0x1902cf02", "0xe50b1f", "0x94211c06", "0xc22ac73a", "0xd06ec20b", "0x340d1e24", "0x6baffb71", "0xd11cea11", "0xdb00bd2d", "0x1db30c59", "0xce10001f", "0xe4cda4d9", "0xef15f3e9", "0xff2af375", "0xbc10ecc2", "0x4feaea1d", "0x99c34ed4", "0x13cfa01f", "0xc4e00ce9", "0xdd1ef6d9", "0x47729c09", "0x46eefee6", "0x29cc9f3f", "0x32a9ea2d", "0x19c4023f", "0x2b40e54", "0x95506c22", "0xb37907bd", "0x1754cd91", "0x7111e0c7", "0x49ec9dff", "0x44e90e61", "0xd0c1b401", "0xf94efed", "0x911f5140", "0xd379b6c9", "0xa34cfffe", "0x1dc614c9", "0xdc1af40d", "0x9ad02410", "0xf4f9bc0f", "0x9c25cc2", "0x120c4d2", "0x4d0bae0e", "0x12e9d053", "0x7e36ce", "0x4d5f9fee", "0xf72ef4bf", "0xc0cae23c", "0x19ee501d", "0xe01f61e1", "0x11b3a322", "0x712d5d95", "0x93e9f0c1", "0x90ffb2df", "0x19f32f04", "0x2faafe2e", "0x199312ed", "0xd29119a3", "0x3e119145", "0x151fdfbf", "0x2aec70e1", "0xe2e99521", "0xe2b6a37e", "0x27bbc20a", "0xed91ce1", "0xa0afc3d1", "0xdc41b34a", "0xc4f32ed9", "0x1f0ff0ef", "0x2330025", "0x17e1f3d7", "0x43212f70", "0xc9d0bfd", "0xc70f1d20", "0xe421ba31", "0x34e01f51", "0x641efe", "0x1f4bbe2c", "0xe25c219a", "0x3d1ce37e", "0xed317dc", "0xe2706020", "0x97b391d2", "0xdc0ae0c", "0x2cf4fe20", "0x606cac1e", "0x1220f011", "0x4449e111", "0xfd019e02", "0x9cd04933", "0x9f3ce15c", "0xb5af61a2", "0xb001defe", "0x26cdd13a", "0x59c3201d", "0x330fdbdd", "0x6cd3acf", "0xce1034e4", "0x35d1de0d", "0xffef2d50", "0xa00342f0", "0xa6f790d1", "0x45f2fb6d", "0xe1140cdf", "0x4ad36d2", "0x1e3043ef", "0x12d2ff43", "0xd70c02a0", "0x675996ef", "0x91ee76b3", "0xc253e394", "0xd0279291", "0x4c1494a", "0x1ae0d113", "0x107131dd", "0x42ee2e21", "0x41c3e6dc", "0x621016b5", "0x34711ff", "0xd105d325", "0x1132c1c", "0xfd003027", "0x21047fe6", "0xf41a2510", "0xdedebd3e", "0xe4d312df", "0x3ed1fff5", "0x1f1a6132", "0x1f132a31", "0xffe13327", "0xc50760e4", "0xd6d0d073", "0x72fecfcd", "0xc1a44301", "0xccd970cc", "0xd1f0a5d4", "0x3135e70", "0xe30f3c2", "0xe24753b3", "0x53e52c7f", "0x422102dc", "0xd3b3e6c6", "0x45f56df1", "0x15216e42", "0x1a7fff3b", "0x41d04f2f", "0xf2e77cf1", "0xe6d34200", "0xaea31c1f", "0x450cc510", "0xecbedd1", "0xc12b5f56", "0xb501f60", "0xfe210022", "0x1052ec5", "0xce95dd25", "0x6fd0d12c", "0x24a175d4", "0x56e2061a", "0x35f30103", "0x70f0b51", "0xe9702e22", "0xb636e1ec", "0xd7c3fb1f", "0xdef4ffdd", "0x6f0471c", "0x7307003c", "0x3463f14f", "0x7df1427", "0xf401dad", "0x5b27c40e", "0xc490f99e", "0xa2fe193c", "0xf03edcf2", "0x4f962eee", "0xf4531cd2", "0xeb1f0ef", "0xb0bfd4b2", "0xfff1502", "0x12c051f7", "0x34d0c367", "0xee1211d3", "0x5b752ffe", "0xf0011e1e", "0xdd421fb", "0xfee0d0f1", "0x2e332d24", "0xecc204f5", "0xd0e01641", "0x920c21d4", "0x2f56fb22", "0xdb249d13", "0x1e5dbed1", "0x300003fc", "0x1015d2d5", "0x26152216", "0xe133e56c", "0x10e7df4", "0x643c402", "0x4f232412", "0xd311f21", "0x2ef2c10", "0x35402337", "0x4df22f6", "0x52f11132", "0x1e306e0", "0xe3103df", "0x53d13145", "0xfc3133cd", "0x1f14312", "0x11435c10", "0xd1f23205", "0xc2104110", "0xc0d00111", "0xb3e100e", "0x1ff23036", "0x1e2feae1", "0x50f2301", "0xdf6134f1", "0x17f12105", "0xf451e40d", "0xf3d04013", "0x3242f7f1", "0x3f1174f2", "0x3d121", "0xf220e211", "0x326577b3", "0xbd921f42", "0xfef10320", "0x30ef1240", "0x50024dd0", "0x4a21d34", "0x113f1600", "0x3c3f6fe0", "0x2336592d", "0xdef13144", "0xa36fc5ff", "0x4eae2e21", "0x3b1049ab", "0xb2d2cb11", "0x15fda4f", "0x1120d01c", "0x1112ef00", "0xf20f4035", "0xc210e33e", "0x7fdd41f1", "0x22ece4e0", "0x13244260", "0x152f4ef2", "0x3f2fcd41", "0x22e76503", "0xe02fe201", "0xf0de5bd1", "0xd045bd4b", "0xa3d1fbf0", "0xf4e7eea", "0xf1d1e033", "0xd10022df", "0x2effff1f", "0x1f41d0e4", "0x130c50e1", "0x331ec00e", "0xa3dfdfef", "0xd1d0fea", "0x1c1dc10", "0xeff030aa", "0xfd2bf20a", "0x420f3e4", "0xfdee2aff", "0x3113ef4e", "0xd5d1d31e", "0xcf1ea2fa", "0xffce00f1", "0xade0e69d", "0xe31cd2b", "0xcd12fe22", "0xfcfc02ae", "0x4d052", "0x1d0fc10", "0xfc1f530d", "0xce5cf2d", "0xee20c02f", "0xf0f110f1", "0x1feffe12", "0xe1d02ef", "0x1011cfc2", "0xe2dfce30", "0x3d2fe04c", "0xff13e00d", "0xfe40de0e", "0xe2fffec", "0x115102e3", "0xf01deeff", "0x2c10cd1f", "0xf0d0ff5f", "0xed1fbfcf", "0xdf21eae", "0xc001d3f1", "0xc4fed1c", "0xf07ef20f", "0x3e1d22a0", "0xe4c1b054", "0xe1ff29c1", "0x201b30eb", "0xcd2100c", "0xc200e01d", "0xffff1bfd", "0xf1ef200", "0x2f2df3c1", "0xffd3d0f0", "0xd00e1a1f", "0x304ce0bb", "0xee1211d", "0xa11ff000", "0xfe1a1e1e", "0xf12002f1", "0xf10d01d3", "0xc1e0ef2c", "0x22efd42", "0xfe2f00bb", "0xfee114e2", "0xb3e106ef", "0xff5b2df5", "0xae139e71", "0x3d3efff7", "0xd2904c1e", "0xd37ff00", "0x30bf309", "0x27e5b33", "0xd3211bf1", "0x43d37100", "0x1b2ff044", "0xe0500c03", "0x21c11006", "0xe0d70b1c", "0x2220f2e", "0x44fffe2", "0x2ed13c16", "0x53146222", "0x201017be", "0xd4e4163e", "0x20034ff2", "0xf0e30e3e", "0xb0e71e0d", "0xf21e4003", "0xb3001c62", "0xdd7ff310", "0x47f93e9d", "0x45bcb25a", "0x9c6cc1c4", "0x1e27f1af", "0x2e7e5bd9", "0xff9eb9d0", "0xc70fe09f", "0x2960c563", "0x40692c99", "0x35a9ea20", "0x9205df20", "0xd96741ba", "0x225039fa", "0xe95bbe0", "0x7d0f1ed", "0xe95ddc40", "0x222eddfc", "0x30ac1cf3", "0xef04b2fe", "0xa2d403d4", "0x2bcbb3fc", "0xa00291b", "0x10e00e32", "0xfe1cd143", "0x7e05e336", "0x73e70fd2", "0x506a611b", "0xc36be0ec", "0x1c1f01f7", "0xff7dd4e0", "0xd5203f42", "0xd5fc22a3", "0x6022e0c3", "0x7144b3de", "0x26e953e9", "0xcf301d5f", "0x11b1b4f7", "0xd79f030", "0x2f000250", "0x652fe0cc", "0x7f7143ef", "0x5e3df310", "0xc2134000", "0xe2410111", "0xca2e213", "0x1271da31", "0x64f13d03", "0x211e01e3", "0xaf0219d4", "0x23a2ffd0", "0xee0940bb", "0xdce015fd", "0x2096ceee", "0xdc0d5d", "0xb11013f", "0x392c9feb", "0x52002d96", "0x642752a9", "0xb0ff211f", "0xcf1cf1f9", "0xa237d522", "0xc0f4f5d", "0xe640cd0d", "0x4c7ad1b0", "0xd20119cd", "0xd1ff0c49", "0x20f2a090", "0xbf440244", "0x2c93514", "0x1ed6c4ec", "0x1f100fa0", "0xd10c203", "0x94b222af", "0x1c9200b0", "0x9fd076b2", "0xe9ef4cd4", "0x23fff15d", "0xd25bfd", "0x40712f40", "0xb0009eef", "0xffa79065", "0x6e7770d7", "0x440c527a", "0x370e2fcc", "0xe5003f2", "0xc7b137c", "0xe502dec", "0xf7e62ea0", "0x3e13cbf", "0xf7eedfc", "0x340d91ac", "0xe2cf3f", "0x1259f902", "0xe7fe322", "0xd101e91", "0x42f3e21f", "0xd4b04ddf", "0x4fc2e6f9", "0x919025e4", "0xf9b30292", "0xf5ae9ff1", "0xf7be1d1e", "0x7b0030f1", "0xc342ddf2", "0x1c50b4a", "0x622401a4", "0x5d10e5f", "0x34d53f25", "0x310f111c", "0x24fdff2", "0x42d051bd", "0x60044c3f", "0xc3fd2c33", "0x941dffe2", "0x302f9efe", "0xbc3d2ff", "0x201a19e9", "0xf1e1ee02", "0x2f1dfef", "0xcb22f4f0", "0xa154d3c3", "0x1c123e92", "0x20aa11fb", "0x12dd41c1", "0xf49a90f9", "0xdf7ea4d", "0x10d00eb7", "0xd9f10124", "0x73222ee4", "0x432b0bde", "0xacde2e63", "0x1a60fe4f", "0xa4fccb3d", "0xca31e29", "0xe3111ed4", "0xff30ce0d", "0xf45e3c02", "0xef4cfc91", "0xb345eaf4", "0xb411fef", "0x966a1dd0", "0xe912210", "0x91cf1de2", "0x3eeed0df", "0xc02f1cc0", "0xf1e720f1", "0xdee201fa", "0xecbc3f92", "0xd7fd292e", "0x25e910d", "0x1ffe55", "0xdc3ece9d", "0x3cfbfe14", "0xfc302e99", "0x3d025149", "0x12ccfdfe", "0x4153113d", "0xa5ed35e", "0xd1c0d11e", "0xf43171f3", "0x20ef1ff0", "0x621e1d30", "0x3d100000", "0xe30af10e", "0xe43cff10", "0x1c34cf61", "0xf12001dc", "0x2f1441ba", "0xd45ed715", "0x31ee1c1f", "0xd4fad24c", "0xf1012c21", "0xb5306a1e", "0x40e4f0", "0x31cf1906", "0x121a3124", "0xffa0fa66", "0xbc39e13b", "0x10ce0404", "0x4dc4e902", "0x3d0cf40d", "0xee1f30f", "0xff00d111", "0xe73a3f1c", "0xb50f1241", "0x32c9efea", "0xd2e0ff00", "0xfcb20dfd", "0xe11eed51", "0xff2fc322", "0xff10f3eb", "0xe00c39c9", "0xcf9e0af6", "0x410125c0", "0x9be9440e", "0xffff260e", "0x2a5902d", "0x1ad2a6f", "0xd50fff2", "0x1efb9ecc", "0x2090f9e7", "0x520705b9", "0xc21b52b4", "0x174f0d0d", "0xb107cff4", "0xb22406c", "0xf460e0ed", "0x3e7cc0a0", "0xcfde5919", "0xf620100a", "0xfd11eef0", "0x113212f3", "0x400d2512", "0x1012d42a", "0xe02fe0d1", "0x1cfb91f2", "0x939321d1", "0x242e0da0", "0x9af067ef", "0xf91c5bc3", "0x41d39f3e", "0x3f12b29", "0x2161fe7e", "0xf2d1bdc2", "0xfe969175", "0x706771d4", "0xe60d625c", "0x571e31bc", "0xe47ff231", "0xc7c1f7e", "0xf1707ff9", "0xc7d67dd3", "0xc2a13ce1", "0x217ec91d", "0xffe91cf", "0x10fd72e", "0x543d1be3", "0x1e74a132", "0x9f404fb3", "0x55f2b4c3", "0x90af5f1e", "0x2f0ec7e9", "0x94cf779f", "0x19c2edd3", "0xe19fc53e", "0x7fd2e13", "0x12306335", "0xc143de10", "0x11b6eb5b", "0x31542da7", "0x47b3307f", "0x67c652d4", "0xb0eeed2", "0xf160f434", "0x31a042eb", "0x70163a11", "0xc4a04e02", "0xf33ffdc3", "0x601b9bde", "0x2ec1b22f", "0x1590bf0", "0x2ea132f", "0x240cdf4", "0xa024d3f0", "0xeffd03b0", "0x6ff7d3cf", "0xf3f263f", "0x419e2d3", "0x42da11e6", "0x2d6cfe1", "0x7f20a62c", "0xc97a42ed", "0x12cf5c03", "0x12433f3f", "0xded69f30", "0x179f395", "0x251e21d5", "0xb4d2fb", "0x4fdfb1", "0x9e0e9b20", "0xeff03c00", "0x111013de", "0xdde1e5f2", "0x121f003f", "0xc002f00", "0xf21211da", "0x4ec010f7", "0x11edda3d", "0xf267b343", "0xf2274e94", "0x4ea55129", "0x35da3b14", "0x3b503f1", "0xf304523", "0x29c0acef", "0x1f215c92", "0xa2105022", "0xbf2357fe", "0xf3bea0ef", "0x27391952", "0x311ce35", "0x15e4706", "0xe9df9022", "0xea3512de", "0x9b2dddee", "0x56c733d0", "0xbbfec0f4", "0xf31f1112", "0x530b21f", "0x53dcecc", "0xc00092b1", "0x6b43b00f", "0x9532037c", "0xedfe0c19", "0x5fe54417", "0x3fbfef24", "0xc0f22e0c", "0xf994b51f", "0x6230336e", "0x40303f93", "0x924d2d29", "0xbe43eaff", "0x4dd3e0b4", "0x6b2b00e0", "0xd260230d", "0xda5044c", "0x5fe1df41", "0xdc72e0e1", "0xe023ccdb", "0x3e061f96", "0xef09ce21", "0xcdf1100d", "0xf331230d", "0x15f02130", "0x1df1ccef", "0x3c6cc13e", "0xc06e9ede", "0xcef015fc", "0xe03c933c", "0xf1d1d752", "0xf2e9db12", "0xeee1ecc", "0x9f90f011", "0xf00e40d", "0xef5f5b03", "0xd093a1ca", "0xe10f20fe", "0xe0fd14ad", "0x10ec01e6", "0xddb5c1f", "0x3e10efa0", "0x31c1ae0f", "0x25eb1ce0", "0x2f7073ff", "0xf210afef", "0x32c0f5c", "0x4fad0405", "0x9f71220", "0xef0ffc01", "0xcde1bd22", "0x235e0010", "0xf22c70ef", "0x9f4d9d1e", "0xf9403509", "0xd2cadcfa", "0x109a0d04", "0xe511ede3", "0x790e923e", "0x44f0120f", "0xfe999921", "0xb1b0e003", "0x191216f6", "0x3260c43e", "0x1e9ffbbd", "0x17c12e26", "0xafd39534", "0xd23fffb0", "0xf77fe2cd", "0x56f19ef3", "0x67f2f559", "0x51b04a4a", "0x1aa094f", "0x14012ff", "0xc504cb20", "0xd113f119", "0xb3fec0e", "0x55ee1f03", "0x3f0f00d5", "0x320dff23", "0xfeece415", "0x2e313d74", "0xc50fe1f4", "0xdee325d5", "0xf14741c9", "0x552fad1d", "0xc92de30c", "0x37a93ae3", "0xc9ef434", "0xed7f00be", "0x42def10d", "0x322ffe9d", "0xd2b43cb0", "0xd5f2a100", "0x9fe0d9e5", "0x101cee2c", "0x79f7910", "0x9e3f2e3d", "0x114cc12d", "0xc9bd4e24", "0xe413d70a", "0xeaae6dd9", "0x442effe4", "0xd1b4bab1", "0x5ede31c", "0x5e40ecf9", "0xa02fb2ab", "0xcf33d0e3", "0x7ef37799", "0x33026f01", "0x9772ef1d", "0x4b671797", "0x5c6ea2d", "0x3d70de7f", "0x6f54791e", "0xce1ba2d", "0xd50da039", "0xf2125011", "0x54110cd4", "0x4e57b7df", "0x1eff237f", "0xa9105e19", "0x2afe6de2", "0xb3c1fe03", "0xf632c21c", "0x1cd31e94", "0xdc1f09f3", "0xe1251f9e", "0x16021fff", "0x7b1f102a", "0xa3c359d1", "0x7176dd15", "0x444ca7", "0xd43d4d5d", "0xeb754d2f", "0x233ec496", "0xff24ff61", "0x19afba5f", "0xc316ef5f", "0x1be42f31", "0x3f7fb133", "0x176d516f", "0xcdcedbd", "0xd7370bae", "0x136a3c26", "0xbf3049e9", "0x610364bf", "0xb122391c", "0x2dfb071b", "0x351d240f", "0x21025e41", "0xd0003030", "0xf5d26daa", "0x411023d1", "0xff153dfe", "0x1f70402d", "0x2b2922df", "0xd4ce3cf2", "0x2093754e", "0xcfdf2bd", "0x1123135", "0x7ec00d45", "0xfdce0d4c", "0xe12efb41", "0x3b29ffd3", "0x270e117f", "0x3deb00fc", "0xf50020bc", "0x1f21ef3", "0xdf10fea1", "0xfed46bfa", "0x3ffbfed5", "0xc70f0f0c", "0x1d015fb0", "0x902bc51c", "0x51075537", "0x14113af3", "0xfaf0f960", "0x693c7cec", "0x5011dbc2", "0xe7b412ff", "0xf3ef2f24", "0xb706d5b1", "0x55d53704", "0xb6e6ad0", "0x1af02502", "0xd0ef71ef", "0x25030ece", "0xebab1d0e", "0xfef1120f", "0xb2e5faa6", "0x5fce605", "0xc4d6fc3", "0x3d11eae2", "0x2f0ef11e", "0xd0e00feb", "0xa01e4421", "0x200e20a4", "0xf042e60f", "0xe1f04c96", "0x22dfd9e", "0x1991fb43", "0x431e3c01", "0xfc21daed", "0x4d5c1ee7", "0xa34adf20", "0xa2e35300", "0xf7d9e4bb", "0xc2b3cf1", "0x5e91d1c0", "0xd1701e40", "0xdf1fa230", "0x19ea31d0", "0x22c0dfc", "0x9f0e00fb", "0xc30adfda", "0x9e2b125", "0x1300a6fe", "0xae2c46ff", "0xceedce09", "0x3da120d", "0xedcc21d0", "0xe92305bf", "0x9e0cff01", "0x1c0391d", "0xb4b130c0", "0xdf0c210d", "0xe02f4b00", "0xd4d29fe", "0xe10cf00e", "0xbeb004fc", "0xe00ce4b", "0x30f1dfe", "0x42f024a3", "0x1e6b3ee2", "0xe21e0fd4", "0x3fe2001e", "0xfa3d03fe", "0xd0ec410e", "0xf31df33b", "0x1ed50e00", "0x1330fe3f", "0xe14de34e", "0x53c9eb22", "0x2d2d2a0f", "0x3df5e0a0", "0xad449921", "0x9fac3203", "0xcdfb519", "0xaf30b229", "0x235d35e4", "0x1f0bbfc", "0xf1ef4fbe", "0x21e0b23e", "0xe0d2ee33", "0xdd2e11c2", "0xe2c1ddf", "0xd0e0e1fd", "0xd2dd74d1", "0xe2fd2f09", "0x5d6f300", "0x25f2e41b", "0xfc264c4e", "0xe200a10a", "0xf0fe2ce1", "0x1d00fbb", "0x4b04eee", "0xf5a92b3b", "0x4e3322f2", "0x2afcd2b7", "0xf23d9cb4", "0xe6df0e25", "0xd5cbc61", "0xe72f523a", "0xf11221f", "0xe3fac2e0", "0x2033211c", "0xf09df7ef", "0x3fce0edf", "0xe1f11320", "0x1632d2f", "0x7e112f3", "0xf1a6cd52", "0xdd21f0eb", "0xca4eef6b", "0x76b3ffcf", "0xa1ec491d", "0x9b102f19", "0xfdc2e5d", "0x4ed10bac", "0xdee4f23c", "0x6e4bbca0", "0x2dea4633", "0x30a921a3", "0x9c9f0903", "0xf07a22e", "0x6e3f94b", "0x41902e24", "0xa01b0979", "0xf375a32d", "0xc5104", "0xdde90b77", "0xd4befd13", "0x22ff704", "0x2536d00", "0x72f06134", "0xacdf394e", "0x5f34cd0d", "0xbe490300", "0xba4e2d2f", "0xc49f5c01", "0xe64e2d4e", "0x401df12", "0x7b1ffe4f", "0xfe204d4e", "0xf160f1ee", "0xfeeef00", "0xf0e00fef", "0xd000e90f", "0xef2d3e0d", "0xe1fee1f", "0xede0fcfe", "0x2e101b0d", "0xf02000fd", "0x1ffe01e0", "0x1efff0e", "0xe0f2fcfe", "0xff1ed", "0xfff0", "0xcff0fffd", "0xd00de0f", "0x100ffb0", "0x2fef2ffe", "0xf1e1f000", "0xf2d2fc10", "0xffeef11d", "0xfff0111f", "0xdee0f1ef", "0xf2efe1e", "0x13f02f0", "0x100fff", "0x1f01f11", "0xfe1910", "0xf0f302f", "0xd00f0ef", "0xf100e000", "0xf122d1e", "0x10f0001f", "0xf01000f", "0x1fff2f", "0xff0100f", "0x1f0ee0fe", "0xf1000d0", "0xef00f120", "0xf001e01f", "0xf0fff1c0", "0xffff0c20", "0xef1ee10", "0xf2c1ff00", "0xfeeeffde", "0xff10ff1", "0xeeeff120", "0xff3f121e", "0xd14010f0", "0xf00ffeff", "0xfff211e2", "0xe0fff9f1", "0xf206e0f", "0x1e00f2e1", "0x3e0eddf", "0x10704b0e", "0xff0f0f", "0xe0e2efef", "0xdf10e02f", "0xef1f0fd0", "0x1e00edfe", "0xe1000ef", "0xe10000f0", "0xf070ece0", "0xf0d1", "0x1ff00d01", "0xdfe2de0f", "0xe1000001", "0xfdee1dfd", "0x1ee0f210", "0xd100f1f2", "0xf07d1d0f", "0x716be0f0", "0xe0e1dabf", "0xe61d3d13", "0x3f50faf0", "0xff00154", "0xf30a41bd", "0x2301f11", "0x194bc3a3", "0x1d4d0e0b", "0xe2dbaee", "0xd10b300f", "0xcb214312", "0xe09903e3", "0xf33d4c0", "0x2100bed0", "0x1c12d0ff", "0x224e3e29", "0xcbbf19f1", "0xfecc9fc4", "0x99ded124", "0xecab57a9", "0xf443a1", "0x21000eb3", "0xe0a2ad63", "0x715614f7", "0x5707dcf5", "0x7000f22a", "0x174133e9", "0x72377d55", "0x3bfe31", "0xe4705d09", "0x600d2295", "0x65c29d1", "0x31f0aee9", "0x21d4d0cf", "0xbc0c0d2e", "0x2ef160ef", "0x1d230eb4", "0xf4f0afdf", "0x490ef131", "0xfe5ad999", "0xebcb4f2b", "0xe0dd9ecf", "0x9a2cd053", "0x1ddb02ab", "0x11b72fdb", "0x2f0f0cd4", "0x9ded351", "0x7b371712", "0x7127e3b4", "0x760d504c", "0xd25e1e31", "0x401f5176", "0x27c0c20", "0x3651205d", "0x11ff6695", "0x7e54f4e2", "0x4123d304", "0x114b4fdc", "0x1ef122", "0x3d622eef", "0xe4fc344", "0x67603220", "0x91fee1de", "0x62c10c99", "0xf94ce14e", "0xd4a9fa1", "0x1f01df71", "0xfe0be3", "0x2442c0e", "0x7ff01c06", "0xdd1ddf21", "0x9fddf13d", "0x509cf41f", "0xcc23277e", "0xce0c17e1", "0xe3f9a039", "0x2be3cf3", "0x3e300be0", "0x2459afde", "0xd2f737f0", "0x7963af1f", "0x2c00fe41", "0xd0c1762e", "0x62b9907c", "0xc9c7de2", "0xe321a93f", "0x14b09f5e", "0x6137a30", "0x10fb37f1", "0xec9f91d3", "0x925b17ce", "0x529902bf", "0xe903c2e", "0x231012b1", "0xb03a911b", "0x15bd04ef", "0x70e25231", "0xed5eb510", "0x45b3e119", "0x35f9c07f", "0xcc22db4", "0xcd1f0010", "0xd7d9153", "0xf1d200dc", "0x43171e9e", "0x1a216f9b", "0x573b260c", "0xe207b372", "0x1e42f412", "0x3b20bf1e", "0xbe1eb3d2", "0xec51cfb", "0xc110fe1b", "0xe9dfaff2", "0x2732d502", "0xfcf046f1", "0x34f20fc", "0xea11d121", "0xf93dfd22", "0xbdce9f0e", "0xc2dd39e1", "0x39779002", "0x40a9300d", "0xf23ccf4b", "0xfd950d00", "0x9f2055cc", "0xce29b711", "0xb6cec10e", "0x430eea5", "0xd90712ee", "0x49f033fe", "0x91f2ceba", "0x1bd4e01d", "0x7a915f43", "0xfeffcfd2", "0x14a20f3c", "0xa00f4217", "0x5f169f03", "0x2900e3ec", "0xfcd110b4", "0x97f24ef", "0xdc9fdacd", "0xb32a011", "0xc1fd74f2", "0x67040703", "0x3ec1e5d9", "0x4631dbd", "0xf1c3c34a", "0x11d395a", "0x2a011011", "0xea1300a5", "0xf2e02d31", "0x5f1116e6", "0xa0d46d1c", "0xce504fff", "0x54dc01c0", "0xf71d3ef", "0x111012f1", "0x592942f1", "0x5fd13e15", "0x7e3440dd", "0xe0c594df", "0xcf1eeea2", "0x2409e500", "0x574133f", "0x1c3001fe", "0xe030132", "0x21bf0b40", "0x1fe24bdf", "0x19fe76eb", "0x6ecd596e", "0x36ec5f", "0xe650d2c", "0x39affc3f", "0x117351e7", "0x1292b270", "0x2a27f0ac", "0x6c4d302a", "0x77b520f0", "0xeb6321d0", "0x970d62f", "0x69efdf7d", "0xd5677de4", "0x12a12169", "0xd232aa6f", "0x6f109ae1", "0x7e11cf50", "0xf019fafd", "0xf07b9400", "0xe910f01f", "0xf1774ec0", "0xbef5f050", "0xe019e35e", "0x219263f5", "0x4ae422b5", "0xe3ed3ce9", "0x1d21edf5", "0x70a043ef", "0x1f1d31ce", "0xf3c51afe", "0x300e00e4", "0x29231fe", "0x3c4500ff", "0x312f39bb", "0xa7bfb53", "0xf29f2520", "0x1d5fec0e", "0x1cc0ea0b", "0xe1102b9e", "0xf3bf900e", "0x5cf2ec3d", "0x31003b03", "0x1672f04e", "0x21c0ffc0", "0xfe26f1ff", "0x31416d21", "0x4390bff3", "0xc1dd25f3", "0xdff9dabd", "0xc3f5ff96", "0x10c3292d", "0x1ee003cd", "0xde5d31b0", "0xc016d964", "0xb442df", "0x1f107222", "0xd7250f0d", "0xde571253", "0xf4727e0", "0xf3712c2c", "0x23a73f0", "0x4d011d4e", "0x237ef42e", "0x5d2f2fee", "0xe10100e3", "0x30243333", "0x572df0e", "0x9ce0f2e1", "0x51e072e1", "0x201d0e1", "0x2f9799ff", "0x9e0e7431", "0xbcce09f3", "0xd016b7a7", "0xe132b5f", "0x2351c02c", "0xe13b70d2", "0x2217b0f1", "0x34770106", "0x613e604e", "0x27f23c19", "0x74f35702", "0xfc75f754", "0x9c1c5b1", "0x27327d0e", "0x2ebe210f", "0x3e3df262", "0xfdb23eb0", "0x19d7df05", "0xa41ef90f", "0x1c2ea3", "0xd2c04c9e", "0x1bd15323", "0x9353f0ef", "0x7e22f60e", "0xe5e051e0", "0xc3a00fce", "0xcc2e92e2", "0x104edb30", "0x39ef1fcf", "0x300d600e", "0xe1df1ddf", "0x174bf9e7", "0x4d304d2", "0x49e01f70", "0x71dfe3db", "0x113f4074", "0x29fefc6", "0x6c122e3b", "0xb1efff1a", "0x3b1af4c0", "0xff0cb7dd", "0xfe11dfb2", "0xf60bcc1d", "0x1abe92f", "0x5ef1e092", "0xf10515"},
{"0x2dfddd10", "0xeca003b", "0x32f30fef", "0xd206d431", "0xc330e3d9", "0x34165d1", "0x1fcfcf30", "0xc0262bc", "0x24390f04", "0xee9231e", "0x7f21bde4", "0xd21ff5ce", "0xfeccf4eb", "0x14ffedd", "0xec9012ee", "0xe2e42f03", "0x2d29e3eb", "0xc309f31c", "0x2e01d121", "0xfe4f110", "0x130ccb2d", "0xf2ee3efe", "0x3f9119ef", "0xec20d105", "0xc2c0f000", "0x3de402fe", "0x1fab95d2", "0xdda3e4b0", "0x212b1c1e", "0xe2fdb20", "0xa1412124", "0x3aefdf2d", "0xdc2a1f", "0x2c14f0ed", "0xfe2d3f09", "0xc949d2b1", "0xfe0ad472", "0xfe25e1f", "0x91706c41", "0x7f9491d2", "0x1eb9fbe2", "0xdc62362d", "0xefa41c", "0x9a4bd0fc", "0xca9342e", "0xff05e41f", "0xeb605104", "0x6fb39104", "0x60bd0d9d", "0x7dcb1f4f", "0xf4edaded", "0x3bc50120", "0xf650e21f", "0x24e2930", "0xc0d0ff90", "0xe51dda3d", "0x43e132ae", "0x209d50c", "0xa29020f6", "0x5207ef60", "0x33ff204c", "0xfc2abd0", "0xd2b0e4be", "0xaf921e20", "0xd0d311e9", "0x93b25", "0xa354ecf1", "0x74f73bee", "0x1501c0e", "0xf901df0", "0xe7900c90", "0xcdb14c11", "0x633c20de", "0xe20d404e", "0x2e142f5e", "0x9fc2d1c5", "0xfed340de", "0x3fe2e1d", "0x11e0e13e", "0xb10bd1eb", "0xd3092da1", "0xfcd5bddd", "0xe20f415e", "0x94e213f1", "0xccde1eae", "0xfb024e2d", "0xb2f1d005", "0xf02d0efd", "0x1fd92c91", "0x10e4dee", "0x400f06e", "0xbbe0e33d", "0xa1b9fcb9", "0x1c43503c", "0xbd0f6ea4", "0xc966bef1", "0xecf9bf5c", "0x394fd2ec", "0x7fddb431", "0x90fde2d4", "0x1a0c102a", "0x230231", "0x92f0df46", "0x3effa22c", "0xe0c9364f", "0x59e24be0", "0xeeac90c2", "0x3bae253f", "0x314ae401", "0x940410e", "0x974151f0", "0xff4952b", "0xd419f3bb", "0x303c22fe", "0xeec193e7", "0x570dcff2", "0x653ae009", "0xfc1bbc3c", "0x93ef7eff", "0xbf10a120", "0x4ffc140", "0xed1c23ed", "0xcae5dd92", "0x3fcdcb60", "0xcb0e5d14", "0xaefee24", "0xdd110dfb", "0x3be132fa", "0xffdf94", "0xf12e03e3", "0xcd96f191", "0xc4bebe71", "0xef1edfd1", "0x2a11ed1", "0x91c01bd1", "0x3941fe2e", "0xe6efe3", "0x1de1f3a2", "0xe2110ecd", "0xbfbcfe53", "0xec0d34cf", "0x6916100", "0x92f00e6e", "0x59622cfb", "0xa4bb70d4", "0x2fef0ff1", "0xce2231b2", "0xdb1f416f", "0xfde315", "0x3933239", "0xe9203c62", "0xfcf0ae1c", "0x3106e492", "0x27955dc4", "0xff1fc7ba", "0xd4f3f202", "0x134e95d0", "0x1e62ef5c", "0xd9c0cc3a", "0x293a3fbc", "0xdc77e5bc", "0x43d13ec4", "0x4df2571f", "0xa507012e", "0x7530f64c", "0xc7fcd7d", "0xeb90b04c", "0xd939539e", "0xc4140fb5", "0x23ab2dfe", "0xbd712bf", "0xfa3beb12", "0x31efe2", "0xf2c45dbe", "0x3b310d2d", "0xe0f27fe6", "0x3d16be74", "0x2ed2ae3", "0xc1d040ea", "0x7f4c6011", "0xf4d97db", "0xe031f2b", "0x9a90e20f", "0x2f5d2df6", "0x7954d072", "0x1a1a1ab7", "0x20e34169", "0x7ba162bb", "0xe302d2a9", "0xfc690477", "0xeda199ba", "0x1ce93ef0", "0xb2ce1ed1", "0xccc032c2", "0xc4d3f0e1", "0x2f90b131", "0xd921f1bf", "0x3bf41d0", "0xf161f10c", "0xe1544fcf", "0x9204ec3b", "0xdd1becee", "0xc3e431e1", "0x15f0010f", "0xfbde06e0", "0x11fe421", "0x4f00ff2d", "0x14373d2d", "0xf022b130", "0xed19cf10", "0xfd96ec36", "0x313e04fe", "0x2129ffa1", "0xe419377", "0xb20a1e1", "0xcc23d4ed", "0xce101be1", "0x7d219520", "0xe23e209d", "0xee0be4e0", "0x20cc9bf0", "0xf3cc1cdb", "0xf110c342", "0x9023b1f1", "0xdf03eccf", "0x7f300eaa", "0x43e4c96", "0x1039f9ed", "0x2fc0ea05", "0xd9e1139", "0xa1501ce0", "0x247fc123", "0x29cb1a19", "0x7f5606c9", "0xc022f491", "0x36eede9f", "0x221fcac4", "0xed01f6b", "0xcd20e9dd", "0x2c5d0f10", "0xecc0bf04", "0x730736c0", "0x5ff31339", "0x463a27f4", "0xb0ecdbf0", "0xf343ff6d", "0xfed1211f", "0xecc0432e", "0x3e32fea6", "0xf4016afa", "0x1e034369", "0x77e4135e", "0xe6366101", "0xb5f0d7f", "0xed2105e0", "0x1dbc2e30", "0x10ae0eb0", "0x6551330a", "0xee15ffeb", "0x7fa7412b", "0x2422b615", "0xf17ee173", "0xaae1d1d2", "0x6dd32bfb", "0xefb504c9", "0x1b3543b2", "0x5500021", "0x161209e2", "0x742a2b1f", "0x62504ef", "0xed20d70e", "0xf1e22c01", "0xbb4fc1a9", "0xfdcd9926", "0x226bb02a", "0xf2fdfa0f", "0xffde42f", "0x1dbeef01", "0x3f7f322a", "0x51bc9eb5", "0x21a0434d", "0x53ceb2f2", "0x55fdf14", "0x13ebfcff", "0x5fed1977", "0x1e900f3", "0x44004b1c", "0x12b13a9c", "0x60f6ee55", "0x34a0ec2c", "0xd7f30b1c", "0x9bfcd932", "0xfe7d692", "0xf79c223c", "0x2e10931c", "0xfc1b4707", "0xcdf5cfcd", "0xd694d204", "0x2352443d", "0xfbf7c90b", "0x4746d390", "0x75d4e7b", "0x612f92fc", "0xcce21716", "0xe72abe", "0x23fcb07e", "0x156045cc", "0x5e1de97b", "0x3f7e5da", "0x162af7f2", "0xd14f92be", "0xc0e96656", "0x4e35f0c6", "0x91b10f00", "0xf2b4cd21", "0xa0f7efd2", "0xf2f1c791", "0xf4003101", "0x990923e", "0x2fb0ffb0", "0xcf10ff0e", "0x121af904", "0x1e000a22", "0xd1d72e1d", "0xd11da1b0", "0x57c2034", "0x9bf9c20", "0xe19194ee", "0x9d20600a", "0x3cd9c05c", "0x5ab2f69d", "0xde4ecf10", "0xde11f0e1", "0x27a3d45", "0xdc20cbdc", "0xed9f172f", "0x6d70ef31", "0x610f10d6", "0xfcb2212f", "0x96125141", "0xa20df393", "0x140fde4e", "0xfb9fb411", "0x4befe6fa", "0x221f7234", "0x5309eeb3", "0xcbbfbf4d", "0xcfc21c2c", "0x94d06dbd", "0x2fed563", "0xaf0f43", "0xdb22330", "0x1ee07371", "0x4311ffe3", "0x3aef31d2", "0xb2eade1e", "0x995d030c", "0xf6ebdd3c", "0xf430cee2", "0xb3ad21cd", "0xfe0325de", "0xe3f505e1", "0x2e219041", "0xd24c041c", "0x1a2f1c21", "0xf10141e2", "0x4d60131f", "0x20dd64ce", "0x215b00e2", "0xbf030c6d", "0xd014cc2e", "0xd0010a2", "0xbde20301", "0xb0ffe0e", "0x7c900302", "0x12d0fb4d", "0xc34cd1c1", "0xdfbac116", "0x3f2ac2eb", "0x14d6d260", "0xf9bd31fc", "0xe6025d0", "0x2d9ff95f", "0x11ef4d42", "0xf20035df", "0xe40452d6", "0x244e90c2", "0x6e557d7", "0x5f63653f", "0xf1250f6", "0x1d100fd3", "0xcf95ef5c", "0x55efca1", "0xbf9e0251", "0x9fffdc22", "0x59e0d3d1", "0x943fe903", "0xda009df", "0x2130fbeb", "0x5c5fa032", "0xc36bda14", "0xbf3b6e00", "0xacb0be01", "0xf94d3d4c", "0xe3ac472b", "0xf94c53e", "0x12713111", "0x2761af21", "0xe1ff1f4d", "0xcb0f393e", "0x23c391dc", "0x7f1f3275", "0x2111ea1e", "0xfbf6ee1", "0xd5e053b1", "0xed1ab2d", "0xbe362250", "0x9ca14b2f", "0x1e40e047", "0x23ca1bef", "0xe143f701", "0xf30a21d", "0xcc0105a", "0x9712dcf3", "0xdf32d221", "0x91a1decc", "0xd52cf22", "0x17d9ec5b", "0x7d0a5e3e", "0xf441c7e0", "0x1040fff2", "0x37fed420", "0x7be2bdd1", "0xc5161107", "0xb192e17f", "0x4006a9f0", "0x34e703e5", "0xfaf05a4c", "0xfa31cfb4", "0x3dec3af0", "0x9b62cc1b", "0x5c913910", "0x30e4244", "0x3c319fc", "0xe252e1a0", "0x1f2c1f50", "0xe16fc0be", "0x10fb24f4", "0xed60fc0f", "0x1fabd0d", "0x12261fe", "0x5bf0bffd", "0xf1df10c0", "0x44e1705", "0xedd0fea2", "0x5bde240f", "0x3c02b14a", "0x11ee0cc4", "0x14bbb11d", "0xf4dce9ad", "0x15113dcc", "0xf1ef5d43", "0xdf21ceef", "0x3ef13ff6", "0x120fec4d", "0x3bde2bf3", "0xe33d3f5f", "0x241d1ddc", "0xb30d00ad", "0x1bdeca33", "0x1260c001", "0x5e22c0", "0xc320fdec", "0x4f00b5d4", "0x41223c0b", "0xdd1bfdff", "0xfb0009b", "0xedd3433", "0xf31f3de", "0xd1e242d", "0x2d3dfefe", "0x5d1d0d10", "0xe4291919", "0x91543b1c", "0xbcf42df", "0x31049fa", "0x53efd2ee", "0xcce42da", "0x62d2c10", "0x304ff032", "0xebff2dfd", "0xcefde26f", "0xde30e7ce", "0x10dca1f", "0x16103b40", "0xef1df101", "0xa21d3240", "0x110ee3e0", "0x25b05ef1", "0xef11ef3f", "0xed42a102", "0xfc1fe2df", "0xb02f0444", "0xec2f410d", "0x112fb0a3", "0x3dfb0722", "0xb42a2fff", "0x9917053e", "0xf3dcc919", "0xffcb101d", "0xbdf0d203", "0x7993531f", "0x1dfc3db2", "0x2c2ec122", "0x9ffab00f", "0x99f6017f", "0xf299e39", "0xf9a23f3f", "0xf33f0ed0", "0x5a949211", "0x30fafd6f", "0xd1706dea", "0xeedfcd", "0x1534e2c1", "0xfe1ec70f", "0xf9d02a2e", "0xe1304de3", "0xa0929004", "0xd5ec05ce", "0xe9f216e1", "0x3ee91205", "0xcc12d3d4", "0x333ac24d", "0xfd0931", "0xe311dfff", "0xa0b1ed23", "0xf0ebf10f", "0xf055040e", "0x50700e10", "0x3121f69e", "0x110d2e73", "0x1b9c99fe", "0xff6072e3", "0x97c5e242", "0x3321e193", "0xb040bcde", "0xe01da3c1", "0xe7d71e30", "0x21dfff2b", "0x1f9e09de", "0xf7f14cac", "0x6b0ddf00", "0xeebf1af", "0x63af3f43", "0x1edf210e", "0xd90522d0", "0xf2fece4e", "0xfe3ba9b1", "0xdd1fef07", "0x2def0e60", "0x75cb2e93", "0x73d24e02", "0xe4fe231b", "0xc0d3fd21", "0x543f012f", "0xf7d139b3", "0xad1f0d2f", "0x39f0fe5d", "0x70fd01eb", "0xeec2410", "0xf1442e2a", "0x9cf21ecd", "0x2e1ad13c", "0x14e33cda", "0xd20f1c4f", "0xcfd0e015", "0xcc1b1d4", "0x775b3fd7", "0xa1e93501", "0xe9f009d1", "0xf1231ab9", "0xc2e0060", "0x3990ebe0", "0x19ea2fac", "0x1e4f20ef", "0xe3f21f12", "0x33193442", "0xf504cf10", "0x36331ae2", "0xf2aed60", "0xb991991e", "0x2939effd", "0xbc5101ef", "0x219012c", "0x3e1c2ae1", "0xdca529e1", "0x27e09e0a", "0xe3efee0", "0x2090bbe0", "0x4fbc3e11", "0xf6f2fe44", "0x6f294244", "0xf13daff9", "0x300f1ce1", "0x1becf529", "0x7e105f9", "0x2302eae", "0x4de43f00", "0x65406f", "0x6f3b3ec3", "0xe0fddb79", "0x1d314e43", "0x31edf99", "0xe0a113c", "0xd0f0dcce", "0xe2ca2afd", "0xb431ced", "0x7e395bd3", "0xf30e2c", "0xc9def3d1", "0xe1009ce9", "0xd4afa21", "0x9601ada5", "0xd0ef2e5f", "0xddede151", "0xa0de0019", "0x72bfffb4", "0x4ef1d722", "0xbe5f0610", "0x4e333ea", "0x1041035f", "0xe3d01704", "0x23509150", "0xccfc14bf", "0x3deb0129", "0x4129200f", "0xdee9f4cb", "0x1ff4e5f2", "0x23ef2e7c", "0xd01125f3", "0xef6dd07f", "0xfd59ff05", "0x1dc01029", "0x3dbf144e", "0xeffdc3de", "0x220523", "0x2f40fb0f", "0x104251c", "0x324230b7", "0x4f62ccde", "0xd21c01e2", "0x10cc29df", "0xf14f7031", "0x6f0c0f2", "0xce6107e2", "0x1f2f9ebe", "0x24f2ab92", "0xfc2dfc0f", "0xb0edd1c", "0x2f0d1fcf", "0x712a32c4", "0xf2317f0", "0x1130fe1a", "0x1006a1f0", "0x14d212df", "0x6ff12ed2", "0x3d099df1", "0xedacfdf3", "0x55ccfef0", "0xde3de0f", "0xfe30d722", "0xf3039ff0", "0x6e5e16fd", "0x23079e0b", "0x444fe6d6", "0x675edded", "0xfc736731", "0xfe6fa513", "0xeef023f0", "0x12a0d6d0", "0xdddd1f1d", "0x4507943d", "0x622404c5", "0x1710d234", "0x5f114e14", "0xb05cfe2", "0xbc03171", "0xe34eb100", "0x942d9441", "0x42c3f2a5", "0x4d1fadf2", "0x4fcc60ec", "0xd3dde301", "0x92eccb", "0xf43f417d", "0x34619e0d", "0x7240e3ee", "0x445f530e", "0xd7124f69", "0xf4710d3d", "0xcf4376b4", "0x5e2203", "0xb390faf2", "0x1d01d5e9", "0x71131a9c", "0x4f3555ef", "0xd5ee046b", "0xdc6fce0c", "0xf223fd0e", "0xf14a7b3d", "0x95100214", "0xe13ef03a", "0x6be150ae", "0x44253e2e", "0xc523ef14", "0x9f3e09fb", "0xd103be34", "0x2223a2c", "0xfef0d301", "0xe44fc1c7", "0xb3147c0b", "0xdb0fff0f", "0xd00d36f5", "0xe12dcfb1", "0x1bdfeef0", "0x3e1cd30", "0xdbf0efdc", "0xffed3a09", "0x22364230", "0xe0b1b40", "0x2fdf02f2", "0x22ffbef", "0x1fbf20f5", "0x3cf2304", "0xd10cf2e", "0x113cf939", "0xe04e67d2", "0xe5f031fe", "0x1ffdec2", "0xef10d1bf", "0x1a9e2eb0", "0x10f31e0c", "0xdfc0ddeb", "0xe40e90e1", "0xd2fd23bd", "0xff1ef221", "0xb02de7ec", "0xf30c3e11", "0x1de1e0c1", "0xee2ec1d", "0xb941f3de", "0xe0ed0ffc", "0x7d4e0b5", "0x2f1e0b0b", "0xf1e0d121", "0x27ee3041", "0xded20bc2", "0x1d13e0b", "0xbe4fe010", "0xf2fe2b0d", "0xcef1d5", "0xffe00d4e", "0xe0e1d10c", "0x24d052d1", "0x4eaf1dd1", "0x1dd21a1c", "0xac31e1de", "0xe64cdedf", "0xf29d2ae", "0xef13e1d1", "0xc440f41f", "0xd5edf9b0", "0x2e341f1f", "0xeece00", "0xbbf021f5", "0xdf3e2b2f", "0xd10ed3c3", "0xc55dd21", "0x2200001e", "0xf3c02bff", "0xbb252de4", "0xfc02ff", "0xbd2f2236", "0xa05a09e3", "0xdf2fb6f5", "0xef1fff1", "0xd492f22f", "0x1dfb1d13", "0x1ad43ded", "0xde03cdc", "0xced0d331", "0xd25c1de0", "0xca121ff", "0x5602e1f1", "0x211970dd", "0x23271f3e", "0xe157ecd1", "0x1f70de31", "0xdf3f4b6c", "0x1cf06eb2", "0x67fe2901", "0xdd4e9c00", "0x24cf12e6", "0x3efd3fe0", "0x20093913", "0xff24b31d", "0xc4cf02ee", "0xfb3dd6c7", "0x1eff0cbc", "0x2f3e4fee", "0xdea100dc", "0x11fbdced", "0xf2ffed3f", "0x1cd01f22", "0xf34fbf0d", "0xfb51f0ff", "0x9f12021", "0x1eddc2d3", "0x3f037324", "0xf4f51a15", "0x1f77f3dd", "0xf15df1d", "0x1af13a73", "0xff124fef", "0xd9330f51", "0xe570fc2", "0x63446139", "0x52fde09", "0x740d1116", "0xf37b3325", "0xca710670", "0x324273ec", "0x34c4ffee", "0x11771440", "0x32203b2d", "0xf20ef9c6", "0x21fd7f2", "0xff22e24d", "0xdc61e7c3", "0x747d6ee0", "0xb67050cf", "0x7399262e", "0xe1d023bd", "0xf321f3e4", "0xc414730a", "0x1c02a0f", "0xe0d0239e", "0x4c303f0f", "0x6f700ecf", "0x7e1907c7", "0xafa362e7", "0xec36663", "0xc02fceb", "0xfd505c72", "0x590c0ef", "0xce503c31", "0x1df0f10d", "0x51feda07", "0xd0fe2dcc", "0x3e0421e", "0xf10eee1e", "0xff732e0f", "0xc10feaf0", "0xbf0171e0", "0xf4fe65f2", "0x6dee705", "0xd5bf4ab", "0xbe16100f", "0x640e22ac", "0xf1d0aadb", "0x3520f119", "0xe91ddd5e", "0x253540df", "0x231de4b5", "0x66f2e690", "0x22331ba1", "0x5250179c", "0x107e90c4", "0x3230d00d", "0xeb39421f", "0x2d0ddd9d", "0x1b2d7e0d", "0x5100a6b1", "0xd3e70f04", "0x110ab001", "0x1c44c1bf", "0xed10c1c0", "0xf10c2d35", "0x9213eb14", "0xe7db6ee1", "0x99c5609b", "0x31dedcad", "0xe9dd3e99", "0x1b19a29", "0x23410fd1", "0x2034dbc0", "0x4103d670", "0x3c2371b7", "0x11a22f49", "0x360ff350", "0xcf2c529c", "0xf17bf25d", "0x4ec190fd", "0x7a03400e", "0xf1ddaeee", "0x4d2ccb45", "0xf4c494db", "0x57eef101", "0xf4ee01ae", "0x1f70e20d", "0xfd00a0af", "0x14f7eff0", "0xb2002d41", "0xeee144c", "0xdb77501", "0x7c902cd7", "0xba0b029b", "0xd1f0e94", "0x2031fcdc", "0x4deee360", "0xcc142c6e", "0xbc2eaa00", "0x5dd74b00", "0x5b2e21c4", "0xcd1cef9f", "0x19c4d2e7", "0x5e9fade1", "0x49c63351", "0xce0e4ffa", "0xf15af0cf", "0x43159c1e", "0x7d2e2e60", "0xccf91bcc", "0xfc9e3e0", "0x3121ccee", "0xfec4f21f", "0x2510c2e0", "0xed22b2c4", "0xfe0335fe", "0x3d1edd0c", "0x55ab14bb", "0xe40ee05", "0x41f010a0", "0x109a02", "0xfb030ebf", "0x5e1075e2", "0x302f32db", "0x1625d10a", "0x22bb2393", "0x250d0ff", "0x540ff212", "0xe5437c0f", "0x5fe42520", "0xfde0d7df", "0x111ecf10", "0xd9d0f0dd", "0x51da2202", "0xd442f24", "0x64d0f223", "0x5be162f1", "0xd1605e42", "0xffa4b9f4", "0xc1d37e2c", "0x721edd91", "0x34dd3ff7", "0x232bee0", "0x7e7f4015", "0x25b1da27", "0x4023cfe4", "0x51ee4335", "0xd31f2b30", "0xf747006c", "0xeeefea91", "0x6720111", "0x7aa0939e", "0xfdd479ee", "0x9dd02f4d", "0x390371d", "0x225af242", "0x5b27f332", "0x50214504", "0x1070e2f1", "0x7f201350", "0xee443e1d", "0xb6fb31e1", "0x30e4113f", "0x11d2415", "0x60511e7e", "0xc3063d32", "0x1150a93", "0x4200270e", "0xf3b20f0f", "0x2d13b1dd", "0x2cde2e60", "0x3ce12a04", "0x4e055c55", "0x1fcef3c3", "0x1d40d7f3", "0x6c20f02e", "0xcd0369a3", "0xde9ce391", "0xdd31017e", "0x212b2d0d", "0x59770465", "0x13401d54", "0x6752f04", "0x49d153f0", "0x75002b5a", "0x10cfe2ce", "0xade13a1e", "0xc30fdbc0", "0x40ee9fd", "0x9ff0f3eb", "0xcbc1ec1", "0xf11edfe", "0x3bbdebfe", "0x7471e1ff", "0xb50d4b01", "0x20c10f0e", "0xe2d1de2e", "0xf12ff51b", "0x1fe30e17", "0xdd3021d5", "0x2e312a0c", "0x530ec0af", "0xd2e01ce0", "0xf01f331", "0xcee35def", "0xcf01e009", "0xee430a6", "0xdde1334f", "0xe000c63d", "0xe03f11d3", "0x9c0bee2d", "0xd0e9df5c", "0xe0ce0acb", "0x9cdb0b1d", "0xc2b21d1", "0xdcffaac4", "0x21fc9f0d", "0x7172dd02", "0xa70c1e20", "0xb15dce1a", "0xd39d291e", "0xe0bc1eb", "0x140ef10", "0xbb4fcc07", "0x4122dc5c", "0xf12dafc2", "0xe3003dc3", "0xe36fd130", "0xf2b37920", "0x1f0109fb", "0x2041ce", "0x9b201235", "0xd21ce27d", "0xb3f2ebd", "0xcff9e00d", "0x2ebf92ad", "0x14efddf1", "0xd11c5b43", "0x11cbea0", "0xc5dfdc04", "0x17daddc0", "0x2d71fecc", "0xbacbf200", "0xf20390ff", "0xfbdd4c31", "0x6bfc235b", "0x5fac1ff", "0xd3209d07", "0xf12f4b6e", "0x223dddef", "0xf2dfe2fe", "0x3334a30e", "0x33f530d1", "0x70430a49", "0x1ffe2290", "0x7209133", "0xfcdb3ffe", "0xff3ef0ca", "0x21c1fc1e", "0xfe10701d", "0xeb0e26b0", "0x1a90de", "0xe0ed3d0", "0x210f5b72", "0x7d00defb", "0xd46b3ffd", "0x13fb55fa", "0x1204c0da", "0xbf251633", "0x2faa3dec", "0xd2472df", "0x71e0f403", "0x92e0ebf", "0xc372645d", "0xefeedfd4", "0xf1e6f143", "0xcff1e313", "0x2109192f", "0x1debee0f", "0x311010f0", "0xe526bd1d", "0x1e5defd0", "0x433ecff1", "0x1a4173cb", "0xd0fe52ee", "0xecd2a33d", "0x1a24190e", "0xe112eb1", "0xbfeeb02", "0xb652ff03", "0x504f7720", "0xeeb09ff9", "0x33f4156c", "0xda9c400", "0x1b7efee2", "0xe14027e1", "0x2202b361", "0x3c7e1fd0", "0xe29f9af0", "0xf0e292d6", "0xb1f1f5b7", "0xf0fea244", "0xd294afb", "0xe04f1a03", "0xda53af60", "0xc1c112", "0x4ff2fcd3", "0x1a05e3e0", "0x1ccdf131", "0x20e005f1", "0xd002fee", "0x5520f25c", "0x1ffdfcd2", "0xfffe202b", "0xf1704505", "0x1e279ff0", "0x7d0dd3b", "0xcab3b4b", "0xf7c942e", "0xd2b15791", "0xe5f5d033", "0xb10de11e", "0xee9e34de", "0xe02e97d3", "0x56042397", "0xf250c213", "0xaf2cf1", "0xcd0009e1", "0x23fcdf3", "0xa1940dd6", "0xefc6d2db", "0xbb711c", "0x31e9ef9e", "0xf2bc9573", "0xf13a52f2", "0x42607643", "0x31462ada", "0x7973b35", "0xf537dd10", "0xd34a03fc", "0x7fb23bf", "0xf37af0fb", "0x1216051c", "0x3b002ebe", "0x4664cb3d", "0x110ecc35", "0x1c06dcfe", "0xbc0d1fe0", "0x501a310", "0x32220ecd", "0xbf1e379", "0x212faed2", "0xb06ccf3c", "0x93ae70ab", "0x9e1f14fb", "0xf3f133f3", "0x31e4e2d7", "0xd7be051c", "0x2b15bf0", "0x62d052f0", "0x4346ce64", "0xb29d4dab", "0x913eedf4", "0xa501a30a", "0x2232ef1c", "0x1fbffb", "0xf3b3403f", "0xf500baef", "0xcb14b164", "0xe3ddc2d2", "0xbfa3ffb5", "0xaf3ed112", "0xf7253ef5", "0x400f301e", "0xfe11437c", "0xde10c51f", "0xeb5f90e4", "0xb1a9159e", "0xe304f03d", "0x1200c6b9", "0x9fd23020", "0x3a4dd30c", "0x512ff21", "0xecd0ea03", "0xbefd02de", "0x2b11d9e", "0xe7d0020d", "0xd10b310a", "0xbec202a0", "0x2e310440", "0xf0d2ded2", "0xfdf1e902", "0x103b00e1", "0xe3e2fffb", "0x93dbc011", "0x1ef00e4e", "0xe21d00fb", "0x4b0e0260", "0xf1d2f005", "0x4c101a1f", "0xd1fdeef2", "0xb7f6121d", "0xb1fefcf1", "0x1cc94eee", "0xfd22e53b", "0x341c04c0", "0xf52cd0bf", "0x5ff4120", "0xcf9a040", "0xc22fc361", "0xff153ddf", "0xe3f704dc", "0xa1f11edb", "0x4c210619", "0xc2dc3bc", "0x5700d4bb", "0xd2f093fe", "0xa4feef2a", "0x2f72bd9d", "0x33f7330e", "0xc231233e", "0xbad963eb", "0x294b6bb", "0x356040fc", "0x3f10d1a", "0x3a130f14", "0x9db35a0c", "0x6e1f70e0", "0x7934f594", "0xff0262e0", "0xbff50ed", "0x4303e01", "0xf4f5de34", "0x1bff1406", "0x9d131af0", "0x15de33f2", "0x100d93c9", "0xfcc075c9", "0xc6eefff", "0x176f9051", "0xf52f16", "0x1cc30e3e", "0xee57ee92", "0x620053d2", "0xddd9d1dc", "0x59fce31c", "0xe0111bf", "0x210f0014", "0x55374f1b", "0x5d1ddbbb", "0xc961dc0e", "0x55dd0bfc", "0x34e115df", "0xf1ad602f", "0xb90bf5", "0x224f19bb", "0xa143f101", "0xedfcbacb", "0x992efdf4", "0xd12ccc40", "0x13a1a5f3", "0xfa1220", "0xd2c50f2", "0x36bf9d70", "0xc3ece7ef", "0x1d9939ef", "0xe9c21ef3", "0x330f1b30", "0x4d90415c", "0x2453eed0", "0x1d4221c1", "0x42a10e10", "0xd0c0277c", "0xf13ce5fe", "0x2fcddc1f", "0xfe1e0f31", "0xe40de16e", "0xcccd33db", "0xd101f61", "0xfce01111", "0x3aff120e", "0xe5501f01", "0xc21c1e00", "0x2ef13e6d", "0xd1f20b22", "0xe100669e", "0x2f0d21", "0xdd0f2e00", "0x3d4b2cff", "0xdfe03021", "0xb61bf1be", "0x31ee5e2c", "0x16e54e3f", "0xcc32031f", "0x1e22e3cd", "0xb0f2bd0", "0x12002d6e", "0xcf01f50c", "0xdfcb3cc", "0xd01fdd6e", "0xd2f10120", "0xdc2030de", "0xfdf23352", "0xbaf1d1ff", "0xbcb11e1", "0xae2fdabf", "0x1e4c9002", "0x20101cb2", "0xb71eff21", "0x2f0b41be", "0xc025331", "0xd01cd13", "0xe4d7bff", "0xbca9cda4", "0x1e0c9fd0", "0x1e0d29de", "0xe1f1f9b2", "0x1bbccc9", "0x3bfdf3f", "0x1000d9ee", "0x2e4f0e3f", "0x21f05ef", "0x23ed22de", "0xcffcf30", "0xe0102fe2", "0x2df06e2a", "0x1eef2513", "0xd40021ce", "0x203c4211", "0xf2620e05", "0x703dc1e2", "0xf12ef0f1", "0xc1e1fff2", "0xf51e43ab", "0xff0d43df", "0xe2d0932e", "0x1e0e3a1b", "0xa1cf0d1", "0x2fead0f3", "0xe04ffbdd", "0xd0bffcf0", "0x3fe000a", "0x1b0ef1de", "0xe700b0eb", "0xe3d0e1e", "0xf131c093", "0xde1d2d31", "0x15fcee53", "0xcf5607e3", "0x4027d2c3", "0xc473bbd", "0xdd31fe11", "0xa4f1114c", "0x9e01fab", "0xcffffc0f", "0x61421f44", "0xb733e000", "0xc565ea2", "0x12674cf3", "0xf940df14", "0xb36f03e1", "0x50d040f3", "0xd0e5d049", "0x51536d11", "0xb2090fe0", "0xbd3f4f07", "0xf15513ac", "0xf95fc1dd", "0x94130c3", "0x263f32e", "0x2fe7d07", "0xf0dde0f2", "0xbafee92", "0x114ed3bb", "0xdbcfa2e", "0xfd11d32", "0x4bffdc1d", "0x2f73be21", "0x20eb5e65", "0x1dfed171", "0xca1214ed", "0x53f1bc9c", "0x10cb96c", "0xef51da91", "0xddbed1f2", "0x1c3fc930", "0x5f12f140", "0xe132fee", "0xbee3ea0f", "0xc4d6ed9f", "0x23cd9c2", "0xa0c011a5", "0x9ade4dd1", "0x2564ebf3", "0x73eb23ef", "0xdf5bd0c0", "0x90eb320f", "0x202ed1fb", "0xf3df09fb", "0xe2f0dcee", "0x1b5b031f", "0x3151eb34", "0x11da4ee6", "0xb12cdd1a", "0xdfe177b", "0x130ad1bc", "0x2f3a93e", "0x14f1dbb9", "0x393ff1ff", "0xc0bddd2e", "0x70fb22d7", "0xd39cedfb", "0xe3fe0770", "0xc2bceede", "0xf6efaf2", "0xd33f0da2", "0xa2220121", "0xd3b14c14", "0xd2332cce", "0xd701119d", "0x2bd9bb31", "0x71d527d1", "0xec0f90e", "0xb7ef9bba", "0x9ef1d400", "0xaf37e0b1", "0x43932af9", "0x56dc27f3", "0x661bca00", "0xd13763d6", "0x6fe41f", "0x963fbfd0", "0xc4791e13", "0xe010bb0f", "0xafd4ee2c", "0x411f31a0", "0x5ff9ca1f", "0x13aef502", "0x1b45e2f0", "0xb000e5c9", "0xed5ad351", "0xdd933bc6", "0xe6a520a1", "0x3b303fb", "0xeb5cc936", "0x2f67ef94", "0x120f0f29", "0x3d5f0f4e", "0xee20c3", "0xca77fcf3", "0x4fb43fb6", "0x3dde477e", "0x26de0afd", "0x4534e091", "0x3791b52", "0x3d2f9bab", "0xfa39292d", "0xdf11a904", "0xd2f5971d", "0xd97c3350", "0x40a1e94e", "0x420412ac", "0x26f2221", "0x9230c4fb", "0xefeb11ff", "0x924e45", "0xdf92e1e9", "0x4d253f0", "0xf21ce0f5", "0x1ae09bbf", "0x5266fb9", "0x705f044a", "0x22235f93", "0x5e77bd2f", "0x59001cb7", "0x21de5a7a", "0x1c2f54eb", "0x10eaf7a0", "0xf03d26", "0x63fff9cf", "0xd35a232", "0x1cfbe15f", "0x4a50b3d7", "0x30f3cffe", "0xc40d914a", "0x4b27faab", "0x12f12f63", "0xc460ab2e", "0xbf3032e1", "0xd5ff05b0", "0xd7af3df7", "0xf30efb00", "0xb002093f", "0xfb3c019f", "0x79cdf97", "0x5e101e49", "0x9f4e3df", "0xe5ce2bde", "0x201c4bf7", "0x45c0d07e", "0xe3a10f3b", "0x22dfb12c", "0x59ecfe3", "0xdf20ed2f", "0x1f0ff01e", "0x395ff1c4", "0xdafc4cef", "0xded32f5f", "0x142e1e0c", "0x10e2924a", "0x1c1d304", "0xd4fff021", "0x31cb1aec", "0x30cee6fa", "0x42c0660", "0x2ffffbf3", "0xe5c0f02f", "0x5dd1d39d", "0x1901e97", "0x5e3fedd9", "0x4de01e0", "0x3eff1d1", "0x101c23a4", "0x560d0b4f", "0xb4e000fb", "0x50d1ffcc", "0x4b42cb2", "0xe02f9ee1", "0x1d3ddb0e", "0x2951f1de", "0xe00a29b1", "0xe2405e2f", "0xfef970c0", "0xf0929eff", "0x4e42bd5", "0xc001251f", "0xd0bad0a", "0xdcaff300", "0xa1fd063d", "0x1dffcb97", "0x9200cc24", "0xed2a13d3", "0xa9220ac", "0xfde09cda", "0x37ca116f", "0xfc3ce40f", "0x1ced1cd3", "0xe3333e05", "0xd24fef6c", "0x540d1af", "0x109e23cd", "0x10f0d3e2", "0x6d0929d3", "0x2d71e2bf", "0x7cfd3911", "0xf2135e31", "0x101aad2e", "0xffd19c10", "0x1ef3c10", "0xf3112010", "0xe5909ec", "0x744e2d5b", "0xff50910", "0x42e6feff", "0xf3acdccc", "0xeb71f3", "0x1ecbe00", "0x45c06b34", "0xf0141054", "0xb513319b", "0xcb2ed950", "0x9f2df039", "0xb9da2ef4", "0xc4092a5e", "0xcc7320b", "0x1e9fde21", "0x1d11914d", "0xf2ffc1c7", "0xda157342", "0xb0ccbe1c", "0x15c9f071", "0xccee417f", "0xfecdd505", "0x2370040e", "0x7c6b12c", "0x7c3e402c", "0x2e145a2d", "0x615dd23c", "0x3f36eac", "0xe033ede2", "0x191f52", "0x4df0e31", "0x42112070", "0x550e5f90", "0x7d2dd94a", "0x9f34c20d", "0x9e04f64", "0x21dccd0e", "0xffd31acf", "0x2cfa1d5", "0xde519dee", "0xe43e1ce1", "0xa022370f", "0xc3f1a599", "0x77ce43ff", "0xf0ed641", "0x194e410d", "0x5d30e303", "0xe6ffdf71", "0x7907064c", "0x1f2f9ce7", "0xbc62da12", "0x20e0d01", "0x5d1d3eab", "0x1eddf01c", "0x4331cb7f", "0xf1ce3222", "0x7522c3c4", "0x320d0b33", "0x2a71c14d", "0x2d11c33a", "0xd3f131d0", "0x44ba611", "0xe6d1fe2d", "0xa5ec1fb2", "0x4b34e1fc", "0xee92fb6b", "0xde04b417", "0x1100f3d5", "0x5dd1ef7e", "0xfe24db1e", "0x3b0dc5c", "0xe4fddf62", "0x5295f31f", "0xcf122315", "0x104e5e24", "0x3d2a4113", "0xf140fed2", "0xf4e501e", "0x4ef0f54c", "0xc6dfd1f2", "0xffd35224", "0x141014f1", "0x135c5f00", "0x2e2be3e2", "0xf21020e0", "0x113d3101", "0x1e01f252", "0x5e3ddf3", "0xdc105461", "0xe2df162d", "0x52422bf3", "0x2cfbc210", "0xc220f6", "0xf41ebf01", "0x53213e00", "0xd550dff", "0x73cc1203", "0xf0ddffe2", "0xfd05dd27", "0x41e17701", "0x1113f737", "0x5424cdf", "0xf2f0f430", "0xe10e02d1", "0x20ef4f14", "0x1210b03f", "0x20de00f0", "0x301003d0", "0x2652c240", "0xf0112ff4", "0x1e001022", "0xe204a10f", "0xda1d3233", "0xde2435bd", "0x4d12f243", "0x4feff200", "0x4064f52", "0x212e003", "0x530f3d2c", "0x30371ee0", "0xd4a01403", "0x41ac09f5", "0xcdad23c5", "0x5d0a501f", "0xdff0c535", "0xff540e50", "0x41206221", "0x5001df0", "0xed32fde", "0x1f21f1ff", "0x23014012", "0x6103121f", "0xd3fac023", "0xb721500", "0x4f002fe5", "0x4f4df2d", "0xac0ff00", "0x2f1201e1", "0xe0f4202", "0xf0f02fff", "0x3210114f", "0x4ed2e2", "0x7f11f2f2", "0x10f7b317", "0xd42ef01e", "0x30fdff00", "0x10bef0ee", "0xd4dfdaf0", "0xef0f60fd", "0xf00fe1e", "0xece10def", "0x1d1fff0e", "0x11e0e00", "0x40ff2001", "0x10fcf110", "0xe2efecff", "0x12e22eb", "0xf00130fe", "0xe0d0f1fc", "0x1c2fee0f", "0xef0d1f05", "0x21f130df", "0xd001ff2f", "0xf6ff0def", "0x210ee12d", "0x1bf2405f", "0xe0f031f0", "0xfe3dfefe", "0xf20f12fe", "0xd3f0", "0xffcd10ff", "0xd1e0fb0f", "0x1e2f5020", "0xe00de2f", "0x100dd11", "0x1f4101ed", "0xf0111f0", "0xf10fe2", "0xffede1f", "0xe0100f2e", "0xe01f11ee", "0xf1010f0", "0xbf00eee1", "0xdf21001f", "0xf110f2d0", "0xfee2c0f", "0xeff0cbff", "0xe4eff00f", "0xcc20fc", "0xdf00e00", "0xe1c011e0", "0xfe4f040d", "0xf150240f", "0xff2fe", "0xf2e01003", "0xfd00f910", "0xd114fdd", "0xd011011", "0xf5e0fd00", "0x1d2f0f0e", "0x200f000", "0x10ff0e10", "0xe1ee0001", "0xfd3fff0f", "0xf1e1fcd", "0xff0111f0", "0xc20ff101", "0xfe3e2011", "0x1010f0e0", "0xfefe0d10", "0xeed0e010", "0xed011e00", "0xfdce20cb", "0xfd2f201", "0xf2dff1e1", "0x2e3d032e", "0xcf421032", "0x2f0df7cf", "0x231cb4fd", "0xf5de35d2", "0xf3ab0e09", "0xe2fe0c", "0xefe01b43", "0x6aec92fe", "0x31f13994", "0x51c60399", "0xc1fe3fcf", "0xaa29e7e9", "0xbf9c2230", "0x10cc437f", "0x234001ec", "0x790f92b2", "0xfef09de", "0x1e0b2f3d", "0xbcb69210", "0xbc24f4f3", "0x12d914fb", "0x1f95f6d9", "0xf0ff0b93", "0xd0f29d24", "0xa1e241e2", "0x19fdfadd", "0x9ef362ef", "0xed923f4f", "0xf5f1e229", "0xfcf24c1f", "0xf500f25e", "0xcf3e9ab4", "0x92a7e0f0", "0x9c37160e", "0xf31e6011", "0x3710f4c7", "0xf712665", "0xe79252c", "0x3c407311", "0xb7a7fbf5", "0xf39e00b2", "0x11522cfd", "0xe02a90eb", "0x77e2022a", "0xe1d0e04", "0x1b443341", "0xe0b1ee9f", "0xff3deea", "0xe3c30f1f", "0x1e4fcf0e", "0x910201b1", "0x5015e3d2", "0x2710dbe9", "0x30bfc75", "0x3f502ce2", "0xc11faf40", "0xd2cc5cab", "0x133cd00d", "0xc39501d1", "0x3a7ef14", "0x521ffc0b", "0x149ff9e4", "0xff21220e", "0x70e40053", "0x1a01dcc", "0x5ed1bd3", "0x3ee90ee", "0x30f52cce", "0x521d1dfa", "0x920afe", "0x353fcf2d", "0x9e2ee1ee", "0x1ecbd0fd", "0xf2feff0d", "0xdf90e5f1", "0x91ddcd60", "0x92f9fd1e", "0xfde2230", "0xf1100010", "0xe30f2219", "0xc3f20cf", "0x21ffb02", "0x1ecfc120", "0xacd5fc41", "0xed2d7ece", "0xfe2141f", "0xd02013f1", "0x3cff3d19", "0xde2cc0db", "0xb5effc0c", "0xfba1021d", "0xaa15bc42", "0x5e1dffee", "0x1e02aded", "0xd0e11d1d", "0xbd1d1d29", "0xdee0e69", "0x4550ef6c", "0xfee297c5", "0x140d2330", "0x330e3001", "0xff3c0c2e", "0xf760ee2f", "0xf2337c50", "0x1dbcec3e", "0x41521120", "0xa4e393df", "0xeef0cd00", "0x3ffedb2", "0x10f20040", "0xd13d", "0xf312fe10", "0x4dde0e1e", "0x62030da1", "0x20d10fa1", "0xfff0b12f", "0x4db1e13", "0x13ff02de", "0xe110bc00", "0xed2d530b", "0x3c0e1e0e", "0x3a210765", "0xe6b2c2bd", "0x42d9c22e", "0xff2ca31e", "0x421019", "0xd20cce1", "0x1ea54109", "0xda2e0e22", "0x4e1ed14b", "0x52d2f4c3", "0x1df9ffe3", "0xd7f0f2e1", "0x170130", "0x100ec2", "0xef922032", "0x1b2d1172", "0xfe30b0db", "0x61fa00b2", "0x3d00ece1", "0xe73f5d95", "0xf040e5ee", "0x3551ed0c", "0x2fbb446e", "0x721be407", "0xd2ca7ea0", "0xee1f2f", "0xe12e9052", "0xac0590e6", "0x4af1dfc", "0xfb61a65d", "0xe15ef6d6", "0xd79b12c", "0xcd105c07", "0xf52c2324", "0xb409e36d", "0xae47d1d4", "0xf4cd3f75", "0xcf6f96aa", "0xfe72ffd0", "0xe01c392a", "0x157ecf40", "0xae9490e", "0x22cd2e0", "0x330fe415", "0x14e1b703", "0xac3fa090", "0xede24950", "0x224f004d", "0xdfd950e0", "0x1b11c225", "0x9e19fc12", "0xb024ce9d", "0x29d7e7c", "0x971915f", "0xae214797", "0x3a701241", "0xfcdf2b04", "0x3ef0e075", "0x930ddd2b", "0xe13db39f", "0x1d9f2a77", "0x1b6f94e3", "0xd151f7a1", "0xed10fc4b", "0xe102ca20", "0x1df1702f", "0xffe0f19", "0x311f04ef", "0xdfbc546", "0x1e009ec7", "0xb2dd351e", "0xcb61241b", "0x56a9e14b", "0xdc0dfe73", "0xbf0411b2", "0xbed24fb1", "0x4943a30", "0x10109522", "0x31491490", "0x9b7ff16e", "0x43fcbe3d", "0x1afafc2d", "0x925f679f", "0xe1cf3fef", "0x902c51", "0x13f0c61d", "0xcb22d59e", "0x99fdd070", "0x161ae2ba", "0xaa9e713e", "0x926d0219", "0xfe4a2210", "0x1c0fc33", "0xb110b2a6", "0xff4e3ed2", "0x30b209bc", "0x211235a2", "0xd59c1cfd", "0x30293a2", "0x2e093a2a", "0xbff9d31", "0xf3d1c202", "0xe919f20", "0x3542bc32", "0x4a1f24a0", "0xd1fae390", "0x1dc9dff", "0xa0c90e05", "0x39e9d19", "0x43e031ed", "0x7ce19493", "0x55f21a0d", "0xef22190", "0xb1c9c0d3", "0x6d129f6e", "0xe21f7d3d", "0xcb5912f", "0x2ed1ffde", "0x2da493e4", "0xdda10a11", "0xaaf0f3fd", "0x3ed2be3", "0xed329eaf", "0xb1ed0f2", "0xf33a9bf1", "0x3f41df20", "0x11a12cd0", "0xf1d6edaa", "0xd26332cb", "0xe7523f06", "0x91dc9e2d", "0xc1b03d3", "0x139de102", "0xf5714e6c", "0x70955ef6", "0xcfc2e0fd", "0xac400c9f", "0xe15ef4f3", "0x9ca5a5ee", "0x1eb20d1", "0x1092a301", "0x4ef06d23", "0x5922fc07", "0xb5ac1eca", "0xd20e1cdf", "0xb5d41fb0", "0x9351efed", "0x7eb1fb2b", "0x22aeaf1", "0xac51a3c3", "0x41c1090d", "0xa4de1ee1", "0xe0192de3", "0xb7270db1", "0x96a7d90b", "0x39c31403", "0x159139e7", "0x94bf5ee3", "0xfac6312a", "0xa2fdfdac", "0xd0ed3bf2", "0xf2ecf9f", "0x9316ef3e", "0x10a1043c", "0x2913c93", "0x300fbcc", "0x2ee724fa", "0xbf422200", "0xbffb2bf0", "0xa01effd", "0x5cdb1e33", "0x1ef9df3e", "0x11f7f4d0", "0xee02f40", "0xf4f4fe2d", "0xe0f2d630", "0x31e52795", "0xf20f4e21", "0x241e111c", "0x20f4fbe2", "0xef91c11", "0x3331e33d", "0x3c317f3d", "0x1eec3d1e", "0x131421dc", "0xf1d403e0", "0x302f01c1", "0xf01c00c4", "0x157d01d", "0xcd200010", "0x4d4c2fde", "0xa70a2a90", "0xb1793f2d", "0xac11ae91", "0xe103125e", "0xd191ce0a", "0xf3a62e10", "0xeedf9db5", "0xfb20a12a", "0xcbd4e262", "0x10970792", "0x4d02111", "0x12f210a7", "0xf333e703", "0x1ac2c03", "0x430f437f", "0x100e2030", "0x55c2fe14", "0x267ccd10", "0x1232cfe9", "0x50413fc", "0x1f09142f", "0xc7f3340", "0xabd03dfe", "0x23e53eb0", "0x50bf2d1", "0xdf1cfa13", "0x9d321101", "0xefebf010", "0xef04b42b", "0xff209ff", "0xf0f0ed13", "0xa0eec010", "0xbcf34e70", "0x1fe414cc", "0x21c24403", "0x2ef1bf3", "0x13e4120d", "0xeef10fd", "0x4ef14f10", "0x76c02146", "0x21121041", "0x3efa0d", "0x2f43211", "0x4c133cc1", "0x42dee00", "0x15e1707", "0xd320ef2c", "0xdd4530ad", "0xb13af0c4", "0xe102afbd", "0x99610ff4", "0xbfb5e0e", "0x2205511", "0x1bf22491", "0x6e0b1e5", "0x1d6dd30c", "0x2f091124", "0x674939d", "0x1e150ebe", "0xa67d512f", "0x10e53571", "0x1f4f5393", "0x111fb21", "0xec7d3e0c", "0x21f943d5", "0x432155e", "0xd096e217", "0xf25e0325", "0x2329e000", "0x1c2e0aea", "0xfc114330", "0xfd30e3ed", "0xce79a500", "0x4f15c9ec", "0xce041e9b", "0xf9f17660", "0x66fb177a", "0xb2fe703", "0x95bf1233", "0x5cbdc23b", "0xd609ef4f", "0x43731a29", "0x4bacd1ae", "0x42f362ce", "0x5323347e", "0x147f33e2", "0x97f10164", "0x221bf0d0", "0xf299420", "0x4112725c", "0x5e939fa6", "0x1f4201b1", "0x13f91272", "0x3730bde", "0xc000c703", "0xae0f2212", "0x53019e3d", "0x21f0d012", "0xeb234f30", "0x7e240c70", "0xf202112c", "0xb5ea537", "0xf24000fd", "0x2cba33f4", "0x2f2dfbaa", "0x34111f39", "0x11ee0e0e", "0x620323f5", "0xd3be016e", "0x1659000", "0x130f5c62", "0xe32fedc3", "0x74101cc3", "0x304fa939", "0x3791dde2", "0x292311fe", "0x410ac1d3", "0x25122a5", "0x2cf02020", "0xec2c3924", "0xfcd1f2e2", "0x2fcfdafe", "0x2e24f0d0", "0x91201bb2", "0xc1ebcea", "0x110dff4a", "0xe2ff126e", "0xfefdede9", "0xfb0ddde5", "0x3bdfed10", "0x3ebfffa0", "0x901a0cf4", "0xcc204e01", "0x1dbc4fe", "0x102104f0", "0xfc231d3d", "0x3f3ad4d7", "0x14f20cac", "0xd0dd2ae", "0x93f1ecf0", "0x9dd0fd2d", "0x10cee10d", "0xcf31b5ee", "0x1c330746", "0x1ddd1d02", "0xe20ec211", "0xbddd00e2", "0xa0f2107e", "0xe40ebbdb", "0xfb2310", "0xe52f1f2c", "0x20e9f1fd", "0xef5e0d20", "0x101a2f11", "0xdedd22f0", "0x9009fd0f", "0x3d22e2db", "0x1ce1ff35", "0x910fd041", "0x21300230", "0xd621dec3", "0x200b16ce", "0x93ecc3d2", "0xa01d0de0", "0xcb22ddfd", "0xc0e2b41", "0xef1fd2e0", "0x2f32e436", "0xbffac15e", "0xc01fba23", "0xbd4df3d1", "0xd7f242", "0xcff1b0cf", "0x12ef5321", "0xe420d050", "0x4ded0c7", "0xc21ced0a", "0xd2decd1", "0xcf2e12cd", "0xe0d35b23", "0xd3fd591", "0x1dd06321", "0x3d00cb22", "0x1f3d0b13", "0xb30f0bf9", "0xfedb011f", "0xa02e05c5", "0xcf02fd3f", "0x3011d3da", "0xce35f10", "0x4dd0cbef", "0xfe1f6aec"}};



const ap_int<13> conv_6_inc[2][32] = {
{"0x333", "0x208", "0x18b", "0x8b", "0x526", "0x2c5", "0x2a0", "0x31c", "0x27b", "0x23b", "0x20f", "0x220", "0x1a2", "0x653", "0x221", "0x1df", "0x64e", "0x8c5", "0x222", "0x336", "0x26d", "0x2ed", "0x2af", "0x1dd", "0x1de", "0x248", "0x359", "0xa1f", "0x1f5", "0x26f", "0x1c7", "0x1d7"},
{"0x2a8", "0x26d", "0x2cb", "0x1ba", "0x410", "0x199", "0x322", "0x270", "0x2ec", "0x18c", "0x63b", "0x1b5", "0x244", "0x1b9", "0x678", "0x1ee", "0x219", "0x337", "0x46e", "0x359", "0x252", "0x438", "0x180", "0x556", "0xb14", "0x262", "0x644", "0x387", "0x371", "0x2e1", "0x22d", "0x6d4"}};



const ap_int<22> conv_6_bias[2][32] = {
{"-0x73a58", "0x2f374", "0x1a1fd", "-0x6fb7", "0xb3a69", "0x2995e", "0xd0018", "-0x5c0c3", "-0x4f45f", "0x37dfe", "-0x10480", "0x2d4c4", "0x5f059", "0xc86be", "-0x589", "0x31477", "-0x491da", "0xc06d6", "0x518a0", "0xb065", "0x7412b", "-0x668d3", "-0x1922c", "-0x85ea", "0x38f59", "0x12151", "0x88898", "0x19ba70", "0x21cd5", "-0x52aad", "0x39404", "0x348cb"},
{"0x1f3e4", "0x19320", "-0x19df9", "0x578ea", "0x2884", "0x1456b", "0x69eac", "-0x3f82", "0x48694", "0x18ac5", "0xf09d6", "0x3cabf", "0x2596b", "0x653ab", "0x1c0e72", "-0x644f", "-0x1a07", "-0x4529a", "0xcadf7", "-0x8e37", "0x2fe3b", "0xa428c", "0x3b7b9", "0x570c", "0xebee3", "-0xce59", "0x85816", "-0x4db6b", "0x7f236", "0x508ab", "-0x3e0a9", "0x11495e"}};



const ap_uint<32> conv_7_w[2][2304] = {
{"0xe1e01f9f", "0xed1fe100", "0x121210ec", "0xf023132", "0x1fd0f5f0", "0x14fd2312", "0x210014f", "0xd11f130", "0xf02f039f", "0x10dfc00c", "0xc21fffed", "0xc0210f5", "0x9f43b600", "0xd00434f0", "0xf50e7251", "0xf3f", "0x112043f0", "0x1ed02f1f", "0x2f0f3f22", "0x3fe1f22", "0x9e5be50e", "0x1f37161d", "0xf310fe64", "0xf12d1042", "0x10c09d11", "0xf0c079f1", "0xfd0ecea4", "0x311e3f19", "0x1d2e152f", "0xfae0e303", "0x3ff9f4f", "0x30f151c1", "0x10cecf22", "0x9fcb79fb", "0xd0f30b5", "0xe13c2fed", "0xe93314ef", "0xd97ee0e5", "0xe5019f6b", "0x3b0f72d4", "0x1f5ffc02", "0xa0f0e91f", "0xcefe2405", "0x152edf1", "0x2935f510", "0xd41c9612", "0x430745e", "0x1fef72fc", "0x302e5fc0", "0xf0f22ef1", "0xf221e045", "0xfd60ff5", "0xf51113d0", "0x201ce43e", "0x204f40e1", "0xde00d14d", "0x102f22bf", "0x5e33ff10", "0x1010b047", "0x2140d046", "0x700f33d1", "0xee33e03f", "0x34313f23", "0xe113d243", "0x4fee5f", "0x64411401", "0xd21f00e2", "0x23de21e", "0x65ec2323", "0xef16f43f", "0x23131f33", "0xf1001124", "0x2ff001ec", "0x121fe12", "0xee311d31", "0x4f033100", "0xf310300", "0xc22010ae", "0xe510025f", "0x302fd10f", "0xd0501e5f", "0x2eff2f14", "0x201de0c0", "0xb1d69f24", "0x30fa2506", "0xc9e2d1f0", "0x351e4f41", "0xc011e12b", "0x40114324", "0xf053f513", "0x5f2f03ec", "0x140d232f", "0x34f932f6", "0x1f12f243", "0x32e20c36", "0x323bc14", "0x2f0eff9e", "0x20100e10", "0x2f00de20", "0xff1d1000", "0x2252f621", "0xca40fe90", "0xd621b25d", "0x30ff11c3", "0xb015430f", "0xf0ce2f3f", "0xa3f914fc", "0xc0051ec0", "0xadfdf4f6", "0xd67fffd0", "0x4002161", "0xed0726a", "0xf03eeff1", "0x326322e3", "0x65025f7b", "0x1331f0", "0xc7032336", "0x2cbffff2", "0x34102244", "0x2623b110", "0x2ff0f2f0", "0xf0fe1d0", "0xdb3f0eb2", "0xe470f40", "0x1310e6f0", "0xcf11e0f4", "0xf41f2220", "0x10221f10", "0xf1cd1e00", "0x60d13a0e", "0x2df0c19d", "0x19cfbc", "0x2ee1f3f5", "0xee32ec91", "0xf4ffcf50", "0xfd0ba1ed", "0x1e312f0", "0xc2ef0d0f", "0xf302f2ce", "0xd11011d1", "0x1b1113f3", "0x2f0e0fe2", "0xf3fe2130", "0xf21eff01", "0x205d0724", "0xd222e125", "0x41f05c4d", "0x93e0ce43", "0x712011f0", "0xde22d44f", "0x42df6f32", "0x1234f143", "0xe10131ff", "0x12729f34", "0x31fffd0b", "0x3f0101f3", "0x502d1502", "0xe123ee2d", "0x15f36052", "0xf4d5c11f", "0xd001100b", "0x20004de0", "0x2102cf0", "0xefd022d0", "0xe200421", "0x4c252ecf", "0xe411004b", "0xef1f0202", "0xb113e792", "0x3170d0f5", "0xf5ea7c5b", "0xfefe21", "0xeeed14f1", "0xc5c0b72e", "0x430f4621", "0x12e0e200", "0xf0f0fb9f", "0xde4d6920", "0xf071c29", "0xc2312fed", "0xc554f570", "0xdd0fddce", "0x6e1af6f", "0x1ff0cc12", "0xe1c321fc", "0xaf913fff", "0x1f2fe0f", "0x4f1f20f1", "0x9230a5e3", "0xf21ffec1", "0xc400df60", "0x2a2000d3", "0xe0cede31", "0xc24e0e03", "0xe20d0fae", "0x105ffdf", "0x22313", "0xf0f2d1f2", "0x3220e010", "0xff1eedfe", "0xff312ff", "0xe0ff1e01", "0xdf2c09c", "0xc34fc0be", "0x15ff6f2", "0xe23eeaa4", "0xd61f9f40", "0xfd2f11fd", "0xe102f1e1", "0xc21001", "0x2f3203df", "0x1f2e0e2f", "0x112fe5f3", "0xfef0d3", "0xd512025d", "0xf0211e11", "0x100f10", "0xf000010", "0xf000010", "0x110f0000", "0xf001f000", "0xf10", "0x100f000", "0xf001f0", "0x100f0101", "0xff00000", "0x100ff00", "0x1000", "0xf1f1f", "0xf000f00f", "0x1000001", "0x1000100", "0x10010f0", "0xf000010", "0x0", "0xf10f00f", "0xff", "0xf010010", "0x10000011", "0xf0f", "0xff00", "0x100001f0", "0xf0fff", "0xf00000", "0x10101f", "0xf10100f1", "0x1000000f", "0x1010", "0xf0001000", "0xf00f000f", "0x1f000100", "0xf000000", "0xff0000", "0x1f001", "0x10f01ff0", "0x1100001f", "0x11000010", "0x101ff01", "0xf0f01f00", "0x10100f0", "0x1000f", "0xf01000", "0x10000", "0x1000f11", "0xf00000f0", "0x10001110", "0xf01100", "0xf0000", "0x100000f0", "0xf10000", "0x10100", "0xf100f", "0xf0100000", "0xf10010f", "0xf00f0f", "0xf00000f0", "0x10f0100f", "0xf01000", "0x10000000", "0xf11ff", "0x10f00000", "0xf01000f", "0xf00101", "0x10000000", "0x11000000", "0x100100", "0xf000", "0xff0000", "0x10000000", "0xf000f00", "0xf0100011", "0xf0000", "0x101f0010", "0x101f000f", "0x10000", "0xf", "0x1f0000", "0x10100", "0x0", "0xf00f0f", "0x11000000", "0x11f00000", "0x0", "0x110", "0xff000000", "0xf00001", "0xff000", "0x101101", "0x10010101", "0xf01f0000", "0xf0001", "0x100", "0xf0000000", "0x1000111", "0xf0f01100", "0xf00f0f", "0x1f0f0000", "0x10100001", "0xf011000", "0xf00f000f", "0xf0f01001", "0xf001000", "0xff1000", "0x1001fff", "0xf001101", "0x11110f10", "0xf0100000", "0xf1000f", "0x1f0f001", "0x100ff01", "0xf000000", "0xf00", "0x1011", "0x100f001f", "0x0", "0xf0f", "0x10ff00f0", "0xf0", "0xf10f00ff", "0x1011100", "0x101001", "0x1000000f", "0x11000010", "0xf0000f", "0x10000010", "0x100f100", "0xf0", "0x1f00000", "0x100ff1", "0x1001000", "0xf1100000", "0x10f0110", "0x100000f", "0x11010", "0x0", "0x1f000f00", "0x10", "0x11001000", "0x1101", "0xf000f", "0xf00ff000", "0x11f0", "0xf00f01", "0x10011", "0xf000", "0xf010f", "0x1f010100", "0x10000000", "0xf01", "0xf000000", "0x10000000", "0x10", "0x1f000010", "0x10010", "0xff0f01f", "0xf000", "0xf00", "0xf000110", "0x101000f0", "0xf", "0xff0", "0x100", "0x100000f0", "0xf0f01000", "0xf10f0f00", "0x11f00010", "0xf1100", "0x1f0ff000", "0x10f1f0", "0x100f0f0", "0xf0f0f010", "0x111000", "0x101f000", "0x0", "0x100010", "0xff000f00", "0xf01100f", "0x100100", "0xf0f", "0x100000f0", "0x10000", "0xf00110", "0xf0f000", "0xf0000", "0x1f0f1100", "0xf0110000", "0x10f00f00", "0x10000100", "0x10000000", "0xf001100", "0xf0011", "0xf001f00", "0x10000010", "0x10101100", "0xf00000f", "0x100", "0x1ff0f01", "0x110f1000", "0x111101", "0x10000000", "0x101f0", "0xf000010", "0x1f0ff0f", "0x100110f", "0x10f00f0", "0x1f0101", "0x1001f000", "0x10100000", "0xf000", "0xf10000", "0x100000f", "0xf00000", "0xf0111", "0x1ff0f0", "0xf00f0000", "0x10ff0000", "0x10f0", "0x1000000", "0x100100", "0xff", "0x1010000", "0xf0000", "0xf00000", "0xf1001", "0x1f", "0xf010000f", "0x101000f", "0xf00ff000", "0xf0f000", "0x10000000", "0x1000f0", "0x1010f00", "0x100100f", "0xf0000f10", "0xf000000f", "0xf000000f", "0x110ff0", "0xf100f00", "0xff000", "0x1f00001", "0x1001f0f", "0x1011f000", "0x1ff000", "0xf010000", "0x10f0010f", "0x11100000", "0x100100", "0xff", "0x1001f01", "0xf110000", "0xf000f", "0xf01ff000", "0xff00", "0x100f00", "0xf0001f00", "0x10000ff", "0xffff0000", "0xf000f000", "0x1010f0", "0xf010ff0", "0x10100f", "0xf1f00ff", "0x100000ff", "0xf00f00f", "0xf1000000", "0x1f00", "0x110ff1", "0xf0ff0", "0x10000", "0xf01001f", "0x1f0f0100", "0x11f01001", "0xf0000001", "0x1f100000", "0xf0000000", "0xf00f00", "0xf0", "0x10000f", "0xf000f000", "0x1000f000", "0xf0ff00", "0x1000f0f", "0x0", "0xf0f0000", "0xff0ff0f", "0xff00f0", "0x10000ff", "0x10000", "0xf00f000", "0x100f00f1", "0x0", "0xf000000", "0x0", "0xf000ff0", "0xf0001000", "0xf1011001", "0xe10f0000", "0xff", "0xf210100", "0xf000f02", "0x110f0", "0xf00", "0x1000f1", "0xf01f1f1f", "0xe000f100", "0x1000ff0", "0xe0000010", "0x10f110f", "0x10c0ff10", "0xff021f0", "0xff0d3", "0x101010fd", "0x10f0f0f0", "0x1ff00d01", "0xef0e", "0xf10e0", "0x10dffe13", "0xd1f02ff0", "0xe01f01d4", "0x101f1f0e", "0x100", "0xf00ef002", "0x110de0f", "0xe1f01e1", "0x10f1fef1", "0xef0ff100", "0xe01003f3", "0x11010f0", "0x20000", "0xf10efe0f", "0xf010f01e", "0xf0f0000", "0x2f202f00", "0xf0000110", "0x1001ff22", "0x20012", "0x12111000", "0xff00012f", "0x1001", "0xfd01012f", "0x1f100001", "0x2122f302", "0x100fe133", "0x2f11f032", "0x520f20ff", "0xf1e030", "0x20213f01", "0x11e231", "0xf0111", "0x30310311", "0xf00fff01", "0x11000120", "0x430e0f00", "0xf013f021", "0x1120e00", "0x1f01f012", "0xe1d100ce", "0xfdff0fd", "0xf10f3e1", "0xe1e0fed", "0xe1f0f3ff", "0x1ee211e", "0xd302e011", "0x20ef0e10", "0xe03efffb", "0x1bc0f3de", "0x110ef12", "0x9d24f2b2", "0xc051030f", "0x201f6cf1", "0xc23fd02e", "0x2efe02ee", "0x5f420f24", "0xf0205114", "0x10300", "0x121b4161", "0x31ff2202", "0xd0bfd504", "0x320d2f24", "0xe30ef2b", "0x11f2ae90", "0xfebfd0f9", "0xb0d00d0", "0xdfc0f0e", "0x32ff42f", "0x910231f", "0xe1f19f20", "0x21d20d02", "0x1020621a", "0xcb915d0a", "0xfe21ee22", "0x9103f0d3", "0xba43d3e0", "0x137f7cf0", "0xe311f03d", "0x90071e2", "0x10400e35", "0x344c9b27", "0xe40df632", "0x1241034", "0x11012303", "0xc0afd644", "0x510e6024", "0x73f9349", "0xf0d3bf11", "0xdede000d", "0xed1fd0d0", "0x1e163e0f", "0x10fff211", "0xfc11f0b1", "0xd0e1e101", "0x10f01f10", "0xff1f55fd", "0x3a95101f", "0x4f12be12", "0x1019ef12", "0x3c12c2f0", "0x117f5903", "0xb102d03d", "0xffef03ef", "0xf03f2b03", "0xf65abf16", "0xe71e3602", "0x3127140f", "0xd6cf42f3", "0xe2bf0570", "0x320b6023", "0x3310c2a", "0xab1107", "0xf111dd6", "0xd2fe59e2", "0xb39cf92e", "0xf3b23422", "0x92c6de35", "0x14c4d05f", "0xdd31ea24", "0xef91dad7", "0x2d0eedd4", "0xa3be6bd4", "0xa292ecff", "0x9ef6f6e6", "0x956b0f2c", "0xf6139a7a", "0x1cb9a9d6", "0xcf143be1", "0xea300f5", "0xb5cfef23", "0xcf9e21ce", "0xbfd22105", "0xe1fc1ecf", "0x1112ee2d", "0x3a3ae10e", "0x21d9a544", "0xe4602b17", "0x75d939f6", "0x94c299e6", "0x7590721d", "0x9f91c223", "0x76d02236", "0xeec3fd55", "0x5099eb37", "0xe1622c26", "0xeea190cf", "0xcaf9391d", "0x2fdc61c1", "0x996ee12e", "0x66b7ec51", "0xc0a99a76", "0xf0d1c9c1", "0xe0900103", "0xb6ba229d", "0xfea2edc5", "0xbcd4cae", "0xb2712cec", "0x2004dcfd", "0xb1faf0e1", "0xe14036b3", "0xfe75a537", "0x15197f7e", "0xefd15927", "0xa1cf42a0", "0xa3ab204f", "0x337f77f4", "0x2d140d26", "0x19ff16", "0x70773757", "0x40b6fa6d", "0xf33e6c03", "0xf2e042f4", "0x9e7cd2fe", "0x57704643", "0xf290eb34", "0xef3ef110", "0x2ed46344", "0xd4cf4c1e", "0x1fd2f0f2", "0xdcedffd0", "0xe241feac", "0x1204f111", "0xff1e2cf5", "0x222d4", "0xf44fef36", "0xd231312f", "0xc21f2e70", "0x40f1f501", "0xfd700", "0x31f23240", "0x1010005", "0xc1600fdc", "0x2f1df10b", "0xd2f01e20", "0xeaf1e191", "0xbf061113", "0x20422ffd", "0x2fc1401f", "0xfd3aea", "0xd02f01f2", "0x21902fea", "0xe00f0a30", "0xff0f1f10", "0x91010f1d", "0x403674f1", "0xded1fd14", "0xe0f00101", "0xe0ed35", "0x55713b17", "0x22fc0ed1", "0xca110e3c", "0x50f0151e", "0xcd0963f", "0x220e4134", "0x31defd1", "0xfc0dfee", "0xbeee69ea", "0xcf35aa6", "0xcd1972bd", "0xdb22f31f", "0x49613fcd", "0xd1c2af0b", "0x19e12df3", "0x101c0ec4", "0xc1900a09", "0xef0fee45", "0x2d00ffe2", "0xabf3e1cf", "0x421e77e3", "0xded152ee", "0x3f0350dd", "0x3020e1e4", "0xc36e0df5", "0x121b5d03", "0x1cd74012", "0xf21f2220", "0x4eeff43e", "0x4e1f30b1", "0xde20ee41", "0x2fe106ff", "0x2d040a0a", "0x3af5ddf6", "0xfe0b0c32", "0x5a63011e", "0x5ef1e52d", "0xeeb4aebf", "0xbefd4d3", "0x1013ff2e", "0x41ce10fb", "0xd0fde1a2", "0xfed1f10", "0x72f0debc", "0x3025470f", "0xdcb032d1", "0x21001c21", "0xdf13fece", "0xf100210f", "0xe0f0e03e", "0x101e03de", "0xcfde0e3c", "0x13f15ee", "0xfe00f0d2", "0x1fff1c00", "0xd04cf20c", "0x20e0e3ee", "0x11ff0103", "0x9c13d0b3", "0xeee22d0d", "0x122030df", "0xdd0fefd2", "0xdf1ff2f0", "0x4f14e021", "0x2202013", "0x20e1111f", "0xf2dcff4e", "0x3eb12ce1", "0xdfdf27e1", "0x3deef0c3", "0xfe2fe11", "0xfe4aebc", "0xffcf0e0a", "0xfbfd30ff", "0xfeff240d", "0xf0f00e3e", "0x92116e0", "0xcc0eb1be", "0x11102be5", "0x103a33fd", "0xdeb16ddd", "0xeed0011", "0x9eeefbc1", "0xa9d2fcdd", "0x247171ed", "0xfce0d1cf", "0xeacf71e4", "0x3010fe14", "0x242fbf37", "0x22eef412", "0xe1ee1f3e", "0xab03c0f", "0xfdff2721", "0x3ccc7eb1", "0xe60f913c", "0x10d5ae10", "0xd0ed3ffe", "0xbe131df", "0x21073f4c", "0x1f0eeeff", "0x2d1102ef", "0xfde1dfc0", "0xf03f2ef5", "0x4c370f", "0x3c933ffe", "0x1f0ad1e0", "0xfeeabde1", "0xcd1ee1d", "0x12605e1e", "0xbcd2b4db", "0xebeff2f0", "0xff11fe13", "0xf55dff22", "0xe6eb0421", "0x20d4010f", "0xf4be5c0f", "0x10e0234e", "0x2cdd3fb3", "0xd6021f3e", "0xa0cfd0f1", "0x24210d1f", "0x33f02d2d", "0x1c4cdfdb", "0xfbf4f133", "0x1f0f1fdb", "0xdbff0ef", "0x462f19df", "0xdfdeefed", "0x13d21ddd", "0x21e21b40", "0xefaf11be", "0xb1f11232", "0xf5e6cfd", "0xd1ee913f", "0x12e11be0", "0xd00f0101", "0x25e20c0e", "0x12f1ff5f", "0xdc021c1", "0xbd1400f2", "0x2e4a7ecd", "0xd0fd2f22", "0x21f01e9", "0xe1dfdff3", "0xc22d2efd", "0x1cde4ace", "0x1afcf2ca", "0xfe03031", "0xde20ddcc", "0xecb1cfc0", "0x20f019c0", "0x10edbef0", "0xc1bd11d9", "0xfb102e02", "0xcdeffdc", "0xb20307bf", "0xff1e7eed", "0xe0cfe10e", "0xede1adc", "0xf0221102", "0xd4cd010a", "0xde0f02", "0xfdf113df", "0xbd1314bd", "0x23d7cbe", "0xc0fcd01e", "0xfff0fedb", "0x20d2c012", "0x9222f1f2", "0x2aff7ba4", "0xd1fe00f", "0x1d412214", "0xd22042f", "0xedc0efa2", "0xfe100bf2", "0x10e2cff0", "0xe1140d1d", "0xae000d4", "0x21ff2c10", "0xb2007cb", "0x20052522", "0xc0febfff", "0x2e0f1ce3", "0x20132004", "0x1111100d", "0xeec2fb1", "0x2cff2ae0", "0x2d122499", "0x1132631e", "0xdf1e212f", "0xf011fff", "0xff00", "0x101f1000", "0xff100", "0x100f0000", "0x100000", "0xf000f", "0xf010000", "0xf1f00000", "0x1100000", "0xf000010", "0x1100f0", "0x10f00f0f", "0xf00000f0", "0xf0000", "0xf00", "0xf0000", "0xf0000", "0xf1000", "0x11", "0x0", "0x1000000", "0xfff0f0", "0x1f00", "0x11", "0xff10100", "0xff", "0xf100f000", "0x10fff00", "0x100ff00", "0xff100f0", "0xf00f000", "0xf00f0f1", "0xf00f000f", "0xf00110f", "0x0", "0xf0000", "0xf0000f00", "0xf0000f0", "0x1000000", "0x111f00", "0x10100f0", "0xfff0001", "0xff00", "0x1f001100", "0x111000", "0x11000f", "0x1ff000", "0x100000ff", "0xf01011", "0x1000010", "0x1f01000", "0xf01ff00", "0xfff0100", "0x110f0", "0x1f00100", "0xf0f00ff", "0x1110010", "0xf1000010", "0x10f", "0x100000", "0xf010f00f", "0xff000111", "0xf01001f", "0xf0000ff", "0x1f0", "0xf0010f00", "0xf0ff00f1", "0x1f00", "0xf000000", "0xf0000f0", "0xf0f00000", "0xf0", "0xbdf0b0", "0x1ff3011f", "0x2e0d012f", "0xfffd3cff", "0xefd00e0e", "0x121000be", "0x2df30fbe", "0x1e00d04", "0xd010dd3b", "0x2d9e211d", "0xf0f1e000", "0x9e36c1b2", "0xffef2d0e", "0x2ccd20de", "0xfc1dffcf", "0xed1ff2fd", "0x41ff0332", "0xf2d1e21d", "0xfe2f511", "0x223d233e", "0x12b1fd00", "0xdd216f4", "0x1cee01c5", "0x14431000", "0x100ebea0", "0xf0cfed0d", "0x2dfa02df", "0x3d0f4c0f", "0x2f2e3e0c", "0x49e0e29d", "0xfc10aedd", "0x2af1cf2", "0xf0f03f1c", "0xd927e3b", "0xdf0bd410", "0x9df0e2ef", "0x2902fccd", "0x467d6eee", "0xadff0cdc", "0xda2d71cf", "0x4f0110", "0x230fbf0d", "0x52f13322", "0x34013232", "0x30b3cd01", "0x2c232602", "0xd0f5fd6", "0xf242b21b", "0x20ffa113", "0xc0dff20e", "0xfa0c00e0", "0xd155e00", "0x30111e1f", "0x4bf001de", "0xfdc0f3ff", "0xf0b13", "0xd0fc25fc", "0x3e97501c", "0xdd0abff1", "0xdef9efff", "0x2c02debf", "0x45702def", "0xbdb2fddd", "0xcb0d1fd", "0xe035ffef", "0xf5d9cddc", "0xf1215311", "0x40051230", "0xe2de0e2e", "0x4f11231f", "0xfdfcf0f3", "0x14f001c", "0xff00f", "0xff00f000", "0xff00f000", "0x0", "0x10", "0xf000f0ff", "0xf00100f1", "0x11", "0xfff0f0", "0xf01110f0", "0xff00ff00", "0xf10f", "0x10f000f0", "0xf0100000", "0xff00001", "0xf0010", "0x100000", "0x1000f00", "0xfff00000", "0xf0000000", "0x1000", "0xf0101f", "0xf0111000", "0xf1ff010", "0xff1", "0xf001001f", "0x0", "0xff00100", "0xf00f00", "0x110000", "0xf000100", "0xf1ff000", "0x1100000", "0x1f000", "0x1000", "0xf00000", "0xf00000", "0xf0000", "0xf0000f1", "0xff00", "0xf0110", "0xf100f0", "0xff0f0f0", "0x10ff0f01", "0x100000f1", "0xf0f00000", "0x10f01", "0x1f00ff00", "0x10010100", "0xf0000010", "0xff0f1", "0xf10010f1", "0xff0000f1", "0xff100", "0xf000001", "0xf000100", "0x10f00f10", "0xf00f11f0", "0xf0f000", "0xf00000", "0xf0ff00ff", "0xf010f10f", "0xf0", "0xf000f00", "0xf00f0", "0xf0f0ff", "0xf0", "0xf0", "0xf0f0000", "0xf011f000", "0xf000f", "0xf0f0000", "0xc020f0e4", "0x4550fe14", "0x25101f1f", "0xe1ddf3d", "0xc210144", "0x300fe7dc", "0x2fcf11ef", "0x132f2bf2", "0xd16fe0cf", "0x13ff1c0e", "0x1e11e50", "0xeb002bf", "0xdff30133", "0x252600e", "0x1c00110", "0x10fd1aee", "0xd1ff01f0", "0x22d03dfd", "0x12001a3e", "0xde011d2", "0xa005f0e2", "0x20477fce", "0xdffe1d30", "0x120df0fb", "0xffdfdff4", "0xf46f3be4", "0x1fce1db2", "0x90d00f9", "0x2dd1211e", "0xb21970e", "0xdde1cfd0", "0xfe0ac0", "0xce9df1", "0xbfac59fa", "0xfcf14bc3", "0xffff0edb", "0xdef006ed", "0xe2f51ce", "0xf0bed0ff", "0x3ddf69df", "0x10c011a2", "0x91ae0d09", "0x1d0ef43", "0xc1123cf", "0x9004f6bf", "0x42b7bee", "0xbfddb10c", "0x1e02eceb", "0x21f20111", "0x9240ebf2", "0x3d0e6bf4", "0xe361fdf", "0xf41220f", "0x5b22f73d", "0x2e0f2091", "0xee2f0c12", "0x2f11e1ff", "0xef1519fd", "0xad20117", "0x2f0e1b21", "0x393227bb", "0x20f5074f", "0xe2fe1eff", "0x1dfffce3", "0x20e40211", "0x3033120d", "0xfeed1eb1", "0x2c1c1a11", "0x6011139a", "0x311727ee", "0xd1fe323f", "0x1e01fe01", "0xffc200c0", "0xf20e10ed", "0xd21e2e0", "0x1f0204d", "0xd00500", "0x1fff2710", "0xd012c020", "0x2eef01e2", "0x201fefff", "0xf0d0f1ec", "0xfe0f00d3", "0xff021191", "0x911f14f1", "0xe2004ce0", "0xdf11901e", "0xf0ff2fd", "0x3041ff03", "0xe0f12f24", "0xde0e1512", "0xf2fff041", "0x1f212e1", "0x10ff703", "0x201f2d33", "0xfe1fef10", "0x40e2de12", "0x20cf40fc", "0xf0d0c1", "0x1cf41e0f", "0x1d02161d", "0x1a00f702", "0xf000c03e", "0x20e01dee", "0x1fcc0f11", "0xd0923efa", "0xed052ad6", "0xd20d5d0f", "0xfb40d5eb", "0x103c3fe1", "0x3e2a03d", "0x1d1072e7", "0x1f7e0df2", "0x14e1dc24", "0xa4fc0761", "0x2d11de32", "0x1af404bc", "0xe66f0732", "0x2ee7324", "0x210fd0f9", "0x50f22fe0", "0xcfef1a0e", "0x2e111007", "0x1f52024", "0x111002fd", "0x1c3ef620", "0xff1120f1", "0xfd000022", "0x1120f4ef", "0x6de6491c", "0x2df1a037", "0x2e2ad052", "0x79e1f1db", "0x2321740", "0xe0e13ff0", "0xee11f1f5", "0xd12eee40", "0x244c0303", "0xc3fc54f2", "0xf100f01", "0x21bf10e0", "0x3f450421", "0x31f04015", "0x6216c32", "0xdf0210dd", "0x20f1f0f", "0xd1d3e10f", "0x2f0e11dd", "0xbed10f20", "0xf231ffc1", "0xde02feef", "0xf100e01", "0xd1fcf0db", "0x4f9001cc", "0xd0c02113", "0xacb021bf", "0xcfd31d20", "0x3f1141d0", "0xcc0fc3be", "0xcc1d1fde", "0x3f130d07", "0x1fcf1112", "0xe2d31031", "0xd0b10e2e", "0xec7fb01", "0xdffc3422", "0x2cdc00a2", "0x2d104ff9", "0x2fd000ed", "0xb0d22cfa", "0xaf222a2", "0x12fd10db", "0x1cd1ef24", "0xfe520baf", "0xbefea0cd", "0xed1d3fb7", "0x20faeb0f", "0xc1907dce", "0xfdccf5f5", "0xacb30a01", "0x19c43ae2", "0x2270521e", "0x2adeb0a0", "0xdabc3020", "0x60200e35", "0xe010c215", "0xffede7d2", "0xe3b0ff1f", "0x3faf3a92", "0xf0f2772", "0x5acf6e92", "0xe42fef2c", "0x20f0ff1e", "0xe0ef3ffe", "0x2dfff202", "0xff06d1fe", "0x3cf2de13", "0xb5f1fdf", "0xbdf3e2d1", "0xdf0d11d5", "0x5f37c2", "0xff9f242d", "0xd3d9e333", "0xeccffed2", "0xfc9c0af1", "0x1370424c", "0xfbe1c2be", "0xd2f3f102", "0x4fee34", "0x2072c121", "0x15ec2262", "0x53b30213", "0x16af6be0", "0x11cd235e", "0x6bdfeda7", "0xe7031f3f", "0xd04d1f79", "0xfbd320f6", "0x1d52ffb3", "0x1fc40ce2", "0x2f4f6517", "0xe1451d00", "0xe7210f7f", "0x2f0c003d", "0x401e3d73", "0xba057107", "0xf13f0fef", "0xc3edfb40", "0x53796707", "0xdda60054", "0x57323e70", "0x2eff1f6d", "0x400e4c17", "0xf94592f7", "0x231f2faa", "0xf79f1ef1", "0x325927e7", "0xa011dc64", "0x77120971", "0x2320db12", "0xb01d4e03", "0x230bce25", "0xb2c0e92a", "0x1ed1ecd1", "0x9eef6614", "0x900e299e", "0xf7330153", "0x11a0f02b", "0xcf600d53", "0x5552f417", "0xa5097c39", "0x9ee6d9c4", "0x91416765", "0x97d0d2ef", "0x67446273", "0x519e4e79", "0x2dede5", "0x3e6ee107", "0x31e43a29", "0xeea13d0f", "0xa7046571", "0x9a9ed913", "0x7752f375", "0x17d09a5d", "0xf0ccfe33", "0x2ffd2cf0", "0xdf2eb09c", "0x5e1ec1fd", "0x401106ef", "0x90e201a6", "0xc770e110", "0x711de0df", "0x1fd12f26", "0xf3f0ea21", "0xc30c11ab", "0xc141f0bc", "0x313643", "0x945229b6", "0xf7712272", "0x630b5f23", "0xef341ef7", "0x25ffd31", "0xe10045ac", "0xd3e224c3", "0xdf233401", "0x9ecbd0a2", "0x27713263", "0xe40b2c3a", "0xffa01017", "0xf5202e11", "0xef1210f", "0x21c004b", "0x22f1f22e", "0x11efc71f", "0xef12f10", "0x21002d03", "0xe1fef0fb", "0xdff11fea", "0x3ff1eaf0", "0xebd3f091", "0xd141030f", "0x302f790e", "0xc0319e1a", "0x11e0000a", "0x210024", "0x1c22f0f", "0x11001400", "0x11f11f5f", "0x10e102f2", "0x2ffb7714", "0xd1fd3135", "0xf2101ff", "0xe010cff5", "0x244ddf12", "0xf1402c", "0xe9f1026f", "0x2b0f154d", "0xff11a71c", "0xfe0f3213", "0xf1ff0cf1", "0xf00f13fa", "0xfcf415f9", "0x2d21e91e", "0xe0fd01d1", "0x171e7fc", "0x302179de", "0xd2e0e12a", "0xf127016", "0x10402f41", "0x220f2101", "0xf2ec1211", "0x1ff1d04f", "0x2adb27ce", "0xf327745", "0x11df7027", "0xfef1d00e", "0xf0f19f14", "0xe26ee402", "0xfd104cfe", "0xfb132e1d", "0xf11f1321", "0x2e0107c0", "0x4d0ff0c3", "0xf2f1d10", "0xe0ff110c", "0xcd31109", "0xe13dbfc", "0xe33c0fae", "0xed01d70e", "0x510f2992", "0xc1e290fb", "0x2fd002e3", "0xf1ffdf3", "0xe3ef0eff", "0x120d1312", "0x1e11f00f", "0xf2cf24ee", "0x314b4700", "0x12dd7134", "0xf5201d0e", "0xe0fece1d", "0xee414fe5", "0x1e5e03c1", "0xf41ee33e", "0xb46e4327", "0x100f22ae", "0xd763f17e", "0x1ee4f1f", "0xd10c2021", "0x4b3610d7", "0x5160d10b", "0x454f03ef", "0x927327e7", "0x311f1ed0", "0xb7732f7f", "0x251f1000", "0x1f1f2d", "0x91003d4", "0x3050ccee", "0x232ff12d", "0xb47027f7", "0x230cf1e1", "0x9734d170", "0x320f35f4", "0xe0b41101", "0x4f1eccd3", "0xcfe5fb99", "0x2dc4f0cc", "0xffff4135", "0xa60ea2aa", "0x405db1f", "0x5312d13d", "0xf0a44403", "0x62cfaa17", "0xbe307f9b", "0xa1f3b29b", "0x91552574", "0xb4aadfca", "0xf7640264", "0x50cf317b", "0xe1c33305", "0x70ce5f07", "0x1ffd719d", "0xebd4d4ac", "0x9f450373", "0xefe9e19a", "0xe7753361", "0x1decd22e", "0x2090210d", "0xc0043003", "0x4f0002f1", "0xff12f6c1", "0xf4f5155f", "0xfa00f224", "0x2573e031", "0x71fc01f0", "0x309065f9", "0xeff549e3", "0x20c1a594", "0x46f4593", "0x314716c2", "0x395d2136", "0x1773bf70", "0x72230ef6", "0x95310", "0x2f1dff2", "0xc02fb6c3", "0xf26327ef", "0x4f7117bf", "0x106a2353", "0x277e3e7f", "0x62242ec4", "0xf0", "0x10f", "0x10100100", "0x1f0f0111", "0x100101", "0x20100011", "0xf0000", "0x1000000", "0xf1ff00", "0x10000100", "0xf01f0101", "0x110f111", "0x100001", "0x100f0001", "0xf1ff0f", "0x1001f0", "0xf0f0", "0xf0f100", "0x1000", "0x100f0111", "0x10f00100", "0x1ff0f001", "0xf0f010", "0x100f00f0", "0x110f0100", "0xf0010f", "0x11f0000", "0x1010", "0x10100110", "0xf100001", "0xff0f00", "0x100", "0x10010fff", "0xf0010f", "0x1f1110", "0x10", "0x10f00", "0xf00ff0", "0xf000000", "0xf100011f", "0xf0f0ff00", "0xf0010f", "0xf0000f00", "0xf0f0f010", "0x10100011", "0x100ff1", "0xf0f00", "0x10000100", "0xff00", "0xf0010100", "0x100f0f10", "0x100f1000", "0x10100001", "0x1f100f00", "0xf00f0f", "0x100f0001", "0x1000ff0", "0x1f10000", "0x1f101f", "0x1", "0xf101001", "0x1000fff1", "0xf0000f", "0x10f0010f", "0xf1f010", "0x10f00010", "0xf010f010", "0xf00f111", "0x10010000", "0x1000f001", "0x10000ff0", "0x100011f", "0xff10f00f", "0x1200012", "0x100f02f", "0xf1f1000", "0xf02f1ff", "0xfff111", "0x11000010", "0x201000f1", "0xf0100fff", "0xf002", "0xf000ff1f", "0xf001f00", "0x10010100", "0xf0f00000", "0xf00", "0x1f01110", "0x10100f0f", "0xf0010", "0xff10f010", "0xf000f0f", "0x1000f000", "0xf0110f00", "0xf00fff", "0x110000f1", "0xfff0f", "0x1200102", "0x10010e", "0xff000000", "0x110000", "0xff000001", "0x10f00000", "0x1f01120", "0xfef0", "0xfff10000", "0x10f", "0xf00000", "0x11", "0xff0100", "0x10f0100", "0xf2f10001", "0xf0000", "0xff0100", "0x100", "0xff000100", "0xf0010f00", "0xf010100f", "0xef0ff", "0xf000f000", "0xf0100", "0xf0200f01", "0x1f1f1f", "0x1e101010", "0x1011f000", "0xf0ff00f0", "0x1000f000", "0x11000010", "0xf1fff001", "0xf0f0f1f", "0xf0f0", "0xf1000", "0x11f00", "0xff00f1ff", "0x1100000", "0xf1f0f002", "0x10000000", "0xf000", "0xff010", "0xf00011f", "0x10001f00", "0xffff1011", "0xf000f0", "0x100f", "0x1054ef11", "0xfe0dfc02", "0xec31c90f", "0x7a6417f0", "0xfd7ecf09", "0xaf4b2dab", "0xe02c11fc", "0x33ddf40a", "0x10773519", "0xd6141c44", "0x7c62ab4d", "0x6f701752", "0x622ab6f9", "0x9993f2b4", "0xe67b7164", "0x146726fa", "0x21eb273c", "0xf3724113", "0x5a3f23dd", "0x4370e320", "0x43edd71b", "0x4f06b200", "0xb600267f", "0xc3f61207", "0xe0224ab1", "0x410d1ae1", "0x9a37e93c", "0x5e2c471a", "0x9b71d629", "0xc16e2bab", "0xa303a04b", "0x32fe02d3", "0xb06712ec", "0x1ebcb9ee", "0xac79504f", "0x2c7207f1", "0xaf7497f9", "0x9662f0c0", "0xa75d207a", "0x3575749d", "0x102d35ff", "0xf762fcb", "0x59561f7e", "0x3d7ef449", "0x647976d", "0x1dafe303", "0xb7e9267f", "0x302624ef", "0x2fafab30", "0x230e7cd1", "0xfb12b99f", "0x127e00ea", "0x3e110549", "0xf222e22", "0x10fdeff", "0xd1fe1110", "0x1017c30f", "0xe0c919c5", "0xee3f01ac", "0xf171b7fc", "0x2e5fc71b", "0xa200ced5", "0xc72fbd7f", "0x4e13dc", "0x2023f21f", "0xe33daf05", "0x3d32d6ef", "0x17e0110", "0xf535f713", "0x3fe0f213", "0xc70c3f7f", "0x14ff141b", "0x707df49e", "0xdd59102", "0x2dbef964", "0xc0aaa002", "0x6372b712", "0x9d01ff29", "0x27bbc077", "0x3713fffc", "0x706f329d", "0xfe549165", "0x71d92a7f", "0xe499fe14", "0x7350c733", "0x99cdfc49", "0x77bec777", "0x7271f1e", "0x511a304b", "0xd20f352", "0x75dd3ddc", "0xe09db0ed", "0x72ffe7e2", "0x99010d3f", "0x779b1776", "0xd2263ecf", "0xd04ce69d", "0x907249e2", "0xfd5ed96f", "0xe09afef", "0xc033e7d3", "0x9cad0d29", "0x27b29774", "0x34101bd0", "0x101c119f", "0xb5524052", "0xd10cea75", "0xdc3af400", "0x40670794", "0x99bbed29", "0x77b0c776", "0x579bd9de", "0x1171c7d", "0xb353ad4d", "0x7150ca75", "0xd22ef020", "0x62362797", "0x9dae0e20", "0x67909073", "0x16dd0dbf", "0x5c5f1d", "0xa1610104", "0x3e60c965", "0xff4f410", "0xdfa2f7c7", "0x9cdbf144", "0x7209452", "0xd02f0bde", "0x1c7f4c", "0xb454ef17", "0x1fd9df67", "0xe406470", "0x3013d7a7", "0x9a9a1c45", "0x37239f74", "0xc6c6f9b7", "0xe02e500e", "0x1062cf30", "0x3efac01", "0x2293e05", "0xf2242795", "0x9ddaf175", "0x37b41972", "0xf4f3fca1", "0xd1f200fb", "0x12000ff2", "0xc0132dff", "0x4d0f230e", "0xaee10625", "0xb2300ed1", "0xc7f1107d", "0x4e0e0e11", "0x1dd1ece", "0x20a011b0", "0xcee01013", "0xade110cc", "0xae331726", "0xc0211fe1", "0xd700b17d", "0xfc2c2ede", "0x40120cf7", "0x2dc20013", "0xe3e11214", "0xe5af1f1e", "0x307e607", "0xb1fc0143", "0x44dcf260", "0x2f2e1eee", "0x20bbdbec", "0xb0e12cdd", "0x1a120c94", "0x3ff0decd", "0x1be02726", "0x9c021ce1", "0xd7e0be60", "0x3e1a20cf", "0x5109d920", "0xa2d07ec4", "0x4fede3e3", "0x9013f903", "0x2e3046f6", "0x90101d40", "0x47e1bf70", "0x1cad114e", "0x703dfd15", "0x1f41a327", "0x31ecc7a3", "0xf5ff1e0f", "0x660d3697", "0x93df0376", "0x65e13c64", "0x16219e2e", "0x311b1f0f", "0x13102e2", "0x3f12cc30", "0xe1210e0", "0xee10506", "0xad4e1123", "0xd431d311", "0xfdfe1111", "0x6236c6", "0x3021e735", "0xd5d90371", "0xd0211c05", "0xe0cb45f5", "0x95111443", "0x57223174", "0xf6e4102e", "0xe04c1c32", "0x5f72a354", "0x35ef2f60", "0x25f12f33", "0x16cf63e1", "0xaea0f121", "0x73e0ef57", "0xe7031f20", "0x1fef2245", "0xf50f0224", "0xf0f0521e", "0x96fdec51", "0x7e02f2f2", "0x1fd4d321", "0x41ce5041", "0x2113e1f4", "0xe0f22feb", "0x1060f1fe", "0xe1000f0f", "0x2015e1bf", "0x10400613", "0x20221bfd", "0x422a35d", "0x43fe3a2d", "0xb0fe2100", "0xfd12fee", "0xf12fff12", "0xff121ee", "0xc2622532", "0x504e34f3", "0xb502ec5e", "0xe1de4210", "0x101ec303", "0x446ff016", "0x25e91d1e", "0x9fe2dc21", "0x6dfd0512", "0xe1a0a500", "0x52fb2343", "0x41f1f0d", "0xd0f123ec", "0x10303a1b", "0x39072eef", "0xf03972e1", "0x1d600550", "0xca70efcc", "0xa510be6c", "0x20107c0e", "0xf0df1d0d", "0xfe9fe1eb", "0x300c1fef", "0x5e13e0fe", "0xa06f1791", "0x1d1064f3", "0xb6f05f6f", "0x3d004111", "0x100d512", "0xe46e1312", "0x4196f12", "0xd5103f", "0xd50e4363", "0x2092e434", "0x313d5201", "0xb011dd1d", "0xd0e315f1", "0xfb221e0e", "0x1af6dc00", "0xf15cefe1", "0xf7ee512", "0xfd21d9d4", "0xf5449a4e", "0x2edef7ee", "0xf1d2eafe", "0x1bf30de", "0x2f2e01ef", "0xfd240e3e", "0x1f62d6ef", "0x1eff41d4", "0xd603065d", "0x343e0df1", "0xf9ff021", "0xfe211ee1", "0x210e1de2", "0x3c02fc0d", "0xce1042ed", "0xcd1dfeee", "0x23041e2c", "0x30fb2e4f", "0x11d5df2f", "0x2df1ef0", "0xdf003cd3", "0xff01e0e0", "0xe032d3fb", "0xa1fcf00f", "0x2522ba3b", "0x1afec1e0", "0x60f003c4", "0xf3ff0e10", "0xff0034e5", "0xf3c21ee", "0xf304130e", "0xd2efddf1", "0x30d044e", "0x2e3ea0e4", "0x30d0fd01", "0xeb01fd01", "0xce1dedd5", "0x7c1510e2", "0xf17105e9", "0xf9001f90", "0x41df040", "0x30bdef30", "0x1033226e", "0x22e47f2e", "0xd2ea220", "0xf410d611", "0x6264c4e9", "0xb6fe15e3", "0xe621ef7f", "0xe9507faf", "0x10d1e121", "0x127fc4fc", "0x11002690", "0x533d311e", "0x773ae6af", "0xbce3f9e1", "0xe7e09f74", "0x25129012", "0x204f5e30", "0xdfe224f0", "0xcc22fd4e", "0x1b5c5d00", "0x1f04041e", "0xa1ddff1", "0xe30ff43e", "0xfe1edef0", "0xa06751be", "0x5de43702", "0xec2a3371", "0x445ed034", "0xe72cd1ef", "0xc72fffa3", "0xd41e7162", "0xd117d0fe", "0xff0efffd", "0x327db011", "0xe343d71", "0x2e73247f", "0x12c05c3", "0xdfb4cef2", "0xe5fecf6e", "0x2525e0e4", "0xd0c2fe4f", "0xfc262ec", "0xfefc131b", "0x1261b3d9", "0xfd4f4f1e", "0x701f3fdf", "0x1f6edfe9", "0xf100d0f", "0x9f023d30", "0xe0b140ca", "0xac2ec6cf", "0xfe64b5aa", "0xdbd04e02", "0x722ef4a1", "0xe000c1d9", "0xe9c90d00", "0xe0355fef", "0x10e713ff", "0xed4ec602", "0xf27235ef", "0xfe621320", "0x610d20d0", "0xf222f513", "0xdd1c3030", "0xb0b26f43", "0x393720e", "0x4c5d27dd", "0x4434a6ed", "0xff10ecfc", "0x7f4172bf", "0xce5230bd", "0x1c20e305", "0xe0e07d5c", "0x13917590", "0xfd70469e", "0x3e26a7db", "0xc990cd0f", "0x7135c796", "0x90410acb", "0x296902a1", "0x1f366d00", "0x10c763cc", "0xf7e4342", "0x4d5151de", "0xed423f50", "0x7433d0c0", "0xa476fe0c", "0x6e4b7213", "0xf1a47de3", "0x41af21db", "0xf0025f1", "0x2026b0cc", "0x1e5d2d09", "0x743241ef", "0xee1f21ff", "0x70f12402", "0xd0e23cee", "0x55aa40ab", "0xfe340390", "0x947a1bd", "0xfacfc5f", "0x7361f291", "0x9f0c41ec", "0x491af24e", "0x10201ef0", "0x33ff71cc", "0xf01f42d0", "0x1a7115dc", "0xfe402170", "0x72f21023", "0xc357071e", "0x7ffc313f", "0x4f35be61", "0xf1012e42", "0x404fc903", "0xbf23d122", "0x754ddfc9", "0xcedd2d01", "0x113c3e11", "0x113e41c", "0xe0373c", "0xc461cc12", "0x5a4eea2f", "0x507f135f", "0xe44cd2f9", "0xb4e4e3ef", "0xc334053f", "0x2502b305", "0xb0f223df", "0xee4f7cf4", "0xc4f20ed", "0xea5d02e0", "0xd009050b", "0x4f21bf9c", "0xc533f07a", "0xecfec131", "0xbf363521", "0x7d4ff631", "0xa1504d7c", "0x2f9602", "0xb65fb3d9", "0x3ef4ce0", "0xf24f6d31", "0x3316e020", "0xa0100cdc", "0x3f7d0edf", "0xfc675a2c", "0x5261171f", "0xf764b479", "0xdd3013d0", "0xc614375b", "0x26639293", "0xa004e1f2", "0x4ee360e0", "0xae221a2d", "0xd95a10fe", "0xed33f75b", "0xdd00ce91", "0xd7ffd17a", "0x4ad04f12", "0xf0d2e22f", "0x1e1e2bf2", "0xee30fddd", "0x353ed21e", "0x120f2e9", "0x10b11f11", "0x12d5d11", "0x10fff2ef", "0x20edee01", "0xb44c19e1", "0x3b361bc9", "0x1e7d0f1b", "0x1266f54b", "0xee3f1cd2", "0xb520e45c", "0x2dd0f1e3", "0xff35f2f1", "0xc3fffe14", "0xd33205af", "0xce7e21df", "0xc20071f", "0xd022ddc2", "0x16f1ee79", "0x41da1010", "0x107d0f05", "0xff010f06", "0x11211d0d", "0x96ef0f64", "0x531e5113", "0xd404d663", "0x55fd5254", "0xf302e240", "0xf04e1004", "0xb70c226", "0x311fbd1a", "0x5010d10e", "0x4f4e47e7", "0xd203fd30", "0x16f05d73", "0x13d12f30", "0xb101101a", "0x1d2123f2", "0x2020fc0d", "0xc2d30ed2", "0xed2f1617", "0x4f0300ac", "0xf6220e5f", "0xe1d21022", "0xa0220325", "0x215ea137", "0x37ec4939", "0xf3eedd1f", "0xbf0b741e", "0x94c1c70f", "0x46223e53", "0x4513122d", "0xe0caeb9f", "0x1e6019d4", "0x20539e9", "0xb2212ece", "0x97633773", "0x99d0f9ef", "0x2712d470", "0x56cc9272", "0xd0c232ff", "0xb0925d10", "0xfddfcb2e", "0x11d10213", "0x9c24f752", "0xef1efd92", "0xe62fe16d", "0x1a0f129f", "0xafa221", "0x212eef13", "0x13eddd9e", "0xf102be", "0x2011222c", "0xbfd200d3", "0x2220dd02", "0x600cf22c", "0x20c151ff", "0x91fe3d1f", "0xa01ed9b", "0xd15103b1", "0xb43c610", "0xc36df994", "0xb730916d", "0x1c3a031f", "0x1001fff1", "0x1dcef10f", "0x201205f0", "0x320d12f", "0x1321c422", "0xe03c10c2", "0xf62f215e", "0xed41f01f"},
{"0xf00100", "0x100f0000", "0xf0000f01", "0x1000000", "0x1010", "0x11000", "0x1f", "0xf00", "0x1f01001f", "0x1f000000", "0xff00100f", "0x1000f101", "0x10010001", "0xf010010", "0xf0110", "0x1000110", "0xfff0f", "0x100001f0", "0xf0010011", "0xf01000", "0xff00f00f", "0xf0001", "0xf0000", "0xf0ff00", "0xf10", "0xf001000", "0xf0101", "0x0", "0x10f00", "0x10f0f00", "0xf000f00", "0x10f0001", "0x1f1ff010", "0x10f0ff1f", "0x1ff00", "0x111f0f", "0x11000f", "0x10001110", "0xf00", "0xf10f", "0xff0f011f", "0x11001", "0xf00f0000", "0xf000000f", "0x1f110001", "0x10f1f1", "0x1ff010", "0xf00100", "0x1f0000", "0xf00f1011", "0x0", "0x100f00", "0xf01f", "0xf000", "0x1000000", "0xf000000f", "0xf000", "0x1000011", "0xf00000", "0x10", "0x1100f0", "0x10100000", "0xf000001", "0x11100", "0xf0", "0xf1000f", "0xff00f0ff", "0xf000000", "0x0", "0x100f1000", "0xf000", "0xf0000000", "0xe0b01035", "0x1441ff02", "0xf12f1f", "0x12c0e3c", "0x30f10221", "0x3f0fd7fd", "0x2ed1e1f0", "0x132f0cf3", "0xd1c0d00c", "0xe1f000fd", "0x10e10b01", "0xece21fbe", "0xd13f12f2", "0x2f2d69fe", "0xe0019f1c", "0x21e02dea", "0xe0de0013", "0x3af1d0a", "0xf0f11420", "0xffef0000", "0xfee10201", "0x401b7704", "0x9ffd2021", "0xf10022ef", "0xf1fee0f4", "0x145ece06", "0xe0e05d0e", "0x9eff230", "0x3bf0135d", "0xee11b74d", "0xd0d41f2", "0xe101ebef", "0xf00e01fc", "0xf0f216e9", "0xd220a2f", "0xfefc01df", "0x26207ee", "0x2e325bde", "0xf2e1e01e", "0xee05d02", "0x510e22", "0x2fb000fa", "0x11ed0ffe", "0xef0012f", "0x19de06ae", "0xf527713", "0xf0ee7f13", "0xdf11ff1", "0xf0e2b024", "0xd16cf2f3", "0xf0006d11", "0xaf423ff", "0xf0201222", "0x4d21f730", "0x4e0f10a1", "0xf03e2b10", "0xfe0030d", "0xff0220fb", "0x1be5fddf", "0xf11d1ede", "0xee20e70e", "0x31f0e991", "0xd0d190dd", "0x2ee0f1e2", "0x1f2f1df4", "0xe0c00f0c", "0x1fd12f2", "0x1ef0fe20", "0xffc0f3dc", "0x114e77d0", "0xe0ee5211", "0x12001e0f", "0xe21f57", "0x41f1023", "0x2121200", "0x953e025e", "0x21ff0e0c", "0x10e1d2f4", "0x3e114df1", "0x1111004", "0xe0f11fec", "0x1121f10d", "0xde011ff3", "0xec232fd0", "0xe100df0d", "0x3101edfc", "0xef15a0fe", "0x10ee01f1", "0xd1fff0ff", "0xf1c01ffd", "0x2f20e01", "0x1ff0102f", "0xe2f10e1d", "0x30fd1610", "0xe00ee000", "0xe20010ff", "0xf0113135", "0x425fdf16", "0xd31d1c0e", "0xb112e320", "0x3fed0dfb", "0x192b331", "0xfe3e50e2", "0xe1412001", "0xe10f03ef", "0xf1123eea", "0xee052cee", "0xef0b7fe2", "0xe905ee5c", "0x1c70cdcc", "0xef23a0ed", "0xe9dff1f2", "0x11ffdd1f", "0xe0afe01d", "0x12fdefff", "0x6200ff32", "0xccf12ebf", "0x13371e", "0xffd4ee4", "0xfbf23e00", "0x112f312", "0x136b0ee3", "0x21a3d0e", "0xf1d5232e", "0xf2011e4c", "0x1fcdd51e", "0x2e1d62d1", "0x1e4ff010", "0x1feff5ef", "0xfdf3121d", "0xfa05fc0f", "0xde1d1e10", "0xdd30dd2f", "0x1341fbae", "0xff1490dc", "0x1dbf2315", "0xf1ec1f", "0xfe0103f", "0x210ef10f", "0x20020032", "0xff00cee1", "0xf13f21ff", "0xffe1f3f1", "0x1200fef0", "0xc07052d0", "0xe003e033", "0xf242203e", "0x22241235", "0x136202d1", "0x132106fe", "0xe2406f21", "0x2020d14f", "0xb1657409", "0x6244b124", "0x734cfe4b", "0x3f00a113", "0x51410401", "0x2be6f01c", "0x12322e21", "0xe456d13f", "0x33435e", "0x404331e1", "0x1f400bed", "0x102d5320", "0x523ff4ff", "0x4ec3250e", "0x13041e31", "0xd033f122", "0xcffcd09f", "0x2f2e32ff", "0xc0f2de21", "0xf090f1a", "0xfeffe42f", "0x3efcfe1", "0x11f0ff20", "0x23ee3fde", "0xf0ffbe9f", "0xbeea69ed", "0xf2f44fcf", "0x223aa", "0x9d30f35f", "0x11a2ec3", "0xf30ee05d", "0x3ff25f01", "0x1010ffa1", "0xbda1c0e1", "0x11f3de3f", "0x1117a2de", "0x9d30d532", "0x419fee1", "0x132cc05e", "0x4edd13ef", "0xe1e3f1", "0xb01fb103", "0x2c0f2ccf", "0xff151f10", "0x10f03421", "0x1f3d2f3", "0x1121e002", "0xdfef220", "0x2000f2d1", "0x1ef1ef1f", "0x2c00d199", "0xd11f31f2", "0x101326d1", "0xfef22fd4", "0xf210a032", "0xf3ec120e", "0xd0100", "0x11f02011", "0x1d1e01dc", "0xde2d1bff", "0x1e2e14df", "0xffe230f0", "0x3102151", "0xe0f3fe12", "0xf0d520e0", "0xedf2c21b", "0xe12d53d", "0xee1110fc", "0xc123de07", "0x701f11ca", "0x21f201ff", "0x22e04912", "0xf005eddd", "0xcb1a0e9", "0xd00e006a", "0x21dffe1", "0x9253df05", "0x7ffd5fae", "0xf00de5ea", "0x21a4aee", "0xf13ee2fd", "0x2aef0e2c", "0x1ef1fb2b", "0xe90ca01d", "0xd151f101", "0x4bec4fce", "0xb14df4f3", "0x11fef3ea", "0x209c4e14", "0x1ef474d0", "0xf23206c1", "0xd21f012b", "0xa2c04ad6", "0x720f6410", "0xef27dfcc", "0xef0c3bd1", "0xf9ae017", "0xef9375e1", "0x736fc094", "0x2ecb0fec", "0x99005bc1", "0x7c7a601f", "0x9d20acad", "0xeecf2c71", "0xf0002e23", "0xdd190ef", "0xe14d9ef3", "0x23fe041d", "0xae211cc0", "0x23a3302", "0x907ff0c0", "0xfff15fc1", "0xf0005df2", "0x11eed0fd", "0x4d333e0", "0xfee4c1ca", "0x10c15a19", "0x400f330d", "0x1c627ce1", "0x7002ef21", "0xf0ed4014", "0x3ec5c2cf", "0x1f003fdf", "0xd992b30d", "0xd0f2094a", "0x40f0421e", "0xd711da4", "0x6d06c0d1", "0xf11030e2", "0x6eee0fbe", "0xceed11f0", "0xbbf14f4", "0xc5e00a2e", "0xdf2d024e", "0xff710db1", "0x7eefc11c", "0x100d22ff", "0x27f7f2fe", "0xf2750612", "0xe26e2400", "0xef72e4f5", "0x73100fe6", "0xf34f4f49", "0x6c3fec1e", "0x313c4300", "0x47d702ea", "0xf16212b0", "0xd06e239f", "0xb0410424", "0x7dd13e9e", "0xc3f02e19", "0x4d4e0e0f", "0x1f4e401f", "0x2617ddee", "0x47012ee", "0xe27f62cf", "0xef71170e", "0x7fd14095", "0xd79c0042", "0x6f1ee2e0", "0x309964e1", "0xf3d6f6cf", "0x4970c7ff", "0xd413d7ba", "0xfe7df6df", "0x72f04091", "0x94121339", "0xe32f4bad", "0x409a20f7", "0x17a0039c", "0x4970d19f", "0xbdc0b79a", "0xac5cc6ee", "0x7ecb0e9d", "0x95011f5c", "0x26a2d90", "0x103a6de5", "0xf1d3e09c", "0x247e1020", "0xc000e09e", "0xce7e37cd", "0x7caa2091", "0x97cd3c7d", "0x71ded4a0", "0xe09e220f", "0xeee3d09f", "0x395fd412", "0x11ec54e", "0xa1be169f", "0x7f0cd104", "0xc14ff211", "0x914bee2e", "0xf0904113", "0xff9fef9c", "0xf94fa69f", "0xcd2fb4ce", "0xbff0d6c4", "0x5cde31c2", "0x950ff44c", "0xa51b03e0", "0xc0212d33", "0xeeff49d", "0xe4021f0f", "0xeb7e92fb", "0xde6f07df", "0x7f9b2005", "0x972f1e70", "0x73111435", "0x10211", "0x1ff000f", "0x10001ff", "0xf100f0ff", "0xf011", "0x12fff000", "0x1f0f01f0", "0x110f1000", "0x110020", "0x11fff000", "0xf10011", "0xf102f000", "0xf11f101", "0x10ff0f", "0x110f0100", "0x1100101f", "0xf0000", "0x11fff010", "0x10f1f000", "0xf0201000", "0xf000101", "0xff0000", "0x11fe0110", "0x2f10000f", "0xf0fff00f", "0xf0f1010", "0xf0f000f", "0xe1f00000", "0xf110101", "0x11100", "0x10ee00f", "0x10000110", "0xff0021", "0x1100", "0xf00f000", "0xf00f00ff", "0xe20f110", "0x1f200001", "0x11fff000", "0xe1001", "0xf01ff10", "0xff0f0f0", "0xf10f1f0", "0xe00f1000", "0xf1f0011", "0x100021", "0x10f00110", "0x120f0001", "0xf00f00", "0xffff0", "0xf0000f1f", "0xf00e000", "0x1010100f", "0xff101", "0xf000000", "0x100001f0", "0xf0f0f00", "0xffff0f0", "0xf0100f00", "0xfff0f000", "0xf10ff1f", "0xf1fff010", "0xf000000", "0xf0f00f", "0x100ff00", "0xfffef0f0", "0xf0100e11", "0xff0f00f", "0x100f000f", "0xff001", "0x1f1f00f0", "0x10f0f010", "0xd1900e1d", "0x1e5f1ed3", "0xf111fc0e", "0x1f11011d", "0xa0ff151f", "0xb10dff1f", "0x5f43f4e", "0x3c0d0d10", "0x10b1fed0", "0x100fb0", "0xbe0f2ff2", "0xef121fce", "0x9f20f71f", "0x941e0001", "0x1621af6c", "0x2aecef0f", "0x4ff01ee7", "0xf0d11010", "0xd10fe4f3", "0xe2100e1f", "0xa0f7f403", "0xc31c0030", "0xd4ee125f", "0x102c2ee4", "0x30bddb1d", "0xaaff2ce0", "0xed1ffc94", "0x6f14f1cd", "0x1030141c", "0xad020cb1", "0xd4efde51", "0x4ecc10ee", "0x40001e40", "0xcfb07eed", "0x5e1fd3c7", "0xff311fe3", "0x6144250c", "0x9d1c1e33", "0x37f2cf7f", "0x3d5d71ff", "0x60fe1356", "0xf272a43d", "0x2f0fe795", "0x3301ff1", "0x550ef4b5", "0x962e1574", "0x5e23053", "0x1400ae21", "0x215e6c2e", "0x1d000e0", "0xc15cd53", "0xe30e002", "0xf013041e", "0xcc3efef1", "0x9212d120", "0xede002e", "0xd15346a1", "0x4fe4f5f2", "0xf3193577", "0x3032f143", "0x120d03c0", "0x93410673", "0x27205e64", "0xe6153341", "0xf0fbe031", "0x4073c212", "0x121e3f62", "0x22311130", "0x47e034e2", "0xbee4f251", "0x5500ee55", "0xf7142002", "0xa0401fdd", "0x102fe0d", "0x14013d4e", "0x1d2ccfe1", "0xdf421301", "0x212e01fc", "0xfee050e1", "0x2321fb0e", "0xc03fe0ed", "0x72400cfd", "0xf412ea5e", "0x1992ffd1", "0xfbe71210", "0xfe55510d", "0xf1ee7122", "0x220f0bef", "0xf0120320", "0x23e23f13", "0x43021900", "0x2eb0211f", "0xfce31003", "0x2d1777e0", "0x2fef3f11", "0x1101d", "0xc0d0b0e1", "0xf0fe2e0b", "0xbde3fed", "0x2f2bf1cb", "0xfef2430", "0xe011e9ae", "0xffb09fe1", "0x21e12ac2", "0x10ffeffd", "0xadeac9e9", "0xd00100d", "0xece0e1cd", "0x93e0e61f", "0xe02d7ece", "0xf1ccc02f", "0xf3e02d0d", "0x5041f3", "0xe4fe1a00", "0x30cf01f0", "0xce1f21e", "0xe9f103dd", "0xd4b7712", "0xfefb7100", "0xef30db", "0xf1e19023", "0xb1d0020f", "0x1dee31ad", "0x2c2b0f0e", "0x1c11f323", "0x2210bf", "0xeec0afb2", "0x10120bf1", "0xd1dd0f", "0xcfe2030d", "0xfdf020ea", "0x1f05fdd", "0x100f7db", "0xf12f29e0", "0xa2df910d", "0x11ff3df0", "0x30421016", "0xe3f00ef2", "0xfed1010", "0x1d020fef", "0x2db133c9", "0x311c654e", "0xffee5021", "0xffee", "0xe071f2fc", "0x1ff1c10f", "0xff2232d", "0x4ef312f2", "0xdcf20b1f", "0x223010bf", "0xdc1120b0", "0xe1fe0310", "0xe0721eea", "0xfc0123e", "0x71efd23d", "0xecc3c001", "0x6ccf191e", "0x39d3203e", "0x19fd6097", "0xa10701fe", "0x401e123f", "0x35ef20f", "0x50e0ed0e", "0xed00e232", "0x61c92aee", "0xfc51631", "0x2bee0ea6", "0xef16301d", "0x11ffae", "0x31c241dc", "0xeee3e52e", "0x13ea321d", "0xede1fe3f", "0x40400ead", "0xcce3a0bd", "0xd00e4ff6", "0xd036f2be", "0xf09dfdfb", "0x94d9543c", "0xccc452e0", "0x99c2ea1c", "0x537f61ee", "0xaddf091", "0xcac07fee", "0x104fed00", "0xd13d0021", "0x51fe0f7e", "0x1ed3ff21", "0xadd32d0d", "0x2ead1611", "0x1cce63b3", "0x101520c", "0x1cfd1ee", "0xe1b113ed", "0x1df0f392", "0xf0f70f2f", "0x3ef3ef01", "0x513110cf", "0xcd1ffcf", "0xf00f2e06", "0x10eff0ff", "0x509f3d1a", "0xf1e0f39d", "0xcceed9e", "0x1dde1bff", "0x41513aad", "0xbdf9fb0", "0xfe0bc1ff", "0x20020010", "0xe1dd0f0e", "0xe1fb04d1", "0xee0f1c1", "0x1d0f1def", "0x211c4f1f", "0xfcee21c3", "0xf10e3d1d", "0xc01e01bf", "0x225e0c11", "0x13f12e1d", "0xee10efcc", "0xfbd30213", "0x10ecec", "0x1fd00ff1", "0x12100a0f", "0xe1401092", "0x21effcec", "0x21f10d5e", "0xee00de", "0x91ee1222", "0xd01f7f0d", "0xf2c0a221", "0x120e0af1", "0xe01f21ff", "0x12f00e1f", "0x22f0fb5d", "0x1fbf10c2", "0x9f12fff1", "0x2f307bdd", "0xd0fe0c21", "0xf300defb", "0x1fb29fe2", "0x940e59df", "0x3cdf3b94", "0xe0b2fa9", "0xf0f132", "0xdce1e910", "0xffdf9ffe", "0xfeee3da1", "0x30adacf3", "0x92bb69e9", "0x1b0f31a6", "0xe3e410b", "0xbd0103de", "0xea1a61e3", "0xe1ce901c", "0x1bdf3ecf", "0x1c0ffd3", "0x92afef2a", "0xfe00304", "0xe3212ad", "0xc02501ba", "0xe4ea79ef", "0x9eeea3fa", "0xefefffda", "0x201120f2", "0xb2450a03", "0x5d005c02", "0xf16eef5", "0x26321f3", "0x1020255b", "0x1fd17fbf", "0x1d10ce45", "0x210100e1", "0x4f46ec11", "0xeeeed127", "0x30e01e54", "0x6f3124cd", "0xe0d7f65f", "0xf0d06ff0", "0xe20d010", "0x20f4004e", "0x406314ff", "0xceeeffc3", "0x2ffc1e10", "0x72f021cb", "0x2f17373e", "0xefe32f00", "0xd11f011", "0xc1fe10c2", "0xef0ff", "0xe1c1111f", "0x200fd2fc", "0xd0b1fc0e", "0x12ff01f", "0xfbf010ce", "0xfdfff000", "0xe0e011a2", "0x13ce0fde", "0xd1f0ff3f", "0x12d1c1ef", "0xb0e1fe1c", "0xe10d31e1", "0xee1ee1df", "0xffff2f1e", "0xf120f1", "0x10cf00f1", "0xe2dee12e", "0x10e02fd0", "0x9fe1edfd", "0x110d2dfe", "0xcd3002e0", "0xec000f", "0x20a092f0", "0x90d12e1d", "0x1cdff0a1", "0x11e01cda", "0x4fe2dc0c", "0x19f10f00", "0xbbfd0df", "0xf1f001b3", "0x30a102f2", "0x91de4edc", "0xedf32b2", "0x1f1b30dd", "0x3af3eeda", "0xf95d1f22", "0xdcf03ee", "0xd4a10a0", "0x2fc31ef2", "0xa20ef3fd", "0xfbe64b3", "0xfe23fecf", "0x32effdde", "0x51c0e0d", "0xecd1d5cd", "0xeefc2fe1", "0x2f6240de", "0xef1203ff", "0xfffff134", "0xdee21d24", "0xe024ecee", "0xe1d201b", "0x2bff22c1", "0xcf012122", "0x11f021ce", "0x3f24ef31", "0xd1e1a075", "0x40f00c64", "0x3bf30dec", "0xeef2021d", "0x4dee10d1", "0xc016e044", "0x20feff4c", "0x30221201", "0xe2ede011", "0x300c2f40", "0x51d01ecf", "0xf013213d", "0x1dff1de1", "0xc00efe12", "0x1001000", "0x100001f1", "0x1000", "0xf0f01000", "0x111000f0", "0xf0000100", "0xf000ff", "0x10010f0", "0x11111000", "0xf0f0f000", "0x0", "0x0", "0xff010", "0x100010f", "0x1100001", "0xf0f1ff1", "0x1f00001", "0x10001", "0x110001", "0x10f0", "0xf0000", "0xf000f0f0", "0xf0000000", "0x0", "0xf0f001", "0x1000f01", "0x1100000f", "0x100ff", "0x1100f0f", "0x1000f000", "0xf001", "0x1f", "0xf00001", "0xf00f", "0xf0f01000", "0xfffff00", "0xf0000", "0x1ff0000", "0xf1f00000", "0x10001", "0x1000000", "0x10f00", "0x100", "0xffff0001", "0xff0f010", "0xf10f0", "0xf0", "0x1f", "0x1000", "0x10", "0x1001f00", "0xf00f00", "0xff100100", "0xf00f00", "0xf00fff0", "0xff0010f0", "0xf0", "0x1000100", "0xf000f0", "0xf1110f0", "0xf0000101", "0x10000001", "0x1f0011", "0x10000000", "0x11000000", "0xf00000f1", "0x10f0", "0xf000f1", "0x0", "0xf00", "0xf000001", "0x0", "0x91d121", "0xf22f4e1f", "0xf411dd1", "0xb230e10e", "0xd13ff0ed", "0xeefe1004", "0xd2ec1f2f", "0x1f30e1ef", "0x1dc1efe", "0xf20f1df", "0x9e1c0e05", "0x443ff0", "0xb345d500", "0xe41ffa1e", "0xa6f6b45d", "0x51c9c321", "0xf01e002f", "0xed313322", "0x62111210", "0xffb3e00", "0xe24f2503", "0x3c2c1ece", "0xc52ff153", "0xe31d4e2e", "0x1001516f", "0x520ef212", "0x211bdc0f", "0xc3249320", "0x123c02fa", "0xd1d0ef15", "0xf22d0911", "0x1d41230a", "0xe0f9313d", "0x3141aed1", "0x6b24ecc1", "0xe36970d1", "0xf74dd47e", "0xaa1f01fe", "0xc627e35f", "0x251c93e1", "0xe01fdb20", "0x11f11e2e", "0x431c0001", "0xfe0c2ef2", "0xdb4404d0", "0xdaff4da0", "0xc62e0e5e", "0x2ccf2111", "0xe1f3351f", "0x1e0e1402", "0xf33c1e2f", "0x1215c23d", "0xd40ff1fa", "0xfcb0efe2", "0x12e7e20", "0x4e21c03c", "0x10dcf1fd", "0x4220e0d5", "0xa351a1f", "0x326c20ff", "0xe52fd37f", "0xd1b1fdd3", "0xb535a34e", "0x31f0060f", "0x3023ef1f", "0xb1f2ee14", "0xe30ed110", "0xed315211", "0x220d4a0", "0xfe2211f2", "0x2530ed40", "0x4e002ce2", "0x1100f", "0x1ff011", "0xf00f00", "0x1001", "0x1f11010", "0x1000", "0x11f0100", "0xf011000f", "0xf0f11", "0xf1110f11", "0xf0f0001", "0xf0000", "0xf0010000", "0x110010f", "0x11101000", "0xf01f000", "0x10000ff0", "0xf0001010", "0xf00001", "0x11000", "0xf10111f0", "0x100001f", "0x1000f0", "0xff00000f", "0xff111000", "0x1", "0xf0ff0", "0x1000", "0x1", "0x100f", "0x10f0", "0xf01100f0", "0x1f", "0x100f10", "0xf0", "0xf0000010", "0x10f01", "0x100001e", "0x101000", "0xe001f00f", "0x10", "0xff1f0f10", "0xf0000000", "0xf00f000f", "0xf000", "0xf", "0x1100f0", "0xf000ff0f", "0x10f0101", "0xf0101000", "0xff00ff0", "0x1000000", "0xf1f0", "0x1101000", "0x1101ff0", "0xf10f0ff", "0x10000", "0xf00f0f11", "0x10ff0010", "0x1f00000", "0x1000010f", "0xf00f001f", "0x1010000", "0x1000f0", "0x110001", "0x1f0010", "0xf0000f0", "0xff01000", "0x10", "0xf0000f", "0x100000", "0xf010f0f", "0x1090fde3", "0x1f1f2ce1", "0xbf41fdc0", "0x1e2f3fed", "0xe24e0702", "0xdecff140", "0xf602cf7b", "0x411e2d03", "0xc3e1e6", "0xdf20fdd0", "0x913c5d13", "0x13573303", "0x9275b704", "0xb64bffe2", "0x1712b47b", "0x60f9fe11", "0xf01e310f", "0x1ff22040", "0x50121102", "0xffd201f", "0x936ef714", "0x2eee0dbd", "0xa62e1170", "0x214be05e", "0x3fdcee24", "0x312e4bf6", "0x421fd9b4", "0x91269d20", "0x761f241d", "0x9eb2f766", "0x461f6a44", "0x3de3a219", "0x10ba2354", "0x73fed3", "0x6b5dcea5", "0x626a11ff", "0x474c2702", "0x9972e023", "0xc715bd7e", "0x464d9026", "0xbfc1fb0f", "0xcffb2c", "0xbf2ee2a1", "0xf2501fe1", "0xe33e4f2", "0xd241fa91", "0xb554fe6a", "0xeeb31e5", "0x6463c2", "0x106edf34", "0x16234d7e", "0x1125c014", "0xc51e52db", "0xc1ee1253", "0x54507251", "0x21f23a", "0x103cfb13", "0x7472f6c7", "0x3d574962", "0x3462f361", "0x1641f742", "0xcca1c254", "0x27517361", "0x11240f10", "0xe00003fe", "0x3fe11012", "0xdf230b0e", "0xf01e012f", "0x1e31c402", "0xff44dff1", "0xe5420d5a", "0x4bf0f1f5", "0x21043df4", "0x623f10f", "0x20ce00fe", "0xefafce0c", "0xfdffc3f", "0x2e2f011d", "0xeedf1cb", "0x21ef2a14", "0xe0111bbd", "0x3921efb", "0x2fb22ef0", "0xee9ed1c0", "0xecdd0c2d", "0xc5f13a0", "0x1c1090dc", "0x2dfe59ce", "0xe03440fd", "0x11a11be0", "0x2ed1005e", "0x1ea1efb4", "0x4fd2fb1b", "0x2e2d5cf4", "0x1b4014bf", "0x3de0d2fa", "0x3f1d9017", "0xf7210215", "0xed9e1ff", "0xd1da2c0c", "0x10b43d0f", "0xccd2e32a", "0x1ed003c5", "0xd1aef916", "0x1f1cefa0", "0xd09f52e2", "0xfcc011ee", "0xdac961bb", "0xfb020cdb", "0xea5321dd", "0x4cdd0dc9", "0xfb9f4992", "0xf540efd", "0xde9e11d0", "0xd1d9210e", "0x1ea101ce", "0xfbf1da9b", "0x14325ddf", "0x1abbe2ac", "0xfd123f3f", "0x4f1eb327", "0xb37c2115", "0x43e9e0ed", "0xf5d112d1", "0xc1d35c11", "0x1c1e020d", "0x3bd00792", "0x9bd23907", "0x20e21c11", "0xd0222f7f", "0xfadfedeb", "0xdef1ec0", "0xdc0f0c1c", "0xa20d2ed", "0xdbc2aab9", "0xbc924fd1", "0x3042fb1f", "0xe1cd31fe", "0x3efa1521", "0x1fbe1cfa", "0x1db0dadc", "0x12232ee", "0xaac212af", "0x3011fda", "0xe915fd", "0xe7790142", "0xf0e0dc5f", "0x15da901d", "0xef42f12d", "0x9f22fdea", "0xe1f1e702", "0xf63d1abd", "0xc00e31", "0x266ce020", "0x5d029f2f", "0xd6d0e14d", "0x6107c410", "0xacecd1fd", "0xb21ce55e", "0x6aa09bc", "0x20250c3e", "0x7763e101", "0x6fdfbc61", "0xc0b12e22", "0x70e6c000", "0xcabbed3b", "0x100fe332", "0x2dd3dc", "0xffcbb2db", "0xf530f104", "0x9f06d5f", "0x32f92019", "0xc3b1949b", "0x9dce2cec", "0x13d0a30e", "0x3f122a90", "0xd029dffe", "0xe52f2db0", "0x2a1f72a3", "0xff094f19", "0x2f397db", "0x9f2cdedd", "0x46ee9d79", "0xdea199e", "0x101de12e", "0xef11d304", "0x4ced3ef3", "0xebde5e1f", "0x1e1093b3", "0x90dd2abd", "0x2b0ef40", "0xd1fb1e94", "0x302ddf1c", "0x920da2f6", "0xa344e11", "0xede300ea", "0x2034b1fe", "0x9ed410e0", "0xbeeff3f4", "0x13e10c07", "0xf02d2e11", "0x200f03d7", "0xd93171e2", "0xbc2910bd", "0x3f2604bf", "0x9ef2ecb1", "0x250fc141", "0xe0191fd3", "0xe1122c1f", "0xf02ef1f7", "0x191c4304", "0xa9fc3fd3", "0x2fe1f292", "0x911ffd1f", "0x31e10021", "0xdf0c13d5", "0xc040410f", "0x2231fd23", "0xe302404d", "0xffeed023", "0xf2213f0", "0x1210f61d", "0x2f2f4221", "0x222ef32", "0xcf62400e", "0x7f51cd21", "0xf2000b3c", "0xecd1b1f3", "0x29241300", "0x103502fc", "0x30f07113", "0xf3f1fe1e", "0xd042102c", "0x5f213ff1", "0x1100fd1b", "0xee1f1311", "0x112012f0", "0x3d263300", "0xffe11e13", "0x12f00d", "0xc0ffd0a1", "0x211f2210", "0x1ffe1fff", "0xfdfb1ffb", "0xcf00520", "0x1f11e4d1", "0xfee0df10", "0x13ed1fc0", "0xefcfa0", "0x9eec2dfa", "0xfe230df", "0xebff009a", "0x9020e52f", "0xf4c40bf", "0xf0deb02d", "0x2fd15cd0", "0x1ceffc2", "0xdfdf0efe", "0x310200fc", "0xfe1200df", "0x9c420420", "0x2096cc0", "0xf00ee23f", "0x2ef0feef", "0x100c211", "0xd2d0f0f1", "0x1d1010ce", "0x1e112f0e", "0x2e010311", "0x1f1101f2", "0xf02fefff", "0xf1e0f1f", "0x20f1d1e1", "0xefe1000d", "0xfdf110eb", "0xff201e11", "0xb2025df", "0x1f115f2", "0xf00fc010", "0xee01e00", "0x20d1e2f0", "0xf0f0000f", "0xfd0e01de", "0xe2d1d1e", "0x1b2023bb", "0x11e310d2", "0xc10ff04e", "0x10f1ffe1", "0x1f0f1011", "0x100", "0x110", "0x0", "0x1", "0xf000f000", "0xf1f00000", "0x10110000", "0x10100", "0xf0f0f", "0xf0100f0", "0xf00000", "0xf0000010", "0x11f00000", "0xfff001", "0xf0001011", "0xf", "0x10000ff", "0x1fff00", "0xf0f001f0", "0x100001f", "0x1100ff", "0x1f0ff0", "0xf000", "0x10011f", "0xf000f0", "0x101111", "0x1f00f", "0xf000000", "0x10010ff0", "0x11000", "0xff0100", "0xf00100", "0xf00000", "0xf0000001", "0x1010fff", "0xf01f0ff", "0x101100", "0x101f1000", "0x101", "0x10f000f", "0x10f0000", "0x1100010f", "0xf0f0", "0x11001000", "0xf0010f01", "0xff1f0", "0xf0", "0xff0f0100", "0xf0f", "0x10000", "0x1f000000", "0x1", "0x10010", "0xf00000", "0x1f00010f", "0xf0", "0x0", "0xf0100001", "0xf100000", "0xf1000001", "0x100011f0", "0x10000", "0xf00f0001", "0xf0001ff0", "0xff00010f", "0x110000", "0x10f0101", "0x1000000", "0xf0f00000", "0xf0010", "0x101", "0x2097e12e", "0x1e6e4d03", "0xcb4fb03a", "0x22f424cc", "0x2e7f77b4", "0x20fd2ece", "0x66ed47f", "0x37121d01", "0x90d60e40", "0xcd1f3abd", "0x9bfcb7a6", "0x2f4222dd", "0xfeed54e7", "0x474db3b3", "0xc501175a", "0xfbfb10f0", "0xcf443f12", "0xff2721d1", "0xed2ce7e2", "0x361f3e2", "0x1f644527", "0x660cd0be", "0xc5561743", "0xd1d3c23", "0x20c24b72", "0x20307c27", "0x6d1fe2", "0x2123a4f0", "0xef62641d", "0x1f4f4da7", "0xe771246a", "0x2b12d355", "0xfd6d74", "0xe2bf71c5", "0x234d149a", "0x21f2a7d1", "0xba91f137", "0x34493c7", "0xa6232a3d", "0xdb79d41f", "0xe0074415", "0xe22764f1", "0xdf4114d0", "0x432d6e1e", "0xe01f3077", "0x767fbdc2", "0x9673f12d", "0x3b4c5134", "0xf0b67102", "0xd1500106", "0xf0613151", "0xd0541fbd", "0x3f601759", "0xe5231df5", "0x7727d7c", "0x74d52151", "0xb0f03d02", "0x700f15d5", "0xff147292", "0xba50ddcd", "0x5eaee175", "0x672ef94", "0xc76e7f7d", "0x6e0df37b", "0x31fa22d4", "0x513f40e2", "0x2c2e66b2", "0xad6033ce", "0xf40d570", "0x7236d0e6", "0xe763154a", "0x7ceff031", "0xf011100f", "0xf00f0", "0x100001", "0x1100000", "0x100000", "0xf0000f", "0x0", "0xf0011010", "0xff00f", "0x1f0f", "0xf01f1000", "0xf000f000", "0x10100010", "0xf100000f", "0xf01000f1", "0x1100", "0x10110100", "0x1f000f10", "0x0", "0xf0ff0f", "0x101010", "0xf000101", "0x0", "0xf000f010", "0x10f1000", "0xf1001100", "0x100ff00", "0xf110f00", "0x100000", "0xf00f0100", "0x100001", "0xff000000", "0xf0000f1", "0xf0ff0001", "0x10000f00", "0xf0ff010", "0x1010f0", "0x1f00001", "0xff10101f", "0x10001f", "0x1f0f01", "0x1f00ff01", "0xf1ff001f", "0xf11", "0x1001000", "0x10010f0", "0x1100111", "0x1f00100", "0xf01f00f0", "0xf0000", "0xf000001f", "0x1101f", "0x10000", "0x10000010", "0x100000", "0xf00001", "0xf010000f", "0x1", "0x10011", "0xf000f0f", "0x1010f000", "0x10100", "0x1f00", "0x1111f00", "0xf000", "0x1ff00", "0xf0100", "0x10010000", "0x10001", "0x0", "0x1f0f0010", "0xf", "0x1f0e1", "0xdff1bc2c", "0xf1e24c2d", "0x3e0c91ec", "0xf000dbff", "0xcc1d0eea", "0xf0e0ffef", "0xfce01ce1", "0xe0f270df", "0x1bf2dded", "0x20ff2a49", "0x1e5e929e", "0xd1622dfa", "0xe1c40ca", "0xd111d1d1", "0xf00e2d12", "0xe01f10ff", "0xfb0e1def", "0x2cee1f0c", "0xafeb2cd", "0xed00eee", "0xf00b10cf", "0xe0f202ee", "0xdffdf40d", "0x119010e3", "0xe1f3f1ee", "0xc1ff0f0", "0x11eab1be", "0xf0e2fbfa", "0x1e2e20db", "0xcf0710cd", "0x12a1c05", "0xe0a123cd", "0xdfe6f29c", "0xa110022", "0x2d1bb7ae", "0xbc353de9", "0x20494099", "0xbf45ffbd", "0x1e0e2972", "0xf100ff20", "0xf03d3de", "0xff1ff03", "0xf2c3bf", "0xd1c00bee", "0x111911be", "0xc045eede", "0x2eec2c2f", "0x1fb15103", "0xe1f3a0ce", "0xe0f1f0e1", "0xe10116dd", "0xe020d19", "0x1c1001fe", "0xc0412110", "0x5eec1dc4", "0xf0e23010", "0x2f06d3ae", "0x1e21c3fe", "0x2e1df6cf", "0xfd322efa", "0x401e403f", "0xa1730000", "0x5e0e0cf0", "0xff122f2e", "0x2d31d1be", "0xd1db2d1", "0x2f1e13cc", "0xeee13eed", "0xcf1fd", "0xb141f0ff", "0x5efffbfe", "0x2fc5f2b1", "0x15ddcf1b", "0xe0a01e4d", "0xfe3e041e", "0xb122ab19", "0x3fec06fd", "0x9e1ff9e", "0x11f60f04", "0xe0e0b39d", "0x56cdc909", "0xed2fc02", "0x1b01f2be", "0xbd97e929", "0x134df1ab", "0xb90eb39c", "0xc101f093", "0xbff2f1fd", "0x39d4ceb", "0xddcfd142", "0xfa32c10d", "0xb0933919", "0x700f01bc", "0xc92f129e", "0xcfe0369", "0x70f5b2e0", "0xdd033219", "0x4d20e7e4", "0xd14f2710", "0x7113a2c9", "0x7cfc3722", "0x1bdef1fe", "0x2f333fa6", "0x40b235cd", "0xa4224b09", "0x1c1495f7", "0x6b1a773b", "0x39d1ab99", "0x797f3f0f", "0x999f909b", "0xee63a195", "0xf003140d", "0xf2ae20f9", "0xb02c26b5", "0x141f3ff", "0x2af1dda9", "0x735115de", "0xaa9cf0cd", "0x5cff74d0", "0x206521bd", "0xe0f0351a", "0xff617277", "0xf2531036", "0xd211c3ea", "0x712c004e", "0x2bbe41d0", "0x9f233133", "0xe00eefd9", "0xd011519", "0x4b07d077", "0x5d2ef071", "0x20fdacec", "0x4b32f55c", "0xa99d0fbd", "0x9e27b3a6", "0xe02ef23a", "0x209422d9", "0xfe4edd24", "0x5f4ce02e", "0x50fde0e0", "0x4e65111f", "0xca9df0ec", "0x1e05f5d6", "0xf071440d", "0x429c32", "0xe2230f7d", "0xf2f1e126", "0x113f031d", "0xf3202f0e", "0x25e6422", "0x1401c46b", "0x55322e", "0x7d729a41", "0xf322ea69", "0x1ee3d143", "0x7e2e221d", "0xee93b24d", "0x300d5325", "0x7e6b13c", "0xff30243c", "0x6d604ee0", "0x3f120c29", "0xfe2f0133", "0x432b122d", "0x2ab2df0f", "0x3fd21f13", "0x11f3df12", "0xbf0ff21f", "0x40000212", "0xe100f20e", "0xf44911fd", "0xe0eed41e", "0x15e21ab2", "0x212df2e", "0x232f12f0", "0xd102feee", "0xcd0c2110", "0xe41f410c", "0xce2312bd", "0x9411e26d", "0xf36d0cde", "0xf1d1003f", "0x2fe20ee", "0xd112e0", "0xddee11f0", "0x3e140cfd", "0xe13210f0", "0x9e40e253", "0xffaa9bb2", "0x1211d12d", "0x1e0f010f", "0xde0120", "0x1eb10100", "0xf000d1cf", "0x142fe10f", "0xf0021f", "0x1c000d1", "0xf0100010", "0x10f001ee", "0x10f01f11", "0xe1ee020f", "0x11000dc", "0xc02202ef", "0x221204f", "0xef101e11", "0x21f0f20f", "0x1e1021ed", "0xd001f1", "0xfff1fe0f", "0x1f12e1ed", "0xe13200ff", "0xd3f0122", "0xe1e1eed1", "0xe210111d", "0x1e0ef0fe", "0x1f00000f", "0xf1f1f00", "0xf0f0000f", "0xf00000", "0x111f1f0", "0x100f000f", "0xf110001", "0x100", "0x1001f0", "0xf01", "0x100f0f0", "0x10010", "0x10100000", "0x1000000f", "0x10100f1", "0xf11f0000", "0x1000", "0x1101010", "0xf01fff", "0x100f1100", "0x10f01", "0x1001f", "0x1010111", "0xf010f000", "0x10100f00", "0xf1010", "0xf0f00ff1", "0x1000", "0xf0f01010", "0x1f", "0xff0", "0xf0ffff00", "0x100", "0xff001f10", "0xfff0ff0", "0xf000000f", "0xf00", "0x10", "0x11100000", "0xf0f", "0x1100000", "0x1000f11", "0x10f000f0", "0xf100000f", "0xf0100", "0xf10100", "0x1101ff1", "0x10000", "0x10000f00", "0x1000000", "0xf000", "0xf11000", "0x1100000", "0x100010f", "0x10000f0", "0xf00f", "0x100100f0", "0xf1f1f10", "0xf01000", "0xff1f00", "0x10f00f0", "0x1000000", "0x1010f1", "0x1f010", "0x1f0", "0xf01f0000", "0xff00000", "0x101f", "0xf00010f0", "0x100001f", "0x101000", "0xf1010000", "0x1fa307ce", "0x2d6fde53", "0x321ddafc", "0x1f0e21f0", "0x15fd4f1", "0xa4bdfee9", "0x26e1454e", "0x44061c20", "0x2191afcb", "0xed6e5edf", "0xbf203a4f", "0xb43e7110", "0x90701721", "0xb21e1cc0", "0xd710c779", "0x3af901", "0xe0fb0ee5", "0xfb32eb12", "0xae10b0f0", "0xf151f02c", "0x9237d7f4", "0xb20ce111", "0xa70e3f7e", "0x2bfbff04", "0xef0afa2d", "0xab1a7bf1", "0xbc10b9a3", "0x1f3442ec", "0xcfe0120a", "0x9fc0fb90", "0xe5049b2d", "0xf2da2eb0", "0x10b11c72", "0xc1b07005", "0x7e4ddcd4", "0x3161d41f", "0xa75f47ca", "0x94e12f17", "0xd740ea7c", "0x2a4e7410", "0x30dc0025", "0x1041c0d4", "0x1ffcc39b", "0xd6ff23d", "0xb30ef400", "0x97310645", "0xa7706970", "0x60e900f", "0x213e6a00", "0x1324f0f2", "0x2b05ee1f", "0xf03fe012", "0xf100f05a", "0xd4501f31", "0xc460de4f", "0xffc24101", "0xf013e4e1", "0x50e4e1c7", "0x43a301c", "0x6611442", "0x3260f4bd", "0xb1124f44", "0x7737973", "0x3521251f", "0xc0fe0103", "0x4571f0e6", "0x2e3f43cc", "0xe15104be", "0xc3254561", "0xb1e6e221", "0x3750c070", "0x231f332d", "0x10f0f00", "0xf1100", "0xf100100f", "0x1000f000", "0xff1100", "0xfff1000", "0xf0", "0x101", "0xf01f", "0x100100", "0x100", "0x100f1ff0", "0x1f000f", "0x1f100f10", "0x10001100", "0x1f00000", "0xf00ff", "0xf010000", "0xf00f000", "0x1010ff", "0xf000100", "0xf1ff010", "0xf00f", "0x10fff00f", "0xfff010", "0x100f000f", "0xf00100", "0x1", "0xf0000", "0x101f000f", "0x101000f0", "0x10001f0", "0xf000f", "0xf00f0011", "0xf0000100", "0xf101ff0", "0xf0001f0", "0xf01f0ff0", "0xf10f0000", "0x0", "0x1f0001", "0x10000000", "0xf01001f1", "0x1ff0", "0x1000", "0x1f000f", "0x101", "0xf0010", "0x10000", "0xf0001f", "0xf1101000", "0x1101000", "0x1f000", "0x1010fff0", "0xf00f1", "0xf0f", "0xf0001f00", "0x100f0", "0xf10f0000", "0x10f00ff0", "0xf1100001", "0xf000", "0xf1f10f0", "0xf000", "0xf0ff0f", "0xff010f", "0xff0000ff", "0xf00", "0x1100f10", "0x100000", "0x101ff100", "0xf1000100", "0xd04df1f0", "0xe121aff2", "0xf2d0313c", "0xefafebe3", "0xeff01c20", "0xf121133c", "0xdff43c2", "0xffd3ee42", "0xc03020fd", "0x1022d222", "0x24cb0f19", "0xbbbfecd6", "0x40b13c01", "0x1954105b", "0x2ae070a6", "0xe4a3ff1f", "0x313210", "0x2f401f23", "0x2cd01c1d", "0xcfcf1e32", "0x5ebf0be1", "0xfed6242f", "0x4af00ea3", "0xf011e15e", "0xc010d092", "0x330ec211", "0xe0ede12e", "0x200a31fb", "0xcbc0fde0", "0xf0f1ef", "0xbc3d3b0", "0xf11f2c92", "0xf12dd094", "0xefcd2900", "0xc1ce630e", "0xfdbf50ca", "0x99c30d2d", "0x216b4290", "0x5ad0b09b", "0x11c14ae1", "0x4e0ec4", "0xc2ef3e55", "0x32d1ef10", "0x2fb41ff3", "0x9bd41c0e", "0x110902c0", "0xf9ee2192", "0xf10f71e0", "0x10c2aefd", "0xdfcd4e0f", "0xfed41a0", "0x4006c21d", "0xe0fdd00", "0x1011f1ce", "0xbdfcdbd", "0xe0f00c01", "0x10f50ef1", "0x9e21db", "0x1e01109d", "0x3ee0d2ef", "0x20feedeb", "0x32514fef", "0x9bcd91b0", "0xb4f01f2", "0x2013f122", "0xf0de0eee", "0xde0e05e1", "0x2dcf1f1d", "0x2bfdfc0c", "0x311e310f", "0xcbd032cf", "0xde121110", "0x2170f433", "0xd3e3f33f", "0x50201111", "0x91f21155", "0x732f0aed", "0x2d030320", "0x4c2e50c5", "0xc136044f", "0xd003343e", "0xf230a03b", "0x3f1dd1fa", "0x5effe142", "0x6faaf9ec", "0x53e402ff", "0xb9f17d92", "0xb5f6b003", "0xbf0121fa", "0x21ed7ffc", "0xe11e3b2d", "0xfafdf2f1", "0xcf90b0a", "0x6b361e9c", "0xab11fdbd", "0xecf000dd", "0xaf3607b1", "0x6013e741", "0xe6fb667c", "0x20b002f", "0xa5d0fdfd", "0x65ff12ee", "0x2c1063c0", "0x4161113", "0xd0deea9e", "0x1c512b", "0xa0075c4b", "0xdc351fb", "0xccb6d97d", "0x702114bf", "0xc9e0d59d", "0xcfef9cd3", "0xe0e201fe", "0xd1916edc", "0xa0e4e950", "0xbfdf0ff", "0x9ee5db2b", "0x63201dbe", "0xcb0fb1bd", "0x9fc62d1", "0xfb0c23f", "0xce001c0f", "0xf10e249d", "0x112310de", "0x1d02feef", "0x5ed210bf", "0x1cefcfd2", "0x3011fde2", "0x30d02e0f", "0xa4bf2df9", "0x2be3ed9c", "0xbafedeae", "0x2bf3fb1f", "0x527d2a9e", "0xdaee91bd", "0xecdae1ef", "0x2035e0e1", "0x1af2ffd", "0xd21012c0", "0xed0e0d11", "0x111feedd", "0x4e2d5000", "0xfcf011c0", "0xf02d1d1e", "0x70110d", "0x3e0fdf20", "0xd110244c", "0xe1df37", "0xf101000", "0x211031ff", "0x116213", "0xf101e230", "0xe073321f", "0x4e5dbf13", "0x32eed7b", "0xff0de55", "0x1fe00f10", "0x2215d30f", "0x4dcf60e6", "0xf212df40", "0xf052022c", "0x4f411200", "0xf091f", "0xe00e0020", "0x20ebfe0e", "0x1df6d4e0", "0x4dd2fce5", "0x22e012", "0xf090eeb0", "0x10c0610d", "0xf1e1d297", "0x12c31d9", "0xe0f0d2fd", "0x10d039d5", "0x1fd19d0e", "0x130f32b2", "0x10dedca6", "0x93cb7cec", "0xe1f05e97", "0xeb2f54ca", "0x9dd00d3c", "0x114904d5", "0xcfa092ff", "0x3cfc3fbf", "0xfdeea3", "0x9190fb1c", "0x4e142", "0x1e3300b0", "0x9f05ed2e", "0xf419acc2", "0xfdffe2db", "0x20ff31d9", "0x212030d2", "0xd0d30a1f", "0x2e0000b2", "0x1f040e05", "0x230022ed", "0x1f110560", "0x1d030f0", "0xdffff21", "0x2011e002", "0x41f3fc00", "0xd1edffe", "0x3b00fe35", "0x6c023fbf", "0x2016277f", "0x1fce5f04", "0xf210e050", "0xff2f30e", "0x130f", "0xdf1ef0de", "0x130c0c20", "0x22210fd0", "0x20e73521", "0xfef30ff1", "0x10001122", "0xf03f10e2", "0x12d0d10c", "0xf110222e", "0xf00f0142", "0xd11e040f", "0x1ffe0710", "0xecff23f1", "0x1021023", "0xdf71ffed", "0x502ee02d", "0xd2000d3f", "0x9d311e4", "0x9f71210", "0x2552f1e", "0xfc1171f1", "0xf10f00d9", "0xf0010110", "0x20f221f5", "0x100f09f2", "0xf3ff012e", "0x2eb01014", "0x2ff73712", "0x4cf00010", "0xe10ff33", "0xf01ef03", "0x60df31fc", "0xf2e0f1d0", "0x2c01203b", "0x19d0150c", "0x1e23d712", "0xff0e121", "0x24f010c0", "0x10e0f00f", "0xbd9d29f9", "0xf004bc4", "0xef1f3fcd", "0xa3efe72d", "0x105e4ed1", "0x1e0a12e", "0x20f17027", "0x206d10d4", "0xd1c10912", "0xe1f10152", "0x2c2ff001", "0xc9d5f61f", "0x34d6743", "0xfe7232", "0x10ffe0db", "0x30101f13", "0xbf0ddc0e", "0x10f1ff0", "0x2d261f02", "0x201250f", "0x4e2007f2", "0x200ff0f0", "0xfe020d20", "0x10f21e", "0x40a4291c", "0x1ed2e001", "0x1e2cfd23", "0x39e2f7ec", "0x31f21742", "0xd2f11f1f", "0x1fff0d0", "0xf0210102", "0xe40e11f3", "0xe1ff2200", "0x10311dff", "0x10b004de", "0x60062732", "0x13005154", "0x1003c13"}};



const ap_int<14> conv_7_inc[2][32] = {
{"0x1fe", "0x57", "0x82", "0xcde", "0x800", "0x420", "0x36a", "0x9c8", "0x267", "0x88", "0x1ac", "0xb7", "0xbd1", "0x35e", "0x134", "0xc74", "0x997", "0x625", "0x70", "0xac", "0x777", "0xa2", "0x789", "0xc22", "0x91", "0x71", "0x72", "0x107", "0xe5", "0x7e", "0x6e", "0x92"},
{"-0x593", "0x88d", "0x227", "0x10c", "0xa2", "0xae", "0xafa", "0x6a", "0x92f", "0x7d", "0x38d", "0x9a", "-0xe5e", "0x7e", "0x12b4", "0x60", "0xb1", "0xbc", "0x4f9", "0x23d", "0x5c", "0x15c", "0xcf", "0xb5", "0x6be", "0x10d0", "0x69", "0x3c7", "0xb4", "0x91", "0x3c5", "0x677"}};



const ap_int<23> conv_7_bias[2][32] = {
{"0x67ecc", "0x1a03", "0x1377f", "0x1de37d", "-0xf762b", "-0x134474", "-0x22ec5", "-0x7470b", "0x5be22", "0x30012", "0x79d33", "0x268e7", "0x3b9a77", "-0x13df7", "0x2b78c", "0x2074ca", "0x3378df", "0xbf4ca", "0xfd51", "0x20c77", "0xb4444", "-0xf9e1", "-0x1d6a07", "-0x66b89", "0x3ad92", "0x252cf", "0x7cca", "0x5651", "0x35791", "0x398e", "0x340e3", "0x207fe"},
{"-0x12e278", "0x159b44", "0x57cd1", "0x1a1d5", "0x182fe", "-0x19675", "0x2ac0", "0xc345", "0x2d36d7", "0x179e3", "0x152323", "0x24641", "-0x14473f", "0x1bdb7", "0x28b98d", "0xfa92", "0x4545f", "0x50380", "0x12c7ff", "-0x4c712", "-0x16f5a", "-0xbdb29", "0x5f472", "0x14e06", "0x8926c", "0x29cc20", "0x27d0e", "-0x128988", "0x3db42", "0x23e5e", "0xe3bcf", "0xdf5bf"}};



const ap_uint<32> conv_8_w[2][144] = {
{"0x1b99f700", "0x600001f1", "0xf70a6917", "0x9f479000", "0x60700a0", "0xa01100f1", "0x9670107", "0x9099016", "0x9f10000", "0x1fa000", "0x12000500", "0x79ff100", "0x3014030", "0xd0e00fe0", "0xf1f3760b", "0x10efb2f", "0xa3ab90e9", "0xdbbfbcbd", "0xba99a099", "0xf21d2f19", "0xe59bb9a9", "0xbbcbec19", "0xd9df009f", "0x9a94f0a6", "0x1c99f7f0", "0x600000f1", "0xf70a6907", "0x94379010", "0x60700a1", "0xa010f0f1", "0x967c107", "0x9099016", "0xf9f00000", "0x101fa000", "0x2000500", "0x97ff000", "0x3014030", "0xd0e01fe0", "0xf3760b", "0x10efb2f", "0xa4ab90e9", "0xdbbebdbc", "0xba99b099", "0xf30d2f09", "0xf59bb9a9", "0xbacbdc19", "0xc9dff09f", "0x9a94f0a6", "0x1499f710", "0x600000f0", "0xf70a6917", "0x94e79100", "0x160700a0", "0xa01f00f1", "0x1967b107", "0x9099016", "0xf7f10010", "0x10a100", "0x1000500", "0x97ff00f", "0x3024030", "0xd0e1ffe0", "0x10f3960b", "0x10efb2f", "0xa3ab90e9", "0xebcfbdbd", "0xba99a099", "0xf31d2f09", "0xf59bb9a9", "0xbbccec19", "0xd9df009f", "0x9a94f0a6", "0x1d99f700", "0x600100f1", "0xf70a6917", "0x94e79000", "0x160700a0", "0xa00000f1", "0x1967e107", "0x9099f16", "0xf9f00001", "0x1010a0f0", "0x2000500", "0xf79ff000", "0x3024040", "0xd0efffd0", "0x10e3760b", "0x10dfb2f", "0xa4ab9109", "0xebcebebe", "0xba99a099", "0xf31d2009", "0xf59bb9a9", "0xbccdfc19", "0xe9def09f", "0x9b94f0a6", "0x1c99f710", "0x60000fff", "0xf70a6917", "0x95c79f10", "0x60700a1", "0xa10000f1", "0x967d107", "0x9099f16", "0xf9f100f0", "0x1faf0f", "0x2000500", "0x77fe010", "0xf3024030", "0xd0e01fd0", "0xf3960b", "0x10efb2f", "0xa3ab90e9", "0xebbebdbd", "0xba99a099", "0xf31d2f09", "0x59bb9a9", "0xbbccfc19", "0xe9df009f", "0x9a94f0a6", "0xc99f710", "0x600100f1", "0xf70a6917", "0x94179f00", "0x160700a1", "0xa01100f1", "0xf967d107", "0x9099016", "0xf7f00000", "0x10a000", "0x2000400", "0x99fff00", "0xf3014040", "0xd0e10fe0", "0xf2760b", "0x10efb2f", "0xa4ab9179", "0xebadbcbc", "0xba99a099", "0xf2fd2e09", "0xe59bb999", "0xbacbdc19", "0xc9dff09f", "0x9a9400a6"},
{"0x92f90a07", "0x7110f05f", "0x70629700", "0x7f0e411f", "0x9b5e120", "0x700f0a40", "0xf077ebc9", "0xf9ba9296", "0x9f00000", "0xe1e0d0", "0x11010f00", "0xf990f0ff", "0x1d004001", "0x31b00cd0", "0x11e07601", "0xe000c01", "0x10100000", "0xf0010100", "0xff000000", "0x10011100", "0x11f01f0f", "0x1f1f00", "0x1011", "0x11100100", "0x90f90a17", "0x721ff051", "0x70629700", "0x7ffe400f", "0x9b5e120", "0x70f01a40", "0x1077fbc9", "0xf9ba9396", "0x7f000f0", "0xe0efdf", "0x10000f00", "0x79000ff", "0xfdf05010", "0x32b01cd0", "0x1e07601", "0xef01c11", "0x1110f1", "0x101f001", "0x1f0000f0", "0xf0110f", "0xf010f10", "0x1010f0", "0x100000f", "0xf011000", "0x92f90a07", "0x7210f15f", "0x70629700", "0x71ee400f", "0xf9b5e120", "0x70ff0a40", "0x1077fbc9", "0xf9ba9396", "0x9010f00", "0xe1e0d0", "0x11010f00", "0xf770f000", "0xd004000", "0x22bf0cd0", "0x1e07601", "0xe000c11", "0x1f0f000", "0xf101110", "0x10f00100", "0x100110", "0xf00f00", "0xf000101", "0xf1f00011", "0x1f010f0", "0x9ef90a07", "0x7210f150", "0x70629700", "0x71fe4010", "0xf9b5e120", "0x70000a40", "0xf0772bc9", "0xf9ba9396", "0x9f00f00", "0xe1e0d0", "0x10000f00", "0xf970000f", "0xd004010", "0x32b11cd0", "0x1e07601", "0xe000c01", "0x10fff1", "0x1f010100", "0x10100000", "0x1000", "0x10f001f", "0x111001f0", "0x11f0f", "0x11100f10", "0x91f90a07", "0x721ff051", "0x70629700", "0x7fee40ff", "0x19b5e020", "0x71000a40", "0x10771bc9", "0xf9ba9396", "0x9000000", "0xe0dfdf", "0x10000f00", "0xf790f11f", "0x1d004010", "0x31b00cd0", "0x1e07601", "0xe000c11", "0x1000ff01", "0xf00f0f0", "0xf000f100", "0xff01000", "0xff1f", "0x10101000", "0x100000f0", "0x1f00", "0x9ff90a07", "0x7210f05f", "0x70629700", "0x702e40f0", "0x19b5e120", "0x7000fa40", "0x1077ebc9", "0xf9ba9396", "0x7f100f0", "0xfefe0d0", "0x10000f00", "0xf790000f", "0x1d005000", "0x32b00cd0", "0x1e07601", "0xe000c01", "0x1ff11011", "0xf01f000", "0xf1f00100", "0xf0000f00", "0xf", "0xff00f0", "0xfff00f0", "0xf1f0ff1f"}};
# 18 "./src/ultranet.cpp" 2
# 1 "./src/pool2d.h" 1

# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 3 "./src/pool2d.h" 2

using namespace hls;
# 67 "./src/pool2d.h"
template <unsigned K, unsigned IN_CH, unsigned IN_BIT, unsigned VEC_NUMS>
void pool_cal(stream<ap_uint<IN_CH * IN_BIT>> &vec,
              stream<ap_uint<IN_CH * IN_BIT>> &out, const unsigned reps = 1) {
  ap_uint<IN_CH *IN_BIT> result = 0;
  unsigned k_cnt = 0;

  for (unsigned rep = 0; rep < reps * VEC_NUMS; rep++) {
#pragma HLS PIPELINE II = 1


 ap_uint<IN_CH *IN_BIT> temp_vec = vec.read();

    for (unsigned c = 0; c < IN_CH; c++) {
#pragma HLS UNROLL






 ap_uint<IN_BIT> temp = temp_vec((c + 1) * IN_BIT - 1, c * IN_BIT);

      result((c + 1) * IN_BIT - 1, c * IN_BIT) =
          (temp > result((c + 1) * IN_BIT - 1, c * IN_BIT))
              ? temp
              : result((c + 1) * IN_BIT - 1, c * IN_BIT);
    }

    if (++k_cnt == K * K) {
      out.write(result);
      result = 0;
      k_cnt = 0;
    }
  }
}





template <unsigned K,

          unsigned IN_ROW, unsigned IN_COL, unsigned IN_CH, unsigned IN_BIT>
void max_pool2d(stream<ap_uint<IN_CH * IN_BIT>> &in,
                stream<ap_uint<IN_CH * IN_BIT>> &out, const unsigned reps = 1) {
#pragma HLS DATAFLOW


 const unsigned OUT_ROW = IN_ROW / 2;
  const unsigned OUT_COL = IN_COL / 2;
  const unsigned S = 2;


  hls::stream<ap_uint<IN_CH * IN_BIT>> swu_out("swu_out");
  SWU<K, S, IN_ROW, IN_COL, IN_CH, IN_BIT>(in, swu_out, reps);



  pool_cal<K, IN_CH, IN_BIT, OUT_ROW * OUT_COL * K * K>(swu_out, out, reps);
}
# 19 "./src/ultranet.cpp" 2
# 1 "./src/pool_reord.hpp" 1


# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 4 "./src/pool_reord.hpp" 2

using namespace hls;




template <unsigned IN_BIT, unsigned PE>
ap_uint<IN_BIT * PE> max2_PE(ap_uint<IN_BIT * PE> data0,
                             ap_uint<IN_BIT * PE> data1) {
  ap_uint<IN_BIT * PE> ret;

  for (int i = 0; i < PE; i++) {
    ap_uint<IN_BIT> d0 = data0(IN_BIT * (i + 1) - 1, IN_BIT * i);
    ap_uint<IN_BIT> d1 = data1(IN_BIT * (i + 1) - 1, IN_BIT * i);
    ap_uint<IN_BIT> dret = d1 > d0 ? d1 : d0;
    ret(IN_BIT * (i + 1) - 1, IN_BIT * i) = dret;
  }
  return ret;
}

template <unsigned IN_H, unsigned IN_W, unsigned IN_CH, unsigned IN_BIT,
          unsigned PE>
void max_pool2x2(stream<ap_uint<PE * IN_BIT * 2>> &vec,
                 stream<ap_uint<PE * IN_BIT * 2>> &out,
                 const unsigned reps = 1) {

  ap_uint<PE * IN_BIT> row_store[IN_W / 2 * IN_CH / PE];

  bool load_flag;
  ap_uint<IN_BIT * PE> dataOut0;
  ap_uint<IN_BIT * PE> dataOut1;
  for (unsigned h = 0; h < IN_H * reps; h++)
    for (unsigned peIdx = 0; peIdx < IN_CH / PE; peIdx++)
      for (unsigned w = 0; w < IN_W / 2; w++) {
#pragma HLS pipeline II = 1
 ap_uint<IN_BIT * PE> data0;
        ap_uint<IN_BIT * PE> data1;
        (data1, data0) = vec.read();
        ap_uint<IN_BIT *PE> dataMax2 = max2_PE<IN_BIT, PE>(data0, data1);
        int addr = w * (IN_CH / PE) + peIdx;
        if (h % 2) {
          ap_uint<IN_BIT *PE> dataRes = row_store[addr];
          dataOut0 = max2_PE<IN_BIT, PE>(dataMax2, dataRes);

        } else {
          row_store[addr] = dataMax2;
        }
        if (w % 2 && h % 2) {
          out.write((dataOut0, dataOut1));

        } else {
          dataOut1 = dataOut0;
        }
      }
}
# 20 "./src/ultranet.cpp" 2


# 1 "./src/weights.hpp" 1


# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 4 "./src/weights.hpp" 2
const ap_uint<24>conv_0_w_new[16][3][3]=
{{{"0x8d898f","0x6f3170","0x4156c6"},
{"0x8a8789","0xb9b356","0x7b7b7b"},
{"0xa70550","0xfda6cb","0x6c72c9"}
},
{{"0xf4d83a","0x7002bf","0x759701"},
{"0x73a4c2","0x7b03a7","0x7dafc1"},
{"0x76f694","0x7cbaad","0x7dd2a1"}
},
{{"0x0d2f16","0x412f14","0xb3bddc"},
{"0x545d21","0x6c524c","0x8a86a3"},
{"0x3f663f","0x3e1347","0x8a84b4"}
},
{{"0x66e8ab","0x855231","0x877612"},
{"0x8f680b","0x846c13","0x846b1a"},
{"0x77087","0xe47ca0","0xb17cd4"}
},
{{"0x81137d","0x824347","0x31de4"},
{"0x84067a","0x198769","0x7dd6a1"},
{"0x78967","0x7eb4b6","0x7ffa84"}
},
{{"0x7cd0b1","0x7cde9b","0x568d1a"},
{"0x0b8563","0x29857f","0xcba67f"},
{"0x09877b","0x0837e","0x0877e"}
},
{{"0x0889a6","0x514d22","0x2a7061"},
{"0x9e8189","0x716a5b","0x187363"},
{"0xe68ebd","0x3e572c","0x7705c"}
},
{{"0x653ff7","0x449249","0x30a5c8"},
{"0xa14a2a","0x797778","0x766855"},
{"0x839ce0","0x838586","0x8ff8b1"}
},
{{"0xc15507","0x868a89","0x8c9595"},
{"0xaf96a2","0xa0ff63","0x757477"},
{"0x7b61b7","0x7b646b","0x709b3b"}
},
{{"0xe8cbd5","0x7c7c7c","0x96c1bd"},
{"0x7c7d7d","0x828384","0x2b4d8b"},
{"0xd8797a","0x8c898b","0x759f65"}
},
{{"0x1b67b4","0x51b028","0x858386"},
{"0x14de16","0x3ab421","0xf49744"},
{"0xae492f","0xba6cca","0x0d71b2"}
},
{{"0xc22ad7","0x887ad8","0x857ced"},
{"0xf533b4","0x8f7d9a","0x8a7cad"},
{"0x54d899","0x9b7c9e","0x9d79b0"}
},
{{"0xe5533a","0x416a64","0xb10624"},
{"0xf7f1e5","0x4d585b","0xe7d5f1"},
{"0x3fb397","0x4ec8db","0x3cd426"}
},
{{"0x360d0c","0xb58d85","0x7703c1"},
{"0x277078","0x504f","0xa19f86"},
{"0x954a66","0x24686d","0x493a16"}
},
{{"0x492611","0x543139","0xbdc3ca"},
{"0xdfa6ad","0x7b6d77","0xc79fcd"},
{"0x433237","0xe0acd7","0x5a493d"}
},
{{"0x72f49e","0x861778","0x853270"},
{"0x7bc88c","0x328e23","0x892853"},
{"0x791da1","0x16889d","0xbeeb6f"}
}
};
const ap_int<15> conv_0_inc_new[16][1]=
{{"0x0ad3"},
{"0x0a94"},
{"0x0fe2"},
{"0x0d89"},
{"0x259b"},
{"0x1820"},
{"0x11c1"},
{"0x0c4a"},
{"0x0aea"},
{"0x12f6"},
{"0x1805"},
{"0x12f8"},
{"0x1018"},
{"0x0be8"},
{"0x1a04"},
{"0x16a8"}
};
const ap_int<32> conv_0_bias_new[16][1]=
{{"0x3d7d37"},
{"0x1a2189f"},
{"0x170d005c"},
{"0x591f62"},
{"0x1dd00e3"},
{"0x0a5af20"},
{"0x12e52fdf"},
{"0x08479b5"},
{"0x0d8099e"},
{"0x4cdd76"},
{"0x2f1388e"},
{"0x4212037b"},
{"-0x24f48009"},
{"0x1264e6d4"},
{"0x663fe69"},
{"0x588e874"}
};
const ap_uint<64>conv_1_w_new[4][3][24]=
{{{"0x14316f1f017f7190","0xeedeeefefbc77b91","0xeed2a2010d97fd71","0x1f3f0e1fff522f0d","0x34fff4df0332212","0x1020ef6e00546250","0x3f03f212e2fca213","0xccb0d0cc9b2ecccb","0x2d0df039270ade0","0x60c035edb4ac0104","0x3ff343029590b3f4","0x25505425b7d20517","0x0d13f0ee23e2d22","0x0eb1fcfb2e1e314f","0x1fcfb61c3fd39f0e","0xdf0feff0cf3022c0","0xdef334d21c213ecd","0x41002fd030061331","0xe12e9e31f133b160","0xe24f2233023bd142","0xc35064230e9e50de","0xf0e1ce24326d20ec","0xe001fc41330d130c","0xfd300e1040b0ff0e"},
{"0x551111f04e724a1","0x20ea3f1f0c79072","0x10020201026b9471","0x1df0ef2abdf0e0d0","0x1ec2e04991dfd112","0x0df0f0299dedde0f","0xfed102bda020bed0","0xccdf0e9f9cc1ecdb","0x1441f407137c2411","0x0cf0d0e93e4ef13","0xf2e10f1292e3fe11","0x45f1f220502e2c2","0xc2e35cf50d2f7d92","0x20bffa1c6ea772ba","0x62fe961f2fa59e0e","0x1e41f0f1fc1eff23","0xcf2302bf092e0ca1","0x3002ff0320342ec1","0x701ee201c27fc151","0x231e2423c1eb1121","0xc45f4022119b60f0","0x131fcf31206f43f0","0x2512ee45225e13f0","0x3ef0f2043d0d4e10"},
{"0x3103ff1f3a1a2e0","0x2ec00f11fd59fe4f","0x2dc15df0ede94df1","0x2f00003ba112d0d1","0x1e2f0099112c2c2","0x0e02dff99dc0bede","0xeee202b1b1b3a02f","0x1ce0ddb3ce0dce5d","0x2331d124e374c342","0xdcb11af1c54f4013","0x0f012e01f26c2101","0x35f120bd66fb6e2","0xd0f1ef2e1d437e00","0x1ede1d2b12b4b0fd","0x3ec1ef0ef2ee9052","0x3e431f143c2eef74","0xcf22f1dffa2dbfb2","0xf001ed023e223ea0","0x0ffff12d1aee1de","0xf11f1122d39161d1","0xc3313e2ee1917230","0x11f2150203f2ffd","0xf2ee2e31c33e25fb","0xbcd10f40e00e43dd"}
},
{{"0x14301e4d53734373","0x32fe2a29146f0226","0x1b02c1ee2d9e9baf","0x11003f0011d2d22f","0xd10fe10f03917210","0x1030a02edf20f100","0x122ec1022ece9d10","0xe21dac01200e9f30","0xf12e00002fee9f20","0xc43d032e052013d6","0x1e31eedbddc1ebf1","0x0bd1de9beab0da29","0xd0f309ffebc10ddf","0x201e1ef01fc0134d","0x300e2731102333fe","0x2e1de2f25c3dfead","0x0dfdcdff3b3d4d9d","0x2badabe10a522a9d","0x21e0b1fc12dee040","0x30d1430fe254132f","0x3ec2301d055e06ed","0xfd0faeeba02de3ad","0xdd11e0bace2dc1ac","0xddd4decd1200cfef"},
{"0x243d521033515f2f","0x44fd4d2d32126f36","0x0d4fb2fd5c9c9cc3","0x1221e111139d42d2","0xcd00600cf2997090","0x3dd3710eff9f7da0","0x34e920441669cd1","0x130d9c1230749210","0x230cb104250923e","0x662c0c20142e0416","0x3e00f132fd1f2f","0xba02db9e19e2d9f9","0xe2d0f9110defd44d","0x710da77143e4942f","0xfdfe07e33c3f1ca0","0x103e32013dbdbf1b","0xe24e1e0e1db30e90","0x0de02deedc256c90","0x221fc3ec00ed33ed","0x2d004ebd47234dd","0x20d023cdc57de4ce","0xfe02d02ca2d7f03f","0x2230f10ba4d6d302","0xd122d2dca4bec112"},
{"0x20012ef32120bf4","0x551f2e1f21f263fe","0x2d11a3ed1d9bbc10","0x11223f10f2eb1231","0x0e01f0f0f0a9f14f","0x1ef1a1f2e05d9d42","0x10eff2fef3d0bfd3","0x2fdece220e249200","0x11f0bf1f0e2c9120","0x563c1d5462540006","0x0df000223f216f13","0xeac4fb9d09b0a9e9","0x30e0f25f5e1004fc","0x2ff1d7f411efc0e4","0x0ce24ccfeb4b7b2f","0xfe1f31002b93fc1c","0x24ef01030b7e010","0xce4ee5705d271ee2","0xccf2ce0fd0bfd4fd","0xce10def1f2f1e2ed","0xed211fbd129fd3cc","0x0e106313517d7e61","0x41e06145227d6222","0x732e311e33504f00"}
},
{{"0xffd2efdc00ccbd21","0xbdb22aec9ebaae41","0xf1015a0e919aa563","0x1e2edb2e1d52214e","0x1d11f5fc2ddf0fbc","0x6ef2e70ef2c0b3a1","0x4dcd9d04efbc9ee1","0xc2cc37f2e0ef2be4","0x0e1f5af222fc6ed5","0x2def0303a010d30e","0x9fde1713ab6f1e0d","0xcbd12dfecb017b3f","0xe2f0ee60e1233246","0x100f2f5cbf1d0e36","0xe10ee31cc21ee430","0xcbb2b19249cca9d9","0x0e2ffed63d224c0a","0x70ef202133041333","0x12f1ff0fc002d","0x71dec60eed0fa3af","0x73ebc72f0d1ee3cd","0xef1e57ff301171fc","0xd0215012ff607fcf","0x6f31af1f4e17019e"},
{"0xbeb05dee91bb4042","0x0cf391eb00a4303","0x354d532c05404656","0x0edc09e0cf35fda0","0x0ccdf5ed1de0edbe","0x7f1fd71f25bec592","0x5d0ebf137e1ebcc1","0xd13e440331417192","0xdf004cd3045f64a2","0x711e0afc64b103a5","0x737f9672f20f9543","0xaf2d5716dd7ddd1d","0xd330017321f1efe5","0x200f72736e042eb7","0x11e50735ef0a0e6","0xcac0c09039ecbaf9","0xee3ef0a43b4c1ed9","0x732f2a3154e30036","0x0f122f1214e10231","0x31fefe3336c3abb7","0xd0fc0b0207c72be7","0xdf0f701effca6212","0xc011533de27131ef","0x62efc2301444a392"},
{"0x2fc033010f7462a1","0x751da55f4e77d191","0x453eb62511753393","0x20fdede3f0343cf1","0x0fef35e13e4e1b64","0x7cff44e03dcfef32","0xfcffa001ec2f9d1e","0xeeffec131eb2c1bf","0x1ee1b0f72fadd10e","0xb2fd3ebcdeff2bed","0x72cbe9ea46920fb7","0x6bf1fc2fecf03f31","0xf101d26d0d102ed3","0x1feec2701ddd0df5","0xf0fdb13d0f00e1d7","0xfec3f1a01a0f2bfb","0xe22e2fb1fe1f0fdb","0x343c2ce5133e2f3f","0xedf3deed0e2ffc2d","0xfbd20cebfb3e2a30","0xcabd0ddfda414a2d","0x40d1d501f09d9301","0x0ff0c3fee2ba9e40","0xe1f1cd4df5fe93b4"}
},
{{"0xc1a2eaab1e523ffe","0xd2cf1bca10ded02d","0xe00e6f0defbd5f2b","0xe5616002052c7490","0x420f7df3f3fd7390","0x310f79f0f1dc729f","0x0dc1a200dfa2905f","0x10f2ff11f20e9121","0xff2d5e0100df9112","0xfe0011bad35eece2","0x1bcf1b9991520dc1","0x3abd0c9aa1ceebe1","0xddd0e43f5afbfd30","0x3f0222fe1a3ffeed","0x521f15121b1f033c","0x34e3ed25e35ce1f","0x753cdd517547b107","0x453f05276462a004","0x0fffbe01f1fc9060","0xfee0d3f1d01faef0","0x33209b11e3116091","0x634f7303f36e65ce","0xcee312b4bfd201ca","0x42fca03b0dd907a"},
{"0xa2c1de9c2b74cdb9","0xf2e0ebac4e12bdeb","0xff0d3ddd5de03c1b","0xe4624120f3d2947d","0xc122f13ffd27e0bd","0xf010f0201ef442be","0xef001311027c5ebe","0x6211ac01fe527192","0x212fac0f020004a1","0x10d02fae14f31c15","0x0fc2dfc1f3131e27","0x2cc0edafc0f01bf6","0xdeeedf1f3b1fcd2d","0x2fb01dd9aa6fceea","0x724f3d3e9dff44c9","0x2e2111adcc0b2e0c","0x2231200cc1ee2d2b","0xb2fc4b4df4105237","0x101fb10212c1907e","0xf22e24f412796f90","0x234f7df0e4517291","0x30327313d47255c1","0xec013295df034dbb","0xd33ddaf10fedae7a"},
{"0x931012cc3c241fda","0xc42f0dbc2de0ceea","0xf01e2fbd2fdd3c3f","0x4340e00ff2d1957f","0xff109f3e00509f72","0xee11912ffe1d9f70","0xdd346220307e50a2","0x1ffdd1010577090","0x32ffcff0f0d1619f","0xd4ef0dedb69e0b26","0x24d1d010f5b10e26","0xffefe20ce3020ef7","0xfededee05abcbb4d","0xeec11daca941cbec","0xef003dceacb641ae","0xee0126b1faec4eec","0xccdf02be9dfa4fd9","0xe00ff0bca0bfffea","0x1340c2f0029b917f","0xe26e3010033ed241","0xd45e7f1f04137390","0x0e1e23f3e34533f3","0xec013195aec21caa","0xf23cbdd4c1a0ae6b"}
}
};
const ap_int<14> conv_1_inc_new[4][8]=
{{"0x4f4","0x44e","0x463","0x579","0x582","0x0e83","0x3ae","0x088e"},
{"0x492","0x4b3","0x4ad","0x5ac","0x430","0x4bf","0x15ea","0x4c3"},
{"0x403","0x578","0x3f6","0x3ea","0x64d","0x408","0x435","0x546"},
{"0x31d","0x657","0x4a3","0x5c8","0x0857","0x424","0x671","0x4e1"}
};
const ap_int<23> conv_1_bias_new[4][8]=
{{"0x097c2","0x08fe98","0x0cf1bd","-0x1a6f00","0x0fe309","0x3e7991","-0xb7780","0x50d19"},
{"-0x7bce9","-0x1a874","0x52294","0x0d6ff9","0x49448","0x129ba1","-0x280e82","-0x4794b"},
{"-0x4cff7","0x0c5aa6","0x0b0893","0x4aa8d","0x51e62","0x0dfe06","0x0c342f","-0x5fcde"},
{"0x0c292b","-0x181c06","0x36994","0x11d32d","0x2707fa","-0x4a00d","-0x145249","-0x8aa88"}
};
const ap_uint<32>conv_2_w_new[8][3][96]=
{{{"0x3b334f1","0x14020f3c","0xe5ec101f","0xfd55c221","0x4fb3f40f","0x2e12af2e","0xd1fbcacc","0xdddfd1ff","0x1d00f20d","0x32e19d01","0x0fdddcfe","0x3ef0030c","0x47b1cf1","0xe1d0690e","0xb0ff5df4","0xefd0fcfd","0x35be0dff","0x23c5193c","0x0d4d053f","0xf416bf1f","0x1c29cde","0x4e95cc1e","0x1b0da5c9","0xcfe5e101","0x0e7be30f","0xef007654","0x0eddc602","0x10247129","0xd050df0e","0xc1fd714f","0xfff0f1c6","0x9c02a00e","0xe49f1e11","0xcf0f1de1","0xef13f103","0xe1f4b421","0x10ced30f","0xb2f2d2bf","0xe90cfe2f","0x0e00dd","0x53111e1","0x3e100e40","0x3ac0edeb","0xcd112fc1","0xffb103ef","0x422014ee","0x12e4d2e0","0x10e0ff1f","0xefcde2fe","0x2e1bec6","0x21ea2f32","0xedd94233","0x0c0b01ef","0xe0a14004","0x20de0023","0x2d2c2ffb","0xafe212df","0x1ece61bd","0x1040bdb0","0x4dbe0b","0x1c0f11f2","0xcebce0f3","0xd04f0fe0","0x1b3f2110","0xc20f0650","0xae2a27e1","0xcfd5d7ce","0xdd651f0d","0xe002006d","0xc35224ac","0xf2f5ce9f","0x0a1ff0ff","0xc1c3d0a1","0x5c001d5","0xd33b1d0f","0x592ab3e3","0xbff9a0c7","0x11f5e331","0x0ed991de","0x1ad9fbcf","0xcac9f310","0xecbf902d","0x4a9e97d3","0x2df2ef10","0x9defd1fe","0xec2efded","0xdeee203f","0x0a2d9fe1","0x9f0f02e1","0xdfcfbb42","0x14101f33","0x0fffa211","0xa4ec0f14","0x31c3aa5f","0xe4222e51","0xefe1a312"},
{"0x26529430","0xd221734e","0xcdf0e71f","0x9c2750dd","0x54c1a6f2","0x5037efa","0x29c2a6a0","0x9316e1cf","0x14ead4f0","0xf624f2dd","0xdbcfa1a1","0xc4f2b6e4","0x21f01156","0x34101124","0x510f5db2","0xd5010f23","0xf2e12e0e","0xe2022214","0x721e00de","0xec23f312","0x3fe5ff1d","0xf2f5130e","0x65db1dcb","0xab030411","0x5e670032","0xd3ebd65c","0x093dc2bd","0xe3d7fd4a","0xd1d4ffe3","0x1f1e947e","0x39fecfe3","0x93e6d0ee","0xd4b02fdf","0xff22cf2d","0x192f2102","0xa2d0a3ef","0x2eea32e0","0xb7e1d4ea","0x1130f375","0x441e35f9","0xf0701fcf","0x1fe07e7b","0x5091f5fd","0x20f539e9","0xe77040eb","0x3e1e2d7a","0x0df4e7f1","0xb2f000de","0x0b1ff2bb","0xe40095c4","0x11220161","0xeefb571f","0x5d7ceeed","0xd31f6470","0xd5159fe2","0xe5a43c09","0x904e4eac","0xd0f0525b","0x107293c5","0xe6be941d","0xfeffa1f0","0x2bc9cc16","0xe331ded0","0x6ff0ee2e","0x49df9f0f","0x0d39115c","0x26c1a7d4","0x26a5f3fe","0xe9ea9dfe","0x3cfbfdd4","0xf0e1f023","0x7deb0990","0xa1e3feb3","0x55ef22e5","0xf22f5d3f","0x5c2c16f3","0xde2bc2d4","0x14e412f2","0x0d121a","0x4bfedcd2","0x1ede665e","0xbfc29e0f","0x2ba3c31d","0x4066f2d2","0x9ddfc1f0","0xff2e211f","0xe0f0111f","0xf10caff0","0x9a23ffff","0xddec1b20","0x12e01f10","0xf0eeac2e","0x9f0ebc11","0x0e03dd50","0x43cf301f","0xd2d0b65f"},
{"0x44044030","0xf210223c","0xd1410210","0xffc6ff3e","0x5df424e1","0xfef0e1eb","0x1a10bdd0","0x92d2a0ce","0x140e01fd","0xe5141eee","0xef1edec1","0x21b0d6df","0xf94330d0","0x0e0300f1","0x21200fc5","0x393aeae2","0xe94a3db2","0x2d21e44b","0xe5e31f14","0x2bfc09ef","0xfb0f1ced","0x104342fd","0x250d310f","0x4c1a1cee","0xc302dd30","0x2ffeef7","0xf2e911e1","0xe30eff32","0x0de2d130","0x1fefedfe","0x0ed91d12","0xe0ffcd02","0x42e10040","0x2f109feb","0x0deef110","0xefffbe03","0x2edeffee","0xd3d212bc","0x1130be00","0x522d03fe","0x0d4330d1","0x3ff0e07e","0x19e00eeb","0xd2011de1","0xd2e0f0cf","0x4d1ed22c","0x0f2f2520","0xf01d0103","0x3d22d5ba","0xefd1bdf4","0xfde24129","0xfe022f41","0x2cd4ed21","0x12e0fe03","0x11e1e20c","0x5f25f3f","0x0da73100","0x3e1e0f00","0x592ebf0e","0xc500ce40","0xe2f30de0","0x40fc0d1b","0x1e7c5dbb","0xc3ff1c5f","0x3370b40","0x4da1dcfc","0x2add5e4e","0xd313e232","0xfce351fc","0x7b953aa2","0xb9dc2d7f","0x4f2f0cf2","0xb0151bb0","0x4000410f","0x3ef36efa","0x1bfbd3fc","0xe035eece","0xc2fe5f10","0xc11472ea","0x4fe0ecfe","0xf0e5c50a","0xb2bc2eec","0xbf1413ee","0x3247e224","0xa1fac1f0","0x0f41e5a2","0x11bf531","0xf01ad1e0","0xba500311","0x0f3d0de2","0xce0eee0d","0x2bbf12","0xaa4fbd10","0xe3ffcd2f","0x2cb0ded","0xfe0b9e21"}
},
{{"0x20be015e","0x2230dc42","0x4b32f3f1","0x335f19","0x43c401f1","0x142f4ccf","0x4e0200df","0x120022dc","0xfde33f1d","0x311fe0ed","0x212e0db0","0xd2eeeec0","0xfd1f1f0c","0xdceccfd3","0xc106f1fc","0x10f5ff22","0xe00fc000","0xdece0e2c","0x9cc1eccb","0x1f0ffbfe","0xd3022104","0x22d13f2f","0xdff6000c","0xf4e5d013","0x3b3f3742","0x1bc2ff24","0xcf6ff033","0x0c232a06","0x2d3cf392","0xfcb00d5e","0xcd110163","0xcb2349f5","0xf20f3d90","0x0cc1112d","0xde052541","0xc0c25af1","0x3ebf24e2","0xceb29a2f","0xe00d0b2c","0x9d50c0ea","0x43ed0411","0xee130bde","0xe00ece2e","0xa06dc207","0xdbaa1d40","0xa0735fd2","0xd2bc0ce4","0xb42e33f4","0xde026795","0x1741cd94","0x2f7be774","0x2e4c46d4","0x216015e2","0xf40fe29e","0x201112e","0x1152ee12","0xcd3c332f","0x1fff0e9","0xc3c03d04","0xe61ef01e","0x0fdd2bbe","0x4f69cf20","0xd12020e5","0xc22e5c00","0x121f2090","0xfddf2c4d","0xc01e0193","0xb1df51ed","0xf232f2b2","0xcfff1913","0xbdcd3993","0x210d361f","0xb1b5b3ff","0x0ee20a20","0xeef00000","0xe021ed0f","0xb592e014","0xdee32c42","0xeedc0ef1","0xef319d1c","0xdd91dd01","0x3011cd71","0xf3d01000","0xf125c12a","0xfc94bf0e","0x1d2f0ac0","0x1ceb41fe","0x0bfcdf20","0xe2b0c3da","0x2e3d13c7","0xe210123a","0xccee34b1","0x2e79bf32","0x9d0c774f","0xf191a60f","0x94d73b9f"},
{"0x0bb0043e","0xe5e00e40","0x2fe412e2","0xce150f2c","0x52b0f05e","0x32e1949","0xeee014de","0x94e73fe9","0xf3eefafc","0x2443010c","0xc1021e90","0xf2e31d0c","0xff1d1def","0x0cecefe0","0x13f1d4fc","0x2e12cef0","0xfdcddcfe","0xbfddc03d","0xe2cdcf1e","0x2e0beaef","0xe0f1f1c4","0xe0df0efc","0xe4f4f0f0","0xe10ecdd3","0x0912e503","0xf9aee4ef","0xa1de3210","0x1f1191f","0x1d24c3d1","0x19bf122b","0x90c02041","0xded1192c","0xc20250bd","0xbaf4e3f1","0x9e403f00","0x2ca0fe0f","0x2c030347","0xdf01e322","0x1401d00d","0xae122fee","0x50a4ac16","0x1e444092","0x2c2da600","0xe24f02d7","0x1293f1e6","0xd0606492","0xddfd52f2","0x6d14f3e","0x5211539f","0xd62f13de","0x62ff02f3","0x221f25e0","0x0b5e1593","0xe42af6b0","0xebff1212","0x423cef6","0xaf0bd03e","0x41ce10c","0xc0113ff1","0x153f1150","0xdeca5bc1","0xe30a00ff","0xb4f130b1","0xf3ee491e","0x21fb1e9e","0x4f1b221e","0xe0421092","0x3ef5cef","0xff2300f2","0xcd0e1a0f","0xe1beca93","0x1e2ff3ef","0xc4200f20","0xe111e0c2","0xd2b2e022","0x0a032402","0xcf6dde2f","0xdeed62c0","0x0c0db000","0x1d524e03","0xdedf94bc","0x5ed35de0","0x2d11f0b0","0xeb12002f","0xecc1b1e1","0x2e0ffa0f","0x1d0c201e","0x1d2afd10","0x31b00dad","0x40ead2d5","0xfefd0df9","0xef0dffdd","0x2d50dcf4","0xaf40e3c2","0x13e000d2","0xa7940ed4"},
{"0xec9e30ec","0x54cb32be","0xf4153402","0x1200fe10","0xdccadef0","0x341b0e2c","0xf4cdf2c0","0xb1e3ecbd","0xe619b96f","0x42c24b","0xd0bee2a7","0xc1a15e9e","0x0e1c3cfb","0x0adbd1b3","0xf306f0ff","0x0e13f002","0xf0ce2cdd","0xccfa0204","0xd0bfdfee","0x2dee1bf1","0xf00d22c3","0xe0ed0210","0x14e6e314","0xfef311f1","0x1992e3b3","0xeae02a1e","0xede0040f","0x2d0fde2e","0xded5e19f","0xfacf0bdb","0xfc2e5f0f","0xfbcfde1b","0x111440a2","0xce2f55a3","0xd0111fdd","0xe0ec40db","0x0fd6d301","0xe0d62de1","0x0ff1bfbd","0xb2c4d1cf","0x21e405b3","0xf1f2f1ce","0x1e10f1e","0xf2f4c4ef","0x2d440c3","0xad0fbcc0","0xf0c13c23","0x4201023e","0xeef21ea1","0x2e1ce2f5","0xe0101ddd","0x1a0dbf2e","0xd39202ae","0x2a004ccf","0xb2130c20","0x1f21be21","0xd69f30ae","0xbd2a4c1e","0xb2221240","0x12be2bf9","0xf2d94105","0xc02ece3e","0x0e2d5fc4","0xf1331f43","0x0e0b4d9f","0x202291e0","0xe1f271b5","0xd3a3210f","0x0e45e3f2","0x1171feb7","0x4e111c2","0x3e3151f2","0xf13043b2","0xf41194e3","0x16c73f31","0x16f731","0x1a70ffdb","0x1fc0e7f9","0x2910120e","0xe1e13f17","0x2b76e1e1","0x20df10ab","0x4b774593","0xb516d4ff","0x2ed2d00e","0x1f1faefe","0x1fda332e","0x0dcb0f1d","0x1100ee0f","0x5edf44","0xf3e2534f","0xf1ed1f1f","0x10eb0b1e","0xcf150b0f","0x131023f1","0xcdef35fd"}
},
{{"0xe3e1f202","0xcd112ece","0x0cb0effe","0x1ec4f13f","0xdffd1e10","0xffcf3edf","0x21b1ee1f","0x3c30c322","0x12b1fe1d","0xb022df0e","0xd1a3deee","0xaeceb04e","0xffedf11c","0x52e1a1dd","0xd0ef32ef","0x1dd0cf3","0xfe0d0e1d","0x20efc03d","0xdfde30e0","0x1ffd2ae3","0xf009ee21","0x23c301f1","0xdf0c40ed","0x2d9dfe04","0xefb47ddf","0xee0e4d17","0x17ffdde2","0xf1e302eb","0x2f33e315","0x0c4212a0","0x2122f502","0xf1d4131f","0xe230cf01","0x0b30df9e","0xbefc4cde","0x0ecab201","0xfe631e24","0x11e1ed26","0xed041fa2","0xe404421d","0x2ca2b1d4","0x1da0eca7","0xed0ee1a4","0x1eee30ff","0xfab1feee","0x402ddb15","0xdccf42c4","0xd0bff3fb","0xdff3ff0b","0xbfd4bfe0","0xe113f020","0x31f190e0","0xe41c432c","0xd5ff33c3","0x3ac1d572","0x2f41160c","0x0d7213cf","0x11fd796d","0x49bd00a2","0x90f31f0b","0x5f11d4df","0x2dfd3104","0x2c1ea1c3","0xd1f0403d","0x3d10f01","0x3f1f60f2","0x5d4ebf4","0xf1044f3b","0xf2316e2f","0xc1010bbf","0xe7b10424","0x1e0f4ff5","0x41e72eee","0xd31013fd","0x3a42d434","0x25c41e10","0x1331e10","0xf20e2e99","0x316c0e1","0x43063ef2","0xee0531fc","0xc4b22c24","0xf1f2bf1f","0x40d31c2d","0xdd3f263f","0x13241edb","0x2cdcde10","0xe1102332","0x1f31462d","0x27fff1ff","0xf501d014","0x1d11f532","0x1223212e","0x30c9f25","0xd142f4e2","0x0e33b21e"},
{"0xeea5efff","0x1f2fb4a4","0xf232073c","0xfaa141db","0x2c7ce4f0","0xf11b7730","0x39abb600","0xb05274be","0xd97e00d4","0xb33d347f","0x1d9221d7","0x94f4a3cf","0xcfe1df0c","0x3de0ddee","0x4b401d1d","0x1c0d9431","0xe0c420ee","0xfda1ef0f","0x0a5d2aea","0x5a3cbc20","0xe5c74ffd","0x10f22fdd","0xef2e2bd9","0x2d39d0ff","0x421373e2","0xcd11f224","0x56fe2230","0xe1a02400","0x4053f726","0xed73e3df","0x531f450f","0xf3b5261e","0xc3f0f103","0xed5ed1ee","0xf21b3ccf","0xd3dcf53c","0xd5711000","0xbeef2ed3","0xf053deb2","0xf0223dde","0x5213d4f3","0xa20f19a6","0x300eafd6","0x0d300be2","0x1b1202dd","0x41abcf","0xf0c2b2ff","0x3ef11d0f","0xcec0d1fb","0xb1d00e01","0x13321d0f","0x32df11","0x217221e9","0xd40e96f1","0x61a1c150","0x1e0ef5e0","0x5e7ff2b6","0x21da161b","0x1adddfd5","0x91e42fcd","0x3105ee0d","0x0f09ff3e","0xfed0ffed","0x22021d1e","0xe5dd0e41","0x1f0d301f","0xe6d5fbe3","0x14020b0b","0x953a6b03","0x102eafe","0xe793de25","0x22fb1005","0xf133edff","0x140eace9","0xff9efe20","0xf2bc2e2f","0xcf7c02ce","0x0ebedf99","0xf393ecd2","0x3ec0ee5","0xfb3dcfad","0xc0be2cfe","0xf0cee2ef","0x21cb3bf0","0xb1fb701d","0x3eef4399","0xf0aece42","0x2eb2012","0xa2feff0f","0xd1fa5ab3","0xc3e10ed2","0xeecdcf01","0x44d091e0","0x10daa75","0x93f11e0e","0x1c15edcc"},
{"0xf2a2eddc","0x31feddfd","0x2b2ebf0e","0x3021d01c","0x327203c0","0xc2ebb6b3","0xf92abefe","0x2feec2d1","0xc9ec4c9f","0x1221a070","0x0a9cdd02","0x954ec2a4","0xd271f4ec","0xfe102514","0xf201ee40","0x26424fcc","0x5e7ae700","0x94107ff1","0x20229646","0xb77564c9","0x0dacc74d","0xa5104420","0x3ff0c341","0xe234f2f9","0xf7bd4e1f","0xeee0e900","0x6fddf40","0xedbed431","0x1c2eb221","0x2d5f2ec1","0x0f1a22ff","0xeeeccf0d","0xccfc9fd1","0x0e0cbcdc","0xddf90dcf","0xb109a002","0x32e2f24","0x1fee610e","0xc3272316","0xc1e75de0","0x2e251131","0x120c5ecc","0x22022306","0x0f060cee","0xfdb2413e","0x327eae31","0xed952f03","0x1cc6f103","0x1e2ec101","0xd3c2dfd1","0x2e4ce002","0xde10f034","0x10d2d2fd","0xf3bd0d23","0x0dfaed01","0x1e4ed30e","0xc39e23df","0x1ef11d0","0xd0dcee00","0x1c2011ff","0x0ce6250b","0x21ebdd0d","0x1f3ef0cf","0xf210f01d","0x1b2bf0f","0xe03df1ed","0xf553ddf2","0x41f4fc5c","0xe2e061ff","0x2b6edbf","0x26b2d117","0xc2e02203","0xb10dd10d","0x4310210e","0x59de4df","0x3bfe3d1c","0xe35b02db","0x125e59a","0xe59f01f1","0xe1fc5ef3","0x3fe0ff9c","0xffc42f13","0x10dbdff1","0xffbb3c0c","0xf0db70cd","0xf040f299","0xf334f020","0xf54f22d0","0xa3da2ee0","0xc0016ca4","0xd1410004","0xc3ed0dec","0xd3919e00","0xc20dfb77","0xd4f21d22","0x1bb42cba"}
},
{{"0xebdffcbd","0x4e51bc0b","0x0eec00df","0xecda3df4","0xddf3479d","0x2e21ca34","0xd15d3f1d","0xecdb11e1","0x425ce3c1","0x0f03e9d","0x1f3be32e","0xcdfd26e2","0x1033ec50","0x0b3e297c","0x19192fda","0xfe120edd","0xe7deda6f","0x1e3fddab","0x19fd2dff","0x306f0f1c","0xa4be193d","0xd031ec9a","0x90024f3e","0xc3fbf3c1","0xd1ffc241","0x3522f2dc","0x36fdf102","0xc22f311b","0x13fc114f","0xf61d2eec","0x303c122","0x204212c","0x1a435f04","0x431d4023","0x524d00f","0xdff22c1c","0x0edfcd13","0xee0f1f6f","0x43eec503","0xd6f43401","0x700f9e17","0x976f236d","0x70dd9724","0xd2b727a4","0xf3e0c031","0xce405356","0x4cbfc125","0x12a150f2","0x0e5cf210","0x2bcbfac1","0x09b9dd42","0x9f1010c2","0xd4c3c40b","0x31e0ddd5","0xe9cf2e4d","0xb141f2ef","0xdfc5f60d","0xffdc2c21","0x0b20234e","0xf314f4f3","0x4fd2153f","0x0fd01f3f","0x1b30c2d0","0xef071fdd","0x27ffdf50","0x272dedf0","0xfc260dc0","0x1c22fcbe","0xaa01299c","0xeeddf0ff","0xbd465fd9","0x64100b02","0xe03a9a93","0xec3bd3db","0xd3ee04e1","0x0db492c","0xbfefcf92","0x5be10e9d","0xa64b1d9d","0xee3acb4c","0x0f0dfc9e","0xdadd4e1d","0x91eafcd0","0x1decfc0c","0x3adffdae","0xb33d04f2","0x1ff1f10e","0x1f0f2dd1","0x3bbeafbd","0xaee3f303","0xe20303be","0x0dff5ae0","0x3fb22ec1","0xe1101daf","0x0f4c1f2","0x1132f3e"},
{"0xfaa43ebf","0x7d42dd01","0xc11f4fae","0x0def0a25","0xc1ec0203","0xff2c5f03","0xa710e1ff","0xe3e274ef","0x140dad11","0xf11d40de","0xe2203610","0x12d1e1dc","0xb27c1e36","0x3f40fd72","0x303b41ac","0xf9313de0","0x16edbf72","0x0c60ee0f","0x3abd212e","0xef475f05","0xd290aa1e","0xb133dfb0","0xc4c45261","0x22e247d2","0xd39b4a2b","0xee00ed9e","0xb7f1de11","0x11ef0e9f","0xd3199c29","0xef1122dc","0xc2e19263","0xedcf12e0","0x3a4fad01","0x2ffe4fa4","0xaec1c152","0xefbf3ee3","0xe2154f02","0x3dd0c0f1","0x40dd210c","0x1f10d5d0","0x41d4f103","0xfbd03db4","0x50ec201e","0x10e0d7d3","0xd2e160f1","0x19ffffa6","0xef410d21","0x1b5dfaee","0x437c4114","0x2d49442e","0x2b2ec2a2","0xd3fe20dd","0xd5dacf1e","0x133df0fd","0xfe0ff217","0xa2dec4ec","0x92bfed0f","0x220fff00","0x0e003eef","0xffc2d40b","0xfc2cae2b","0xd1c0531f","0xeff19403","0x0e40dbb","0xe53baf3f","0x20a1ede","0xc0c391e5","0xf2e1109e","0x9a3d0bce","0xdd1b1014","0xbe120a0a","0x72dc3921","0x0f1f0bc0","0xbeeec122","0xf7112fe1","0x1f0e13d","0x53f11fe1","0xcb10230e","0xe52312af","0x3062f13c","0xdb3e0bfb","0xff205251","0xde3301b3","0x2d14112e","0x11d24edc","0xa2fef0cf","0xdc422020","0x23dd0f04","0x51c0cdcf","0xb40f0ef6","0xdd1251f3","0x1f2d4ae5","0x70c2b0c1","0xf30e00a2","0x1d54c302","0x4632f33"},
{"0xeaa12dad","0x5c309fd3","0xb1bd4fbd","0x0eeb39e1","0x200eedd0","0xef1a190d","0x71cf1b0","0xe7be46ed","0xc3fd90ed","0xe13e2ef0","0x2ef520","0x13bfe0e0","0xdb72e333","0x10d2eedb","0x1bccdd5f","0x1a5ce10f","0xe502305e","0x1fa02d90","0x2b9f1e6f","0x6110b254","0x14a30d31","0xded34fc5","0xd4921161","0x2e00e5bf","0x5fa1ff11","0xfe35fa30","0x0f2c2253","0x1f15212e","0x14f1a02d","0x1d124fff","0xddaf1475","0xffc3213f","0xef17cf01","0x2c04516","0xeece0343","0xddd05d10","0xed2ffccf","0xec0dd4df","0xd0012d1e","0xfdda1b32","0xb0215bce","0x2a9402af","0x92436dae","0xfa1dcb3b","0xaf1b0a9c","0x1b94edce","0x90202ecd","0xfb20d93c","0x29412113","0x2f1bd1df","0x312fbfac","0xe1eebfde","0x0c001dc2","0x6b1df111","0x72d3f02e","0xb3cff2fe","0xdf0b3ac0","0x702e3114","0x61e4e00c","0xce0d37bd","0x2de19f5e","0x0e1221","0x2ecfa4d1","0x0d700ec","0x501e9224","0x1e303dd5","0x099ebf36","0x44b101b3","0x9b5f3b90","0x0919f0f7","0xafd20df9","0x51ce3931","0x52b9b227","0x6ebdb1ce","0xe15df00c","0x1e2c0e3","0x7be9f023","0xbc5fde01","0x9c4be722","0xe300ecc1","0xfe3b3bfa","0x9a0042e6","0xcda0233e","0x32ee2adb","0xd2ff2c10","0xc02ecefc","0xdfef3c20","0x24febefc","0xd2400dbe","0xceddb92f","0xedce3eda","0x111ddbed","0x6127e0d3","0xe50ceccf","0xff02f0f4","0x43004d15"}
},
{{"0xd7aea107","0x1f031a22","0x42dcf14f","0xce0ffed4","0x27be91c0","0x11f30de0","0xe9e9b3fa","0x910e1217","0xf5e0cce9","0xe5411fd1","0xfea9d19b","0xbe0b533e","0x20f103de","0xe6c1ee02","0x09fe1f30","0xf16f04d1","0x6f20110f","0xd730c090","0x3f14021c","0x204fe21f","0x0be42f1c","0x563ffcd0","0x6efa00cc","0x1eff0d4f","0x9dff0aab","0xee0cd0fe","0xb2014ead","0xfcdedb2e","0xe3dffe9b","0xe13101bc","0xf411ffa0","0x0efcd1fe","0x351a1fa3","0x1e4f1ee2","0xe34ddfce","0x4f5cd2fd","0xb102cb41","0x1e114a1b","0x2c132d2c","0x104df3b","0xa1361e3c","0xff2f2a0a","0x22e12cfc","0xe1f0c21a","0xe2235eef","0x0dce0efc","0xd0402cf3","0x1d2efcd3","0x9c311fa1","0xed04f315","0xb2133e0f","0xfc9c0e22","0x1001d0d6","0xb0a2db20","0xf23b0c3e","0x1c1101e2","0x42c1fe12","0x1fd21e2c","0x1b0d211d","0x0d32e0f1","0x3d0ff2","0x162f2d4c","0x612ea2de","0x11f321f2","0x3de0ef9","0xf53be92b","0xd0faaf9b","0x0c1b1bcb","0x0bdffbd","0x424cffbd","0x32ebedad","0x9d0afefb","0x2f21f03e","0xf215df00","0x5350222e","0x21341225","0x0bd24002","0x4f1d02f","0x17243f4e","0x11132d2d","0xfc3361e2","0xc14122e3","0x12231e0d","0x111112f0","0x92f00fcb","0x300f4702","0x1e2d02de","0xfffeb231","0xbeef000d","0xfcd1130e","0xeb1d20bc","0xfef092df","0xbefe3e32","0xfd0f47ec","0xc9110020","0x32e692e0"},
{"0xecbc2300","0xf3e303cc","0x23e30e11","0x2c2011ce","0xceba0dde","0xd2ff43de","0xe64303e0","0x5a1000ff","0xed01ee5a","0xd44c2217","0x5cd03d3","0xef0f4e0f","0xf2bdc0f4","0xf50a2c1b","0x12c1e734","0xee2544ad","0x539992c3","0xa77c152e","0x7bbfd776","0xfe123797","0x1d012eef","0xd56ce043","0xd12fd100","0x1114391e","0x9f1f06b1","0x311362f3","0xf12fd0f4","0x0f004e02","0x3fb9c305","0x43d3211","0x12ec0122","0x11d524fc","0x5ffbb264","0x220fb170","0x43ee2521","0xf1952c2e","0x90351cca","0xda03fdf4","0xdd223d0d","0x1ca0eb0d","0xd1e326ec","0xc3104db4","0xb42ee422","0xec0f30ff","0x1d0993d7","0x5ca434d3","0x6c2cd210","0xfe0d6fe5","0x9fc23d9e","0x1120f1a5","0xf7e53ef3","0x1fbdce2d","0x1f3dbfe7","0xa75e0403","0x1600e172","0xb1e17610","0x6171ef23","0x20b0431c","0xfb2dd511","0xa3336d23","0x26d23f11","0x3632f5d4","0x3416f0af","0xd2e43ce2","0x2341f030","0xf72d2c3f","0x0f41b39b","0xd3f02ef1","0x2551320b","0x37f11f40","0x20221eab","0xd221e31c","0x1473aeee","0x0fdd7f7a","0x3bac21ba","0xd210bd11","0x45cc0cd","0xf3a16b2d","0xca00efc5","0x93fc932f","0xefc102fd","0xa0c11add","0x4a00f1ea","0x12fa65f","0x9000dddb","0x21ef05f5","0x911e1f1d","0x0dcae00","0xad1d9ed9","0x1fff11e0","0xddbe10ac","0xeef09ce0","0xafefee1e","0x3f33dc","0xbe02f20f","0xf4d59210"},
{"0xc00fdcc0","0xb2fb21c9","0xb2e5f4f0","0x20ff1dbc","0x0d302ce5","0x13003151","0x23652ed0","0x4021011c","0xd9403ddc","0x0f014dd5","0x0cdf3e40","0xff3c1ce2","0x27000f31","0xf60c12d1","0x12febc0f","0x22e212d1","0x6fdefe0","0xc62e111e","0x64ede4f3","0x1fd227b3","0x3eeff2d2","0xf01be221","0x222ec0c0","0x5b343d1d","0x131f191","0x14ee30fd","0x16c00d13","0x241d1fef","0x2bd9feb7","0x14f0e14f","0x1001f000","0x23e41505","0xf11ce05e","0x1e55bf7a","0xd5ed3433","0x3e01a06","0xb22233ee","0x0a20cbf7","0xc6f52021","0x11233dfd","0x09a91b3","0x14d40424","0xd5a51572","0x1dd263d1","0xfefcf2e4","0x4cc2d61f","0x0ee20230","0x0ce5bc7","0x93fde99b","0x5ffc00fd","0xc2034afb","0xfeeccc3c","0x103641c1","0x5dd21cf","0x75b34dfe","0xe1ffc40d","0x70072304","0x13bd1f01","0x1a3fe21d","0x30e1e02f","0x2da3fa3c","0x14fdefd1","0xb1c51deb","0x1fd0190c","0x3014ef21","0x70b1cd4","0x35d5fead","0x11e20dd3","0x405e207e","0x274cdb3e","0x3de202cc","0x22d41f05","0x17d93c2","0x5e0cb043","0x0a9bfe1d","0xd3efffc0","0xe3bccfa2","0xe1031e22","0x0d0c0cd3","0xc1be24cf","0x0afffd0","0xd0f33daf","0x2ebaeefa","0xf0ddf7dc","0xd301cc29","0xdfeff521","0xee1a00ee","0xe21fac12","0xdf33bdd9","0xbfcef11f","0x0aee11ed","0xff0d9a21","0xbe11ed3c","0x302240f","0xd113211e","0x4e39124"}
},
{{"0xfa92dc10","0x4c0f00e3","0xe320f2f1","0x0d30e22","0x2fe00214","0xfa0e6314","0x1f421533","0xa0143e01","0x3c1304d4","0x0ff0be0","0x09d12032","0xaf242d02","0x34f0640e","0xe1323d41","0xfa621efd","0x2f1e0c11","0xece1c3de","0x3eb40fe1","0xed00fecc","0x1410bf23","0x0e0fc021","0xffa4eeea","0xfe0b41be","0xf3fee331","0xdce74c0a","0x964fb4f7","0x2336d261","0x1f543ef","0x7272cee5","0xf1fa775a","0x0d4294d3","0xb6377d09","0xd34f01b3","0x11fe606c","0x0b44b1d6","0xa6f3b40e","0x430f06e2","0xad21433e","0xe42f1dbb","0x5e400f0e","0xc2ee2c2d","0xf46cf01f","0xe313ef9c","0x5c1ddd1a","0xec15e0f0","0xeb02a2ad","0xbef301d1","0x1eee0d4f","0x3d3e51cf","0x30ec169c","0x54540d20","0x3211f155","0x7a2c75ef","0xdf4ded9a","0x433ee35","0x34391c1","0xeab01ecf","0xcf3d1ddc","0xa3e1e477","0x26b3b2fc","0xd1e4e3f0","0xe02fe304","0x6159f03f","0xf0ebe5e1","0xb1fd0122","0x1f11a305","0x20fcfe4f","0x1def4e1","0xf2cbed03","0x4de3b026","0x3e4ae02f","0x22cd42f1","0x13f1ef0e","0x09f1d232","0x320c100f","0x0c5de030","0x120211f1","0xfae1fde0","0x2debd05e","0x0e3edd50","0x25e710a5","0x1ff22eb1","0x3bd90e1b","0xfe3b0121","0xdbdee1c2","0x4e1e3034","0x1ecdb002","0x2fcb31f","0x1c00000","0x2e02fe30","0x300eec34","0x1241f31f","0x4923f3f","0xf10fde10","0xe003f12f","0x15e2310e"},
{"0x2aef1af1","0xacebb091","0xd13ed343","0xed0f0c06","0x21730232","0xad0113df","0xef9cb425","0xa221da1b","0x2f2103f2","0xb1cbe9fc","0xf993fc02","0xf40009f1","0x305dc22d","0xb16c3501","0xd2d4b252","0x320eed","0xea051e5b","0x1f3e53f7","0x1103feef","0x2e00d5f","0xee11f2e2","0x2b92d1ff","0x101d5ebc","0xf2e0b261","0xf0e3e1d9","0xe1fdeffe","0x3cc03e1a","0x102fb020","0x0e0731f1","0xe5dcafa0","0x1de01cfa","0x13ef924c","0x1b97ffde","0xf1f0afdd","0x09d10d2f","0x240dc120","0x6fbab5f7","0x92506deb","0x2e2db7b0","0xc515b7b6","0xeccafbfb","0xa47e2205","0xa0c1b0d3","0x22be1ff0","0xcc143f52","0x5bddf1b2","0xd4f13c03","0x1eff1e4f","0x4b21c50f","0x32ffffe1","0x1e220232","0xee141e7d","0x1ee4d2e1","0xc2eae930","0xa91df461","0xa112f001","0xf5c390a2","0x0fe0df21","0xebfe3142","0xf6e0124f","0xbec0f1af","0x2eff10d4","0xee1dee0c","0x2ece3d1","0xb1bf32e1","0x1d0ea0e7","0xe0ff0e0d","0x10fe03f0","0xd3bc5000","0xfdfebed7","0x1e5ef02e","0x21fe300e","0x31e2e1b0","0x0af5e2e5","0x0f4cf1c0","0xcb5cd16e","0x0e30e5d3","0xaed0f4b7","0xbb0bbd0e","0xcf501149","0x9520e410","0xf32d570f","0x1ff1cfae","0xbd33e2f9","0xfe7cb031","0x0e0e7363","0x10c0bd1f","0x0c05aea","0x77def3e","0x10927ad9","0x0f03d3f7","0x30100de","0xf79bbe22","0xe690b9dc","0xa124c474","0x13f2b4ff"},
{"0x2ecaed32","0xce0fe0fe","0xc3e9e356","0xcbdf20f1","0x332dc22","0xfe1eeffe","0x0ccf014","0xf1c1dc1a","0xee2f14e1","0xefdb19ff","0x1bc3ead0","0xf6015eee","0x50709d23","0xe07b342e","0x1e9c2625","0xd3be43af","0xdb00eded","0x2bd940c7","0xa1eed9ee","0xeebc1adc","0x0fc2d194","0x40990ddd","0x0e9ee9d","0xdd2cccf2","0x0eedf1d","0x0e1bed1","0x2f0d1f10","0xe0fd0114","0xf1fcee2e","0xd101edf2","0xef1cdf10","0x1cfaf114","0x2feda0f0","0x1ef0c1d","0xc30d4312","0x2febe033","0x290feea3","0x9f014f30","0x72bb132d","0x0fbed7d7","0xacd14f9d","0xdd4fed17","0xb0cc1e53","0x2fecede3","0xf0423e20","0x5dad0fbe","0xe4dc4e11","0xfb1ede2f","0x3fd0d3fe","0xd00cfc1f","0xedff2175","0xf204fd2d","0xf2b2d001","0x1dde1bf4","0xebdb0ff1","0xe0ae33bd","0xe3a60101","0x1e0d1d12","0xdcd01fee","0xecf0f12d","0xeec2ffd0","0xfd0d20f2","0x9f1cf1ed","0xfe0b0df5","0xdff0131f","0xbf0beff4","0xd0e00f0f","0xdb0fe1e3","0xcfed444b","0xa0fbed02","0xdc1f104f","0xfc4fff05","0xe19e1f21","0x3fe014e6","0xd50ff1d3","0xff0e0e4b","0xf1bc0ff0","0xe3ea3101","0xf621b2a1","0x16d4d239","0xc0eedcff","0x2dac54c","0x120212c3","0x13d4d1f9","0xef7efe42","0xf12df211","0xf1dfdfcf","0x12fdbefa","0x375f0e50","0xf2ffdeef","0xfe3eede1","0x710b1fb","0xc39c0e1f","0xb2041011","0x1f24e112","0x0fe0350c"}
},
{{"0x123efd30","0x2201f2f0","0xe2f302f0","0xf0e22d10","0xbd32dcb1","0xfa00c22b","0xc9213d1c","0xf9cc0932","0x203172d1","0x20d12010","0x1c7e2dfd","0x4b4fe92a","0x5fbf201e","0x4e2aaf0f","0x42daef1b","0x0e0a2f12","0xdee32acf","0x19f2e2ef","0x9bececfb","0xbcdefa3d","0x14c31793","0xd1d2f1b4","0xbb2dee60","0xfe1bf02f","0x1514f020","0xfcefeddb","0x0fdd0efe","0x1dbe0e21","0xac13f39f","0x1d43fd95","0xfb4dfed0","0x4efaff30","0x91ebc2f1","0xe01f1603","0xe73ea0ff","0x2b4cf3c0","0x1e5d3f0d","0x3ee03099","0xe20cfdb0","0xddcfcbef","0x2e590111","0x10110599","0xf03ac0d2","0xe1eee5c2","0x449e021","0xbd02f39a","0x0f2bccf3","0x12eda7bf","0xf0201ccf","0xf61d93e3","0x30e1e041","0xfe3f0514","0xf0df1ffc","0xb7fa94de","0x10b1d131","0x0e0ef3f1","0xd092f13a","0xd7db95d1","0x5952ff2","0x0d32c2ed","0x1c6101c2","0xb12f6f6b","0x3bdb015f","0xeed110fa","0xe47e32cc","0x31c07b7d","0x3d9da0bf","0xd1f1defd","0x3bf121c","0xd2d03ffd","0xf02dc4e1","0xf01e9610","0x3e0121cd","0xfef1c30b","0x2ec13eff","0xe1ddcff2","0x0ff141cf","0x10cfe010","0x1223bc2","0x2e1dbfde","0x3ccd1fef","0xee0addf3","0xd121d1b2","0x2e4d0d10","0xf301ff0e","0xd11310d5","0xe5defe10","0x1fed0104","0xedc1ee31","0xff21d0c0","0xd31d010f","0x0ddd0303","0xf0c0b24f","0xbe41e2cb","0xf2ddd0f2","0x1eeed421"},
{"0xedf0dd40","0x11e1fd1e","0xa0f20ed1","0x1ce3f911","0x92d42dee","0x2c2edc26","0xa0012ef7","0x21bd0efd","0x2f1ab412","0x971b42df","0x6dfcd774","0xcf2025ed","0x530226f3","0x3d104210","0x31fd21ff","0x3d3a0452","0x11c21bef","0x5bdf230e","0x9b002c2f","0xefefec7d","0xf6f131f2","0xe11fd317","0x77d5ef15","0xe72e363b","0xf1e50ce3","0x2dec2c2e","0xcd120ef0","0x1afffe2d","0xcee5fe9d","0x335efee7","0x55f5f0ff","0xd4ed31ac","0x707a9090","0x943b7720","0x119295f1","0xc1b47493","0x12132ef","0x0c133103","0x114232ef","0xeef2fdef","0x142d13ff","0x3130d5e1","0x1f0fe311","0x213200fa","0x215c341f","0x2333d1a5","0x200fe1fe","0xf140031a","0xd0ff0d0c","0xc6fdacef","0x13de1162","0xcef0b5fe","0xe0be200a","0xa71c90ea","0x4110d274","0xdeffb7d3","0xff9bee1a","0x950394fd","0x20711534","0x1dffd3c5","0x0b7fceee","0x11d137c","0x1f9eef0b","0xdd0012f9","0xf47101cf","0x1e0dfe7d","0xea9fe1e0","0xb6f1cfb0","0xf4cddfce","0x0fe42fde","0x1f5fd602","0xc22fc7e1","0x2e0455c5","0xdd049c17","0x3d7f3d61","0xec6ec1c2","0x7f0f0526","0x1e3ef07","0x1d40d25b","0xec6203de","0x3f01a520","0x21ff1e2e","0x100cf2ff","0xcf0420f2","0xcdce31f0","0xee113dd6","0x2dbbcf5d","0xfeff13e1","0xc44fd320","0x0f07140","0xf49eafe1","0x9c45f3fe","0x19301f1","0xbf2fcef1","0x0fb4fdde","0x9010d31d"},
{"0xfd0dce4f","0x1fd23101","0x9e00001f","0xeb020904","0x9dde1bce","0x3efae433","0x23e13cde","0x135ef9ff","0x20251e0f","0xd1fc223d","0x74b0f1ae","0x1442f7fd","0x2f7f15d4","0x0e115042","0x3d19df21","0x4f09e133","0xc03d0eef","0x1dc24dcb","0xcb4bfe0b","0xfce90231","0x4f151fff","0x0eeffeff","0x4efcedab","0x509e111","0x15fd0ed1","0x2d111ec","0x2f2011","0x0c201f30","0xee231faf","0x34defdd","0x091f1dab","0x205fcf21","0xfef4dfc2","0xd22ede07","0xd5fe2ed2","0x3113c126","0xecebe3a1","0xef23f554","0xeff0efec","0x0a020f2f","0x0fb2c0ef","0x0c4bd55","0x1dcfa0ea","0x0d12c209","0x41b63f0a","0x23f1bf42","0x0fdc1fb","0xbbf2befa","0xf0d2fffe","0xb221c1e4","0x0e2ef3f","0xd0f225f3","0xd0102c2c","0xf2ff1302","0x2eb10e61","0xcff1f3f1","0x0dc2a10d","0xf2d2df62","0xec016223","0xd1c3ef0e","0x20cd1203","0x110d1ae","0x2cedef42","0x13d421","0xed90410c","0xf120d3ce","0x0fdffd22","0x1100fd21","0xe29de200","0xef3ff001","0xf11f0f21","0x1120213","0x3b3905e7","0xd0221f32","0x16e1c753","0x9df071c1","0x407f9234","0xe22d7229","0x39cb0714","0x9bf37fc4","0x23fc021","0x40fc6dde","0xcdee14c3","0xafe32cc4","0x69740fda","0x210b0713","0x4baee329","0xa4c27fc9","0x257fa2e1","0x1f0c177b","0xfb9fb693","0x97a712de","0xa4eb6ecd","0xc213dd11","0x0d37e0e2","0x9300b3d1"}
},
{{"0xc3dedd21","0xdfd17b10","0xb0ecde00","0x0d3e4310","0xe291a1e1","0xf0c2404f","0xbcd0046f","0x0f01f22e","0x30bcebe2","0x420dcdf0","0xe11c332f","0x30ec01e0","0xf10b3f31","0xef1dd0ed","0xeee25021","0x3b3f2f13","0x900a1c4b","0xde3b013a","0xa2316e2d","0x501d6eb7","0xa2eedd0d","0xddb0f22c","0xaf4330dc","0x2fc10e12","0xef051223","0x5f094de0","0x513f21eb","0x11fe0240","0x202521df","0x322c4010","0x730030de","0xf5e1a520","0x7f2613e4","0x22c7220","0x7022d620","0xd6e43612","0x12fe5d30","0x1250ed12","0x1206fb23","0x11103df0","0x3cad020","0xa42f1ffe","0x1103e124","0x1b02410e","0x4129bc2f","0xb4f1dced","0xe6d4d753","0x0ee1310f","0xed0911a3","0x4fefbd16","0x3149bcf4","0x207f101f","0x40ebd3fe","0x6d023e14","0x2e09d4c1","0x9dfe0ffc","0x6e97d039","0x423b0be1","0xa0fa3ff1","0x9b0f1ff9","0xe11f0103","0xf1f2710a","0xfc6cb0c3","0x2be610c","0x3dfec012","0x1def74c9","0xe33fdfe2","0x3dcc51d0","0x36edc031","0x31df76ca","0x5701d121","0x2005e1f2","0x1e300ef2","0xf0faf6e1","0x0e112a3e","0x1e1e4c30","0xea525ece","0x0a21d7e3","0xe2c53cd9","0x1b2e192e","0x90ef79fe","0x79d624f4","0x93cf59c3","0xfeed093b","0x1becde90","0xd300fd2e","0xe5f0cbd6","0xf0ffc4fc","0xfccfbeae","0xc5e2c5ea","0xe3efefb4","0x111e61e","0xc2fdcaf1","0xf120de0d","0x0b1fea5","0x12d1251b"},
{"0x547ebf11","0x3eef2f0e","0xf11b0e00","0xe79f602b","0xe0919ee7","0xc4f26f7d","0x1fddc310","0xd693174c","0xd2da9dce","0x13330c45","0xcdccf140","0x3fe045e7","0x352f1f02","0x2f3d021e","0xf3020e61","0x3d2320f","0x9e390c22","0x3a43053e","0xd1310e30","0x4eba4fb0","0x91bb9ddb","0x1d92012f","0xd0003dd0","0xfebc3fcc","0xe22fce90","0x099febdd","0xbf0d3dc9","0xfbbbc010","0x131dfc9d","0x3fcffdfa","0xbacc3d99","0x2aff90e5","0xe1e23bae","0x6fefeeeb","0xdab10e9a","0x3cfc9ff1","0xdd112edc","0x352d0f00","0x45341ddf","0x174ffa00","0x50032ef0","0xd10d032d","0x77f2f0df","0xa7e0040d","0x6fc39f07","0xd70c1f2f","0x71b1b641","0xc0b50603","0xca7ae3e4","0x3ef0c464","0x5fb0ccf3","0xe1220e03","0xff0d5d0b","0xef1d1f2c","0x3fe333e1","0xa2341a10","0x1ec309b9","0x1039301f","0xd42e25d2","0x9002e0cb","0xf21b0ee0","0x3f15f1f","0xcd3effee","0x15bf0140","0x3c0cdf31","0x2dbd02b9","0x0d4dd33f","0x111e4011","0x4f0ed111","0x1001c6ba","0xee101723","0xf602f63f","0x1121dfd2","0xf220f24f","0xec112d2f","0x10501b22","0x3c4515d2","0x92fd001d","0x0c7d1f2c","0x20620120","0x204200ed","0xf54ccff1","0xef6ddc19","0x140e12b","0xffd446f0","0xc110ebc1","0x21bfc22","0xf17ed611","0x2121350d","0xd1002e9b","0x22eafee3","0xcd70e51b","0xf1fdf331","0xd100cfbe","0xd0a11dd1","0x13f0f20b"},
{"0x1bf3fee","0xf232f10b","0x5ede301c","0x1dffe43a","0xe0f3f00f","0xd422f3bc","0x3b03d09","0xffd11759","0xefd212e2","0x20024ff2","0xd32e10ee","0x403ec10e","0x1fe35e05","0x5af0032d","0x0f2ddb6f","0x4b1f3d1","0x991a7dc3","0x39bdd3ff","0xa10c2e2b","0x50cbfb9c","0x9fcf1fbc","0x0cbe3d3b","0xeef12f01","0x0ddc01fd","0x45310404","0x3d0e0f31","0x0d6d101f","0xfd32f440","0x36202402","0x3010f132","0x2c4f23ed","0xf251e421","0x240e1410","0x611f3211","0x2c4f04fe","0x140d2e4f","0xee4ff10e","0xeeef1f23","0xdd312ded","0x1e1de903","0xeb0200da","0xe0ffb22f","0x6ad01be9","0x4d6dce11","0x3e077f01","0x30df3190","0x72f31ddb","0x1f23d7fb","0xee64623e","0xdf0caef9","0x54e44ba1","0x24ffdf27","0xe1356029","0xc01e0fcc","0x3f2151d2","0xd7f3ee11","0xbd24ded9","0xbe2d60ed","0x2e114313","0x92b22ff0","0x31ffbfe0","0x32ffbebc","0xfb4b1fcd","0xf4c90d14","0x1ccdce14","0x31fdc39c","0x50eb100e","0x2efa0ff0","0x41d09011","0xe26fe4da","0xecec4300","0xd300c262","0x4df0f0f","0x1fff0a0e","0x91eff0f2","0xd4c2ebdd","0x59a90f7","0xb5e90909","0x32dfb766","0xd1e207af","0xf5efcecf","0xa7611eee","0xc9ddb733","0x52d1d1f6","0x2e00c1e","0x2542b6e0","0x64220151","0xef2117c5","0x627430f3","0xe3e1f69b","0x39e014e3","0x9515f7ee","0x2af2e04","0xe110a2ad","0xfd1342e5","0xf6d3f701"}
}
};
const ap_int<13> conv_2_inc_new[8][8]=
{{"0x244","0x39d","0x32a","0x64b","0x2a7","0x509","0x290","0x330"},
{"0x2cd","0x233","0x411","0x3dd","0x350","0x3af","0x2dd","0x451"},
{"0x791","0x2e5","0x3b9","0x3e8","0x513","0x3a3","0x531","0x37d"},
{"0x2f7","0x300","0x2cb","0x2a6","0x374","0x323","0x3e2","0x423"},
{"0x42a","0x21d","0x28a","0x2d4","0x29a","0x3ab","0x412","0x394"},
{"0x420","0x441","0x32d","0x392","0x2af","0x2b3","0x378","0x2a1"},
{"0x408","0x3a2","0x41c","0x3cc","0x394","0x0810","0x1cf","0x45e"},
{"0x2c6","0x274","0x243","0x286","0x361","0x1d2","0x2f0","0x2c8"}
};
const ap_int<21> conv_2_bias_new[8][8]=
{{"-0x13e8a","-0x65ec","0x1ae9","-0x93433","0x1a078","-0xdd7f","0x1191d","0x0abd88"},
{"-0x31720","0x72def","-0x310ea","-0x20cd9","-0x2c6e6","0x2d2ba","-0x66902","0x75e55"},
{"0x1a561","0x4db50","0x73710","-0xd6b37","0x4efe","-0x5ce2d","0x282e6","-0x19a84"},
{"0x70589","0x440d9","-0x38c3f","0x12e32","0x324df","-0x46920","0x08837d","-0x2dd98"},
{"0x138f1","-0x101","0x6b0a","-0x29b8c","-0xb7","-0x2777d","0x4023d","0x53264"},
{"-0x1c05e","0x6dd39","0x0c5f0","0x3d0da","-0x259d5","0x083b51","0x6f81a","0x1ce6"},
{"0x116a7","0x0ee182","0x347a0","0x59c08","-0x2cdd8","-0x6d23","0x11f24","-0x3089"},
{"0x5675b","0x5cda5","0x120c1","-0x37ec8","0x581e","0x4fddd","0x265d6","0x27f2b"}
};
const ap_uint<32>conv_3_w_new[4][3][384]=
{{{"0x1aeca0f0","0x103012d2","0xeff3e005","0xc2bf0e2d","0x3c4ed340","0x90fc145e","0xf52e349c","0xc12ef15c","0x10eddf30","0xc03030fb","0x22114ee","0xd3f13c00","0x3563f440","0x9ecf0041","0x32df219e","0xb2d00f53","0xd01e3020","0xed4f2d0b","0xeffef2fc","0xedf4ccfd","0xe724e240","0xdb9d2e14","0x11a7efa0","0x11d32d21","0xe1d013e0","0x121ff13f","0x30c0022d","0xe11ff211","0x0f2f0de0","0x0ed0c112","0x0ff4d101","0x1e2ddee1","0x2423272f","0xe035f7eb","0x094120a","0x0f1ebe03","0xecee10fe","0x201cf117","0x75657eaf","0x1530d0e3","0xd03d0def","0x127e2d51","0xdf1b242e","0x0f00e3d1","0xb01f3231","0x0c34e10f","0xa0eb0121","0xbdd122e0","0x2f150f","0xe34130ce","0x517cd1c5","0xed363092","0xdd0cf66c","0x26f0412f","0x3b2ee3f4","0x2f20001b","0xd93212c1","0xb3de0e2d","0x0dc210","0xc1e000a0","0x1ff012d","0xc002e3df","0x123f30f7","0x4eedbdef","0xae200de5","0xf2e2ff7b","0x12edb040","0xd5deb0ce","0x1dfb2f1d","0xefb5f1fe","0xe4d15003","0xfd0ecd31","0xf2d22e96","0xf1234211","0x2e1d313c","0x0c0f3f","0x2322f05a","0xfe12e031","0x4e6303e","0x7dd12fee","0xc0e720b1","0xed1f151d","0xfef9e10b","0x1dfa1f23","0x3fe01e2b","0xdf00b131","0x43e1fe4e","0x5cc10490","0x0e0effe0","0xec61130c","0xefede2c2","0xee0c0c13","0x21df1e","0x21df323","0x3a7ed51","0x4bef06d5","0x0e12100f","0xc336edb2","0x0d05ffe","0x2303ff0f","0xd0e15e14","0x1d5f7f0","0x202ec301","0xd24c111f","0x10e120f2","0xff03feb3","0xfcc2220e","0x12d51121","0xd10d3122","0xc0f7d0ec","0x2f1bd501","0x2012001","0xf1b3e201","0xd1fd01d5","0x0ebc5e1","0xe2f040ef","0xfd0f5ef2","0xa027edbf","0x3e4fe110","0x1e01cdf","0x2fd03c14","0xc10fed35","0x32fd11f1","0xf04e1f4a","0x1ff021e0","0xeb2034e2","0x104c02ce","0xe15e2930","0xff9532c1","0x2f61100","0xf2dfffdf","0x2007e203","0xaf230ff3","0xda0fa601","0xe12db25a","0x1fff0d03","0x90a6d235","0xced21d10","0xdaf300de","0xfee315e5","0xcfe30cf2","0x0fff0331","0xeec4fe30","0x1ef13fc0","0xf2ffe95e","0xe2e00f50","0xe0f1e0e1","0xf2e10df2","0xd33f14f1","0x32df102f","0x2fdb11fd","0x2edee41d","0xf0cce922","0x1dfe1c00","0xddaef11f","0x10210e10","0xe03b10e0","0xefee461f","0x12cc410c","0x1de034d4","0x21f9e9e1","0x0b2dee50","0xceced01f","0xe220d5fe","0x100d10cd","0xe00b4020","0xe1c2bf03","0x11e01101","0xb2feff2c","0xc2e3bcb0","0x171f2741","0xd0323f47","0xb0c4f3d3","0x1f1fd3f0","0x63ef1ee","0x1dd4131e","0xfc2f0307","0x999e01ed","0xb43101d6","0xf5011ee3","0xebfef3e6","0x77feafae","0xfe371032","0x477d003b","0x121ff0d","0x155de2","0xfcb3e200","0x2d2f5a11","0xf2406bfb","0xbf1eeb21","0x31e52ebe","0x33123c93","0xfe3bffb0","0x40e1147d","0x1e1ba90c","0x21fdd10e","0x311e410d","0xaf22fa4e","0x1c2dbf2","0x1dd42b12","0xedebfcb0","0x2cddc2e","0x14dcb931","0xfffefe1c","0x0db0eea","0xe01f9f30","0xd0c3fc31","0xeff46a1c","0x0d3bedc2","0xeec0ff2e","0x12c19d41","0x401010d","0x11ee1f0c","0xded39dd1","0xdef20df2","0x20e43a31","0xff24fd03","0xcdee0143","0xb1a201fe","0x144f4dbe","0xe10cb9ef","0x0f32123e","0xf21c2a05","0xe03ff1df","0x27443a42","0x40fe0036","0xf9b0110e","0x7f0f2cba","0x0f0d3aec","0xcf00062f","0x5f1a30e0","0xad71c0e4","0x23340a09","0x4145fe26","0x29b04419","0x2041eaa","0x0d317b4c","0xbdc303de","0x41d153dc","0xe9707ebc","0xe34f0e0f","0x4e00213c","0x0d11ddfe","0xb1ee1dff","0x4120e0","0x2eb20cfc","0xf03ecfb0","0x1e13fbf1","0xd1330c0e","0x3df035ef","0x6030f92e","0xfdfff213","0x123f1ede","0xd04f2c4f","0x26004eb2","0x323dbd","0xcdf3111f","0x10ef0e14","0x4231eb39","0x0ffbf220","0x4ded30bc","0x2e00d1e","0x2eb71911","0x6fa75a00","0x13bb00dc","0x401eff5c","0xf0ef0010","0xdd0df0cd","0x1ffe3d0f","0x0f114ff3","0x1ef11fde","0xe012ff1f","0x3fef210","0x110dee3f","0xb2cf011d","0x2110d0fe","0x1fe0f1e","0xb200e0e2","0x0bef00fe","0x1102302c","0x1fe00fe","0x30bddbd","0xa1cc04ff","0xd011dedf","0x24de3c2e","0xaf0cf3e3","0x0aeff0df","0xf005312f","0x10ffb230","0x131ed140","0x1d1101bc","0xf6f4d0ff","0x1af0ff2e","0x2fd11fe1","0x3a211d42","0xeef1e03f","0xedcfc161","0x5d0dff1f","0x4030ffff","0x1514d02f","0x21eaf020","0x0cd43fe3","0xecf30c10","0x4cc11232","0x10ec130","0x30eed11e","0x313601e1","0x6f3c00d","0xd0fd00f0","0x5b1750f3","0xc3f00d2f","0x3ac371f4","0xfd1e1212","0xdc047e2e","0xeeec2df1","0xecdbf9ec","0xee023013","0x41d0ede1","0xf3f21151","0xe11b1230","0x79e25ff7","0x99af11f5","0xbcfd6ee0","0x6ccbfd0c","0xfb2e5d92","0x632b19b3","0x5f15dd00","0x0f79b11d","0x4cb223b4","0x3ef7ddd2","0xd21f73a0","0xfd103ee0","0xacdddfcf","0x4fda7fc7","0x0e2cf4d2","0xbf5adc0f","0x1fdf4deb","0x500df05d","0x0cac0a1a","0xb2f73d25","0xf2cd22ba","0xa1fa3901","0xb2ebf45e","0x15249df2","0x3ec36a22","0xfd1dd4fe","0xd091ca00","0xd4050d31","0x1f6be0ed","0x12790acf","0x729a11d","0xf2419c0f","0x0b21b35","0x1f03120e","0x2d91dafe","0x13fe1ce0","0xf02f2129","0x13bedfa1","0xf04d9e10","0x0f2c1e12","0xef21550d","0x1131114d","0xfeb62e03","0xe300e1e3","0x103fdf3e","0xcebfdd10","0xd32d31ee","0x0f2f311","0xee3f602e","0xe22e0e1e","0xe4e420ff","0xeefbd2d0","0x14edde2d","0xfcefea10","0xe0ff7299","0xf203bc43","0xf0f05f61","0xd05000fb","0xc0d111ed","0x0dfeee0c","0x2fb0ffff","0x0c1c0c13","0x27c3199","0x200a423"},
{"0x1edcd04a","0xae5064c1","0x1f34c1d3","0xe0c00bc1","0x6a404531","0xbff3e3fd","0xd21c34c2","0xd2c993ee","0x0bbfa221","0x9d5e6f14","0xdf243204","0xd1d20bd7","0x3f2f30e3","0xf6cebfd3","0xe1355bfe","0xa30dbefa","0x1df09216","0x99d02ae3","0xf1fa030b","0xbffedecb","0x421510fe","0x1dc2df4","0x0e372cd0","0x10ff1cba","0x12ecf1f0","0x100d0e34","0x12000010","0x3013e2d2","0x2c1d17c0","0xe7fbdeef","0x2ff0c001","0xfd1eed7f","0x761706b1","0xf107d0e2","0xe1222c96","0x79327fb2","0xd91e567f","0x17f909b7","0x31329dbc","0xf21bc96f","0xdf1a09fe","0x3f2bd079","0xd09b1dd1","0xfe1fb594","0xaf2c034e","0xd9e2ef1e","0xc1e9af0d","0xfde21c24","0x11fa10ef","0x1e02ec1","0xbbdddffe","0xf112ee9f","0xcd2c261f","0x10df0f03","0xfce0c322","0x3c201fa2","0xbd1b1fe1","0xc2dfe02c","0xcfe9c20f","0x0ddfdaf","0xb04f022e","0xc0d1c111","0x4ec10f24","0x6deddae2","0x932aedf4","0xf301ee7d","0xd0dbd221","0xf30efebe","0xef2ce12c","0xfedf01fd","0x3fc21f2f","0x2d2f0cf1","0xc0e7f0f4","0x207e0060","0x1109232d","0x0d2c20c3","0x2a217b5d","0xae123e03","0x22e30d2","0x61af12cd","0x1aeef03","0x0dbeff0d","0xc0e9d529","0xe0dbfee1","0x1c3f6d3a","0xb131de11","0x20d3cbf5","0x4ff3ee90","0x1edf2df","0xfd4e110d","0xf1fc032d","0x2f000bb2","0x1431f2c","0xd01dedf0","0xfe14cde3","0xe43215a3","0x0dd30640","0xfe06d214","0xfeb2f00c","0xff0dede5","0xe2a11efe","0xced6e31c","0xf2040041","0xe4202102","0xf0021131","0xe054e0f4","0xdcefcf0f","0x12fecc30","0xf3913213","0xdbc7d37c","0x31e17f20","0x30e300f","0xe0d2e423","0xc34f0ed2","0x1ef9aef3","0x22ee4d2f","0xce1ef321","0xdf27bbec","0x203adf32","0xedb03cdd","0x21ed1e01","0xc33dd215","0x202cf720","0xf01ef15a","0x1442ff0d","0x1d0f12f3","0x2103f52d","0x12f1a30","0xe1b303ce","0xe3223be4","0xdf3f56e2","0x6ee4f9f3","0xaf240714","0xfdfdb7c2","0xf211c049","0xeddebce2","0xaee726be","0xc1034cf3","0xa9501f17","0x25e6f0b5","0xfa7c0ff5","0x350a3d24","0x5ff7ee0b","0xeeff259d","0x260257e4","0x909027b5","0xe1242011","0x2feded0e","0x0b22f2f2","0x73db1901","0x70775d20","0x6769c00c","0x4e1006bc","0x5d6600ee","0xbed24edf","0x1e70dcb2","0xdffe50e0","0xd1da6f26","0xf440719c","0x172d1fc4","0x1f2b2f1e","0xed3d1e42","0xff4e123d","0xf0afe3ce","0xf201110f","0xfc4fef1d","0xee1cd033","0xe2c41e22","0xe3ca1d22","0xe11faf20","0x2350e0d4","0x204f0019","0xde2be50a","0x1090d11","0x20d1a0de","0x5ce33540","0x0fb2b1a","0x0b20302f","0xe27d1eb1","0x1e3ffdbb","0xf12dd4da","0x47f919d0","0xfe0c9ed5","0x3cfc2f42","0x1de03d","0x30132f0d","0x1cfedefe","0x2e00fe1b","0xf362000b","0xceae1e12","0xf01abefd","0x401bfeb1","0x2e32f02","0x0ef005d0","0xf2de1e0d","0xe313d3e2","0xe00cefec","0xe0400b14","0x354ade71","0xdff0c102","0x0cd5f422","0x0b2f22bf","0x22c13e0c","0x100f1f4","0xf11e3bc9","0xf31d01f7","0x452c1eef","0xf0001fb4","0x0cc4fe21","0x10b2f","0x0fd11d2e","0x30e12003","0x10d22aee","0xd1a220bf","0x0be0ebde","0x1f33301","0x14ff1221","0xd3e0e4c0","0xd2b21220","0xe14020d0","0x12d1cdf0","0x5100ff10","0x4f204dd2","0xfe2ec1c0","0x54f3014b","0x51300f32","0xfec13539","0x1fd41de0","0x1c12ce0e","0x23e31e31","0x1f00110f","0xcef0c1c2","0x3f37e0fa","0x53111e05","0x10ce221a","0x10df5e12","0xfcc01022","0xffe20304","0x1f10f10c","0xdef33dbf","0xf2047b3d","0x24fed159","0xbee30df1","0xeb190ebe","0xbe0f0ea0","0xfa1f4ae2","0xff1abd90","0x3f1cf013","0x2326795c","0xe2416133","0x92a12dcf","0xdd1e0da4","0x0d6fe99e","0x69d17de6","0x234b2292","0x9f39d12d","0x0df3d92e","0x0f133ef4","0xffbc41ca","0xe221eed4","0xf10f1d9a","0xd2cd43e5","0xfc0ed293","0xef2143ef","0xe1f0fdcf","0x22e00210","0x71c10020","0xff0c211d","0x1f0001f0","0xfe11f131","0x141e30fd","0x4e042ed2","0x1c01e1f","0x120e222e","0x3cf0f2d","0x1eedf1e","0x12adf120","0x1f1fee32","0x1efc5ff0","0x1ef32ef0","0xd0cd0d0f","0x11de0dc","0xd1fd0d0e","0xe2fde4ce","0x1fcd4ee1","0xdded0e32","0x0dbdfece","0xf3e6fe01","0x0fed0ff","0x0ffcbf0d","0x2f12200f","0xe215f15c","0x2d1d1eee","0x4e133200","0xecf20310","0x30f2e10e","0x15fe201f","0x0cb1e1c2","0x2cd70ff3","0x7f4e30e","0x14f2ede","0x1d3d1d02","0x20dedc2","0xdeef16f1","0x32df1ef","0xdecf3df3","0xf0e613c5","0xe7d3b1ef","0x27ffcd1","0x305ddcf4","0x174d22e3","0x91fa2120","0x13df2ef2","0xe10e4231","0xf022e120","0x0dd01e0d","0xf2ee034c","0xff322bfe","0xe31e1f33","0x11fe01f","0x21e6fb12","0x200ff0c4","0x4030d310","0x1ff24eed","0xff3ff2fc","0x322fe940","0x14cfd22","0x3de4bc10","0x2da43d22","0x40eeb2df","0x2fedd540","0xdad04100","0x101eb1bd","0xcd2da922","0xd10f1fff","0xdfc6ee2f","0x0eb62dfd","0x0e4f0103","0x5bbda0f","0xbde353c7","0xf01ee2f7","0xe24b14f1","0x2ed1e0e","0xd7402e2f","0xe012500e","0xdc42f03f","0xd39f5fa2","0x2ef4dbcf","0x5a3af933","0x7dedd3cf","0xfb69bfd2","0xc662120a","0xf1e2111e","0x1d2fc0c","0xe2c04fac","0x0f101df6","0x1f1eff41","0x2fe12323","0x1e5afda0","0x1eecd2f6","0xf1f314df","0x12021d22","0x434243f4","0x2c3e4ee6","0x0ed0274f","0xce21f0f3","0xf13f22cb","0xfe11e113","0x1d33140e","0xf0f10d3f","0x2201321f","0xfced1012","0x0eefddf1","0xece0cc14","0xc30f0f99","0xc523df7f","0x302e1030","0xed4ecf1d","0x10de64c0","0x6f3b6dee","0x4dd1fbf2","0x0b2efb07","0xc03e0f99","0xb43fc241"},
{"0xe0ecae4f","0x4df12ced","0xe020cd25","0x1bb001f0","0x2ee043be","0xf2d1e1f0","0xe0f912f1","0xee0c92fb","0xe2e2af41","0xfd0f5dd3","0xf1d5bb21","0x19047102","0x3eb13b91","0x161ef4f3","0xd0d91020","0xf0feacff","0xf00f3f03","0xfc3f4963","0xd492bde9","0xfa1523dc","0x319f2abd","0x62fee523","0xacfdf122","0x73b5d0e0","0xd0e0011c","0x1f10e1e1","0x1f00013f","0x1012e23d","0x0f30f010","0xfbe1112e","0x1fe122","0xf0f0b1e1","0xef140f20","0x2214d0d1","0x0ff1e32d","0x2f11022c","0x0f312d1e","0x3e22f010","0x0d02e310","0x1100ee","0xfe0df00e","0xf1f0fe2e","0x11f0c1f0","0x2ffe22d","0x1f22321e","0x2e11ef0d","0xefd1e000","0x2c102fe0","0xe0fe22e0","0x1e2f21df","0xdefcfe0d","0xdd210190","0x1f3ec1cc","0xb23c2cef","0x1e03e5e0","0x313010e1","0xcdff1100","0xf0eed00b","0xd2edfd1e","0xdfe2eeaf","0xe01effdb","0x93d1dde0","0x2ff3f122","0x4113fbf0","0xc0f10113","0xf0ffe05d","0x3defe2d","0x1fed0fa2","0xd0efe00d","0xc1bec01e","0x12e4202e","0xfef11c12","0x11d010fd","0x401fe27a","0x43010100","0xff4b0edf","0x3b005c2e","0xefb20d13","0xd02c2bfd","0x21002f2a","0xf200ed31","0x0c0131b","0x12ccb6eb","0x11fde5d0","0x4d105b2d","0xe1d0cc30","0x1e0ed9e1","0x41efefec","0x1ce4f0e0","0xd16e30ea","0x4202d2d1","0x1ce01fe3","0x2105fd1d","0x23d3dd12","0xc40fd903","0x403ee326","0x301ff7b7","0xcbf0ede5","0xf342fe11","0xfd11ef3f","0xace4e522","0x621e3d1","0xfd364e0f","0xf110303d","0x220424a4","0xc277dee3","0xdde2ed03","0x2e7acd40","0xef92f111","0xa0134033","0x41fed90f","0x10db2121","0x9fce0230","0xe554e00e","0x3d3990f0","0x470d11de","0xdd1f3f10","0xac570d2f","0x4019dd5f","0xccd021ff","0x332ce121","0xaf0fe1ed","0x0c24ccde","0xf3231d1e","0x112713cc","0x0c112902","0xdf4e10fe","0xff0edede","0x210e4ffe","0xf1f0e0f0","0xb93fedf3","0x21f6fd2f","0xfb1351d9","0xec00242e","0x1523cd0d","0x0ef0df9b","0xd1f24d1c","0x2c14ceba","0xeceb1c2e","0x10d6f11d","0x21fffcff","0xcde6e441","0x41e3cbfe","0xb0d3d2e0","0x35e7e511","0x13be0e94","0x5370c1d2","0x33df31ce","0x1c110620","0x37fcf9f1","0xf014ade0","0x4130fd6a","0x4e27f3ed","0x72c3e4bd","0xeebefdc1","0xee2d50cd","0xcd1c214e","0xb2dbeaf2","0xc02dac0c","0x1fc31dc2","0xde19d310","0x30de025c","0xf212f10d","0x0fdea6fe","0x20f232f","0x0a13fd3b","0xfe000e02","0x0fb52c43","0xd31ede10","0x0fe10e1e","0x430eba3","0x110d115a","0xdff5e240","0xfbed1d00","0x22f2d011","0x2c054201","0x1021fc2d","0xfcfe0ff1","0x0f1f01b0","0x2d2f1e4a","0xfee2122d","0x19fd1b22","0x1021d012","0x21014df0","0x22f1f2e","0x30105d1f","0x2f1232bf","0x11df1f1e","0xf111203b","0xfb0f10e3","0x1e0cfcf2","0x4e0d10ce","0xf1f070cf","0xee1f23ff","0xb10e5502","0xfe1efe00","0x123ddcf5","0x79112306","0x0f59dbef","0xd13be729","0x4c1d230e","0x10370c2f","0xde1f74a2","0x13f0ea4","0xcb303c1d","0x7bdf64f6","0x1c39dfdf","0xe33bc6a1","0xe1f1f21d","0x10400f0f","0x31f15401","0x11f12b0","0xffc2edf2","0x0fd23302","0x1ccf30b2","0xf10f0714","0x24ff2b1e","0x0ed30cec","0xa1920d2e","0x0b022dcb","0xfff6ba4d","0x2eff0030","0x32faedc2","0xcd1fefd0","0xe242eb3c","0x6dd2e91e","0xd0902d29","0x24f03dd1","0xefc4ba0f","0xddc3e12f","0xe1cb019e","0xcec2d11b","0xaf3e0c3c","0x3000a93f","0xe19d02eb","0x2cddf0ff","0x0ca5a9ec","0xbda6d03f","0x0b2af699","0xced1fecd","0xe00eee1f","0x2002c4d","0xed0fef1f","0xfdecfdbc","0xe1a201cd","0x2a415c2f","0xa4e00de0","0x4d01ef10","0x5ff2da2e","0x2de3cf2","0x11d1c3fd","0x6ce940e2","0xef140fbe","0x491d1cd4","0xf3c01de1","0x212e2003","0x20d3efd3","0x240f4df3","0x11ce250c","0x1ffb1bd4","0xfc2f14ab","0xafdf1225","0x0e16cf31","0x10f153df","0xed000f31","0x9df76fa3","0x41e50df1","0xc30511e4","0x134d2e1","0x10e1af1f","0x473c2175","0x0f090ff3","0xf90fd205","0xbfb572ef","0x0fe4b0f","0xf20cd0ff","0x4e0ce0d1","0x551bee31","0x46474e50","0x2791ebe","0x3ed221f3","0xe2e401af","0xfff210cf","0xfc0c01e1","0xeed0edaf","0x12d03ee1","0x3410fc01","0xee4ddcf2","0xd212ed0f","0xdddf936d","0x1020d2f","0x610125f","0xf13e0dd0","0x2d301ec0","0x113dff90","0x13f2031f","0x531df90f","0xceb0b20f","0xbeb51a10","0x62f0f011","0x0e624b9d","0xbd4aeba1","0x14fbfdd6","0xa470d4ce","0x2200d90a","0xfcb40b31","0xe1cfeb03","0xe1e4f0e4","0x31210bb1","0x9de1fdf5","0xb13ae3f7","0x920cb200","0xf20ffdd0","0x10ebee6c","0x20c3ce3c","0xcc130240","0x5cd20f1","0x0d123a11","0xe10d4e11","0xe0e3cff0","0xd12efe20","0x11ff0e7d","0xf2e0fb1f","0xe113d320","0x10dbdd00","0xfd34cb4f","0xfd0dee32","0xdef2d030","0xce5cfd51","0xde1cce3e","0xf1b1af30","0xce1ee20e","0x2dfaadcc","0xbbb1ab4e","0xfcde1122","0xb0d4f030","0xd1b1eefb","0xe032cec1","0x23eb1f30","0xfcfdfee5","0x4200fdd6","0xd0d225ef","0x20a12e2d","0xe4327231","0xd10c1d4f","0xb1311112","0x31c4db0","0x7bcafadc","0x5b1dfb43","0x30c221e0","0x2eabe0e1","0x41370ec","0xf31ce0ff","0xf2d0cef1","0xef23fc0e","0x2de11d0d","0xd21d0052","0xdead12e0","0x209011ef","0x3fef1f05","0x2fd11f0e","0x0b0eeb0d","0xf00f0d2c","0xeaaff1e0","0xd1eefe90","0x4f25efdf","0xd43cd3ea","0x1ee1f142","0xf0feeffd","0x1beeaf3b","0xe3d11b0e","0xc0dcb1f0","0xb2decc92","0x3e02ccef","0xd02ee2cb","0xb12f1162","0x3f3da03e","0x1cfec01e","0x0f236cc3","0x3bc1efd","0xbdd2cca2","0x0e3fad00","0xae4e0fbc","0x9f6f0430"}
},
{{"0x1cf101f0","0x0f002ed2","0x0f330f1e","0x1d1210fe","0x1f001e2f","0x0e21f21e","0x0ff00fe1","0x0f2f01d1","0xf1b2173e","0xbbd01101","0x21033d42","0xedf1fff2","0xee03f1ee","0x1ee1ff0d","0x313f2e21","0xd30bd2cf","0xfa2e0400","0xdb211024","0x1ff02cf0","0xf250ccf5","0xcfe32ed0","0x15dd2e13","0x6057f3e","0xf70e10d0","0xf111fd12","0x1012220","0xf01002e0","0x1fe0f20f","0x12d00112","0x0fec00ef","0x0f12111f","0xfe0f2e01","0xf0fe1902","0x13fe0b5f","0x2e00161e","0xefdcf33a","0x2fe1fd3","0xeff2320c","0xcdc20fc2","0x1bf1ce00","0xf64e650d","0x2fc03720","0x0f02010f","0xf400ecf1","0x42fc0","0x3eed0112","0x637f3f32","0x130bc1f","0xf1e10011","0xfee0003f","0x10ff0300","0x2000101b","0x2030e01","0xeb110120","0x22e1ff01","0x20df021e","0xf10e0f12","0x2ed5ece0","0xe0d2f600","0x400ee2c","0x131110f1","0x1c1ff420","0x0fd11fe0","0x1af3f101","0x22f20130","0xefe2cf11","0x0e0062f","0x2e02d","0x3fff0f2","0xfe1f1f1f","0x1f1ffe01","0x1dd220f2","0x0d31e10e","0xf3200f41","0x2ea3143f","0xff1f00f2","0xd02eff04","0xef40c0fe","0x2ee502e","0xdf121f01","0x1c4fc104","0xd23e431f","0xd1fee651","0xe3e00330","0x2e2a1e1d","0xfff1a01e","0xf42e1de2","0x1f210b1","0x0f3cdff0","0xff1f342d","0xff0ed431","0xf1e13f1e","0xef2e0d2f","0xff42cd31","0x2224d0e1","0x122f0e02","0x10e03301","0xf1e1fcef","0x1bed011e","0x320f0211","0x23fcfd0f","0x0a0e3030","0xc11cff10","0x0ed0f001","0xc3c2053e","0x0faf14ff","0x2a0dfe2d","0xf3edeff3","0x4dce1bc","0x09cf1d5e","0xfd452e60","0x12ffbfff","0xe1fff53a","0x0e2c0ec1","0xd011dd3d","0x121ddd2d","0x1eaf12c0","0x1bcff36c","0xed207e9f","0x41cf100f","0x1f22f213","0x102bee0","0x20ffc63c","0x0f52b14","0xffa1ab20","0x3ee1acfc","0x35e2a04f","0x11e321e5","0xe1e21102","0xcf05001d","0x312ae3da","0x3b0c2be2","0x31c2f00c","0x5fa1eded","0x403013d","0x3efd04df","0xe2dd116e","0xbb01303d","0xb40a7dfb","0x3ffcf9f0","0x5e1f622c","0x4f2041d9","0x4c42b0ee","0x6e1ea5ee","0x31fbd62c","0x0ffd14d","0xfdcd2cfc","0x10e10ec7","0x0ff0bb","0x0a1c2f10","0x1e49dfee","0xe42efcee","0x2229d711","0xf1a1c4c2","0x10931a0c","0x1922ee97","0xdf02e12e","0xf69d921f","0x17a47ef1","0x775d19f1","0xfe0ce90e","0xdb9f01d0","0xf1b3ce2b","0x0d20f02b","0x20def11e","0x3ff1bf7a","0xf0c460a0","0xf3e101e3","0x2d10f03","0xdff001d2","0xd0112332","0x0f12fd1b","0x3ef31f10","0x0d10e0ed","0x120c1122","0xe3fdbd0c","0x3fd5b061","0xaea50e00","0x9c00e7d0","0xfce129dd","0xc107c2ff","0x2be5c0d1","0x227f02cf","0xf3de0e20","0x0c2d60c","0x40d52ade","0x100210bb","0x2e2212","0x54c6dfcf","0x4ca013d1","0xffdf1190","0x0fd5ec05","0x25d1dfdf","0xc1e61ece","0x202d401","0x6e104223","0x63f7017b","0x1a24c1fd","0x220f2e7","0x0f5d1101","0xe0f4a46e","0xc12672a1","0x23f31d42","0x3fb33431","0x61675661","0xfb14c1ef","0x4ce2157","0x102c1ff1","0xde02df4e","0xe06e70c2","0x1033044","0x56ce110d","0x5b1d60d4","0x4b3ecde0","0x0f2e3e1f","0xff0f6efb","0xee3eff2c","0x1cd61c","0x1cb0f311","0x0aa1d1e3","0xfd2af0ec","0xdf0f0630","0x26195f12","0xd723d4a4","0x0fddb01","0x0e2bdb10","0xbdce0251","0x1cef121c","0x3c5af1ed","0x1eb010c","0x09ddca1f","0x203022dd","0x100c1c1f","0xdf3ffd61","0xed2df0d1","0xdc20e01c","0x34ee20c","0x0fb0fef","0xcfe2dede","0x12e02f2c","0x305145e","0x2f3111d0","0x1002232e","0x0afefe0d","0x1de110f4","0x1b4e5e2e","0x0f0050f1","0x501e11ee","0x2113d43e","0x2212fef2","0x1ec21e1f","0x2fd02c1c","0x31f22f24","0xdcdf114f","0x51fe7003","0x1a3d22bd","0xee111321","0x521e0014","0x21212210","0x4e11000","0x3e03e111","0xed9e260f","0x221e5d5e","0x230007ec","0x0f2d2e1f","0x12fce0","0x19700f52","0x3efc6e30","0x33f1701","0x3e22f20f","0xf2030de2","0x0bee22f3","0x11320eeb","0x511f4e15","0x297d0421","0xfffe6f4e","0x5e3fefdf","0xde2c4100","0x114fee2","0x2bc21f0e","0x12045eed","0x22eff61d","0x1f30f030","0xde315f41","0x1f5bafeb","0xcff9db01","0x2c41eac0","0x30c40ffc","0x291574c","0xd10bd0ef","0x5570011c","0x1f202eb4","0x1000170e","0x171f1ec0","0xf03d1d92","0x3a2f2d62","0x72f4379b","0x2ffecf9d","0x136311b2","0xe0315bc5","0x2a511450","0x27f92d27","0x2d355ca2","0xeaf13e11","0xff31109f","0x210efff0","0x21f1229b","0x1221ef11","0x3ebd4d0c","0x694c0141","0x4e423ed5","0xef010ee1","0xdeccf1dc","0x13cbc30b","0x1cee214d","0x12debefe","0xf1f0f0c4","0xfe32f4fe","0x22ebdfaf","0xd331ed10","0x3b2dffe","0xff0f1f44","0x4e0ec5f1","0x72fc5fb3","0xf4e44f12","0x303326e2","0x0e2ef00e","0xe6609fe5","0x31fdf13e","0x1ced6505","0x4c1ee0f2","0x3e1f","0xe2f11efe","0x6c441fe0","0xff201e11","0xf303beef","0xf00b1aef","0x27c","0xf2cf1910","0x21eff15c","0xe11d0303","0x1ad12bf3","0x0ebde011","0xe2d1fe21","0x1fb001e","0xdeeff45f","0xeeddf9fd","0x22effd43","0xf03d1e0b","0xf93d3001","0xff3bc20f","0xf012dfef","0xae01f02f","0xfcbfd10c","0xcab03b0a","0x0ecf3","0xf01a11ea","0xd9ef0313","0xfe2fff0e","0xf2044bc5","0xb3e31405","0x2b0ef43e","0x2e31be10","0x253ce3e1","0xfbe0fe4e","0x2faf4db1","0xd3ecf7f1","0xff2f2102","0xd1f312c2","0x0cf0c1d2","0xd01cfd10","0xe3f100ff","0xff2bed24","0x0d9200d1","0x0ae24ee","0x20c4121f","0x51141012","0xf11291d1","0xd2ed4e6d","0xe3f24e2b","0xe13ece34","0x3c061d0e","0x49fc15cc","0x1d01e4d3"},
{"0x1ef20fcf","0x1f1103c4","0x0f2031f0","0x32f01d30","0xe010003f","0x0d23011f","0x100fff20","0x1e2040fe","0x65d4071f","0xfede0cc7","0x537f20c4","0x70ff6ec3","0xdc04e72e","0x36eefed4","0x3effad21","0xd21d007f","0x7c3707b2","0x2de43197","0x1d501e97","0x4f207c94","0xcb222661","0x27ea2ec7","0x2f049b20","0xe51e2e2d","0xe02f2902","0x0efff04c","0xf3d00ff0","0x10f0011e","0x2ff1bff","0xfdfe12fe","0x1ff11000","0xf12f0f11","0xb2e909f1","0x44eded79","0xf39fef4b","0xcffcd2c9","0xf4090ca2","0xb1e211fa","0xddef11d2","0x2f410e3f","0x47e2670e","0xb0b21243","0xd7411ca1","0x701e5dd3","0x0cd72723","0x74daed97","0x522bffff","0xe37ae073","0x1dae10d","0x1001006d","0x10dff02d","0x1120123d","0xe00fe2ee","0xeaf10e2c","0xfd1aef00","0xdd50ad0f","0x161f1750","0x9ee3b7ed","0x12952bfd","0x231bd97","0xbce10400","0x45b9ee27","0x77707f5f","0x475abbff","0xe00fbb32","0xdb4cff1a","0xfd90dc2d","0xf02dd2c6","0xefd92fe1","0x5edfd22","0xf0265fb1","0xd732ffe2","0x3023f7e2","0xb17735c0","0xd0b73ff1","0xfd714ac7","0x136431","0xf1c9f015","0x662e7cf1","0xd3e9dcf3","0xb939cd0f","0xbe6a4e4b","0xecc9e112","0x410d195","0x329ff41","0x4b09d3e","0xedeaa2df","0xbef2eba0","0x0c19ef0f","0x0cfe1022","0x1dde3223","0x0e0f20ff","0x163de03b","0x4ffbed5","0x4e36c1dd","0x2f0ffddd","0xef0d2412","0x32f20cfd","0xf20e301d","0xf11ee2b7","0x1e34d604","0x71111ff","0xd22d10f1","0xff11d010","0x57f347d5","0xa5a155a2","0x163f3cf0","0x513e1ef7","0x19f2c737","0x37ccbdf6","0x2147fe22","0x157ade5c","0x110623cc","0xfe475e9f","0xb2d13cd5","0xd0701d10","0x1ea12f6f","0x94ecfc57","0xc017099f","0x12bf2edf","0xe11f21c0","0xe101a1d1","0xf2cef6ed","0xee02fdb2","0x0e35be51","0xe09405fa","0x4ec0dc40","0x3e1d5312","0xc1f042fd","0xb20f50d0","0x4efe1109","0x2134fcc1","0x3d700141","0x491c31c","0x494fd3f","0x3b2d12ec","0x151c401e","0xfff10105","0xc4dc2dec","0x110e39ff","0x33215340","0xb1c901ea","0x3205dd0b","0x6ffcf4cd","0x11dd270e","0x13e1ce5c","0x214f500b","0x0e0e1f97","0xebfed7ee","0xe60d10fe","0x0eeb0eb0","0x5b0eda5a","0x211707f1","0xded14904","0x347f2ba7","0xc12d2293","0xaa01076e","0xc7ccaffe","0xefd6ddce","0x1c41eb5d","0xfd071bf0","0xf0f13fb5","0x22aeec2c","0xd40ff33b","0xe0c3fd3e","0xd5fcdd2a","0x0efebef","0x0fe2fec2","0xf2fb1ef3","0xcd0b3014","0xd10e60e1","0xf112dfcf","0x19e12cd3","0x6cc11d0","0xbdff0ef3","0xa479ef3c","0x5f12adc1","0x99913b31","0x9d9e2bd0","0x1c21e900","0xb02210d3","0x3bbdbfe2","0x191cfbe","0xb4390ddd","0xe6f11eee","0x0ff22b2b","0x9caefaac","0xef610001","0x3b1cdfe","0xfeec4137","0x5fccdb90","0x4fedbe07","0x0debee2e","0x1f1d1d4f","0x3cfebd","0xdfecf2ec","0x40dfd20b","0x33e52e0e","0xcd0110ed","0x2fc3edf2","0x2ed4fdf2","0x3f1c2c32","0x24cdfff","0xd1ffe2ff","0xfd1dd25e","0xf2043e1f","0xb01010ef","0xf1f3002f","0xff030dff","0x4e0f3cf0","0xf04efe22","0x2fe33df","0xfc2ece23","0xee5cfc11","0xedfedfed","0xd0e20031","0x4553476e","0xe16736a1","0x7f342f7","0x3c624e96","0x09c20474","0x53a44ee5","0x51fd3dff","0xc75ca06e","0xf02c0e10","0xed1a0d1e","0xe1c0240f","0x4febf1ff","0xfda0102b","0xba11d229","0xcec91be3","0xd0d21201","0x1e0b003d","0xf1f01e0f","0xd00143d2","0xc0db11ed","0x2fd1cff1","0xed3e210b","0xb0c12f02","0x12ffee30","0x1de5265e","0xeec1de2f","0xeee35b0f","0x0cd3efe7","0x3e0c09b0","0x3919d4f0","0xd339def2","0xe02d1cbe","0xda00c673","0xadf6f26a","0xabb179cb","0xedfeeae7","0x4feb50ef","0x1eab1d14","0x161640f0","0xf5594e9f","0x1cfe2a2d","0xfe411ef0","0x9dbffc11","0xef202e11","0x0e1e02d1","0x0ade30f3","0x1fff11dd","0x3d1bd3ec","0x11eb1ffc","0x0f12dcef","0xeb31c05f","0x19ff1130","0x212d2df1","0xa0250000","0xe1f21dbf","0x0beeedfe","0xd4cefeda","0x2b0fdf51","0xece1cf7d","0xcc272e30","0x0f2fd0bf","0x9de0fe20","0xf01d1bd0","0xffe4dffc","0x40012a11","0xbe2103b5","0x0d5e113","0xe3173911","0x202ccecd","0x4fe90a02","0x565f5dff","0xef51041b","0x11bb3e5d","0x59fd9d3a","0xaeef2f1c","0x1c11ecfd","0x232b32cd","0xe2213d1f","0xfed0fab1","0xfb0100b3","0x40ae2e3d","0x39e19f0c","0xe0a0fcec","0xfd22ee0f","0x24b971e9","0xbe32ee1d","0xfd1e29f5","0xd902fde3","0x402c0ef2","0xec11b020","0x130faeb2","0xd13dee1e","0x3cdb5ff9","0xfc3c0001","0x1ccddcc7","0xcc132f0c","0xef30feee","0xf20ed20f","0xdcfe0e2c","0x9fdfc1c1","0xf23e10d0","0xd02ffffd","0x13ecc0ef","0xdeee0ffa","0xc0e2d1eb","0x19fb21d","0x4c5fc234","0xd3cce41e","0xf02eeee2","0x101122e","0xffee20ef","0xdf032d0c","0x13ee32be","0x4fb0212","0x2f2fe424","0xf1fe23cf","0xefdd31f3","0x325ef3fd","0xd04f3fff","0x4321f01","0x100e0efe","0x3f02031","0x21f31f11","0x0e0245c","0x2bef21","0x1ed00fe0","0x0e030c2","0xf033d011","0x1419274e","0xe0e2f3f1","0xe7306be0","0x1faf2f97","0x1907e7f7","0x272bc1a3","0x24df0ee","0xf17c9f4a","0x692fe737","0xaa951403","0xcc203bb7","0x0e101ea6","0xea2f7616","0x472dcac5","0x2e4b3bb","0xf57eeebf","0x1f327f6","0x5f1b3e2a","0x24203101","0x102dd2a4","0x0c32eef2","0x5fcb7c15","0xeeff412e","0xf14df301","0xf4eff5ee","0x343fc121","0x12120f00","0x61f003ef","0x23efe25","0xb10f3001","0x49dc30db","0x4010f1eb","0xf3f40341","0xc50f95c6","0x0f1edd1f","0x340122f0","0x2e6c0e23","0xd044af3e","0x494c0cc9","0xe54ffe0d"},
{"0xe1121c12","0x121e1f10","0xf41111f0","0xe12f30ff","0x23d1fdf1","0xeb00f210","0x10ff10f0","0x0c10e0e","0xc4f31e42","0x41fe0024","0xf01dcf2e","0x1314eff","0x22fb2cb0","0xfc10f021","0x10f11f2d","0x1fd200c0","0xa1101d01","0x21fb9f01","0xdf3cc019","0xe1ff41ed","0x13fd0cfa","0xba12c56f","0x2de14d1e","0x2ce4f2d1","0x11f1ff1","0xf1001e10","0xf1311300","0x10111131","0xf000f220","0xe01e0000","0x1ef10010","0xf21efd0f","0xed1bfbf2","0x0fe00f69","0x0fa0223d","0xf2f0d02e","0x11f12e1","0x10ff231c","0xfff4e002","0x2de00f3e","0xee03eb30","0x0f23d71","0x2f2bfe2e","0x4ef004be","0xf0d3f2fd","0x2311f220","0xeee31042","0x12004d63","0xef0e1f21","0x31f0f059","0x21cf3f09","0xd11f021d","0x0f0de3a0","0xecf0110d","0x1fd0201","0x2f20f34e","0x420715fd","0xf0c20911","0x337e2ca3","0x1c007196","0x090fe721","0x17edd0c6","0xf0f0becd","0xd90ee330","0xdf250dfe","0x1dee6b1f","0xf0ccece2","0xe10ed304","0x0fec3901","0xc7e0f112","0xcfc1cc0f","0x1af242c2","0x3c470dda","0x3152fcf","0x11cf1fe3","0x0c1170f3","0x1f1d0231","0xef3ecef5","0xb0d2db21","0xdf01fc02","0xad5decf2","0x2eeb5f2b","0xf13d0011","0x24deb3d0","0xfe4b0d21","0x3db49dfb","0x1feecd0e","0x3c122bcf","0xf04dc00e","0x1dfcf014","0x0de11204","0xf000621c","0x1dfd1c","0x3f0bf03","0x1d3ff1fc","0x4de2fd00","0x20e2e11","0x0fe0ef4c","0xeeecdfd1","0x1f0f000c","0x232e0fdd","0xf11d2f1f","0x12edf00e","0x1ff0e021","0xe2e41a20","0x40f3e05e","0x1efa0e3d","0xffde00ec","0x3dc2ed","0x6edfb31","0x3dfe12f","0x1fb1f13f","0xf2161def","0x6fdfff4a","0xd1aefcec","0xbfeef10f","0xede10e10","0xeeb2c02f","0xe0ff0d1f","0x2e215f0e","0xf4e133f0","0xf71feec4","0x0df321e2","0x0d0c1f","0x1b109d52","0xff9fed0a","0x32c03e3c","0x30ef1cd9","0xd44e41e0","0xe5ef1300","0x21dbde30","0xf2210d3d","0x0b61e212","0x319de1fe","0x51af5eff","0x602e0299","0xd22f200b","0x31c0cf05","0xc1de2e00","0x0c101acb","0x2e6f261e","0xeefc32fd","0xfefe2f1b","0x7f2200bf","0x201000ff","0xe303df71","0xf0de2ff0","0x2ff1102c","0xd0510e10","0x393e2cff","0x0ff0f100","0x3f001fa0","0x10fbe022","0xf110b15d","0xd0af013d","0x2dfce45c","0x3e5f0df","0x091ff1f1","0x1fc0210f","0x11f20ee2","0x0dfa1e3f","0xf12fe12e","0x1e03e2","0x100232d","0xc2f101ef","0x09ff1fff","0x1efe115f","0xefe20dfe","0xf4c2f121","0x0f01df97","0x124414ad","0x2612ff2f","0x1d33fdf0","0x25431b1d","0xede00102","0xee1f1d1d","0x32060fd1","0x2bd311b1","0xffc2e21e","0x213320d","0x26f1f0","0x2cff0f21","0x0c1d1ff","0x2f11d1d","0x3f524cd","0x5cd24ffe","0xefe20032","0xff132ef2","0x2403b30f","0x1eca0ed5","0x3204fc0","0x1ff7c2e0","0xff1fff61","0x200d5eff","0xa1ae2cee","0xfecfc000","0x21ecef0f","0x41e61dd1","0xbbe21103","0x12d00e12","0x1fcff12","0x14cde4f","0xcfd00eed","0xedf2c00e","0xd0ebfd4e","0x1ff31eef","0xbb003d0c","0x12e1ec11","0x21eddee1","0x111dad4d","0xaed1ef00","0xcd00012d","0xb2cd1cfd","0xefb03de0","0xdad1d2eb","0x1124ecf3","0xef54ff5d","0x1e901de4","0x402e0306","0x1bfa70df","0x0c0ef66e","0x6ce7df14","0xccee1f0b","0xe200f500","0xf00d1f42","0x1de0ffdf","0xf1ce02de","0xffead32f","0x10c2323c","0xdef3055b","0x0ecd2c11","0x2f5e43df","0x1eef1054","0xe1323030","0xbdef0fbf","0x0ffdd2ee","0x1ff510fc","0xff122f0e","0xf0b2fc11","0x40efd322","0x4dded11f","0xff301e4e","0x1405eef","0x7edcecf7","0xfe4e2703","0x110dfeb2","0x0fbf11a3","0xeed2e9e0","0x5cc1f2c0","0xfede3f50","0xdc6e7937","0x3ffdcc6","0x0e4b34ef","0x27e90993","0x3a3cdc0","0xfbffe99c","0x3ccdfe31","0xef11d003","0x0dfe4cf1","0xfeff0e0f","0x3c244302","0xffee00b1","0x15d0df0f","0x0f0000cd","0xf0dff0ff","0x22312e3e","0xe0e2e14c","0xed01223f","0x0b2daf","0xcde61021","0x3f5ddf0","0xfdd0cd2e","0xf1d23cff","0xcfeff05e","0xe4e3bc3f","0xdd045fef","0xceff0db1","0xee1dd1f2","0xd01f0ef0","0xc351042d","0x4eef1a2e","0xc9431e42","0xa1a42dae","0xd3f1cefa","0x220d0c92","0x7ada51de","0x31db2f15","0x927c1200","0x2f01353d","0x0d10c130","0x0e5012d1","0x21e2ce0","0x1ffd1203","0x30600d0c","0xe1c12c25","0x112e03f3","0x211034ec","0x1df2b212","0xff301ed0","0x2f2c0da0","0x30bd313d","0x4e10d041","0x4ffd6d03","0x4efbc5","0x101f26e0","0xfe42b100","0x30411ed1","0x2f0b22a2","0x4fde214a","0x3d3e1f3f","0x32dcefe5","0x1f510dd3","0xfe10fde1","0xb2bdfe1f","0x1c0ff001","0xcf0f20d0","0xd2ff3d1d","0xdf42cff0","0xe1edee00","0x10b0402b","0xe102eed0","0xe29ccd2d","0xfcfbbf1f","0xa2ddf01e","0xf2fb1dde","0xdf1fedfd","0xe0cf00f0","0xe0d4300c","0x1222deac","0x32b0bd00","0x0d4ede31","0xdde924dd","0xe02cdcb2","0xc2401dec","0x0d02cdc","0xdcc45e3e","0x1310031d","0x1111140","0x2003003","0x2ff21109","0xe11f0030","0x4bf1df0f","0xe1e23f11","0xffe1d00f","0x210ce04d","0xf01ff300","0x111fe0","0x0cfe22fa","0x0e20070e","0x1d102c0f","0xf01e20ff","0x1f429f0d","0x2df2e","0x0ef12f0","0xde0f1131","0xf00ee1ec","0x111114ec","0x30def0ed","0xe3fcd0fe","0xef12c2d1","0x3ffe1e9f","0x2dbd0d6e","0x0f0dcd13","0x4f2020dc","0xed3ecbde","0x1ded2cf2","0x5bd331b","0xffffd1ff","0xd3124ffe","0xe493c35c","0xa4f1db1d","0x2c00e2c2","0xf00b2fe2","0xd10f60f2","0x117a31fb","0xc300c640","0x12e70e7f","0xb3d40f17","0xa22f2ed2","0x1c2e20b7","0x397b7e95","0xb43f5036","0x296f0dfa","0x922df4ee"}
},
{{"0x7ceedd0","0xd32df39f","0xeec0efee","0xf111ef33","0xd1e2e232","0x10cc1f0f","0x0d0d0ffd","0x1fefbece","0xf5ebcdf3","0xde2ff09d","0x0fffeddd","0xf252e110","0xdc12d10e","0x112f0f10","0x5d1ecfed","0x3aefa1df","0xdfbbdc30","0x0f2fefae","0xdecafe1c","0x2220042","0xfb1d0fee","0xff6fd011","0x4bbbfe00","0x3912c2a0","0x2e0ce001","0x1ced0f0e","0xa3e21f20","0xdc0fb15e","0x1f3eefd0","0xfddb21ef","0xdc0cf0e0","0xf2222140","0x1cf0010","0x1eff3cd0","0x93c12e3c","0x121a040","0xe3bcd0ed","0xe10f31ee","0xd9e010f0","0xefff1f10","0x30000ebe","0x34ed2d9d","0xadc3fe2d","0xbd11af3f","0xe1bca1df","0xd2c25f0e","0xce1001ee","0xdef31ff0","0x14f412e2","0x1e01f0b7","0x735e12be","0x61d27101","0xed54f75f","0x2befd1d0","0x1020923e","0x100df5f","0x30f5c1a7","0x1eddc297","0x7e7dc0a6","0x20b07117","0xda7d2221","0x171bc9c6","0x5e55af0b","0x230f0dab","0x22f7ee13","0x202fc4d7","0x7d4f04d0","0xff0360f3","0x134df3f2","0xe4f11fd3","0x20e1d3ee","0x320deedf","0xf5b11010","0xc41efef5","0x3031e4ab","0xf4f21013","0xbebb71ff","0xb40512d0","0x4b15ff31","0x5f0ffaac","0x24d121ce","0x94d020d5","0x4d11f6cb","0xf2110d2e","0xb201340b","0x101111d1","0x5b01e120","0x6f3cf1ce","0x31212014","0xcfe00dd5","0x0afd051c","0xcf01010f","0xde2451fb","0xe42e00b2","0x3b27f","0x11020cf","0xffee2fcf","0xfe2f01d1","0x22c1ae0c","0x0b0fdde3","0xcf2313ea","0xdddeee1e","0x141fe115","0xf1200202","0x0c1d30c","0x29c0f00e","0xf4d10e0c","0xfb12ce21","0x10e2a40c","0x0dd4db1f","0x0f33f146","0xece224e3","0x0fc1e7f1","0x09b1e6ec","0xb52d1eee","0x1d02e0fe","0x11bfc410","0x42e0cab4","0xd1c51e72","0x76f12df1","0x0fce0162","0x0de3144c","0xc402d204","0xf422de23","0x2edfb14b","0x11d511ee","0xef4afe0e","0x1d2f0135","0x0efdf631","0x3332323b","0x130432f","0x343dcf03","0x3da0f151","0x11b042f2","0xe03c4e1b","0xf32e1402","0xddcbefdd","0x2f4ecd6d","0x214a300f","0xc4ffaad1","0x1baecdf4","0x2ff13110","0xedbfffca","0xd3041f2d","0xd0122ec9","0xc4edecf2","0x93911f2d","0xecf1a0ef","0x3fd1af2","0xeefcc111","0x1cfe3cb3","0x11f32510","0xef500d0d","0xd0141ed4","0xdf9203f2","0xd5053ab3","0x111dec24","0x0fdc20e4","0x103df0d2","0xc5f9071d","0x22de101","0xe2100cf0","0xb290f2c0","0xe5153c3f","0x14cf1df0","0xd3c1f3f3","0x12d9cf31","0xc11cd1ee","0x0ffc2f23","0xfdae0e40","0x92edbf54","0xfa221ebd","0x40ecd0b0","0x1e0b1ffb","0x2c1b4cf0","0xf2500c31","0xff7d1eff","0x2dbff03f","0x93e1c2e0","0xda1042dd","0xdc1be0ac","0xe1ee0f0d","0x1ced00dd","0xed40f121","0x133e1ec3","0x1e2ec23f","0xf4c4e1ed","0xe0311e2f","0xcde7dcbd","0xb2111e3f","0x11edd5ce","0xd101f011","0x13d03291","0xc012b01c","0x120dd1dd","0xff2cf2dd","0x5ffeee3e","0xbdf14fdf","0xeb30e201","0x10020704","0xf3f120e1","0xd52cc00d","0xf42d0d0e","0xee0cae1f","0x4eef4c0f","0xde03e11f","0xfb201e01","0x0e1f10e","0xf310ef21","0x40cd6dd","0x3001fef3","0x0ed3d01f","0x0e0711e","0x3f66e020","0x422bb1e3","0x2f113cfb","0x0fcb0b1d","0x43f22f5c","0x200d120d","0xe1ebf30c","0x2391dee","0x0f223200","0x0d521f0","0x10132f0f","0x37bd77db","0xd0f00333","0x7100eed","0x71ec1105","0x100717d4","0x502a02e4","0x4f69f1d0","0x107c2d64","0x5a1f13d2","0xfc15012d","0xcf025cc1","0x131f1001","0xf9222417","0x51bc31e4","0xef2ec202","0xe01c2e10","0xff00ec51","0xdceaeb1f","0xbbb1f0fe","0x0f11cc1d","0xf0f10c1b","0xdfae1f01","0x09fdffed","0x2ed50ceb","0x0f300fde","0xe0ec10e3","0xf0b313ff","0x1120e13","0xb30f00fc","0xddfc3032","0xe40d0f59","0xf2c64fe2","0x1f2ff0e0","0xe1ef16d2","0x210012fc","0xf33e0011","0x1b2c310f","0x0f1d0b23","0x53d6111","0xc1047d91","0xfe341000","0xe11c0ef2","0x1231f4fc","0xffebdc2c","0xbe01ed0b","0x91d1f310","0xdf0130ff","0xc015fddd","0x12f32da","0x446ff0f4","0xf106c11e","0x23251ce3","0xee433f0e","0x3e2bd34e","0x6eec2ff1","0x361bb21","0x2f3d041f","0xed3fd0e2","0x6f2e3c0","0x2e211cd","0x23f0cb01","0x0effb13d","0x25df5012","0x150b5de2","0xf00d1ad2","0x40f1227c","0xc3ffdde3","0x2f01c","0xf01ef02e","0x0c0130f1","0x1edfe222","0x20044110","0xf10f3902","0x1f1d36f","0x0ed0ef0f","0xf112111b","0x1f2cd1ed","0x1bff4f0e","0x0fcdcd0e","0x2304e2d3","0x20e0cf1","0x3200e41f","0xfcbfe0e1","0x0f1102de","0xe01df00e","0xfcff1df0","0x2fccefff","0xf0d11001","0x233f0b2b","0x10326fff","0xd3be4fec","0xf502b0ef","0xf07f532b","0x11d100af","0x10bcc157","0x2f3224d5","0x40edcfc","0xe2301f1c","0x2bdfe00","0x3414c0bf","0xfeed1ffa","0x2dfcf0c","0xdb1ff1f4","0xbef30ed4","0xf0f0cffc","0x0c2fe53b","0xc1ec91f0","0x632fcbd","0xc1ad066d","0x6dfec03f","0xeb114fd2","0xfcf4dd23","0x1f000efe","0xff20b50e","0xefcf4ece","0x4e131ee2","0xbdf00d0e","0xfdfeef32","0xfcedfcec","0xc0bb00de","0xf00fd241","0xe101d10f","0xeed05d0e","0x3e23fb06","0xc23101fc","0xcf311035","0x0fcbfd1c","0xd000dfee","0x20eda02d","0xcf3ed1be","0xac133f0d","0x2bf2fe30","0xdc1ef0de","0xbef02541","0xebdc2c5d","0xcf1fc1f0","0x0ee4ddff","0x40ecf6e1","0x420fcb22","0x10fd00e1","0x0f00f110","0xf4700cf4","0x24111121","0x22d330f2","0xded3ee22","0x10ce1211","0x1004df1d","0x1f12f5a2","0x1eb11e1b","0x0f330b01","0x4b4e02c0","0x210221f1","0xecace220","0xf310f97d","0xf4f2f00e","0x11fee1dd","0x61befd2f","0xddc3101f","0xedbc71af","0xd326e020"},
{"0x1c42e03","0x200310f","0x21e63230","0x320f1011","0x1b5ed4f","0xdd12e000","0x114b51e1","0x0f12c2c1","0xd5e41542","0xdff137bc","0x52e3f000","0xe200fdc6","0x1224ebed","0x0f04d321","0x747e31f0","0x442cc2b0","0xccfd125d","0x1e0520ee","0x3423021b","0x12edff0","0xfdb20fe4","0x5df33325","0x74c1709d","0x15e302d6","0xfd3f2012","0x0ffdf051","0x2300f1f","0xce1ec250","0x113f211c","0xfdfdffec","0xbe5e1dff","0x10e1e","0x2f113141","0xe1031d02","0xa2f10f0e","0xf32faf1f","0xf3d1ef0e","0xf021e0ce","0xc93f1fff","0xec03e00f","0x2f2f2fee","0x6e04ade","0xb024ee0d","0xdf30dd00","0x0d0c1f1","0xe1c521cf","0xcc4ef1ce","0x1c022121","0xe3052ff3","0x1342e3f4","0x603fff0f","0xf3f32f53","0xf00efe1f","0x0c021031","0x0f11d4dc","0x1af1d391","0xc4e02ee0","0x323db211","0xe10feb2b","0xe100d151","0x23d101df","0xd3b4fc30","0x1de0f1cd","0x3cc2bf93","0x10ee020","0x51ebb210","0x3f4c000f","0xe3f2e052","0x21fe13ce","0x5e6e21d","0x2ad5f20e","0x2cdffe06","0x1102c6e1","0xee9222a6","0x40331d9","0x1e11042d","0xa0f43700","0xbf311e21","0x2f0d0b21","0x40ff0b2c","0x113ff7c4","0x0d9110c4","0x0e20f00b","0x1fe10ffb","0xa41354fe","0xc2013cb1","0x54e3ee6d","0x741ef3ec","0x110fb010","0xfda11ff5","0xed4fe20a","0xee13db2d","0xce3113bd","0x3013dbee","0x4c3b25f","0x0ef303e2","0xe124f0f0","0xf1301110","0x21e3cf00","0x0ff3cfd3","0xf00021ed","0x3f02e32c","0xe35c40f1","0xe30fdee1","0x0ee1fee","0x12ef20d","0x14c1edfb","0x1200d24f","0x13d0c4d1","0x3c03d0dc","0xc13c03f2","0xf100f53c","0x100f27de","0x1cf0b10b","0x37fdcd1","0x4100001","0x1f1fc41f","0x73b5cbc2","0xee203f22","0xedc1301d","0x9f5e3210","0xc0122c0a","0xc2f337dc","0xe13eda15","0xfd02a131","0x630ffd11","0xc11b01ff","0xed0e023e","0xf22037f4","0x74f3eda","0xb24245e3","0xe05feaf6","0x0f07b463","0xd61920f4","0xb0f2f30b","0x156df55e","0xcd3ef1ef","0xe33ffe3e","0x122c442f","0xe1e19bf1","0x2aa29123","0xfe2ef2fe","0xcdf2fffa","0xf4221cfd","0x20bf21dd","0xc1adee14","0xc541e12c","0x5c09d1c1","0xbbe73c93","0x0e23c021","0x2eee1ae5","0x11143123","0x4d2d0dd9","0x0dd21ed2","0xb6f00c54","0xfe0a2da4","0x0903cd13","0x12002146","0xfef01e17","0xa54e351d","0xf01dfe09","0x0fe05f1c","0xf49f1051","0xdff12dff","0x6220de23","0xbed52f22","0xf3a93fe4","0xbe3011cd","0x203e2f11","0xfcb0042d","0xd02edf23","0x21530d0","0x4f0df0df","0x101b1e20","0x0f0cbf1e","0x11ffe1f","0x0f10f2de","0xfec1151f","0xd1eeb0b1","0xdde11320","0xfed4dfdf","0xd01e0c33","0xbec0913f","0x65bf001d","0x10f2e1b0","0xfe0c14e0","0x6350d5ef","0x0f132223","0xd1e62102","0xf0323d40","0xc1bf0311","0x66ed5220","0x42cd22b0","0xe150dd21","0xd1fdd2e3","0xfa3d0fb1","0x10debc5f","0xedde7fed","0xfc20e3b1","0xc120f306","0xe4d021ae","0xd33af21d","0xe02f121d","0xdadfd00f","0x111eedf0","0xfee10efb","0x1c501102","0xe4e00f02","0xe61e3ff1","0x133e27ef","0x201ef110","0xecc3bef5","0x464f7514","0x2244ee10","0x443291e7","0x3fede1bf","0xff2b0b1f","0x4bde0269","0xfe90ec1e","0x10ff200","0x20f1dce","0xffee211f","0xff3ef0f0","0xef01ec1e","0xf0bcc95e","0x1cd1d04d","0x7139b90b","0x622ae3cf","0x21bf17fb","0xf3100e02","0x0ede00d","0xfae31c41","0x2fc4d92d","0x19fefde1","0x3e6bcbcf","0x15f041dc","0x2d300e2d","0x30f0bf03","0x2ffabd30","0xdd003ced","0x255150a0","0x22cdadf1","0x9dd7e60e","0x3034002e","0xdde41eed","0xcff9f030","0x0b0d0d9e","0x123a21e","0x0c640fcf","0xa9164eb3","0xcaf202bf","0xa2146f44","0xcf2610c5","0xf30cbfee","0x172de175","0xf10901d2","0x1a13dde7","0xc01350ef","0x422ed1e2","0xcff0fff2","0x1d2e2e43","0x37e4bfdf","0x1316f331","0xc24b2ecf","0xcefddc1a","0x34fce0d9","0x5de0d14c","0xdfeeccec","0xd109f9bb","0xc4d0d221","0xdf10fdee","0xe1342ffc","0x32b467df","0xf4050cd5","0xd41700c1","0x7f023bc3","0xbdf4153f","0x3efbc6bf","0x513a1c21","0xe77c0f77","0x1d4306e4","0xac433f0f","0xc0140de5","0x150bec0","0x0d02e364","0x47c300db","0xdfd3e043","0xd34c2d13","0x1beff1e","0x10dfd010","0x2cffdf0d","0x2201e32b","0xe43bfff9","0xd91e1d6d","0x110cd010","0x14f3fbf1","0xddfd104c","0x0deec3cf","0x3ce1e21c","0x13f1df0a","0xf3fabfd9","0xd9edff5f","0xd2107e00","0x7d22ab2","0xddfffe11","0x0d2015de","0x0e12f330","0x32fe9","0x3f1ff21f","0x39feee50","0x222e42e2","0x0e00ffe1","0x31300e0b","0x15314eed","0x33ec41df","0x11f2dfe3","0xfb445402","0x13b031fc","0xce2e9334","0x5d1e210d","0xc041dede","0xd6f3edf1","0x21cf23ed","0x2515b3ef","0xffbe311c","0x12e2e309","0xab3fb317","0x10cf0fe0","0xffffd00f","0xd21102fe","0xf1ecd220","0xe341110f","0xe0f00232","0x6f3edf1f","0xdb3023c0","0x10f4d020","0x102df13f","0xf4d1d4d1","0x3401eb0e","0x51033f52","0xee23cf1e","0x2d03ff15","0x1d0d4020","0xb1cf01fe","0x4a1c21de","0x42fef0f","0x102129f5","0xf2122f41","0xc060f040","0xbee2f016","0xf2fe2cf0","0xf2ffdd03","0x175e07fb","0xe5fd041f","0xb6c10c1e","0xced41d0f","0x0f3d1ddd","0xde10e12f","0x0c6d2dff","0xb21dd2dd","0x3b141f07","0x99f404e2","0x0f1e1dd3","0x0f902ef0","0x0c326fdf","0x3fdfd0d2","0x13271e0e","0x103b0eeb","0x0bf4bd36","0xfe973010","0xd4a2bfef","0x1b202105","0x220b3de0","0x3fbe62f5","0x3b4fbd93","0x491ad100","0xfefbea19","0x531dea79","0x09f4e1e","0x340a2df","0x5ebf2cd1","0xfa2e1e5e","0xa0c9f1d3","0x90020414"},
{"0xefce32db","0x320df03d","0x61d1061c","0x11104de","0x3ec3f02e","0x0d247d1","0xed2f22ee","0xfc1001d0","0xe4de4612","0xf2eefe12","0xe2f313c0","0x4e21ddf5","0x0de2d143","0x79f0ff1","0x4204f0fc","0xfc1af541","0x25e22d0","0xe1e72e2e","0xa1c340d2","0xce72fdef","0xb412bc7a","0xdddd2c11","0x45a3009c","0x12cdff43","0xe414f311","0xf00f0702","0x7103eb30","0xf013f247","0xf310ff00","0xed191e11","0x102121d2","0x143e1fe4","0xc4d065fa","0x212c47ff","0x74e1dceb","0xf204c4f5","0xf4c0ef32","0xff1ff000","0x6ef352b0","0x55fd00f5","0x1e0f4cf","0x554e13ba","0x40d1090b","0xcb00ce21","0xd0aef0f0","0xe0b22f41","0xbdee24cf","0x0fe12d15","0x23202ed1","0x0f1013e5","0x401d41b1","0x2101f0f7","0x10301031","0x3f332015","0x30e1d3ef","0xde20d102","0x30c1df1","0x1eed1204","0x103e30e0","0x23e03fe3","0x34123ee","0x13211bf4","0x3f01e4dd","0xfb11d0d1","0x30f1cf14","0x2ede5e5","0x1b1c2e0c","0x220ffd32","0x33054ff","0x73f10e2","0x3e16030d","0x2e0ffd3f","0x1330f690","0xdcd104f3","0xa103d2ce","0x21201d2c","0x93302320","0xe95aec2d","0x3eeeee40","0x6d1ebb2f","0xe23ff7f0","0x20a4e102","0x90221eba","0x101f0a09","0x9133250a","0xea0b1ded","0x30ffff3d","0x71fbad73","0x2c0aff12","0xddc11323","0xb031efad","0x14efc1b","0xcd203291","0x0f0d1b0b","0x12b1de2d","0xfff0da21","0xd1331b3d","0x1dcded3d","0xf1d1bd2c","0xe30fded2","0x4ecd1fad","0x2215b15d","0xce0d3fc1","0xcde1ae0f","0x0efe2b00","0x2c1dcf4d","0xd1eedd0d","0x1f1edf0f","0xe3f01fc0","0xbf1db040","0xe00d01e0","0x0fe01fdd","0x3fce2e21","0x1dd0912d","0x19fe1fd","0x3e2ded0b","0xe1f2eeaf","0x1eb3edce","0x0efe21d1","0x1471cf","0xe3fa0c0f","0xf1e03d0c","0x5c011d3","0x30210df3","0x0e54d5e3","0x912bf014","0x5d0c0ff","0x3001e1","0x22f1cbd","0x4dff2d1f","0xc4cf42e0","0xd9043ad1","0x4e43c33f","0x9fea23e6","0xc610b01f","0xf040d412","0xfd3feca0","0x4f4fbd7c","0x41edf23a","0xce04cdd0","0x2cacddff","0x5feff1d1","0xb1e2fe1a","0xd0c6ff0e","0x0befef0","0x4fe0de72","0x1e3aa319","0x2229d10f","0x239100fe","0xc1f01c0f","0x0e20ea19","0x0bc61ff4","0x4193dd5f","0x0ed0dc0e","0x1a69fe01","0x51b97ec0","0xedd50a52","0x3034afe2","0x4c019060","0xebe763c5","0xf1cdfeff","0x3fe1b0d","0x1d1cfd15","0x2bb21fe","0x0e721d42","0x6fe0e1b3","0x2fd0c027","0xdf2720b0","0xf00cf013","0x1003410b","0xd10c00d2","0xf2f42f41","0x2001f3f5","0x4f020a0f","0x0fec011","0x32c30f03","0xadd1f7b3","0xef2d2fb1","0xf46fb2d5","0xd5d7122e","0xcaf3d454","0x41e32dc3","0xd1e1b600","0x50dd4270","0xd02735b3","0x112d1fb4","0x41759344","0x103453f","0xebd30212","0x2fb33d25","0xe243f3f2","0x46cd122e","0x10ef0fdc","0xce9e11de","0xdfefef2f","0xa1f11ede","0x2de0ab02","0x9e104fdd","0xf02df2be","0xd2e2f23e","0xf7fc5cf1","0xf2dd22db","0xef0f013e","0xdc14cd1f","0x141efcf0","0xd04020ce","0x444f01ee","0xefbff021","0x324d1950","0x12ff02ee","0x4c00e260","0xf9e3dd3c","0x61207010","0x4f035111","0x10fdb0f3","0x2c3f12de","0x0e2f1e","0x0f1f201d","0x1e003101","0x14f00df0","0x312321","0xfdeffd10","0x212ff010","0xfdeef104","0xf03d215f","0x2f224130","0x0efcef4d","0xe40ee01c","0x0f001000","0xeece212e","0x21ff021","0xedeed3b0","0xf01e413f","0x1c33e0ef","0x203efd11","0x10200f00","0x12bdf34e","0x1e222f4b","0x2e1e0f4f","0xdf1f10df","0x323e110f","0x41dfcc0f","0x9eb1f4e1","0x2d1df1e1","0xcf05fdee","0xc0ebd05c","0x1c1ffedf","0x20040121","0xf111df1e","0xdb2410b1","0xbb0bffdf","0xcaefe923","0x11d40e14","0x32b6e32a","0x4fdc0e33","0xd22d31b3","0xefe4d1f1","0xc4f1121e","0x404bef54","0x0e0ff031","0x1e4eff45","0x44c5ef1d","0x1e0ff31","0x203b21cf","0x0cfdccfe","0x3fcf1bed","0x30c10e3a","0xa0030001","0xfef2fadd","0xe0e0f3c1","0xee11c0ee","0xc00210fc","0x0ca32aff","0x10ff0f3e","0xe300fe3a","0x2033f00c","0x10b4dbf1","0x5df11103","0xcf1f3def","0x2e03e71","0x4f234ac2","0xff1d1e2d","0xc413e25d","0x12100e","0xe110dd3f","0xed3d01f1","0x0ed1ce2","0xe4cf20f0","0x22d51710","0xc101e1b6","0xe5134dce","0x11d40197","0x0b3707f4","0xf7f991ff","0x0f50fcf2","0xd47ade4e","0x3933a747","0x99f431e5","0x1219a7","0xd121d0a7","0x2d207345","0x7cbbd02","0xd01710d1","0xd47c0ecd","0xdf0fe130","0xee1ff0de","0x100cf11a","0xf021cf03","0x42ef113f","0x3000e130","0xfe4fe0e1","0xff40c2ef","0x2d11495f","0x1df20d0","0xf01452f0","0x24124fb2","0x40d12112","0x0f6012df","0xf1fca002","0x3c4fe0ef","0x2e221b0c","0x20d00fdf","0xf4d03200","0xf626f0de","0x2faf5cdb","0x0f1160b","0xdcbedf06","0xf0fed1fd","0xdf11cce0","0x0fee01ff","0x120ec1d0","0xdf31ffee","0xdebd5e10","0x4f410ffe","0xf1d02101","0xfce5bd13","0x40190f3e","0x31d0edbe","0x421f2ef3","0x1bf22030","0x130f031","0x2334cc52","0xfffd0f0e","0xd000b0fe","0x2a1bd15f","0x6d0df0f","0x1ed01f60","0xfef0225b","0x0e4cf909","0xcf159f0f","0x0e1c0bdf","0x1ccbe","0x7ee1730","0xc710ffd1","0x715eef0","0x791f3ec1","0xf953c504","0x730cefa5","0x1e5a0dee","0xf35c0173","0x4c30fbf2","0xbadd1d10","0xd1100ba1","0x0f0f2d0f","0x1f003bee","0x0c11fa0f","0xf0ee72e1","0xf2cffedd","0xe00dbcce","0x1bcf2b4f","0x51d0fe3","0x1b112e01","0x236301e5","0xed2c40f6","0x320cf1b3","0x5d20050f","0xd1f0ddf9","0x710f0a7c","0xf3a34f33","0xd111ddf0","0x2de11c12","0xae1b0e0d","0xce5df335","0xc023e203"}
},
{{"0xee0fff1e","0x1e1bf124","0x3e1ee23f","0x2fb0cfa1","0x344ee41c","0xed6f2400","0x1303f251","0xc0f100b1","0x0c031000","0xeff01131","0x2e13fe1","0x0fb2cef2","0x36ff051d","0x21022ed3","0xf1e4e450","0xf2fee30f","0x3ddf1140","0xf025233a","0xe0225f01","0xed93cce2","0x3f0e4610","0x71c1ce91","0xede1117d","0x145ee32f","0x1003f001","0x10f0013f","0x2ff1100e","0x0f000100","0xf1022fe1","0xee04dffe","0x1f001131","0xffff0fff","0x1fe0dfd1","0xeef02e71","0x1000e","0xffffd23a","0x0fe131de","0x1fe33e30","0x0ffff2e2","0x2cc10f0f","0x1cd0fa0f","0x22e02021","0x0f2fe311","0xf421f13d","0x11012ec","0xf0100010","0xf1f03120","0xffd20eb3","0x0f15ed4e","0xb3dfe20f","0xf0b0f1ed","0x4002f13f","0x0ef2f0f5","0xfd1ce102","0x1ff12f04","0x22dddfcd","0x110ffc62","0xe00ef45f","0x1dde14ff","0x0fef01fe","0xdf1f1fe2","0x7dfc0113","0x0dd1fe4","0x1fdeecff","0x200f1f73","0x1e30f15e","0x0ed02113","0xdf0021c1","0xfeefff1f","0x7e2f0d23","0xe39c2ef0","0xf102ee24","0x1fdcfa12","0x2111c07f","0x1200bff","0x4f2e0f29","0x20c05f9","0xfc102b41","0x1e2cf0d0","0x0e00eef","0x0f01b6f","0x2cdfc0f1","0xefd0daf0","0x2f111c3c","0x140f11eb","0x0befc4ee","0x0dfa20e0","0xe1a02de3","0x1d010b2f","0x2ce0c200","0x0fd0ee22","0x0f22021e","0x1fedf0e0","0x0b2fd1e4","0x1feb0050","0x0f0fe2d0","0xd301c1ca","0xf1cfc11d","0xd212afa2","0x1120cede","0x49dceff2","0x23c11201","0xfb5043fc","0xdede3ee9","0xc001e02f","0x3dafe7ee","0x52f30dff","0x53135f","0x4ed0ed53","0x1df0036","0xe551425b","0x2df4d1b","0xd0a21e62","0x0bee0de","0x4d10de2f","0xe0ff041e","0x22df3f0e","0xdcd41c10","0xf10fdec0","0x2cceee0c","0xd2db41d0","0xd002f1ee","0x32ef033e","0x312ff1b1","0xb1d4e301","0xad1e4fef","0x21f210e","0xd3314b11","0x11c66dd","0x0ec1fe41","0x10501b4d","0x2220e90","0xf30ff73f","0xf01b23dc","0x20fdffc0","0x0d1c10","0x462f62ef","0x0b962051","0x9a21092e","0x2f1e0ab4","0x10efd63d","0x149af2ea","0x22dcbe00","0xd03eae04","0x2d0f1ef2","0x0eff203d","0x1ff221f","0x0ff00fff","0xf1f21ff2","0x1eef10f0","0x210000f","0x1fed0230","0x0e000f11","0x13c1103f","0x0f0e1f2f","0x1f0c21f","0x0bee11d3","0xed24010e","0x1300ff2f","0xfb0dd421","0x1d0d1ffe","0x10cfef0e","0x1fff1ef","0x11fedf2f","0x101f0ffe","0xdd220200","0x0feeff2e","0x3c2f20fe","0x56e1060e","0x4dfeee0","0x4203e0f","0x70ff0fb7","0xfdfee701","0xe7e1de01","0x201bde10","0xe03fdd41","0x722527f0","0xbb474dd5","0xc4515b97","0x5f7f7b94","0xd9e21772","0x77cb29e7","0x2012edfd","0xd73ceb50","0x30101bce","0xe01e11fe","0xf1e1efe4","0x0f2001f3","0xfffe1e30","0x170eff1d","0x0df3cfdf","0x12120e01","0x0f1f0dd9","0x2fbedf3","0xf3e3f1f2","0x4e0fe5b1","0x1cd509e4","0xdd0f3017","0xfefd24a1","0xa1be0655","0x1392fdd","0x5f5b4ef3","0xe1fbb3ff","0xfe1031ee","0x2e23adef","0xdece7d15","0xfe2e02d2","0xfb4c13e0","0xfdfd30b1","0x6f1f2d1c","0x2fdedffc","0x203ffd0d","0x37aee01c","0xd0d0213f","0x14f022e0","0x2001feb4","0x55d3f625","0x0e0607d1","0x10f20bf1","0x3f020ff0","0xefdf1f00","0x130d1f16","0x727142bd","0x143aefc0","0xbfca0df9","0xf070fa1c","0x1df0d1b","0xff3095b1","0x0e900ef1","0x0d031220","0xaecc74d2","0xd2d61111","0xdf2c2fe1","0xe0bd10cd","0x1102141f","0xf1e1f23f","0x211f0f3","0x1e12e311","0x223332","0x1f000313","0xfedc20e3","0xedb2df01","0xebbbdf5d","0xfbc1ceaf","0xee3c11fe","0xe1c0cfa0","0x1f111034","0xd1ec0fbd","0xf2cd2011","0xe4e0d11d","0xd4390e3f","0xecded2d0","0xee3a2d12","0x131effb4","0x0f502e24","0xc440fe20","0x20202c01","0xdc3e13f6","0xfe5b2401","0x3d1f0203","0xfa3229c1","0x0e2ff0c4","0x1d21323f","0xb55efee5","0x20cffdd","0x211eb1e0","0xedf5d011","0xfa0322e4","0xde4f5dd0","0x0ddd2f11","0x311ac42c","0xf303ffe0","0xf9bbdfe3","0x0beef21b","0x0d1fee2","0x27d202b2","0x4f2c1b1e","0x0c0c0055","0x17bff042","0xe4204021","0xdcab5a11","0x2cbfd10d","0xbfb2d0f1","0x12ffbc00","0xd31c0000","0x0e1ef913","0x20440e9d","0x2130cfe0","0x210df3ff","0xb4b01ff1","0x1251ec52","0x0e0f30d2","0x40101cef","0xbb3e1ddd","0x4efb3dde","0x0e12d2e3","0x1dce0335","0x9002c6fc","0xcffe2cc4","0x22cfffe6","0x2a3d0fe4","0xc17f2605","0x33be34d","0xc72af210","0x0db1a011","0x96f0010d","0xf1113004","0x2ee3eff","0x0c1afc22","0xd0d0e3d0","0x3c3d1121","0xb13f052f","0x23fadadc","0x0eefbe5c","0xf0db1bfd","0x3efee35c","0x140f030b","0x2dc4222e","0xee0c01dd","0x2ca4ef22","0x2293a0d","0x205ddf6f","0x0eeefb22","0x1d0f111b","0xeffffedf","0xfbd02b53","0xeac91fcf","0x1eb50c33","0x101a1b51","0xfd3ede31","0xeef101f4","0x2f00e2ed","0xeebd10fe","0xe91ded2d","0x0fea42b0","0xf1d019e1","0x2ce1d3e","0x0f4c020e","0xe52eff24","0xfcdef2ed","0xf1ffdeef","0xef213f01","0x1c103aa0","0xff116242","0x204f2c2e","0xc264f01c","0xcfc022df","0xfd330cf2","0x0b130d10","0x4ec40df2","0x0d205be6","0xc14d4110","0x262beed","0xe6ef323b","0x1fcff5df","0xbc012021","0x10f2ed5f","0xed2d1e11","0x3d231e13","0x3b0f31e5","0x1c11de0f","0x0dce2e21","0xcfcaf03e","0xf0f20eee","0x13d000dd","0xe00f3fef","0xf1c0f11e","0x0eae1f12","0xcefceffd","0x12ddd0df","0x0aba03d","0x2f0c0e0f","0x1eceaef0","0xce4f1f1e","0x21de232c","0x11b10b00","0x1efef13d","0x1bf1fba","0xd0dce10d","0x22faceee","0x3eedfd10","0x2e3c103e","0x19eb3e1f","0x113f3e1f"},
{"0x12f11df1","0x4ed92024","0x0eeef1df","0x1eeeda1","0x5dd1f3ed","0xc03c4e11","0xf142de4d","0xb0e3bec1","0x0fcef0f0","0x2ebb7f40","0xd1d2fef0","0xe1029ed0","0x60adefe0","0x2135101","0xeed2f35c","0xd2fff1ff","0x1efcf0e3","0x2ef20f5b","0x91f229ce","0xec13a119","0x3d1c0e23","0x30b024f5","0xe9e12f5f","0x0f50030e","0x09ddf92f","0x0e0fd5d","0xff1e0b0d","0x0eff046e","0xe02010e0","0x0ef220f0","0xfea00130","0x1fe01230","0xf7c914ca","0x171dcf7c","0xd090ea4b","0x0e11d00a","0xde2015ad","0xeaec2f31","0x4c69cfd0","0xaa70ce11","0x0fdde721","0xdaf5f503","0x0ee209c1","0x22520e6","0xfb21010f","0x22eaf1f3","0x174c1f7d","0x274bf121","0x33effa05","0x0fd2cf0b","0xd3ce02fa","0x20fdf129","0xe1b1131f","0xfbcdf023","0x1efacf02","0x0c9f1eed","0x33ed0922","0x1db1aa2d","0xcfa0011d","0x112ed019","0x30004c2","0xe9dd2330","0x0ea9fdf3","0xfa94f0fe","0x4efb2973","0xfdd1de4e","0xcbce0144","0xf21edfdc","0xcbed0fe1","0xfa3cb130","0xf0ca2e11","0xa1f1cd21","0x27cf273f","0xd0d3e22f","0xe6004d4f","0xffe0f097","0xdcf6d7d5","0x230d92f5","0xf27af01f","0x2dc93c","0x4a0607e7","0xa9c625f3","0xb2041996","0xf1410e96","0x9a1f7530","0x37a9cce7","0xe057ffec","0x76bfb10","0xed0ffede","0xcde1e0ee","0x1f21efd","0x2ef12110","0xaf0e101e","0x2a5ec200","0x2f2d0e2c","0xf903e001","0xe4d0f4cc","0xe3b0d34a","0xf63fcfff","0x1223ecd","0x129fd3e4","0x21d00","0xcfec441f","0xf10e3d4d","0xd4111ee2","0xfea122fc","0x505f005","0x62006e1d","0x42f32f27","0xec0a10c6","0xc12e426e","0x13c06131","0xef0fff00","0x13b0fde2","0x22ffe52c","0x1efdd03a","0x71ff3ea1","0xa94e2002","0xf2de0001","0x3dc210fd","0xc2ebdd1e","0xd3fecf1c","0x30ddc23d","0x2110f5c0","0xcc04a5d1","0xbd003e1f","0x1feddece","0xc0120c11","0xe5dd1bf0","0xc12fc062","0xfee1deec","0x7dfe31cd","0x613112a","0xec5fea0c","0x1ecebd0e","0x0dff3dd0","0x360c2f22","0x1da2ef5f","0x9ec10a1d","0x3feefa0f","0xe2fff5fe","0x1ecbced9","0x1ebcdd1","0x2c20cd00","0x0c0ee9ff","0xe0fe2f7d","0x1eef000d","0x1f0fe0db","0x101061e1","0x1ce1511f","0xeddec0d1","0x19c0cd10","0xcd39c91d","0x20bd042f","0xde0dba1e","0x33ffdd6b","0x14fb32bc","0x0b10e53b","0x5eed400f","0xdc94cbe2","0x1f19e9df","0x1fccbfec","0x0ce1d4f","0x1feee05a","0x20ebefce","0xdaffc32c","0x0dea5e31","0xfd9540df","0xed01e92f","0x20d0fe3e","0x0fddff3b","0x1e11f01a","0x132fefbf","0x19f01d0f","0xe01d011f","0x0d2e200","0xec370910","0x419fbd5f","0xed0adf1a","0xfce1521a","0xf12ede0a","0xfae1b241","0xc0fffe5d","0xf0e423f1","0xee1019f0","0x2f90cf2b","0x10df110f","0xe1fff13c","0x10ef1c0e","0xf9c1f01b","0xf0fffd1f","0x20f00e0e","0xf1adc20e","0xe301efd1","0x1ffaa314","0x3cee13e5","0x1df6e004","0xd1dc0f17","0x0a0fc152","0x10010723","0x2ccb130d","0x312f2fe4","0x0f3ea424","0xfcf155d0","0x1f22b23e","0xd221f224","0x3cff1f20","0x3d2d11e2","0x0b2d5f1f","0x11232dd2","0x3fbdc4c4","0xed00dfce","0x340d125c","0xf3d1e220","0x5d3d10f","0x22f1efd2","0x75d702d4","0x0ee7de41","0xe1001a97","0x6b216ff2","0xcb203e21","0x2094ac7","0x326192dd","0xff3ac022","0xc2e339a9","0x204dfd59","0x109c4cd2","0xa14fc6a2","0xcecc2d4e","0xf90e3d05","0x9ee9a0fe","0xdf155104","0xe009f931","0xbfbded0b","0x0cebdfa","0xeec0c210","0x300410f","0x4d220121","0x100c0332","0x0f1fef00","0x2de9222f","0x142fe0e1","0x4efde35d","0xcd1312f2","0x4b0e511f","0x42cdfde3","0xf0132d22","0x3f1df09","0xcc0a123e","0xe63fef0c","0x5e0d021d","0xc0c1e34f","0x1d00522d","0x2f900e13","0x1e15e6f","0xf111fe2b","0xcc023f32","0x43e1100","0x433a0540","0xd0d1f151","0x1ce23df0","0x1e9fadd6","0x10033f7f","0xb0c2ee3b","0x25aeedea","0xd016ddb0","0xd3a1ffcd","0x7a020f17","0x4d35fd2","0x0beda5dc","0x4df90205","0xb33fbae5","0xb9cdadb1","0x99d57033","0x1efe1c04","0xe2b1f1c2","0x594342f7","0x75fb909e","0x1fde9d43","0xb1295fed","0x5af5e9c5","0x99900f32","0xb19eeece","0x1bfff0","0x2f0919e2","0x12faaacf","0x40e5a99f","0x103e2dbd","0xe2ee1310","0xe2cffed1","0x4360004b","0x1d0b0fd3","0x40e105dd","0xce3129ee","0x2eef1e2e","0x10011236","0x0cdbe4fd","0x9ae219de","0xc0701ae6","0x6bdb3ab7","0x6b3022c7","0x5720cfa5","0x3def3f2c","0xcb196100","0x2ceef0ef","0xb4d10ed1","0x22e2e02","0x420d2aee","0x2c1c1cb0","0x30e2d0c3","0x3efe3340","0xfd2d61ce","0xf3e1e311","0xed111fb2","0xf31d02a2","0xf4e320a7","0x3e76f322","0xe7fad000","0x27d61270","0xf45b1ff0","0x2ea4d4f7","0xa99f11e7","0xff012eef","0x40e10ed1","0x0b3e1d41","0x471c9dff","0x54273bd2","0x227b2fd0","0xe025e50d","0x1ecff1d3","0xe145f02e","0x0c61ff02","0x3fabff2c","0x3b21113f","0xf0615e9b","0x21dff023","0x4defd30","0x1031f10e","0x104ea12f","0x2cc91edf","0xe3321c21","0xdee213e2","0x4d55eb91","0x0e27334","0x72021a51","0xde1142a2","0x311013ae","0x5fd16cd1","0xee574952","0x22e103c4","0x5c56f3c5","0xef2e10f5","0x1e32beb0","0x3f2032cd","0x110306c0","0xeed3fc4d","0xf1426c5d","0xf00ce104","0x4ff70605","0x5e422ad2","0xe7e132f0","0x15e014f1","0x3de1101e","0x13f132d0","0x41cf3df5","0xe43de3f2","0x716e01c0","0x0f60fe22","0x341025bb","0xe047c2c3","0x50e6ddd1","0x326751f3","0x1fb41d65","0x32cbb414","0x57fe42d1","0xa321f003","0xddef230e","0xf00dee1e","0x22e9f00","0x37f0e200","0x4e00fd42","0x32ffc2fe","0xcef02f16","0x1013ee1c"},
{"0x3c2e0235","0x2eec2d31","0x1efd36ff","0xd1e0fe90","0x4d1202ff","0xf052ff11","0xf210fffc","0xc1d1e1e0","0x2c20e1df","0x0fa0311e","0x2312331b","0xefd4bdb1","0x504f0223","0x24100142","0xdd10e25e","0xd2f11d10","0x3c33e2ff","0x2111f3e1","0xd3505d40","0x2e0400d1","0x1a70ff26","0x32bcf0e4","0xeca3317e","0x146e1401","0xec31eff0","0x1010f2fc","0xdf121010","0xf100016e","0x11230ce1","0xeff100f1","0x0e121222","0x2ff001fc","0xe6ccd30e","0x36e0ec4e","0x32eeef39","0x2f0df3db","0xffd0e79c","0x0c002ff0","0xdd0f20f0","0xfb12d072","0x10f0d4f0","0xeae31cc6","0xff700aa5","0x2e2e6fd5","0xe933f542","0x340cf0e3","0x113efe3b","0xd01f204f","0x20f1f44c","0xb432952d","0x16d0013d","0xfe0ed497","0x0d25f211","0xc7a9c3d1","0x1d6df125","0x151ede19","0x31be0537","0xbce0b710","0x25acdf20","0x220cd4b3","0xd9d136f2","0x17a9bbb7","0x3247fe05","0x2770eafc","0x0df1141c","0xdb31d01f","0x30220b7f","0xfe20c00d","0x1a0df12c","0x7aecf30f","0x10f34d92","0x10f2ab01","0x1feb2afe","0x300ff07e","0x210d2e1e","0xce10f4dc","0x1f2af7bb","0xf6312c02","0xfec120f0","0x5bd1ff2c","0x2ff31d0a","0x1dff20e2","0x101dd9d5","0xefe3f5ed","0xe12e061c","0xf7dead26","0xe10bddfe","0x3aa11b00","0xfced1e1f","0x0d10bdec","0x201e000e","0x1100133d","0xff01104e","0xfaffd231","0x10fd1f2c","0xf0f0f001","0xeec09caf","0x0ba29539","0xcfc9eb2d","0x123d13ff","0x4ccadce7","0x3fd153f1","0xfd0e34ff","0xe2d2edb0","0x12efcdd1","0x19edf0d","0xff5dcd25","0xf01c143e","0x0f110dc3","0x21ed402e","0xdce14f17","0xdf021abe","0xdedfcf10","0x1dc0fdf0","0x0d1ea35f","0xde0ff213","0x1f0fd0a0","0xe15b0fed","0x11d2b313","0xdef11ab2","0x0dde0de1","0x3dddef0","0x1fefb61f","0x1f0ff4ef","0xfdd4f1e2","0xce1043ef","0xeeffccec","0xec0ee0f0","0xc2ff5ecf","0xe31fee10","0x1fd1230e","0x5d4124ef","0xe1f1f42c","0xcc62530e","0x3ffeccdf","0xcf1f3dde","0xe40f24f1","0x2fef01e3","0xdcc10dfd","0x7ee06de1","0x23e137f1","0x1111bfcb","0x30ef915e","0x5ff01eff","0xd5fe12fc","0x3310004c","0xfff3013e","0xf112120c","0xe22e04f0","0xef0f0d2f","0x1c2ef0f0","0xfc41ce1f","0x37f477f0","0xcff707e3","0xe2d74bc4","0x33352fc4","0xfc131322","0x74f91ae6","0x777b1d7d","0x276aad4e","0xfce2fff4","0x197503d2","0xe0d41cd1","0x2151e0b2","0x0e0b2cf2","0xd6ec3fe3","0x144ffff","0xf55120e0","0xfe11fef2","0x1f02cf0","0x2ff10e","0x2100100e","0x1010efd2","0x192e0200","0xe100112f","0x10fe200e","0x0f0ffb01","0x22fffd74","0x0f0e0f1f","0x12ff2e1e","0xf111efe1","0xe933120f","0xef1e2120","0x2ff0f3f0","0x1efe1efd","0x1f00d3f","0xe00e020f","0xf1000f1e","0xff0ee1ff","0xda02320d","0x0f30e01","0x3fff21e1","0xb22dfe2e","0xc2d0fdae","0xb0cb9f2c","0xce2ed322","0x2be6bfe1","0xdfa2303d","0xca4ad404","0xffce17d9","0xf21cfd5d","0xffed2f9f","0xdedf9d0c","0x0fffe60e","0x22e4bbfd","0xb0f4f12e","0x3c2beec3","0xf0bd27ae","0xdf0f1d41","0x1e221f93","0x31c09ed0","0x222010ef","0x3340dd1e","0xc63021f4","0x120ee2e0","0xd2a0dfcf","0x4205f0e4","0x3234f111","0xfd00d032","0x1c213c11","0xd05011e0","0x201e10f6","0x2203f20f","0x23f0e4de","0xd0201e0d","0x412cff3a","0x219fb24f","0xbffff3ed","0x1ef0e12e","0x0ee1f11e","0xcd000f4e","0xfdf31f0f","0xb02e2ff2","0x0e01ef1","0x21dd310","0x110e0fe","0xfef11212","0x1e01e21e","0xeff3fe32","0x23ee112e","0xfc4db014","0x0efdcacf","0x32dea021","0xd0e32122","0x092e19f1","0x3ecfcce6","0xe2aebf3b","0xcea2cc2b","0xfc0bfd40","0xe0aefdfb","0x21e00df0","0xced1332f","0x2cde2ac1","0x3ee00fe2","0xd13aef5b","0xbe4e020d","0xef0d1b63","0xf11dd1df","0x1df00fef","0xeb0d1330","0xeaf53ad0","0x5ede0fb5","0x4cd0403a","0xee4c242c","0x4dc0fe03","0x21dcd214","0x1e1ef12b","0x11eee04b","0x10e0102","0x0d236310","0x2f11311c","0x0e03ef12","0x0fff2df0","0x61edfb14","0xf15ebcf1","0xe3f1fefd","0x1d6bdf3f","0xe240521e","0x20fddf0d","0xe0d34611","0x0f536efd","0x6311ff04","0x0ffeba1","0x131221ed","0x0f11ea0f","0xd4f1490f","0xfcec9ed0","0x11f563f4","0x0a0d1ff3","0x1ace003e","0x120ae20","0xb00f0a1a","0xe401f109","0x1fe019d1","0x1fcfd101","0x2d0213f1","0xfdde0212","0x4ad2fe3d","0x1e4ce2fd","0x1b00db4e","0xf3f0feec","0x1f12f90e","0x10d2d410","0x2e1f3116","0xf0de02ee","0x3f05fe2f","0x3f6c01e2","0x4e20dd10","0x11e30eb0","0x4be0f102","0x2efef35f","0xf2d02b32","0xccdbef1d","0xf04070d0","0xf04f0114","0xd0e20d94","0x5e22f435","0x47f0c69e","0x3bf2fff1","0xdeed10ef","0x3b1722c4","0xdffe5b07","0x3dc3e0e","0x30220ed","0x2f4d3a22","0x93fc9dda","0x3ed5cfa2","0xfd3371ed","0x1e23f202","0xf3f1bfa3","0xe0dd210e","0x2e10022f","0xe10f002e","0xfe2de10f","0x1f03bfec","0x5fa00b02","0x1d00de3e","0x390e6d3f","0x3b05ce1d","0xeed1f00c","0x160d30ab","0xa2af3c0f","0x13415bce","0x1db1e110","0x2dd2dd11","0xdfce5c13","0x5140bf00","0xdfd2112f","0x30c4f0c","0xa602df2e","0x0d643ffd","0x0eb2c93f","0x1fe3e111","0xbdf1f2ed","0x2d5912d","0x9ed5fd40","0xe1114d2b","0xb10fbe1e","0x1f463fb2","0xe0d3cc24","0x54ee2f9f","0xf3e4ff13","0x2c11230d","0x64221f4d","0x11cc312e","0xf0eef0fe","0x51bfc324","0x2a01d0d6","0x20f441bd","0x1331ec22","0x43d0a011","0x142f70e5","0xfdb0e171","0xe2f3b2e3","0xb3dbc03f","0xb1c10e11","0xdfcf42dd","0xfbff1051","0x0f2c9f10","0x7f1c3c1","0xe0fff35d","0x13f1ed00","0xff0f0e3e","0x10f1fd1b"}
}
};
const ap_int<11> conv_3_inc_new[4][16]=
{{"0x2b3","0x259","0x205","0x31f","0x1d4","0x320","0x1d3","0x291","0x2b7","0x2ce","0x2c6","0x234","0x227","0x229","0x2b2","0x292"},
{"0x1d2","0x256","0x2ba","0x272","0x2a5","0x2ea","0x3a4","0x269","0x251","0x253","0x200","0x21d","0x25a","0x24c","0x217","0x303"},
{"0x1ed","0x2e2","0x1d0","0x2e6","0x2b8","0x2fc","0x29c","0x274","0x2cc","0x208","0x22a","0x1b4","0x25a","0x2e0","0x227","0x265"},
{"0x2f6","0x253","0x2b7","0x2ae","0x2e9","0x341","0x25f","0x2a1","0x2f5","0x232","0x29f","0x287","0x213","0x236","0x219","0x228"}
};
const ap_int<20> conv_3_bias_new[4][16]=
{{"0x1ea51","-0x229be","0x28e0b","-0x276c7","0x2368d","-0x2030d","-0x6ba","-0x1466e","-0x1e58f","-0x2a339","-0x2e29f","0x1315e","-0x15c60","-0x1422c","-0x195f4","-0xdef6"},
{"0x13a4e","-0x4e5bf","-0x32bee","-0x1205b","0x0e61b","-0xc03e","-0x2156e","0x16530","0x0b989","0x0f0ef","-0x24c29","-0x136b4","0x6d2","0x0abc6","-0x22ca6","-0x1cc95"},
{"0x16898","0x4cc71","0x21608","0x1ccaa","0x4ee8","-0x4b3de","-0x30cf","0x3e56","0x1c2c1","-0x30a57","0x274d5","0x0cab0","-0x5ae0","0x0b761","0x3dc4e","-0x3e64a"},
{"-0x36398","-0x37361","-0x2fc10","-0x16aa4","0x44f6","-0x31830","-0x1ec0b","-0x1def7","0x52493","-0x13556","0x2a540","-0xea6e","0x1af1","0x0b2c1","0x0b6b4","-0xc64e"}
};
const ap_uint<16>conv_4_w_new[2][3][1536]=
{{{"0x94da","0xeccd","0x39dd","0x1ed5","0xc332","0xfbe2","0x1f11","0x1b6b","0xdb90","0x31e9","0x753e","0xaeeb","0x2d0d","0xafaf","0xe079","0x5bf4","0xad09","0xdee2","0x2f2f","0x5da6","0xd25e","0xb0b3","0xe3b2","0x11c0","0xf9c1","0x311f","0x5014","0xa343","0xec49","0x9dc4","0x47ef","0x39e0","0x23f0","0x2203","0xdde0","0x7ee7","0x2f5f","0xb2d1","0xe0e1","0xe4e1","0x19d0","0x1020","0x6240","0xa24e","0xc0e9","0x91b1","0x12f1","0x9959","0x0b14","0xddee","0x1c5f","0x40e","0x29e0","0x5feb","0x3cef","0x3dbb","0x1dcc","0xfd0f","0xcade","0xb0f0","0x0f4e","0xcb60","0xb1d0","0xe013","0xee27","0x9adf","0x392f","0x4ff","0xec15","0x0ed0","0xfefe","0xfdec","0xf2ef","0xcd4c","0xe41e","0xe0b0","0x100","0xfef6","0x5ffc","0xbfff","0xfe0a","0xeab1","0xc9ee","0x0c3f","0x6b10","0x0ceb","0xf3d2","0x095d","0xc4a3","0xe0fe","0xd03f","0xcd32","0x6a0a","0xfe31","0x1ed5","0x0db","0x325f","0xbc0d","0x5ede","0x21e2","0xf124","0x1f1","0xd30d","0xe20c","0x0f2f","0xf0f3","0x1fb2","0x1f1c","0x0b32","0x220d","0x2dc7","0x1e4e","0x7e6d","0x90cd","0x3f9f","0x9de4","0xc123","0xe514","0x1f3a","0x31f1","0x612f","0x0c11","0x0db9","0x9be1","0xd061","0x92e0","0x3eae","0xdb36","0x4001","0xecc4","0x1df0","0x90f1","0x12d0","0xe6bc","0x1490","0x210","0x4121","0x1ff0","0xc092","0x9001","0xea27","0xc4c3","0x5212","0xe911","0xe157","0x2efb","0xf3f2","0xde1e","0x4fa6","0xe220","0x2dc0","0x1b5e","0x0a13","0x2105","0x5c16","0x4fff","0x0e26","0x432a","0xff02","0xd10c","0xf006","0x33d0","0x0ffb","0x2cd3","0x6c33","0xf023","0x1a14","0x2a1e","0x7c30","0x1e42","0xddd0","0x42a1","0xefd0","0x4f97","0x0c1c","0x74f1","0xecd9","0xffb6","0x1fb","0x5f11","0x401","0xddc7","0x93e3","0x1f1a","0xf3fc","0x1a4e","0xc2fc","0x5e9","0xce00","0xe590","0xc4cd","0x14e4","0x2f3c","0x9f0f","0x12df","0x2c41","0x1e35","0xee0f","0x301e","0xa3ad","0x0b3","0xd2fd","0x50d7","0x64ff","0x1f02","0x22a","0x0b12","0xfc0d","0xf30c","0x73b1","0xf24d","0x7412","0x51fe","0x2c9","0x31ef","0x2ee1","0xdd32","0xa31c","0x0dc6","0x2eff","0xead3","0x0f7","0x709f","0x4c32","0x1e2f","0x9cd9","0xc23f","0xf351","0x1d4","0xdddb","0xdfb3","0xdfec","0x0e23","0x1f12","0x2577","0x59b0","0x121d","0x11c3","0x1ebe","0x22e","0xd0cb","0xd51b","0x0fbf","0xf3ab","0x133e","0xd3ff","0x0d0c","0xe041","0x902c","0xdc01","0x1c0e","0x0b2f","0x1d3f","0x14fd","0x2b01","0x3016","0x1311","0xce12","0x130d","0x0c1","0x321e","0x0e9c","0x1c3d","0x0940","0x100e","0xef09","0x32f3","0xd0eb","0xc03b","0x3f","0x0c4d","0x2034","0x1fc1","0xd20e","0xfe09","0x0dde","0x6065","0x9d9f","0xdbcb","0xdc0f","0xf5cd","0xe111","0x2f13","0xbfdd","0x2021","0xdfa9","0xf01e","0xe2eb","0xc313","0xfcfc","0xa042","0x1903","0x91f0","0x3610","0xf1ec","0x4246","0x3ee1","0xec30","0xa035","0x152d","0xf20f","0x0a0b","0x91b4","0x31a0","0xf64f","0x753e","0xd2f4","0xdd35","0x20d0","0xf7a0","0x314f","0x239e","0x3141","0x247b","0x93bd","0xf622","0x0f2d","0xb20c","0xa1c5","0x4ec1","0x0f0a","0x30ee","0xfa1d","0x2500","0x6cfc","0xa2b0","0xd4df","0x3702","0xac11","0xd2e9","0xf32e","0x5005","0x2feb","0x0ced","0xe4a7","0xc2a3","0xefe3","0x5e","0xd53d","0xe9de","0xd91b","0x3114","0x2c0","0xf111","0x52fa","0xd343","0x112f","0xb2ef","0x9eaa","0x4f4e","0xe3ed","0xdbe0","0x41fe","0xc4cf","0xe3c0","0xdcf0","0x3a39","0x332c","0xe29b","0xff2c","0x5ef","0xf1de","0xf410","0xf40b","0xcff4","0x532","0xd1e3","0x512","0x5f61","0x266","0x2ecc","0x410c","0xf073","0x132","0xc611","0x1b07","0x240","0x4303","0xd2f4","0x94de","0x7242","0xe6ee","0xf051","0x0e","0x3002","0x35d1","0x1a3d","0xf2a1","0x220d","0xe156","0xc31e","0xc1ed","0xf7db","0xce30","0xe1ed","0xc3fe","0xadec","0xecfd","0x2490","0xd100","0x22ce","0x5dcc","0x215b","0xafc2","0x159d","0xdc37","0x0fdb","0x16e5","0xd60d","0xd0e1","0x74d","0xf61e","0xc321","0x7d91","0x19b0","0xb401","0xdf4f","0x5f30","0xc6df","0xf610","0x2224","0x0d32","0xff03","0xe113","0x9100","0xffb4","0x5fcc","0x1e22","0xef06","0x2cf4","0x3df1","0xf5dd","0xe33d","0x1cd","0x1c52","0x2e13","0x12f3","0x0fd9","0x731b","0xbe2e","0xcd7f","0xcfb3","0xfff1","0x113b","0xee31","0xfe75","0x2ee","0x0ebd","0x0ef2","0xa191","0x61df","0xf021","0x20f1","0xbead","0xb4eb","0xf2fe","0x09de","0x09d3","0x716d","0xc020","0xdf36","0xe020","0x92df","0xa192","0xd030","0x4100","0xb5fe","0xea3d","0xe9d2","0xe3bc","0x319","0xee0d","0x20d1","0x9c13","0x74c4","0x413e","0xece7","0xff43","0x9430","0xbcaf","0x117","0x4429","0x25","0xad10","0xfbbe","0x224a","0x40eb","0x0960","0xf523","0x2f","0x9f37","0x1e15","0x4211","0x4f2f","0x5d0b","0x9513","0x1de0","0x7e4d","0x0e13","0x390f","0xd100","0x23b3","0xf0b7","0x9f29","0xd4e2","0x13e3","0x1c4","0x5f1e","0x0e7f","0x323d","0x220a","0x6700","0xfdea","0x91cc","0x1f1c","0x417d","0x1ef3","0x0c61","0xd429","0xe2d5","0x204f","0xaf1f","0x763d","0x50d0","0x1f25","0x0ef0","0xf077","0xfe3c","0x2feb","0x13c0","0xed33","0x1f0","0x2322","0x2dd","0x1f2","0xcfce","0xbfdc","0x0d2e","0x1e21","0xe1cf","0x1cdf","0xefef","0x2091","0x0a21","0xd19d","0x5541","0xd200","0xd0f3","0x31b1","0xd2d0","0xef0f","0xa1ff","0x4ec9","0x2a2c","0x3cf1","0xbf6b","0x9a1f","0x102c","0x17ff","0x0c1d","0x32f4","0x24","0x0e1f","0x6403","0xfebc","0x0f2c","0x14f1","0xcfe4","0x7010","0xfd01","0x2213","0xe3f1","0x5401","0x2216","0x6a54","0x2ee1","0x1fb","0xbde0","0xbd43","0xf13a","0xd344","0xc1ca","0x30ef","0xd3d3","0xccd2","0xb0f2","0xa2e4","0xdf34","0x92f2","0x66e4","0xbdeb","0x2e94","0x63e1","0xdde0","0x3ccc","0xb9e0","0xd713","0x42ad","0xeed0","0xde10","0xa9e3","0xbf4c","0xede2","0xe001","0x9e5b","0xb70e","0xcfde","0x1a0","0xc230","0x3042","0xfdd0","0xf212","0xe22f","0x5393","0xe14f","0x2d42","0xd15c","0xe231","0xffac","0x7f2","0xac79","0x15c","0x23ba","0x549f","0xd600","0x3214","0xd504","0xca05","0xc64d","0x4d","0xed34","0xff46","0x9730","0x2ef2","0xd4cf","0x0de2","0xe233","0x106e","0x1f42","0x3e14","0xf011","0x320a","0x0d32","0x29a4","0x4519","0xfeee","0xf45c","0xfecf","0xd1f0","0xc0f5","0xee20","0x3da6","0xd45a","0x6279","0x2efe","0xb032","0x19cf","0x130e","0xfdb2","0x2def","0x442f","0xf130","0xd04c","0xf5da","0xda21","0xbe2e","0xcfdf","0x47d4","0xdd19","0x452b","0x12","0xdef2","0xce5a","0x31e0","0x4c1b","0x111e","0x1531","0x34a","0x306c","0x470c","0xc359","0xca0e","0xa7dd","0x44f2","0xe014","0x41ee","0xb1cf","0x4acf","0xbce9","0xaccd","0x10cb","0xa13f","0xf20e","0x2d1d","0x25a3","0xfe3e","0x20","0xcbc0","0xc3f1","0x2213","0x1211","0x4003","0x9c17","0x2c04","0xd2f1","0xa1f1","0x303d","0xd001","0xd27a","0x2f39","0x3c3","0xd02d","0x1fe7","0x2f","0x4d72","0x1e2d","0xeecc","0xd120","0xf9f5","0xc531","0x54f1","0xfcec","0xd5fe","0x7f01","0xfeee","0x206e","0x40e5","0xf2f2","0xd122","0xff63","0x21ee","0x1d4f","0xe255","0xd324","0x7016","0xbd7c","0x4d72","0x6e46","0x7ebb","0x5e3","0x544f","0x2611","0xc21d","0xf252","0x351","0xa603","0xf09b","0xc14d","0xedcf","0xb6c6","0x7171","0x0c01","0x5221","0xf90e","0x3f5d","0xf1d1","0xd0d4","0x5722","0xd0d4","0xfa21","0x1024","0x6470","0x3224","0x0dee","0xd199","0xa3ce","0x1e21","0xa12c","0xfc22","0x640f","0x0f20","0xf522","0x2eee","0xe5e5","0x9d70","0xf0bf","0xd350","0x706","0x4ec2","0x3fc5","0x70d1","0xdf02","0x411b","0x2bf3","0xfa6b","0x09a6","0xfa70","0x5e00","0xf44c","0xedf4","0x9f50","0x5ed5","0x2f09","0xd6f3","0xf573","0x7e0a","0x7acf","0x7f07","0x2ff","0x1904","0x2f72","0x5b63","0xec1f","0x1111","0xd35e","0xb13e","0xdf70","0x2d0","0x7ebd","0x1300","0x517d","0x3110","0x10f0","0x4f13","0xdf31","0x2e24","0xcd2a","0xeb32","0xfde1","0xd1b1","0xf0ff","0xdf3b","0xbe41","0x4015","0xd031","0xf2e0","0x5412","0xb24d","0xd313","0x224e","0xed03","0x3a1e","0xd5f1","0x2c","0xb17f","0x9eec","0x20d3","0x9169","0x1b4b","0x4f00","0x0c47","0x5e1","0x5137","0xa336","0xf203","0x3cf","0x9be6","0xe72f","0xf23f","0x2ed","0x3f40","0xd9cf","0x0fd2","0x301e","0xf23d","0x4ef0","0xecf5","0x33","0x1bf0","0x2f97","0xe70d","0xd22f","0x7fee","0x96e7","0xf3f4","0xe9fd","0xf4f0","0x1f01","0xe32f","0xf99e","0xfcea","0xe611","0xc16b","0x9ffa","0xf0b3","0xbf4d","0xd4b2","0x10b","0x0fba","0xdc00","0xeef5","0xdca9","0xe050","0x2143","0x0ef","0x59ac","0xd0e9","0x10c1","0xffef","0x9ffe","0xe2f0","0x2e1c","0x2320","0xf0dc","0x311b","0xfbb0","0x0ae4","0x3230","0x527a","0x14f3","0xe1dd","0xfd2c","0xcec2","0x0f11","0xf250","0x9240","0xbf2f","0xde10","0xef0b","0x0ef1","0x2670","0xffb0","0xdf01","0xdde1","0xfd2f","0xf207","0xfb03","0xfe1d","0x0f","0xecfe","0xf49e","0x0e3d","0x4fb","0xa40e","0xf3ee","0xdc4b","0xc205","0xe20d","0x3711","0x3ac2","0x704c","0xb2f5","0xec34","0xe01f","0x2ea2","0x143","0xd0d5","0xed3b","0xf043","0x942e","0xcee1","0xa00c","0xefd6","0x91ef","0xb34e","0x1eec","0xa933","0xdfb2","0xf22a","0x5222","0xedc3","0x3d33","0x3bed","0x2e2b","0x9f3d","0xd31d","0xac4d","0xf0df","0x3f9a","0x95b0","0x20b","0xe314","0x1023","0x3403","0xe157","0x2fc3","0x0e02","0xdfef","0xe3ce","0x0fcf","0x4f1d","0xe034","0xb3df","0x7f11","0x44c","0xded0","0xfd1b","0xfd07","0xf295","0x7400","0xf37c","0xedcf","0x997e","0x5df6","0xf39e","0x1f4","0x239f","0xf1f0","0x391e","0xb00b","0xc279","0xb1ec","0x13ed","0x10f3","0xb351","0x7201","0xe10f","0xfec5","0x9a71","0x52d6","0x3f31","0x125d","0xf31b","0xeff1","0xe9f1","0x6d4f","0xff3f","0x10f0","0x23eb","0xeff2","0x5fce","0xac4d","0x9d93","0x1ca4","0x3050","0x6c04","0xd000","0x3032","0xf1c0","0x1ffd","0x1000","0xd2e5","0x12f","0x3be4","0xf6fd","0x2cd2","0xed70","0x7d5f","0xcf1f","0x1917","0xe10f","0x3c2","0x2ff1","0x2e30","0xb25e","0x724f","0x3ffe","0x2fc1","0x1f77","0x7ede","0x414b","0xc1c0","0xef9f","0x214f","0xd111","0xfded","0xfddc","0xe211","0xf12d","0xdeec","0xff00","0xff40","0xc932","0x7155","0xe0c7","0x2fbf","0xe4b1","0x2e2b","0x0bd1","0x3edf","0x1f4c","0x0ce1","0x10de","0xff09","0xe0f0","0x50fe","0x2e02","0x200e","0x3bfe","0x212c","0x24c0","0xc022","0xeef9","0xbff0","0x2fee","0x2e2e","0x1e43","0x3bee","0x920f","0x1b2b","0xaea2","0x5012","0xde15","0xa0cc","0xd240","0xd0aa","0x2f99","0x414e","0x1fd0","0xb43f","0xfe1d","0x11cd","0x133c","0xd1ca","0x0dbf","0xb2e1","0xcd13","0x91c4","0xe21f","0x0f0b","0xe002","0x20b9","0x2ee1","0xe930","0x4bc1","0xe00d","0xfffe","0xdd02","0x331f","0xfdcb","0xb1de","0xd3ed","0x3efa","0x9b1f","0x0df","0xa1ce","0x4f07","0xcdeb","0x210f","0x2b20","0x0c00","0xbfcb","0xe112","0x3c03","0x50ef","0xdd3b","0x9feb","0xd0f0","0x4d3e","0xaf4e","0x2c3e","0x12f2","0x540c","0xa11f","0xe1e1","0xc040","0xe2ad","0xbffd","0xe214","0xcef3","0x3301","0xae2b","0xd1ee","0xd1ee","0x3f4","0xde6c","0x31fe","0x130c","0x100e","0xc00d","0x25","0x0e1d","0xf0e1","0xf4c6","0xe2cf","0xbbf1","0x1c6a","0xb427","0xe61e","0x3c45","0x3240","0x41e1","0x1f67","0x1e57","0xf03d","0xffde","0x50c3","0x10e2","0x1fd9","0x13ec","0xe307","0x12","0x4df0","0xe50c","0xff5f","0x2b3","0xfd70","0x2041","0x2200","0xde04","0xbeec","0xfa3d","0xe39d","0xda2e","0x53bd","0x0e00","0x13e","0xfeec","0x53e2","0xe372","0xb7d0","0x113e","0x1fe1","0x2144","0x31ef","0xd243","0x30df","0xb219","0xc427","0xfe0e","0xcee0","0x09b3","0xd25f","0x10fc","0x2da9","0x2e1","0x0ec1","0x1f3d","0x9e9c","0xdfe1","0x3f20","0x9d0b","0xaf6f","0xed0a","0xfdb3","0x9c21","0x2b1f","0xddf0","0xd1cb","0xe4f3","0x2f99","0x300b","0x0e11","0x2b01","0xa4f4","0x40d5","0xed1f","0x0b12","0x30e3","0x644e","0x0ed3","0xc023","0xebef","0xe4ec","0x92e9","0xf2de","0xfdfb","0xee12","0x1a4f","0x0b15","0xd1a1","0x0f0e","0xea03","0x0fe4","0xd1f0","0x5e1b","0xeeb1","0xef05","0x30f5","0xdf7f","0x40dd","0x42ed","0x114f","0xd017","0x2dd","0x0e11","0x2fee","0xf00e","0x1c14","0x1014","0x130d","0x14","0x470","0xc23d","0xe2ee","0xbdcf","0xff10","0x9eef","0x1fb4","0x0cf1","0x729e","0xfc4d","0x7c1c","0x4b21","0x2734","0x5e39","0xf017","0xe1ed","0x1c94","0x2c3d","0xcbc5","0x91bf","0x1490","0x9cdf","0xe10e","0xbf39","0x90ac","0xcd0b","0xf230","0xda0f","0x31e","0x11d2","0xb330","0x2301","0x3ed1","0x2fd","0x1c2d","0x440","0x3f2f","0x13d1","0x9150","0x0de5","0x23e","0xb3ef","0xd30f","0x0ec3","0x2f0c","0xc921","0xf44f","0x63cf","0x710f","0x0d2","0x1e99","0xd6c2","0x14e3","0x6152","0xe292","0xfdd2","0xa275","0xebbf","0xef7d","0x2f70","0x5e22","0x0b","0x2214","0xf200","0x11a","0x6ec4","0x7ba4","0xe4d1","0x4e12","0x29c4","0xdfd3","0x91bd","0xb13c","0xfbab","0xfdca","0xfbcc","0x3f3f","0x0fc1","0xf134","0xbfbf","0x321d","0x3d0","0xc239","0x3200","0x4c02","0x9a0e","0x4f13","0x3c04","0xf64e","0x5fab","0x30b0","0x10c5","0xd249","0xe63e","0xcfb4","0xfeae","0xe0d0","0x4d0b","0x9c7f","0x6074","0x322f","0x9fdf","0x925f","0x4151","0xc05e","0x7bd6","0x5ffd","0xbed7","0x2509","0xd73f","0xad15","0xd0ad","0xd33e","0xfaee","0xb037","0x4e2d","0x15b","0x7230","0xbdfd","0xdeba","0x2e7c","0x5e20","0xdee9","0xd20f","0xd312","0x0e3f","0x4ed3","0x7c02","0xccef","0x49d2","0x3f9f","0xcf11","0xf1e2","0xfc12","0xd420","0x25d4","0x190d","0xd2cd","0x1436","0x5ff4","0xc40f","0x141","0x245f","0xedfd","0xc0be","0xe521","0xe2ce","0xcdf3","0x40d","0xccef","0xf2ff","0x4215","0xbb0c","0x219d","0xd239","0x2002","0x12ef","0x0d20","0x7a49","0x1023","0xd10f","0x1c2f","0x0cc0","0xdf2e","0x730b","0xb31f","0xfe13","0x2dcb","0x0fff","0xd23e","0x110f","0xf60f","0x14f1","0x2f7e","0x3d1f","0xce04","0x31f1","0x0efd","0xceed","0x2c0","0x1a51","0x2e1f","0x5470","0x9056","0x202f","0xf2db","0x4e0b","0x2ed","0x11ee","0x40f2","0xcfdf","0xabd9","0xf1e9","0x7a2e","0xcaf7","0xfaf1","0x4dfb","0x5b02","0x3ed3","0x0ebe","0x1cf1","0x0cbb","0x4e9a","0x124b","0x3a1a","0x1909","0x0f10","0x3b0e","0x325b","0x3033","0xcd52","0x2e1c","0x13f2","0x1daf","0xa3c3","0xbac0","0x0bfe","0x2ff9","0x509d","0x2c1d","0x1070","0x2900","0xf3fe","0xdc40","0x264c","0x31d6","0x1435","0x110","0xe40d","0xf929","0x2cc6","0x20f2","0xff1f","0x23b2","0xb6fa","0x2039","0x12fd","0x71e5","0x63eb","0x3f10","0x13d9","0x0d1","0x12cb","0xd313","0x1e25","0x302","0x3d2f","0xdd0e","0xc2e3","0x0df3","0x1411","0x1d4c","0x3fb0","0xc2ab","0x100f","0x1f3c","0xcfb0","0x12b2","0x17eb","0xfe20","0x2","0x3f1","0x1e22","0xd212","0xf411","0x1a32","0x40e2","0x2ce4","0x9fd3","0xe299","0xbb0e","0x230c","0xee9d","0xde35"},
{"0xe33c","0x2e03","0xebe4","0x302e","0xdf34","0x23f2","0x2e3","0x214d","0x4dbd","0x1dec","0xe300","0x932d","0xdcc0","0xb190","0xae2b","0x5ed5","0xff7c","0xc31e","0x91f2","0xb0c5","0xfc6e","0x2cd6","0x1f90","0x2eba","0xd9d1","0xe542","0x4f3e","0xbb55","0xde4f","0x4cf5","0x12af","0x40c5","0xfe3b","0x0fe0","0xce21","0x52fc","0xbe12","0xc123","0xc5c1","0xd4f4","0x3baf","0x1ff","0x530e","0xbfc5","0xd0ce","0xe30f","0x1022","0x911a","0x2d3b","0xd2ec","0x1e0e","0x5710","0xfdc7","0x0ef","0x1ebb","0xf3e1","0xe4cd","0xdd00","0x9d1f","0x233e","0xf0de","0xee1e","0x6de","0x311","0xffe2","0x22e","0x3cff","0xd4ea","0x0d14","0xff40","0x1ddc","0xe34c","0x32e1","0xe126","0xb011","0x13fc","0x0df1","0xe00f","0xf70c","0x140","0xfcef","0x3420","0xfad3","0xed1f","0x5eec","0xeced","0xe1e2","0x0d3d","0x0d1","0x44f0","0x17f2","0x6114","0x3929","0x7e57","0x5621","0x6112","0x2bfd","0xf23a","0x23b4","0xc0f2","0xfc25","0xf412","0xcfcf","0xdf2e","0xe10e","0x41d4","0x1fdc","0xaff0","0xee5e","0x214a","0x32d2","0xa21e","0x1c71","0x7e77","0xc03d","0x2b4e","0x4f7e","0x1ee2","0x10fe","0x30de","0x4e0b","0x0df1","0xf3e4","0x571a","0xf2e6","0x20fc","0x4e0a","0x7e14","0xf114","0xac23","0x12df","0x2b72","0xf1be","0x40fb","0x1dbe","0xbdbf","0x2e10","0xe911","0xffd6","0x2e30","0xb117","0xf347","0x2e5c","0x1a44","0x61b1","0x1063","0xb7e3","0x50a2","0x0b01","0x645","0xcbf4","0x4111","0xe390","0x4d23","0x3ca4","0xd1e9","0xfe22","0x30f","0xefe3","0xde2e","0x2392","0x1d3","0xddcf","0x191e","0x204f","0x3654","0x12f1","0x220f","0xf1ab","0x7140","0xed04","0xbfbb","0x4b4d","0xc0ba","0x12b4","0x7d2d","0xe4bd","0xfeed","0x2e2c","0x099e","0x330","0xd3c2","0x140e","0xd00c","0x352a","0xbe46","0xfbe2","0xa0cc","0x1a01","0xb41d","0x75ac","0xfb3f","0x0d3d","0xf092","0xe21e","0xa300","0x0e32","0x111e","0xda3e","0x5434","0x12e5","0x2eed","0x3304","0xad1b","0xe0f3","0x2333","0xf1dd","0xf3f3","0x2fe2","0x9272","0x7a5","0xad9f","0x106e","0xe554","0xbd0a","0x100","0x3123","0xe5d1","0x63f2","0x205d","0xb37f","0x452f","0xeeff","0xff23","0xcffd","0xbfa0","0x794","0x41f5","0x3515","0x2f05","0xad4c","0x730b","0x1f5f","0x6c0f","0xc4d0","0x3b70","0x1d4c","0x1b23","0xced0","0xf040","0x0fc2","0x92e0","0x4ade","0xf2fd","0x65f4","0xd192","0xc5ec","0xdc5d","0xb19c","0x1bbb","0x4e11","0x09e6","0x24d","0x3111","0x10e","0x31d","0x5df1","0x93a3","0x23ff","0xeff3","0x72ff","0xefcf","0xddef","0xfc0e","0xd49c","0x0bdd","0x1f4f","0x1e20","0xcb5d","0x707f","0x15f0","0x1040","0x4e32","0xd3e1","0x4e1e","0xf235","0x7d50","0xcdf0","0x0c1e","0x10f3","0x219b","0x0efe","0x291d","0xe1ff","0xb214","0x5ed4","0x62f","0x510e","0x9c25","0x31f2","0x9b30","0x2f11","0x9c30","0x221","0x4010","0x127","0x2e05","0x3e1f","0xe2c0","0x4edf","0x312d","0x4f0d","0xf2b2","0x7bd1","0xd6ca","0x2021","0x1531","0x5fcf","0xe0f0","0x1712","0xd3f1","0x53e","0x11","0xe0fc","0xe1d5","0xf752","0x4bb","0x71ed","0xc397","0xd204","0xc44a","0xf22e","0xee32","0x0ee1","0x10e","0xb516","0x331e","0xe144","0xdc7d","0xe619","0xe123","0x52b","0x4c0a","0x0ce0","0x41e6","0xbfaf","0xddd1","0x0d04","0x4f3c","0x1ca1","0xd904","0x417","0xb020","0xff1b","0x1ed9","0xdf5e","0x11ca","0x501c","0xe50f","0xe2ec","0xa5ef","0xbe22","0x3ff1","0x110d","0x0fb0","0xd210","0x5dcc","0xe650","0xcedc","0x31e","0x26da","0x1ed0","0x4400","0x31fc","0xeed2","0xd5c1","0xe430","0xf15d","0x3b3e","0xfd3e","0x0be2","0x23ff","0xd9dc","0x2e00","0xcf1e","0x4a51","0x11df","0x1ebf","0x70dd","0x11ea","0x2b25","0x4123","0xdaf1","0xdfe0","0xf1e5","0x43b","0x3a1e","0x292","0x2fec","0xe1f4","0x30b","0x1020","0x4f0","0x9f40","0xeed3","0xe2ef","0xccba","0xe11b","0x21e3","0xf500","0xc902","0x90f2","0x229b","0x22e2","0x2350","0xff22","0x921d","0x4a62","0xeff9","0xa005","0x4ea2","0x27ab","0x293f","0xc1ec","0x1f1f","0xf72f","0x55de","0x7f70","0x734e","0x2441","0x3053","0xc230","0x7fb3","0x9209","0xae29","0x12e","0x630d","0xc524","0x14ee","0xaeda","0xf259","0x3c12","0x31da","0x2477","0x1f13","0x1c1e","0x203c","0xee1a","0xe112","0x4f1b","0x2fb7","0xe2ef","0xde07","0xb45e","0xde0a","0x912b","0xe433","0x4dc0","0x219","0xefda","0x20e3","0x39ce","0xadb4","0xff91","0xef1c","0xb11c","0x6db0","0xdc33","0xfdf1","0xe00f","0xee41","0x1440","0x91b9","0xa2e2","0xa0ec","0x2cef","0x1f22","0x0b4e","0x92f7","0xf2d3","0x422","0xa2d3","0x73e1","0x24","0xf0af","0x4e25","0x7516","0x6f0e","0xabb9","0x0ec3","0xfbce","0x9e7b","0x6fde","0xee39","0x0ed","0xd047","0xd135","0xfd6d","0xe402","0x13c2","0xb047","0x2e2c","0xede1","0xb206","0xef5e","0xb401","0x49b2","0xbd06","0x7e94","0xbedd","0xff1a","0xba97","0xad5a","0x731a","0x3fbc","0x75ef","0x1dfd","0x124b","0x1d4f","0xb42c","0x2009","0x9be0","0xfa1e","0xdfff","0x29b4","0xd9ed","0xb0c4","0x3f31","0xd32a","0xa312","0x225d","0xbf2d","0x2f0c","0x22ff","0x10bf","0x9221","0x3312","0x9031","0x11c0","0x909d","0x1f31","0xb50e","0xe471","0xd22f","0x4b1e","0xf0fd","0xefbc","0x1603","0xfe24","0xc09e","0x2d0c","0xa00e","0x5d2f","0x0d1a","0x2dc","0x7179","0x0c71","0xcd92","0x103e","0x1ee2","0x3efa","0x9fd6","0x22c9","0x6cdd","0xfc97","0x326d","0xb920","0xf0c2","0xee07","0x3c27","0xff3d","0xbcac","0xdfce","0x5262","0x0e2","0x2f90","0xd302","0x2aff","0x6a1f","0x33d","0xf15f","0x3df2","0x53c2","0x3034","0x12d3","0x52fe","0x215a","0x11ac","0x7164","0x14e","0xe54f","0xdb20","0x424d","0x10fd","0xfb0f","0xbd92","0xb01b","0x3ee2","0xd33a","0x73f4","0xde4a","0x3fe4","0x0f0c","0xf610","0x6e25","0x1fc1","0x0f11","0x6ccb","0x5c40","0x2d0","0x0d1f","0xfed4","0xeeca","0xdcf0","0xe2f9","0x1101","0xb02a","0xf192","0xf2f0","0xf2f3","0x3dc5","0x722","0x311f","0x6daa","0xe2cc","0x249","0xb11c","0xe4e2","0xf0c1","0x3ee4","0xb00d","0x6f05","0x0dcc","0xf5ae","0xf724","0xe011","0x9231","0xcff4","0xec06","0xd1df","0x0e20","0xfef7","0x1541","0x222f","0x4ce1","0xc02d","0x211f","0xf1fa","0xad7f","0xbe11","0x4b5","0x3f2b","0xbcfe","0xbceb","0x09c1","0x57a","0xe4f2","0x1ff7","0xd4cf","0xd321","0xf525","0x327","0x41f5","0x530a","0x2b1b","0xf70f","0xc901","0x10d2","0x6","0xd111","0x601f","0xf6f3","0xeff3","0x1e2c","0xf11e","0x1efa","0xdf00","0x61dd","0xb919","0x5efd","0x3d3e","0x2ed1","0x0f0a","0xdf9c","0x71ee","0xaec1","0x343e","0xff5f","0xd373","0xfc20","0xef62","0xfe2d","0xff2b","0x6fbc","0xc019","0x5109","0xefc4","0x6d0f","0x7faa","0xfdca","0x74bd","0xce92","0x134d","0x2171","0x920f","0xf95f","0x2afe","0x4c0c","0xdd0a","0xb109","0xef2b","0x2daa","0x09f4","0xc142","0x2dc0","0xc1fb","0x20ee","0xc2c0","0x4f7d","0x65f","0xb5df","0x3e22","0x3dde","0xfdff","0xed13","0xbf6b","0xed12","0x41aa","0x0c46","0x1f00","0xe740","0x7262","0xc331","0x9cbf","0xe120","0xdde2","0x6d2c","0x3d00","0x10b7","0xe011","0x2e05","0xd04f","0x0c3f","0x922e","0xe35d","0x9d5f","0x293","0x2","0x1df0","0x7e70","0xe3ee","0x432b","0x9f29","0x9e5e","0xe3d1","0x295a","0xfeb3","0xa209","0x49cf","0xcfe9","0xe003","0x0de5","0xf2ac","0xe141","0xeeee","0xacdf","0xade6","0x1752","0xf112","0x1971","0xd1d2","0x0de","0xa173","0xefbe","0xdbc2","0x9de9","0xa2e2","0x0dde","0xdea2","0x12b4","0x3210","0x53f0","0x2c4d","0x302c","0x6aee","0xff0d","0x1ef2","0x39da","0xf1c4","0x5b27","0xf165","0x4e1f","0x2010","0x33ef","0x0e9f","0x25b9","0xef20","0x2f3d","0x0e2f","0xf009","0xeb94","0x93c9","0x2dbf","0xcf42","0x0ec3","0xeba1","0xa00f","0x1e09","0x9dd9","0x3ff0","0x10cc","0x324c","0xfbdd","0xf1f0","0xd0f2","0xeefd","0xb0b2","0x320e","0x7049","0x9433","0xfe1b","0xbf0e","0xec2d","0xf220","0xf1af","0xcd53","0xafb9","0xdec3","0xf1ed","0xeff2","0x94f4","0x3b0d","0xd30f","0xdb13","0xc0c0","0xfdc3","0x151e","0x9def","0x3c10","0xcef0","0x2fe6","0x0909","0x9d7c","0x0d29","0xcbbc","0x9f3d","0xa3ee","0x3d73","0xb7d3","0xdd7d","0xff2f","0xece2","0xd216","0xcd1f","0x29a0","0xe005","0x4207","0xf0da","0xe5f1","0xfd0b","0x9e2f","0x0ada","0xcb0a","0x2252","0x1301","0x3d55","0xffd7","0x2f21","0xe2f6","0x335","0xeea4","0x211e","0x112c","0xa120","0xf112","0x3d9d","0x53e2","0xc05e","0x22ce","0xfce5","0x3ff9","0xe2bb","0x317d","0xaf9c","0xfcb2","0xcc55","0xde23","0x2220","0x279d","0xeff0","0x2d45","0xe30a","0x3323","0xff11","0xf1a0","0x1ab1","0x2fdd","0x1fdd","0xe007","0x919e","0x4f12","0xb12e","0x1731","0x24fc","0x1fb3","0xdcb3","0x2066","0xef30","0x3f1e","0x52ec","0x62f","0x1f26","0x127d","0x3e63","0x4d55","0x9020","0xdf4e","0x30e1","0x7211","0x2e2","0x236f","0xd1cd","0x2f5","0xf7f3","0x71e9","0x7e35","0x1b25","0x1c3b","0xef11","0x390c","0x32fc","0xde61","0x3251","0xe0f6","0xf3b2","0x1e1d","0xb5f3","0x1a0e","0xe5bb","0xd2cd","0x0fe","0xbfef","0x0e20","0xf02f","0xe0bd","0x2111","0xafec","0x1af1","0x1e03","0xfebe","0xcbbe","0xec9a","0xb34e","0x9000","0xf7d1","0xfeeb","0xbe44","0xfcb2","0x703e","0x1eee","0x6930","0xebdf","0xc34f","0x1ddd","0xc3c4","0xed1c","0xec21","0xffc9","0x1b99","0xe20f","0xf53a","0xed60","0x3ff","0xc2f1","0xc3e0","0x12e4","0xed0f","0x1e3","0xdde1","0x2402","0x1fff","0xdfe2","0xbd2e","0x103e","0xf00d","0xe434","0xe27b","0x6d24","0xf97b","0x703e","0x3e72","0x0fbf","0x79ff","0x90fc","0x91cc","0xecee","0xed79","0x75cf","0x77ae","0x6022","0x2029","0x100c","0xe33e","0x6ed1","0xef3a","0x7dfc","0x1142","0xf1be","0x0e94","0x9f1c","0xb0db","0xf0e1","0xd20a","0xfee2","0xde1d","0x3efe","0xff04","0xe2f1","0xf27f","0x0df4","0x9e7d","0x732f","0x0e66","0xe9c0","0xab41","0x4df2","0xd472","0x14e1","0x1f36","0x100a","0x790f","0x7245","0x1f3e","0x7dd1","0xff10","0x5de2","0x2c0b","0x2f11","0x2213","0x49d7","0x4b01","0xd330","0xadf3","0xfe1c","0x1ace","0xd322","0x12db","0xe10c","0x25d3","0x3e19","0x11f","0xa010","0x12fe","0x7511","0xee07","0xdcc3","0xdfb0","0xff1c","0xec2c","0xfeee","0x112c","0x3243","0xc45e","0x702d","0xef97","0xeef2","0xd134","0x7d79","0xfaef","0xced0","0x225e","0xda07","0x1c5a","0xd06e","0x1fd0","0x14e2","0x30c2","0x791d","0x13f1","0xff13","0xff22","0xf4e2","0x1c9a","0x5122","0x393","0x1d23","0xf1d0","0x32e","0x9037","0x4f0d","0x1f9f","0x796f","0x0dee","0x991e","0xbd2e","0x0ca","0xf499","0x434e","0x20df","0xeb97","0xae7c","0x74bb","0x4251","0xe4e1","0xde17","0x1421","0xbff3","0x9ed4","0xf434","0xe60c","0x0","0x7d9f","0x5f65","0x5d1f","0xfbb7","0xffa3","0x14ad","0xc9d1","0x3d71","0xbeb9","0x212d","0xf0fb","0x21de","0x14ef","0xcd90","0xffb0","0x29f7","0xefbf","0xd02a","0x1b","0x2ba2","0x9ee9","0xedbf","0xde12","0x11f1","0x222c","0x9602","0xa2ee","0x4f62","0xe114","0x1c31","0xe411","0x4dc3","0xdcfb","0xeeb4","0xf311","0x0fcd","0xbee4","0x230d","0xdbf2","0x1300","0x106d","0xd5c2","0xd26f","0xe415","0x9050","0x0c2c","0xe5b1","0x90fe","0x912b","0x4f07","0xfcf1","0x41d0","0xd090","0xa3c0","0x2c1d","0xd1ee","0xd141","0xee02","0x0ac1","0x1ffe","0xffed","0x2141","0xdb3c","0x0c2c","0xe200","0x30c3","0x29ec","0x219","0x3b0","0xc1e4","0xdfe4","0x3f3f","0xd11d","0x1b3d","0xbccd","0x0e04","0xbd1d","0x2a32","0x3a02","0xdaf9","0x2054","0xf3c0","0xb9ed","0xec13","0xf2ca","0xdf01","0xdf13","0x34c0","0xff5e","0xd5ec","0xfc55","0xf5ee","0xdddd","0x20","0x2304","0x60d7","0x4cd0","0x2e63","0xf16e","0x1ef","0xf0b1","0x1f7","0x2c22","0x23f0","0x10f5","0xc20e","0xf6db","0x423d","0xf211","0x40fe","0x0d0","0x5d11","0xb24a","0xe205","0xece3","0x3302","0xa6eb","0xe1b2","0xf324","0x13f1","0x400f","0x0d0e","0xb02a","0x714d","0xdd03","0x21fd","0x6f11","0x13f4","0xc40f","0xc3b1","0xdc03","0xe1d0","0xd71c","0xcecc","0x410","0x1100","0xf3c5","0xe02e","0xdfeb","0x43fb","0xeef0","0xbac1","0x5fe2","0xf09f","0xd0af","0xf4cf","0x20e","0xf29f","0xa092","0x6413","0xc0fd","0x3e23","0xf0b3","0x5d1f","0x0f5","0x3d92","0xfbdd","0x1cd5","0xae15","0xe5fb","0x20d4","0xf0ab","0x122f","0xc17a","0x3c5d","0x106f","0xffbd","0x4130","0x3cb7","0xc34a","0x1ef5","0x6f3d","0x97d4","0x2401","0x773a","0x7b10","0x4d44","0x6073","0x1d2d","0xcfa3","0x9e4c","0x1f91","0xf014","0xe1e1","0x2f5c","0xd50f","0xde2d","0x5e12","0x49e1","0xc110","0x79d1","0x223","0x7dc1","0xfe92","0x521","0xfede","0xf3b4","0x93b2","0x2f00","0xb16e","0xd014","0x1e7a","0x636","0x9ff0","0xded4","0x10db","0x212","0xee6e","0x71c2","0x6dd3","0x23fc","0xe1fa","0xa5fb","0xfef2","0xec4f","0xc2e7","0x53f1","0x72c3","0x21fb","0x1373","0x2f12","0x1142","0x0e27","0xb301","0x7229","0x33db","0x53e3","0x69e0","0xeeb0","0x6ce0","0xfc03","0x3db","0xd2c3","0xf30c","0x2e19","0x6bc9","0xaccf","0x0e4d","0xd01e","0xbc0f","0xf1de","0x30eb","0xaf21","0xd209","0xf070","0x2bc1","0xaba3","0xa1f1","0xf117","0xe7a3","0x3f61","0x1bd4","0x12c2","0xed74","0x231c","0xd0f1","0x6c2f","0x0fa6","0x1e11","0xcf2d","0xefe3","0x2df0","0x4b43","0xde02","0x3671","0xe707","0x0b33","0x3f31","0x7074","0x2033","0xe7d4","0x1eec","0xc5e0","0x5205","0x992b","0x1454","0x0f00","0x2051","0x3fb2","0xdd1f","0xf9e1","0x3f7e","0x430f","0xfe0f","0xa2cd","0x20f4","0x0f10","0x3ef4","0x1f51","0x5219","0xff10","0xee90","0x53bf","0x3f40","0x512f","0x1e44","0xe3f5","0x0fc7","0xe274","0x0fcf","0x6bfc","0xec56","0xe119","0xdc10","0x909f","0xe1d5","0x35f0","0xd1e5","0xff0a","0x0ff","0xc05e","0xf17c","0x0fce","0x0bd9","0x91de","0x22f9","0xaf01","0x50dd","0xa01d","0x0c0c","0xef0d","0xd0ac","0xd930","0x2f11","0xf02e","0xe24e","0xed40","0xd317","0x13c0","0xf04f","0x11d2","0x6e20","0xe473","0x1cee","0xbd20","0x3f0f","0xa0ee","0x23c0","0x5900","0x0df1","0x3102","0x20cb","0x0ddd","0x2052","0xc0c0","0x1e4","0xef11","0xe200","0xfd21","0xcbef","0xff7d","0x0b62","0xd2f9","0xc2f4","0xdb11","0xc701","0x41a1","0x323c","0x1cef","0xf320","0x211","0x24de","0x3e53","0x0c90","0x22e0","0x1265","0xe0ff","0xf136","0x90d1","0x1334","0xdc00","0x5dfc","0xcefa","0x63ff","0x0efe","0x1fd","0x25e","0xd0e0","0xbcec","0x5d91","0x3ef","0xce73","0x0ddd","0x110","0xa43c","0xff3e","0xcc44","0x13ff","0xf2f1","0xf421","0xed2d","0x0fc5","0x1101","0x1d40","0x419f","0xeced","0xcf59","0x13e9","0x552e","0x31eb","0xed3b","0xee19","0xcfe7","0x10ba","0x9790","0xe1e5","0xf263","0x1002","0xb2e4","0xf1c2","0xfdf2","0x2701","0x1133","0x24fe","0x9fef","0x2f00","0xdc0d","0x0feb","0xefef","0x561c","0xe117","0x2001","0xd4e1","0xbf30","0x0b23","0x1ae2","0x1b71","0x41d1","0xfc97","0x922e","0x9e99","0xec11","0x450c","0xdeb3","0xf2f3"},
{"0xa119","0x4c01","0xe922","0x4d00","0x9e0e","0xb2de","0x2c4f","0x5211","0xd9a9","0x200c","0xb209","0x210","0x1e2c","0xd190","0xcb49","0x7ed7","0xed59","0xff1f","0xadc3","0xe1de","0x2ced","0x0b6f","0x1d36","0x24f","0x09af","0x113f","0xc406","0xbf44","0xd12d","0x6e11","0x90b4","0x5fd1","0x4f49","0x3011","0x9c03","0x20d1","0xd906","0xdbf0","0xfc3f","0x43cf","0xebbd","0x141d","0xd7eb","0xc1d5","0xac49","0x3ddd","0xe3c2","0xbfea","0x52c4","0xf73f","0x130d","0x7005","0xeb0f","0xfcd9","0x221f","0xdeee","0x14fd","0xde22","0x4d70","0x121","0x73ae","0x5f1f","0x554e","0xa417","0xbe10","0x50e","0x40fe","0x9225","0xca14","0xcb02","0x1030","0xeecd","0xf00f","0x3af3","0x52c6","0xf323","0x3acf","0xca00","0x4779","0x3f5e","0xbfff","0xf600","0xfe1e","0x5c31","0x0b43","0xbdf5","0xec20","0x1de3","0x2f1","0x3f30","0x4301","0x5cd2","0xc1bb","0x7d41","0x57ab","0x2124","0x0df4","0x0cf","0x3ec3","0xbe12","0x3eff","0x0f04","0xcf2d","0xf00f","0xf1ee","0x0fe1","0x2e9f","0xf00b","0x2dc3","0x32dd","0x64f0","0xef02","0x3e91","0xb499","0x9432","0xdf5d","0xc2f0","0xd222","0x2e0d","0xf11f","0x40ec","0xabf5","0xf3ae","0xec49","0xfc43","0xf02e","0xfeae","0xd1fd","0x2c1f","0x3f30","0xe504","0x0f12","0xdefd","0xfefc","0xae3b","0xf01f","0x4e0b","0xabb4","0x0ea3","0xe52b","0xfe22","0x2235","0x0f0","0x0c32","0x44c3","0x4e6","0xec2d","0xfcb1","0x13ce","0x413f","0x14e0","0xe2f3","0x22b3","0x423e","0xdeb0","0x930f","0xee24","0xf14d","0x1ff3","0xe210","0x1fe2","0x2700","0xf9ef","0xddd1","0x3c2b","0xe613","0xe2d2","0x40f1","0x35d0","0xfed2","0xff2d","0x932c","0x3910","0xc641","0x32b2","0x9e12","0x1be9","0xe294","0xeb00","0x1b11","0x0e01","0xacd7","0xcbdf","0x70c9","0x2e1c","0x3ed6","0xd611","0xd3b2","0x0ee3","0xdf5a","0x2ce","0x3910","0xfcdd","0xa1fe","0x2c1d","0xf201","0xf012","0xe140","0xdc22","0x712","0x239f","0xe2fe","0x113d","0xae9a","0xefcf","0x2fe","0x11dc","0xe3ed","0x3e23","0x5030","0xd92f","0xffdf","0x1e61","0x172f","0x2","0xb272","0xe0ec","0x0912","0xd1ff","0xb2d0","0x0c2f","0xe3d2","0x519d","0xd22f","0x0fcc","0x1f0","0xeaf0","0x22","0x3105","0xe3e3","0xde13","0xb20f","0x3fe2","0x22f2","0xcf0f","0xbfff","0xffee","0xe2df","0xc19f","0xe44f","0x1dd1","0xd2a1","0x49f2","0xf04c","0x96fd","0x1d51","0xac60","0xf11f","0x215b","0xcdfb","0x7402","0x24f1","0xf120","0xf1e5","0x3909","0x3cde","0xfb33","0x90a2","0x60dd","0x220d","0x1aba","0xddfc","0xe251","0xfe0f","0x1fce","0xec0d","0x3d00","0x1961","0xf016","0x7314","0x1049","0xf11d","0xd932","0xb2b0","0x2e0d","0xe640","0x192e","0xb901","0xbf31","0x09be","0x211a","0xecc0","0x29c0","0x1120","0xc4ce","0x2b04","0xd31d","0x232e","0x111e","0x2ee0","0x9f4e","0xd0f7","0xd303","0x10c7","0xf00e","0x0ca6","0xfc24","0x14da","0xefc1","0x402f","0xff6c","0xf9ee","0xbd0f","0x0fec","0xeeef","0x1e12","0x95ff","0x50f0","0xfcef","0x20e3","0x140f","0x2f37","0x40f2","0x3f0","0x0fd4","0x654e","0xb14d","0x1ec0","0x5223","0xf193","0xee0c","0x2400","0xeb2f","0x0de3","0x5cec","0xe4bd","0x1291","0x1f6","0x7a52","0xd41c","0xe1ff","0xb504","0xa2dd","0xcef9","0x4714","0xbd0f","0xb30d","0x1e2a","0x2c3f","0x4c1","0xf9f2","0xe407","0xbf51","0x32f0","0x5ebc","0xef00","0x7bb","0x74ed","0xbfbc","0x5ffe","0xefeb","0xd2dd","0x4db","0x0f00","0x203","0x312","0x4962","0x4e0f","0xef03","0x9c7f","0x2ce9","0x1cc1","0xd34f","0x370c","0x9f22","0x42f1","0xe1fd","0xcf0c","0x4eba","0x9cdf","0x0deb","0xed1e","0xe92a","0x1e34","0xcf00","0xc920","0xeec0","0xcdd1","0x3df1","0xbefa","0x2c00","0x362","0xcd1f","0x0ef","0xf003","0xe21c","0xcdde","0x4ea0","0x14dd","0x0e52","0x5fd","0xe1cd","0x263f","0x900b","0xf3d2","0x2020","0x3be","0x23ef","0xeeb4","0xd301","0x1440","0x4f42","0x1f7e","0x3cc","0xf74f","0xdec0","0x3ed","0xa4fa","0x2df2","0x19e1","0x322","0xd1d7","0x1f0","0x1eee","0x27d","0xc52c","0x11d2","0xffd2","0x32dc","0x205d","0x4ec7","0xee1f","0xcd77","0x3fc0","0xcf6f","0x7604","0x626f","0xa0ce","0x4336","0x3d0f","0x22da","0x116f","0x109","0xd3cd","0x2a3d","0x3c24","0xf310","0x0e0e","0xd4e2","0x0efb","0x0b5","0x1720","0xc323","0xe03f","0xf03d","0x940e","0x3edf","0xe0d1","0x61ec","0x3fe4","0x3d0f","0x09ff","0x9066","0xbeb2","0x214","0x112c","0x1292","0x1fc5","0x0c03","0xb61e","0xac7e","0x54d1","0xbf90","0x1090","0xf22f","0x19f1","0x630c","0x3b17","0x1755","0x32fe","0x4400","0x0f14","0x6425","0x1fd5","0x4522","0xf043","0x4d06","0x4b0f","0xded1","0xefa4","0x20","0xbfed","0x61bd","0xe2ec","0x262e","0xcc4f","0x1142","0x1f71","0x11e1","0xff2e","0x19f2","0xbf20","0xebf4","0xfee1","0x4f0b","0xcb4f","0x0c21","0xba02","0x6ce0","0xc12f","0x234e","0x10e2","0xd122","0x902c","0xcd1e","0xde22","0x1f00","0xf15e","0xd014","0xa0a9","0xffad","0xedd0","0xfbb3","0xdd1e","0x10ee","0x0b02","0x1ef1","0xd210","0xf00c","0xce1d","0x334b","0xd00f","0x1074","0xb040","0x3fe2","0xc22f","0x413f","0x1f14","0xfdc0","0xc79e","0x4ff0","0xd0e1","0x124f","0x1ef2","0x4dea","0x12f0","0xde9e","0xefcd","0x2e04","0xb003","0x2f3c","0xb1fc","0x0ede","0x1b4f","0xdff9","0xf46a","0x29fc","0xcfd0","0xee0e","0x30d5","0xf14e","0xdec6","0x2eb2","0x17f6","0x7bcf","0x2ed5","0xfe1c","0xe100","0x3c30","0x13","0x1502","0xea1f","0x24a2","0xdd02","0xcdcf","0x2fb0","0x271b","0x1140","0x3c30","0x4dc1","0xdf60","0x1de1","0x3f3e","0xcee1","0x2e02","0xf0fc","0xe50b","0x2b11","0x44f4","0x2f02","0xc46e","0xdbda","0x0f64","0x2fa6","0x9d53","0xf0f3","0xefe1","0x352","0xa53f","0x74ec","0xc17e","0x10d4","0xf32a","0xb60a","0x1ebe","0x500","0xf690","0x1bb6","0x13db","0x44b3","0x9f50","0x9231","0x4d05","0x3ff4","0xc1fe","0x0d32","0x20bd","0x1e92","0xcf6f","0x411c","0xd3d3","0xd74c","0x25d1","0x3fa3","0x7274","0x233","0x9301","0x20f","0x60f5","0x4531","0x1a0","0x4d03","0x0f4a","0x36b9","0x94e5","0x3f13","0x2d22","0xb0ee","0xdf2d","0x22e","0x432","0x25","0xbeed","0x2c4b","0xff2d","0x909b","0xa403","0xb3db","0xee1b","0x1010","0xdc77","0x3a21","0x190d","0x921f","0xbe9e","0x977b","0x3797","0x166f","0x511a","0x5014","0xa23e","0x0ec","0x14cd","0xe727","0x5e2a","0xfd21","0xff0f","0xf5c0","0xdef4","0x21b1","0x11ca","0xa11c","0xfb10","0x1c5c","0xfdff","0x1efe","0xeff3","0x201c","0xe329","0x2640","0xce34","0x6ef0","0xd30a","0x431","0x20d0","0xbfe3","0xb139","0x53e0","0x4f13","0xfb49","0x54ee","0x0fe4","0x3b03","0x2ec9","0x9d13","0x299","0x1e3d","0xea9f","0x1ae","0xefdc","0xa2df","0x11","0xe3e9","0x4423","0x11d2","0xb92d","0x19fe","0xff1e","0x2133","0xb11f","0x1430","0x3fe9","0x0b4d","0xece3","0x3e22","0xc410","0x0fcd","0xe30a","0x1f3e","0x3dff","0xf214","0x12c","0x2de0","0xb1d1","0x72b2","0xfc3e","0xeed2","0x74c1","0x2a35","0x1ff2","0x140f","0xeac4","0xe002","0xee1e","0x0d70","0x22f1","0x12d3","0x502d","0xe204","0x417c","0x21e3","0xeb35","0x5e20","0xa3e2","0x1cd0","0xe150","0x33b0","0x4e5b","0x3051","0xf131","0x0d64","0x431c","0x3dca","0xe11e","0xf0af","0xc509","0xb291","0x9d52","0xf963","0xe2eb","0xfffd","0x195e","0xceee","0xa1e1","0x10eb","0x553d","0x0e22","0x70d2","0xfed5","0x0b03","0x13bb","0x121f","0xd7b5","0x115","0xebd6","0x2ede","0x434d","0x190a","0x1213","0xcf0d","0x0e0f","0xeddf","0x23f2","0x1b2e","0x912f","0xc0f6","0xbed2","0xb211","0x1e5e","0xd26e","0x1ce6","0x3d21","0xe00f","0x1c2d","0xd5b3","0x3c30","0x224c","0xffee","0x2054","0x1229","0x43b3","0x6efe","0x3115","0x311c","0xfeb1","0x21f","0xd023","0xd0dd","0x1e4f","0x6cfd","0xf2f2","0x1c3c","0x2ecd","0x20fe","0xa05d","0x32f","0x21","0x213d","0x3f00","0xf010","0x14fe","0x3531","0x0f0e","0x5fac","0xf240","0xf303","0x320b","0x101f","0x2fe0","0xe222","0xf73c","0xc2ed","0x1152","0xfb13","0x3edf","0xeff5","0x7e51","0xc45f","0xfd02","0x2e1","0xee3e","0x1c3e","0xde3b","0x545f","0x1601","0xfdf3","0x11fe","0x9d41","0x2241","0x23ed","0x223c","0xe2d3","0x1fc","0xc542","0x303f","0xf1e4","0x103b","0x121e","0xafff","0x5440","0xcde1","0xef0f","0x0f2c","0x923f","0x21d0","0xcf13","0x301f","0xeb42","0xbfa0","0x226d","0xfe0c","0xc092","0xff0b","0xf0b2","0xb4f2","0xf149","0x1b1","0x235e","0xfd42","0x4c16","0xe02d","0xef50","0xf335","0x9fe2","0xe337","0x7424","0x0ef0","0x71f4","0xaf75","0x1ff3","0xe1ec","0xf1f4","0xd19e","0xdd2d","0x1c21","0x2fee","0xd6d3","0x4b75","0x1ea5","0xf11a","0x0cc1","0xa011","0x691e","0x4f1d","0x5eb7","0xa6a3","0x133c","0x33e","0x424b","0xc423","0xeaee","0x114","0x52be","0x3ef3","0x2f16","0xa44e","0xff7f","0xaf12","0x40e4","0xbf61","0x15e4","0xf1dc","0xd506","0xee03","0xb6eb","0x9d46","0xda0d","0x2c4c","0x3150","0x2c21","0x0ea0","0x11d","0xe702","0xcc00","0x39a4","0xd14f","0xe3c0","0x4a1a","0x131f","0xde91","0xff00","0xa122","0x3eea","0x2354","0x12a6","0x233f","0xfbc2","0xeeea","0xf150","0xf01f","0xced1","0x5207","0x36ab","0xdf2e","0xb0df","0xdfe6","0xa9e4","0xe0c3","0x4ee0","0xfd5d","0xeee7","0x20ef","0xfebc","0x3dcf","0xc0d3","0x0f","0xba51","0x20dd","0x1b9a","0x11d4","0x20f","0x3306","0x1df2","0xd341","0xec2d","0x16e1","0x1f0d","0x0f26","0x20fb","0x1c4","0xe012","0xe0c0","0x1bce","0xe200","0x13d0","0x10f1","0xf4ac","0x4d1b","0x6324","0x9def","0xb0a3","0xcec7","0x0cf0","0x31b3","0x12cb","0x1ec2","0x0cf0","0xbfd0","0xf10b","0xf1ec","0x29b","0xe0ec","0xfeed","0x1d32","0x10ef","0xcff1","0xe5f5","0xdfc7","0x0c13","0xc0fe","0x1da","0x2f1f","0x60f","0xe1ef","0x0ffb","0xffef","0xd03e","0x3ed0","0xfdbb","0x3bca","0x4260","0x752f","0x2","0x4ee7","0x2f96","0x9f19","0xe0b2","0x3bee","0x4257","0x1101","0x93ff","0xfe1b","0x2196","0x3d0","0x3afc","0xfbcd","0x1d0","0x115c","0xe5b3","0x7fb7","0x0e16","0x40e7","0xc024","0x5343","0x40f0","0xea52","0x0da0","0x0cf","0xbf1b","0xf400","0x2dbb","0x20df","0xecdf","0x223e","0x1b06","0x5a96","0xde03","0xffc3","0xdefe","0x1c00","0x0fe1","0xe135","0xc96f","0x1042","0xe1ec","0x1f24","0xf500","0x42b5","0x232","0x0ce1","0x5ef4","0x3df5","0x1fe1","0x13c2","0x31c1","0x6cf","0x2203","0x104a","0x0b1","0x0cf4","0x22da","0x10f","0x24db","0x3119","0x4f43","0x5ec1","0xf040","0x5ffd","0x3dcb","0xb4ab","0x41c1","0xdef2","0x42d1","0x1f3","0x20","0x1fe9","0xdf61","0xfb0e","0x41dc","0x237c","0x22e1","0x320e","0x0dce","0x1240","0x720e","0x5501","0x0c1","0x570","0x1dcc","0xfe6d","0x421d","0x1130","0x54ed","0xed5f","0x4207","0xdc33","0xd0d1","0xdb30","0x5d41","0x0f9","0xa3fa","0x2b9","0x722d","0x0c","0xcd94","0x1f2a","0x4bb3","0xcc03","0xe0b9","0xe1ef","0xeaf4","0xd01d","0xcfaf","0xde42","0x20ed","0xc019","0xe200","0xd0ab","0x164e","0x224","0x2fbe","0xcd11","0x0cf4","0xccf0","0x42fb","0xef31","0x0bfd","0xb133","0x232f","0x3b23","0x60f","0x20d","0xfee2","0xe1bb","0x92c2","0x251","0x4ebf","0xcbf0","0xdbe0","0x9112","0x213d","0xeb1e","0x3053","0x293","0xb42f","0x1b21","0xf24a","0xeb44","0xe002","0xfbd0","0x3cb4","0x2030","0xf117","0xdc0d","0x332b","0xcf13","0x20b0","0x5c1f","0x1320","0xf50c","0xa4e0","0xed11","0x2bed","0x237b","0xed20","0xf292","0x2ff3","0xd14e","0x2d2","0xea6f","0x1d21","0xb2c1","0x1df1","0xdb6f","0x2c37","0x3eb","0xf6ed","0xcd24","0xfe91","0x2b1a","0xf40b","0x10","0xd130","0xc01d","0x412","0x5040","0x3e96","0x2f34","0x505e","0xf021","0xdb09","0xecbf","0x14d0","0xcdf1","0xe1f4","0xfe03","0xe9e4","0xd2cc","0x3312","0x1142","0x1ffd","0x0dec","0x4d1e","0x0f72","0xec0f","0xffb2","0x3b21","0xe1ae","0xd0dc","0x33f2","0xc10c","0x4d0e","0xdcfd","0xef20","0x5cbc","0xe92c","0xdc10","0x5c0f","0xd330","0x1224","0xbde0","0xee0f","0x0e0f","0xb30b","0xc1db","0x120d","0xcf3c","0xd302","0xeefc","0xcc1f","0xf1c0","0xcdee","0xb921","0x7f0e","0xe2bf","0x1d16","0x0cc0","0x51fe","0xf115","0x6ae4","0xf122","0x1f50","0xf463","0xf0f3","0xbb3f","0x23df","0xd3e1","0x202f","0xe320","0xfd02","0x50ee","0xee02","0x1f7c","0x1c","0x2ebf","0xffbb","0x3d12","0x714e","0x2f12","0x0fb3","0xcfe1","0xb0c1","0xd121","0x42f4","0xfc5f","0xd9e1","0xb4ee","0x724e","0x4de0","0x511","0xf20b","0xf0ee","0xfc21","0x4e0c","0x100d","0xeee0","0xffb4","0xedff","0x231f","0xd932","0xfdbe","0x30c2","0x0f5f","0xf3f0","0x1fef","0xf501","0x2c2f","0x2439","0x2de4","0x9960","0xd4c5","0x13d5","0xee4c","0xd1d7","0xad22","0x3","0x0efd","0xffd6","0xfc03","0xb41d","0x3045","0x29e7","0x3d1b","0xf2a6","0x1df","0xae13","0x0a01","0x26e3","0x953e","0x2226","0xfe52","0x6e2e","0xc047","0x2f4f","0xdbf4","0x237f","0xf2d2","0x1f04","0x39cc","0xb2c0","0x1efb","0x40ff","0xf1e3","0x1bb3","0x90fd","0x0faf","0x62cf","0x101f","0xa0e2","0xf0ff","0xfd3e","0x0e0","0xf121","0x2","0xa13f","0x12df","0x5301","0xdde2","0x2313","0x2113","0xe70e","0x9bfc","0xf3e6","0xf5d0","0x211e","0xccfb","0xff1b","0x11","0x45df","0x0f7e","0xdd11","0xf3e1","0xf1fd","0xebf3","0x4120","0x1e2d","0x13cf","0xfef1","0x353f","0xc00d","0x2bce","0x91fe","0xdf3d","0xf051","0x44bd","0x120f","0xbf1f","0x4622","0x1f11","0x0903","0x120f","0xbfe0","0x1e00","0x3210","0xbf10","0xee1e","0x5cb0","0xa2f1","0xd1be","0x1d","0x10c","0x3ff","0x0b61","0x37","0xe0ee","0x50ed","0xce72","0x2203","0x1e64","0x2542","0x2faf","0x33c4","0x0ae1","0xcefb","0xd504","0x60b1","0x2063","0x1521","0x2d01","0xbe19","0x14d0","0x223e","0x22c","0xee2b","0x2949","0x919c","0x0fdf","0xc414","0x0b1f","0xdef0","0xeec4","0xefc0","0x3f02","0xf9e2","0x2a9d","0xfc1e","0x1d0d","0x3a1e","0x103f","0xef1d","0x0f23","0x20bc","0xfdb2","0xf151","0x1d12","0x9e3f","0xe140","0x90c9","0x3002","0x3931","0xc3d0","0xbeeb","0x0bf0","0xed2e","0x325b","0xe2dc","0xf0ee","0x41f6","0x1fdd","0x3030","0x0ffe","0xc11e","0xfecc","0xdcbc","0xbf1d","0x5e31","0xc6e1","0xeffe","0x0ddd","0xcf3f","0x23c0","0x212d","0x13b3","0xfd2f","0x329d","0xd0d2","0x324c","0xd24f","0x9f33","0xdcbf","0xf109","0xcc01","0xdddc","0xefed","0x41e4","0xcf1e","0x1eec","0xb02e","0xe101","0xdeaa","0x319f","0xf4d4","0x2222","0xdd39","0x0fad","0xbd2e","0x2759","0xfa00","0xf35a","0xb2d1","0x153d","0xfa09","0x2cdf","0x40f5","0x2ea2","0x5003","0x17c2","0x61dc","0x1249","0xcd1f","0xb6b1","0xcfec","0xd409","0xec01","0x11ef","0x221","0x3d17","0xe14f","0x0a23","0xe203","0xdcd2","0x1605","0x1563","0x0e2f","0x6519","0xc3dd","0xb3ff","0x4d20","0x44a4","0x0b4a","0x3b0c","0x25d1","0x21f6","0x1e36","0xc1f1","0xc213","0xac3e","0xe211","0x0def","0x1ac0","0xc5bc","0xdebe","0xbd01","0x33ea","0xfedf","0x2be2"}
},
{{"0x0f2","0x222","0x2f1","0xff21","0xce0c","0x3f24","0x901d","0xfac0","0xb1e4","0xf21f","0x2cc","0x50d1","0x2ced","0xb110","0xe070","0x0ee0","0x4103","0x6a9f","0xb35d","0x703e","0xf050","0xed0e","0x9c51","0x7ed6","0xfc0a","0x42bf","0xd31f","0x103a","0x3910","0x43d1","0xd21d","0xe231","0x23df","0xcd45","0x32ef","0xea2e","0x3b7","0x0ada","0x0e02","0x25","0xeec3","0x35f1","0x6f01","0xbf5f","0x4e0","0x5e2e","0xfbbe","0xf020","0x2710","0x1512","0xd22d","0xe501","0x0a23","0xf020","0xfd02","0x1ff0","0x0db","0x503f","0xeb2e","0xd100","0x0ded","0xfdfe","0x0e3e","0x1100","0x11f2","0x3d01","0xbd11","0xa1fb","0xaf2f","0xc241","0xb9fd","0xf345","0xf320","0xe94e","0x2f0","0xc749","0x9ce2","0xb1a9","0xb114","0xe401","0x212e","0x1c31","0xf90f","0xaddd","0xf33c","0x146f","0xdffc","0x0f31","0xbd0e","0x1f11","0xd1e2","0xc5cd","0x9c3d","0xd1ac","0xe00f","0xb2ef","0x1ede","0xd1fd","0xf1f0","0x1e0","0x140b","0xff22","0x1e","0xe4d0","0xfde4","0xb117","0xc019","0x9d0f","0x91f6","0x40ea","0xc132","0x2d16","0x137e","0x1f02","0x9371","0xe622","0xff2d","0xa224","0x4b0f","0x3460","0xbff0","0xefd2","0xfa9c","0xbb00","0x9ede","0x09c9","0xd2f6","0x120","0xe33f","0xf00f","0xef12","0x310","0x55fc","0xd520","0xe41d","0x312","0x1e31","0xff40","0xefaf","0xadee","0x9191","0xf009","0x31d0","0xe231","0x11d7","0x21f2","0xd0e1","0xcf70","0x142f","0xc492","0x170e","0x909e","0x40dc","0xe2fe","0xf59c","0x9231","0xeec3","0x9459","0xf59f","0x1cb3","0x5d44","0x4e61","0x2fd","0x9772","0x1464","0xd3f2","0xff51","0xe0e1","0x310d","0xf632","0xe091","0x5e1","0xa1ff","0xff0a","0x3ff9","0x0bf1","0x229d","0x0d21","0xf3e2","0xa723","0x301","0x22ef","0xf970","0x434","0xd10c","0x21","0xc490","0xf12b","0x9c1b","0x55b1","0xc9ad","0x2f0e","0x1e0f","0xc430","0x2b0","0xff4e","0x3fe1","0xe2b1","0x1123","0x5edd","0x4ed6","0x43f3","0xdeac","0xe1d0","0xcd4e","0xf2e1","0x121e","0x2214","0x150","0x7046","0x403c","0x7f30","0x1d7d","0xe3a5","0x4d11","0x7330","0x413f","0xd5d4","0xfea5","0x25cc","0xddfe","0x30e1","0x4170","0x2cd5","0xf5e0","0xff04","0x0eb0","0xe11e","0xcfe0","0xc1ed","0xee03","0x432d","0xf103","0xd2f0","0xf1d7","0x0c0c","0xfbb2","0x4db2","0x50fc","0x9fe4","0x5729","0x7514","0x54e5","0x7135","0x3e4f","0x3117","0x7f32","0x41c1","0x1503","0x53ca","0xd3b1","0x60f2","0x5a00","0x2e01","0x554","0xd33f","0x70b","0x6e01","0x1240","0xd0fb","0x0f7","0x1177","0x13be","0x41ef","0x72e4","0xf1ab","0xcf23","0xeff1","0x21d4","0xee9f","0xbedf","0x305d","0x2f25","0xfde0","0x1052","0x143d","0xc1e5","0x437","0x4502","0x0c07","0x2042","0x1de3","0x2f67","0x6c10","0x63d1","0x4df3","0x0f04","0xef21","0xc1e1","0x10e0","0xe301","0x660d","0x301f","0x31f2","0xf103","0x42b2","0x1e0f","0x1120","0x1c0b","0x2d20","0x60dc","0x2fd2","0x50d2","0xe193","0x1d2d","0xc04e","0x13d5","0x0e1e","0x114c","0xf5a2","0xfcc1","0x3fae","0xf3f4","0x0f01","0x2c2b","0xfee9","0x5f9c","0xa211","0x1272","0x1014","0x2bbd","0x0f22","0x390","0x33cb","0x60ea","0x1ed2","0x49f0","0xe00d","0x32fe","0x311b","0x0dcd","0x0e31","0x6bfb","0x1136","0x1123","0xf4e3","0x1ef2","0x2033","0xd33f","0x53fe","0x1274","0xd231","0xe937","0x4d34","0xcbff","0x42f0","0x1da3","0x71ed","0xbe2e","0x774f","0x0b3d","0x2f","0xcdfd","0x111","0x13d2","0xf04f","0x5f30","0xcd01","0xff2e","0xd2dc","0xf9f9","0x16df","0x1c90","0x3eda","0x1e00","0xe23e","0xe9ac","0x4dee","0x512","0x3132","0x1030","0x5210","0x2dde","0x1d2d","0x1dc1","0x1123","0x0c2d","0x620","0x19c3","0xd0cf","0x103","0xe63d","0x0f4e","0x5d10","0xd42f","0x2010","0xc400","0xfe24","0x1d03","0xc6e3","0x339a","0x2d12","0x50c7","0x173","0x6177","0x9a10","0xd1f2","0x90f3","0x2291","0xb6fd","0xf011","0x3015","0xc215","0x4d33","0xfa31","0xa7ec","0x65d1","0x4fe4","0x3fe4","0x431c","0x0a57","0xf910","0x4006","0x10f1","0x6c4","0xc133","0xc011","0x25db","0xf721","0x4412","0x535e","0xcb43","0x3049","0x1b23","0xb0f4","0xd1ef","0x1e24","0x1db2","0x2ede","0x7c4b","0x4ad6","0x4e3","0xff6c","0xef06","0xccef","0xede1","0xee0a","0x9051","0x5932","0x50f4","0x507","0x3aac","0x262f","0x3965","0x1ec2","0x493f","0xbf04","0xf5e5","0xee36","0xe3e0","0xa316","0x0c72","0xdffb","0x3b4c","0x7f3d","0x229e","0xd717","0x3fe1","0xf7e4","0x3d16","0x5615","0x2d4e","0xec02","0x414f","0xd214","0x2044","0xec15","0xee0f","0xfee2","0x19cb","0xde2c","0x2dfd","0xa127","0xe11d","0xe0ff","0xe2b5","0x223f","0x51c2","0x1c1f","0x36e1","0x2d4e","0x112f","0xf71e","0x2ee0","0xf0f2","0xbe5d","0xeffd","0xed1d","0xbd22","0xfe2d","0x533e","0x21c5","0x6f9e","0x5475","0x2106","0x452c","0xb1fd","0xedde","0x3240","0x42fe","0x3426","0x4ed","0xd63f","0xb2e0","0x2b00","0xe1eb","0x13ac","0x9302","0xaf07","0x5900","0xf096","0xd20f","0xbf20","0xff00","0x6234","0xfc12","0x0e29","0x242e","0xc63f","0x4f5","0x2f41","0xeb02","0xcf50","0x9ffe","0xd6f5","0xd990","0x9012","0xb0f3","0x21fe","0x3013","0x1e1","0x12b2","0x1f32","0x2d29","0x23ff","0x19fd","0xfdfd","0x20f1","0x1d0a","0x3bef","0xc115","0xc30f","0x300b","0x3fc4","0xdfdc","0xd133","0xc9a3","0xb93b","0xeaae","0xee59","0xe1e0","0xf933","0x533f","0x20fe","0x4621","0x7f27","0x4320","0x0c21","0xc064","0x7202","0x624","0xec2d","0x2ef6","0xacec","0x93b9","0x3129","0x0f0","0x6a2d","0xe2e5","0x2301","0xdc26","0x1a9c","0x300e","0xf22e","0xa17f","0xe49d","0x5edd","0x3442","0x3c42","0x15af","0xf11e","0x1fe4","0x0c17","0xfe23","0xdcc0","0xe3dc","0xea3f","0xdacd","0x31dc","0x0ab5","0x0d2e","0xa212","0x30cc","0xa631","0x0ef2","0xd22a","0xf104","0xeccf","0x30e5","0xe6e1","0x21fe","0x5e5","0x9efb","0x0fe0","0x2f6c","0x3d1f","0xfdda","0xdb11","0x913c","0xdf04","0x10d","0xd32e","0xddd1","0x1ffe","0x4ce3","0xe1f1","0xe012","0x11ff","0xaf09","0x792b","0x1f4f","0x9d24","0xb32b","0x50b5","0xfdc0","0xcc42","0xedff","0x7051","0xbf24","0x32a1","0x312","0x420f","0xf0e2","0x3e2f","0xbfe5","0xf00d","0x1bef","0xe0c3","0xdc11","0x3243","0xfe71","0xe2f3","0x13c0","0xa012","0xf004","0xe5e0","0x403e","0x550d","0xe0a4","0x1d2","0x1d92","0x4911","0x10ad","0x1102","0x41c1","0xc31d","0x60d9","0xf3e3","0xbabf","0xd500","0xf0de","0x44b4","0x5c20","0xf1c4","0x11dd","0xda41","0xdc9d","0xdf2d","0x4b1a","0xa313","0xbecf","0xc022","0xdd44","0x50f","0xff3d","0x17c2","0x11c6","0x299a","0xe21e","0xe7ff","0x2","0x420b","0x101c","0xe113","0x3449","0x3df0","0xdf25","0x3f9f","0xff66","0xcf9d","0x0d70","0x15ce","0xc2e2","0xeeeb","0x0d","0x2d41","0xe1f5","0x3dee","0x204e","0x4ce5","0x44ed","0xdc21","0x9e12","0x149f","0x3df","0x0dd3","0xf227","0x1cd1","0xd1c4","0xdfaa","0x1fc2","0xed40","0x0c05","0x3e35","0xa91d","0x54df","0xe03d","0x4ff2","0xfcc9","0xd4d1","0x1ee2","0xf2d0","0x4cf0","0xc1cf","0x15df","0xbd1b","0xe2df","0xed00","0xf0a0","0xcb4e","0x344e","0x2bde","0x1561","0x5d2d","0xe36d","0xd25d","0xa020","0xd311","0x1213","0xf01e","0x402a","0xa509","0x0dc1","0x24c1","0x11ce","0x1e4e","0xefde","0x9af3","0xe3ee","0x5f31","0x21eb","0x7102","0xa50d","0x2c6","0xe0df","0x20e1","0x213c","0xaf21","0x40c2","0xeedf","0x230f","0x5af2","0x2dfb","0x0c03","0x3d6e","0x5b10","0xfc0c","0x201e","0x0efe","0xac3f","0x5292","0xe6f3","0x0f5d","0x4240","0x1014","0xfaea","0x30bd","0x3dc7","0x3f5","0x0d3f","0x9efc","0xcec3","0xca40","0x330d","0x2d3c","0xb224","0xe5a7","0xb341","0xddfd","0x3020","0x3a31","0x0ee9","0x9ffb","0x3eb2","0xc2f2","0x1b03","0x9d10","0x2003","0x3fef","0x41da","0x5d3c","0x7030","0xb127","0xb132","0x0ccf","0xd13f","0x1e30","0x11fc","0xcf5b","0x4f39","0x2ef","0x46c0","0x90ca","0xf302","0xb71c","0x5f22","0x3a02","0x20de","0x4c22","0x251","0x0de1","0xdf0b","0x54b1","0x3ea","0x300f","0x3c2e","0x1ee4","0x122c","0xe023","0x91d4","0x31df","0x0c0c","0x3d23","0x2f42","0x141","0x121c","0xee3d","0xd3ac","0x9091","0x4f09","0x120f","0x3035","0xefe2","0x3f11","0xcc10","0xc214","0xe003","0x4000","0xe5f0","0xf51f","0xf1fd","0xef5e","0xfef3","0x1fba","0x22a0","0xedee","0x32ee","0x112e","0xd2e1","0x202e","0xeb11","0xf100","0x200","0x111e","0xb4f3","0xe1ef","0x1cfd","0xdb32","0x240","0x0fcb","0xe6dd","0x1c09","0x21ee","0xe32b","0x0dfe","0x1ff1","0x1123","0xaec1","0x612b","0x5e00","0x1f","0x21d","0xbee4","0xe312","0x1541","0x2bf9","0xea0d","0xeedd","0x0cd0","0xdcf9","0xc110","0x49b5","0xcafb","0x1ec1","0xc21a","0x2040","0x0f09","0xdded","0x0afe","0xfdf0","0x4f00","0x740","0xd4c0","0xbbd0","0xbbf2","0xeeac","0x1e22","0x943f","0xfa2c","0xb3e0","0x2de6","0xfc00","0x42f","0x3312","0xf112","0xebd5","0x42e0","0x141f","0x172","0x1492","0xffe7","0x1721","0x1deb","0xddf1","0x321c","0x324b","0xf3c0","0x4f1f","0x302d","0xe5d4","0x7cd5","0xbde2","0x302f","0x6cf0","0x326e","0xedaf","0x0fe1","0x20ff","0x60df","0xfe00","0x1f2c","0xf27f","0x331c","0x3ac1","0xfec0","0xb212","0xf12f","0x0ffe","0x1f4e","0x0de","0xd2fc","0xed1f","0x0dac","0xbcfe","0x7f54","0xe22e","0xcddf","0xa03d","0xd0b2","0x09f3","0xb012","0xcf3f","0xd6f2","0x4d04","0xfc62","0x4dbd","0xce4c","0x09c1","0xa0eb","0x22cb","0x61f1","0xafb4","0x4f20","0x0db3","0x7a3e","0x0a2d","0x320e","0xc2f1","0x0faf","0x13f4","0xfefe","0x6efd","0xd41c","0x1d30","0x4c09","0x32bd","0xc232","0xefe0","0x3a3e","0xe031","0x30e1","0x2ec3","0x3d13","0xede1","0xf2e5","0xe211","0xfdd0","0x22fb","0x1fd1","0x5e0","0x7d6b","0x11e1","0x12b3","0x1dee","0x1ee3","0x92d3","0x1ffe","0xfe0c","0xef3a","0x6f1c","0x1360","0x9193","0x16b6","0x0b2f","0xeb0f","0xd5d7","0x2ef1","0x14de","0xeb6b","0xace2","0x404","0xfdb2","0xdd20","0x0e0c","0x09d3","0x1fc","0x2d0","0x7052","0x1234","0xd259","0xae35","0x4032","0xf0cb","0x4d2e","0xef1f","0xed1f","0xef5e","0x0df","0x32e0","0xfd23","0xf4f2","0x5ee2","0xfeb1","0xff14","0x10af","0x6ee9","0x7e4f","0x20eb","0x0fe1","0x0eb0","0xcfcc","0xf112","0x732","0x611e","0x143c","0x212","0x2e21","0xfd21","0xafa4","0x2212","0xe11a","0x5d4b","0xdd52","0x1f1a","0x910b","0x0fdf","0x1bb1","0x7133","0xfa4d","0x7d5f","0x31c","0x55c2","0x1ccd","0x430","0x223","0xf220","0x0fcd","0x1e2e","0x140a","0x0e0c","0xa5e2","0xe0ed","0x0f2","0x3521","0x5212","0xef5d","0x1fc2","0x3d0d","0xfe26","0xa4ec","0x6700","0xf040","0x1df1","0x71","0xb3c9","0x11bb","0x20d0","0x9fe2","0x173","0xf9a2","0xf2ec","0x31c1","0x72c7","0xda6c","0x3ed1","0x3ed3","0x0ea1","0xc3ee","0x5101","0x23c9","0xf022","0xefe3","0xeff0","0x1efc","0xc1b0","0x921f","0x4c03","0xde2e","0x0f20","0xe0fe","0xdcf0","0x6161","0xf4a4","0xeed0","0x216f","0xede1","0x9aee","0xeeee","0x12","0x22be","0x09ef","0x9ef0","0xcc6c","0xece1","0xe11e","0xe0e1","0xb00a","0x6d2c","0xe632","0x6231","0x19a3","0x1fd7","0x54f6","0x4214","0x6e51","0x5335","0x20f7","0x545d","0x2131","0x125","0x0c52","0x0e22","0x351a","0x4c17","0xfe40","0x2924","0xf520","0x2d1","0xd00c","0x43de","0x3cf5","0x262","0xe007","0x2fc0","0x2efe","0x222c","0xde22","0x1544","0x5ae9","0x1cfb","0xfef4","0x6054","0x15dd","0xef91","0x36f","0xf59c","0x0e2","0xcf2b","0xb3d1","0x6cfe","0x11df","0xae3e","0xbd56","0x2902","0x4c09","0xcf0c","0xfdb0","0x4ba","0x2dff","0x23f","0x205f","0xf5d7","0xf5b7","0x0df","0x223","0xf92e","0xe092","0xacc4","0x0f45","0x0aff","0x1ef9","0x1b2c","0x2c0e","0xb12f","0x0e5","0xd0ab","0x1de1","0x1ea","0xae6e","0x0ce2","0x411c","0xff11","0xf013","0xe1d3","0x3e3d","0xfee0","0xbd3f","0x1310","0xfe00","0xc900","0x30fa","0xedb6","0x0daf","0xd1ec","0xfc1e","0x4dd2","0x0bc","0x2d4f","0xed15","0x2fef","0x3dea","0x62de","0x1f33","0xb63c","0x3411","0xb012","0xf329","0x342","0xfe01","0x2091","0x295d","0xdf1f","0x25dc","0x11c2","0xf36e","0x209f","0xf919","0x13ed","0xdfec","0x2f2f","0x09f0","0xe2ab","0x111a","0xdd0e","0xfcdc","0x21fe","0xf10f","0xea3e","0xd0ff","0xfde1","0x3f40","0x2a21","0x3c5","0x6fbf","0xe0fa","0x313e","0x9df1","0x4edc","0x4c32","0xf50e","0xe59e","0x3db6","0x3443","0x36d","0x4015","0x3ea5","0x7e1e","0xea30","0xe4d0","0x113","0xc4e0","0x260f","0xffd0","0xc1b4","0xe616","0xaa9e","0x0ebc","0xea9a","0xe3c3","0xe219","0x3ddf","0x29b6","0x7edb","0x22f1","0x33c9","0x1017","0x0b4","0xd11e","0xefdc","0xce00","0x4c32","0x20cf","0xa5dd","0xc02b","0x2c4c","0xf4ff","0xd0b7","0xc0eb","0xc006","0xd2ea","0x50c9","0xee0f","0x5fa0","0x2e3f","0x2b1d","0xcd0e","0xd06f","0x13e2","0xb3ee","0xb02b","0x3ffe","0xd142","0xebf0","0xfe9e","0x120d","0xe40f","0xeea9","0xf221","0x0fb0","0xcf0f","0x701f","0xff00","0xe265","0xe2da","0xa44d","0xcefd","0x11f9","0xee20","0xbdce","0x2f0","0x703f","0xe130","0x3193","0x4c6b","0x6fd1","0x1fa0","0xebef","0xce21","0xcf21","0xfede","0xf7b0","0xe1f0","0x120d","0xcafe","0xd714","0x117a","0x1ff7","0xecdc","0xb9e7","0xf0dc","0x222","0xb0cd","0xc32d","0xf160","0x323","0xd4fe","0xf731","0x13f1","0xee31","0xd922","0x44fe","0x3ce7","0xf4b4","0x609f","0xb203","0x55ee","0xdce3","0xf1e1","0x2ef0","0x5f1","0xe34d","0x40de","0xbf30","0xd91e","0x259","0x0df3","0xf1fe","0x9c9a","0xb1e1","0x32fc","0x2021","0x21ee","0xd132","0x0dfe","0xd013","0xcefe","0x13e7","0xe4db","0x1be1","0xf13b","0xc1fd","0x3043","0xfdcc","0x0e1d","0xd337","0xb5bd","0x1e11","0x0d09","0xaf17","0x26b1","0x5f2","0x0cad","0x2002","0xbfbc","0xffb3","0xe1aa","0xbede","0x32de","0x3e0c","0xef35","0x2347","0x0f3e","0x3fe1","0x4123","0x2041","0x2fc0","0xd2e3","0x1e","0x11e2","0x9e02","0x3042","0xf5e9","0x62bd","0x3cb6","0x11f1","0xeed0","0x35","0xac11","0xff04","0xfdd5","0x301c","0x0d1f","0x1c0","0x332f","0xa2fa","0xfb56","0xbe52","0x4e34","0xb12d","0x4031","0x2c0d","0x2413","0xfa42","0x2125","0x0e7e","0x0d1d","0x2d71","0x3bf7","0xf219","0x4fee","0xfef1","0x41f3","0xf133","0x4c77","0xd41e","0xf3ff","0xfb60","0x0e16","0x76a3","0x6d47","0x0d3e","0xb722","0x196e","0x334d","0x159e","0xad5e","0x9f01","0x6295","0xa4f1","0x2c2a","0x674f","0x772f","0x10e4","0x44f3","0x5c2c","0x915f","0x14f","0x46e2","0xf50f","0x1e22","0x190e","0xf034","0xdfd1","0x1096","0x23bb","0xffa9","0xef3c","0x293","0xedc3","0x7f1e","0xcbf9","0xfcfd","0x509","0x4290","0x1e1","0xe1cf","0x16c1","0x461f","0x2010","0xf4d0","0xe1ec","0x3acb","0x22e","0xdfed","0x0f0f","0x7216","0xfd10","0x1f7f","0x6329","0xc2b4","0x1101","0xff95","0x420e","0x4ce5","0xe1e3","0xeaf1","0x0f3e","0x09fb","0x4d3e","0x22ed","0x522e","0x5ccd","0x12dc","0x2c52","0xf31c","0x2b3"},
{"0xe540","0x3d0f","0x0d33","0xe503","0x1051","0xe426","0x4032","0xa10e","0x32f4","0x1e30","0x3ddc","0x73b2","0x459c","0x23ef","0xff3b","0x2040","0x1ac1","0x7279","0x0dd1","0xeffe","0x34ee","0x32f3","0xa093","0x9209","0x1dee","0x52f","0x19ed","0x95cf","0x1b0a","0x415b","0xe5be","0xf331","0x2dd0","0xfdcb","0x6100","0x30f0","0x517d","0x1f4c","0x21e0","0x0e20","0x3ae4","0x0d9","0x7616","0x77e2","0x0fcf","0x7dae","0xeb17","0x6ee","0x120b","0x13f","0xcf1e","0x33f3","0xd2fd","0x201e","0xfd1e","0x0c1e","0xcc41","0x110","0xbfed","0xe19c","0x2ded","0x0d6d","0xcf2e","0x66c5","0x10bf","0x2c39","0xf900","0xee00","0x31fd","0x6719","0x96c3","0xb162","0xdefa","0xec30","0xe16e","0xe199","0x2e0d","0xa3fc","0x4415","0xbe07","0xd2d5","0x340b","0xb934","0xee2f","0xc4f9","0xf76b","0x1fa1","0xaff4","0xbedb","0x0ad1","0x10ee","0xcef9","0xbff1","0xd1fd","0xce1d","0xd312","0xe103","0x2f12","0xedc0","0x9e3f","0xe6d2","0xef1f","0xd7c5","0xcef6","0x52e5","0x3f73","0xd17e","0xc113","0x4046","0xe435","0x223","0xe107","0x0fd2","0x111c","0xd00d","0xc03e","0x2d1d","0x9b42","0x0fb","0xdf3f","0x55e1","0x997f","0x4ee9","0xcf4e","0xdfdf","0xdd9b","0x11f7","0xeae2","0x2ffe","0x43ed","0xe141","0xfeff","0x61fc","0xf753","0x200f","0x170d","0x102e","0xed23","0xf2ed","0xd37f","0xbf9f","0x0c0c","0x44f4","0x210c","0xfe67","0x3d4b","0xb952","0xbf0f","0x155a","0xe1d6","0x39","0x109a","0x0d0c","0xe0ee","0x32de","0x5132","0xcbce","0xc2fd","0x1bc","0xaea2","0xe0c2","0xfedc","0xf541","0x4410","0x3f1d","0x41","0xee2e","0x54e2","0x1d60","0xe031","0xd0ee","0x213f","0x9f11","0x4f25","0x3ebd","0xd3b3","0x26e4","0x0e00","0xefd1","0x9745","0x4fe3","0x215e","0xf0a3","0xb141","0x1265","0x1404","0xc013","0x103","0x9020","0x4220","0x4a14","0x22e4","0xddf3","0xf50d","0x720c","0x2e32","0x11c2","0x1bd0","0xf3be","0xd91e","0xcf12","0xf03e","0xf07b","0x0fe1","0x121a","0x1101","0x4a00","0xed01","0xeba1","0xfe3d","0x419e","0xe2a1","0x2ec4","0xedcc","0xaf2f","0xc042","0x1f09","0x2dd1","0xef9e","0xde1a","0xd9d0","0xb1fc","0xd610","0xb0e2","0x522","0xa0e4","0x3e0f","0x120e","0x3f10","0xd4ed","0x6310","0x9d4a","0xb214","0x2114","0xbef7","0xfdca","0x6b3","0x90f1","0x7192","0xb2b2","0xe20b","0x4553","0xf2bf","0x1fdf","0x739d","0xf2cf","0x1df5","0xe2f3","0x614","0x47d0","0x3093","0xee02","0x0fc0","0xfd23","0x50cb","0xc7d3","0x1cdf","0x4c33","0xf030","0x3edc","0x310e","0xcf04","0x2fff","0xecd3","0xeacd","0x2ffd","0xbee5","0x1d2c","0xad9f","0x22fd","0xd330","0xe10e","0x1bbb","0x2c21","0xdefd","0x4b10","0x0ab2","0x3f12","0xf21e","0x29cd","0xdd0f","0xf013","0xe0f2","0x4044","0xa23e","0x50d1","0xcf92","0x43","0x0cbe","0xcda4","0x6f4","0xcec2","0xef1f","0x2343","0xee11","0xfcdf","0xdc2e","0x11d4","0x39ce","0x1ef9","0xf900","0xb4f1","0x2e0a","0xf2a5","0x121f","0x7062","0x342","0xfebf","0x162d","0xdfe4","0x406c","0x310","0xd7d5","0x2194","0x4fc1","0xde2c","0xc215","0xd130","0xf51f","0x0eef","0x15cc","0x5e12","0x9f6d","0x24cd","0x319f","0x0c14","0xeb47","0xd5c4","0x21f6","0x54ee","0x3c4b","0xca03","0x17dd","0x71e1","0x20c0","0xf1e7","0x1002","0xe220","0x1fb0","0xede5","0x1ff1","0x134c","0x9141","0x3ffe","0x3092","0x212e","0xf3b0","0x52ff","0x11e0","0x43c","0x4e22","0x30","0xc04f","0x0d14","0x1d93","0xec0f","0x204e","0xf32c","0xb2ea","0xaddd","0x50b9","0xfdda","0xef99","0xe7e9","0xf907","0x4449","0x1fed","0x362c","0xe400","0xac24","0x5bcf","0x74b","0xfd41","0x1fed","0x497e","0xde2d","0x12fb","0xc04c","0xedac","0x310d","0xa525","0x62fc","0xf46b","0x1403","0x44d","0x1025","0xf102","0x1f13","0x0efb","0xf5fe","0x1492","0xddd1","0x2ce2","0x20b","0x4171","0xbc27","0x2100","0xbdff","0x1e0","0x1ded","0xd0c2","0xfb3d","0x2553","0x42c","0x3911","0x1dcb","0x1def","0xeba2","0x9f11","0xc22c","0x4265","0xf1d3","0x43e1","0xffed","0xca1e","0x2af1","0xe403","0xd0c1","0x27d4","0x0ee0","0xd123","0xef37","0x0eef","0xaf05","0xafea","0xe0b0","0x325e","0x1c4","0x211b","0x7ffe","0x30b2","0xf2ff","0x23a2","0xfe21","0xaf91","0x9130","0x9fe1","0xf1b9","0xcf10","0xd1d4","0x6103","0x2022","0x7d7","0x773","0xef27","0x0d25","0x91f2","0x5fff","0x2dc6","0xdcd2","0x939c","0x9070","0xf0e0","0x2039","0xb7e1","0xcb2f","0x1272","0x0c05","0xd0c3","0xd50d","0xcef0","0xc329","0xaaf7","0x7ae4","0x1314","0x3e","0xb2fc","0xffa1","0x3e00","0x439","0xdefe","0x0c6b","0x22e2","0xe410","0xfc11","0xfdbc","0xedbd","0xe002","0x1eff","0xfed0","0xe50b","0x1520","0xf607","0xdee0","0x3044","0xeb71","0xc53f","0x0fe2","0xe0ed","0xd451","0x3e1c","0x132","0xefbd","0x4c63","0x432b","0x3bd1","0x13fc","0xefd0","0x2ff5","0x12f1","0x221d","0xd310","0xff3c","0x1ea1","0x3eb","0x220e","0x1f10","0x9040","0xae5f","0x5acc","0xf0f0","0x1abf","0x0d0e","0xf1e0","0x4d03","0xf0fc","0x0d39","0xc50f","0xf662","0xe3c5","0x3d1a","0x2e1d","0xec0a","0xb022","0x94c1","0x69ea","0xcee1","0xb100","0x30cf","0x2101","0xf1fe","0xefc1","0x301d","0x24b","0x0b1","0x124d","0x5bf","0x22ed","0x4fd0","0x13c","0xc100","0x53ff","0x1113","0x0ed","0x903e","0xa322","0xedf6","0xbbef","0xcabd","0x1c69","0x4101","0x2d2d","0x3074","0x37cb","0x15ed","0x7dee","0x15bc","0xfb64","0x7dc4","0x2e72","0xdd23","0x3e2","0xc32f","0xba11","0x92e0","0x505b","0x24e4","0x1069","0x40cf","0xf3dd","0xdb1d","0xf9fc","0xe1ff","0xae16","0x2723","0xfe40","0xec37","0x22ea","0xf131","0xdd7e","0x2f43","0x1a47","0x2f93","0x4cfd","0xa014","0x7320","0xd716","0x750d","0xe151","0x9dfe","0xfb62","0x744e","0xc1e7","0x9092","0x33fd","0x7f5f","0x1b20","0x9bef","0xdddc","0x105f","0x90c3","0x1bbc","0xc741","0x49a4","0x221c","0x79e7","0x0f96","0x3ecd","0xc61d","0xcfe1","0x325f","0x6de2","0xeec0","0xffe0","0x3f0a","0x0f","0xb110","0xfecc","0x3416","0x5dcf","0x53e9","0x1a12","0x440f","0x4ea5","0x1042","0x6c73","0x1b2e","0x3221","0xd2e5","0xefe2","0x2f12","0xe31d","0x0c11","0x1f1e","0x2f64","0x3f0f","0x35cf","0x1ed1","0x2e0","0x43f1","0x1c6e","0x9a30","0xe591","0x4320","0xb170","0x6f5","0x9f53","0x1f03","0x140e","0x3f23","0x3321","0x73d9","0xe9c0","0x71b7","0x4f5b","0x17ff","0xee19","0xb0ff","0x4e9e","0x930e","0x4ee","0x1e4","0x7edf","0xeffe","0xd00a","0x4c13","0x3a99","0xeb0c","0xfd5f","0xb012","0xb4ba","0xaf30","0x3c34","0xbd9c","0xa14c","0x53ec","0x171e","0xd99c","0x0f12","0xd5b3","0x4c0f","0x22c9","0xe22a","0x091f","0x7622","0x1de","0xb17d","0xb00e","0xde70","0xdf91","0x3f4e","0xe31b","0x9c2c","0x2e4e","0x32f4","0x3963","0x29f0","0xea9c","0x7029","0xeadd","0xd3e2","0xfcc2","0x5f1","0xb3ab","0x5f53","0xfb04","0x0f17","0x1910","0xe511","0x3fc","0x2fc4","0x1031","0x7b01","0x5203","0xa03b","0x5031","0xc00f","0x5be1","0xe3b9","0x3d6","0xbf34","0x3263","0x1e0","0xedc0","0x3bcb","0xeeef","0x2fa4","0xed01","0x21d1","0x1043","0x500d","0xbe4c","0xb310","0x5b11","0x2fdc","0xd522","0xa225","0xf2df","0x0fbf","0x9f61","0xbce5","0x6b0d","0xe7d1","0x0a4d","0x3d5f","0xeff1","0xd7b7","0x7606","0xb6e7","0x7de4","0x7c99","0x772f","0xd413","0xf30d","0x4300","0xb1ed","0x1345","0x224d","0xc40f","0x13de","0xd11e","0x3cde","0xdfad","0xeee1","0xdd03","0x31cf","0x2c14","0xe3dd","0x3d10","0xf102","0x20f1","0x104","0xed0b","0x2bef","0x0d71","0xec0e","0xb2d1","0x21d0","0x2373","0x3001","0xf2ea","0x12d3","0xfdfa","0x262c","0xf20d","0x1224","0x61a4","0xa01f","0xece7","0x1a31","0xe153","0x3eaa","0x94ec","0x2092","0xf624","0xe122","0xc390","0x7e03","0x11d2","0x71db","0xdd4b","0x2f2","0xc2d5","0xc3f5","0x36fc","0x3f34","0x122e","0x60b5","0xc111","0xe2fc","0x7de3","0x2016","0x9b0e","0x3ff1","0x1600","0x1e22","0x0eab","0x1fcd","0x3302","0x5ce","0x12a0","0xe5e2","0x9dff","0x6e2a","0x103f","0x2112","0x40df","0xcedb","0x4010","0x2fd4","0xe3ef","0xdfe1","0xeb90","0x53e9","0x5271","0x7000","0xb312","0xf0a0","0xf995","0x9e09","0x5fc9","0xdb02","0xff76","0xfb0f","0xcc3f","0x7eec","0x0ed","0x403e","0x10ff","0xb123","0x13ef","0x7253","0x121","0x1db0","0x1d92","0xeb0d","0x2feb","0xf0f0","0x1f7d","0xe044","0xe94e","0x7211","0xef1e","0x3f2d","0x13b4","0xebab","0x5efe","0xfaed","0x211e","0xffc0","0xd2cd","0x12e9","0x347b","0xfe19","0xeeda","0x71fb","0x30d1","0x913c","0xd1ef","0x1f11","0x121f","0xb1bc","0xf1b6","0xeb01","0x1052","0xf264","0xe0fd","0x3ec","0x621d","0xff2c","0x54c","0x4015","0x1a","0x41c3","0xe5f3","0x6d6f","0xb11b","0xeeed","0xffb4","0xe9d1","0x4efe","0x1435","0x12da","0x20fd","0x11fc","0x439b","0x0f4e","0x0e25","0xfcd9","0x100","0x1421","0x7b31","0x2fc","0xdf2c","0x0e11","0xfff2","0x71af","0xd11c","0xe1fe","0x4fc0","0x2076","0x444e","0x21f0","0x145","0x2ed1","0x2ee","0x50d5","0x1d0c","0xb62d","0x4367","0x1271","0x64eb","0xed71","0xb520","0x6c27","0x3fd3","0xe134","0x46f0","0x3107","0xc61d","0xfa1f","0x7eee","0xd6bc","0x3711","0x49ec","0x1129","0xf09f","0x1d1e","0x61ff","0xf2ee","0x9020","0x3be0","0xd0cb","0xdf3d","0x3b2e","0xb11a","0xc91e","0x935f","0x2f1c","0xdaf0","0x1df0","0x32c2","0x9d24","0x261c","0xebf1","0xf1cc","0xefb5","0x2b20","0xfd11","0xee13","0x1ff7","0x1f3c","0x5b1b","0x4117","0x55a2","0x2f10","0xeec0","0xf2c1","0x264","0x327f","0xfded","0x2da9","0x7c9c","0x0e99","0x107","0x31c1","0x1013","0x4f43","0x9444","0x0e44","0xabd5","0x33e1","0xc642","0xe0e3","0xe310","0xb0f1","0x59a5","0xffb9","0x3ddb","0xf3ac","0x4e45","0x11de","0x0dd4","0xfc3b","0xbf31","0xbb05","0xfbe5","0x3102","0xf903","0xa221","0x349e","0x100","0x306e","0x304f","0x90dd","0x6d11","0xf02b","0xff2f","0x1290","0x35b1","0x5931","0x9fd5","0xdd23","0xe139","0x49d6","0x43a","0x2990","0xced0","0x1120","0xb679","0x94cd","0xb42d","0x5fb9","0xfa0f","0x1f2d","0xff1c","0x1a0f","0x93eb","0x1eaf","0x93ff","0x13c3","0x51a2","0x12e5","0x2921","0x0b","0x3fdc","0x1f","0x50ef","0x4341","0x430e","0x0cf2","0x1511","0xee40","0x422","0xf464","0x3d3","0x1c5d","0x1de1","0xb034","0x145d","0x12fe","0x1c23","0x7d4e","0xa0d9","0xad00","0xdd27","0xecbc","0x3204","0x766f","0x200e","0x1e3d","0x30ff","0x3be4","0x90ac","0x4fd2","0x1fc1","0xfc40","0x2a21","0x11f9","0xc10a","0xb001","0xb4cf","0xe370","0x4207","0x574e","0x6f09","0x0ff2","0x2110","0xf072","0x91fc","0xe2f1","0xf220","0x101e","0xe47b","0x23ef","0xc10c","0xa134","0x9fcf","0xfb33","0xf90c","0x1fd0","0xee02","0x62c3","0x317f","0x2e2b","0xfd74","0x0d10","0xc332","0xe352","0xcf1f","0xec42","0xe7f3","0xe0df","0x320e","0xfaa4","0xa0cb","0xec00","0xf2ec","0xd503","0xc01e","0x9b9d","0x9114","0x0e70","0x7771","0x22e0","0xe0ff","0x4c47","0xdb3c","0x1f03","0x3951","0x5b12","0x999b","0xd2e3","0x9dae","0xff9f","0x4aee","0x102c","0x7ef6","0x0c6d","0x73df","0x5011","0xe3c5","0xff20","0x6fde","0x3e03","0x46e4","0x4cc7","0x162b","0x2ffc","0xcb41","0xeb71","0xec13","0x243e","0xee2d","0x33ef","0x7901","0x2c3e","0xbd55","0x4ff0","0xbf7e","0xeef3","0xf101","0x1207","0x7224","0xecdf","0x7e32","0x1ef1","0xf5e2","0xfee9","0x2cd3","0xe250","0x7a73","0xc2d1","0xc0c3","0x3217","0x1edc","0xe22d","0x626e","0xe2f7","0xe21d","0x3ef2","0x921c","0xcf0c","0x1970","0xdc19","0xd1d3","0xe4df","0xe19f","0xdd03","0xd0fd","0xff3b","0x35ce","0x0bf1","0xab0c","0xf0f4","0xea62","0xffe7","0x9cd7","0xd0d1","0x1b2f","0xcc1c","0x9da4","0x10","0xe150","0x37","0xe2b2","0x2fe1","0xeff2","0xca41","0x1104","0x324","0xa1f3","0x4206","0xf315","0x0fed","0x0ed2","0xf3f1","0xbee1","0x35f1","0xfbe3","0x303","0xf03f","0x9309","0xd210","0xec5b","0x920d","0x2120","0x3034","0x5152","0x7520","0x11bb","0xceff","0x3303","0x310e","0xef21","0xeff0","0x10ee","0x41fe","0x21fd","0xcb1f","0xfc01","0xc230","0xc4d5","0xf4f2","0x5251","0x35fe","0x292b","0x10ce","0x4149","0xcce1","0x0cd3","0xddcb","0xeff3","0x0b43","0x15b3","0x0ff","0x1f2","0x32e","0x3fce","0xf130","0xf404","0x31e","0x5f9c","0x70dd","0x59","0x140","0x307","0xc9de","0x3c1c","0x1d7f","0x56f2","0x34b0","0x7171","0x550a","0xe14d","0x4ef4","0xf241","0x107e","0x13eb","0x6df1","0x1000","0x4f0","0x400d","0xcaa1","0x1002","0xfb5b","0x1fbe","0x1e09","0x16c1","0xf2f9","0x114f","0xfae0","0x512","0x43","0xc134","0xff03","0xf9f5","0x524d","0xf011","0xc14d","0x3052","0xe544","0x13ee","0xb21b","0x2f4f","0xf4f0","0xdfd0","0xefa1","0xf14f","0xdfc9","0x212d","0xeb34","0x391","0xf0c2","0x51e2","0x1e1e","0x135c","0xf154","0x5223","0xbd0c","0x20fc","0xe5fd","0xcb30","0x0dfe","0xef02","0x3dfe","0x2e2a","0x0c2f","0xc69b","0xef01","0x411","0xaaee","0x303c","0xcffd","0x711f","0xfcfc","0xf3c7","0xdfc1","0xda74","0xd6f3","0x2f0f","0xeb2e","0x2be0","0x327e","0x611e","0x3f21","0x1e02","0x2de0","0x1f51","0x0bd","0x624","0xeeee","0x6b3a","0xf743","0xb013","0xfcbc","0xff2c","0xc01c","0xeae1","0xadff","0x7273","0xfd9f","0x16de","0x0a1c","0x4273","0xf2f5","0xf6d1","0xfe9e","0x5142","0xf02e","0x132e","0x100e","0x55ef","0x31d1","0x1565","0xe430","0xc4e3","0xf1bc","0xeb12","0x2f10","0x3d25","0x3fbd","0xfe10","0xfe21","0xe4fe","0x2e","0x21a0","0x9c0e","0x6dff","0xd12c","0x4240","0x4322","0xfcf9","0xf9a1","0x3ff1","0xf02f","0x1b17","0xf07d","0x20f0","0xc349","0xc01b","0x1def","0x10c9","0x41ee","0x1efe","0xe0fb","0xeac0","0xe1fa","0x0f1b","0xfae1","0x1105","0x3b40","0x11e","0xab02","0xfb01","0xceda","0xde0d","0x1b90","0x4afa","0x0dd2","0x12f3","0x7a54","0xbef6","0x2e10","0x3de9","0x20d4","0x6f20","0x2c2d","0x241d","0xc9d3","0x1924","0x459b","0x5dde","0x20f3","0x60eb","0xfbef","0xfff3","0xac13","0x9eee","0x2ff","0xf020","0xc139","0x0fd0","0xbd30","0x5dd","0x1546","0xf01b","0xff23","0xbdc1","0xcef2","0x1fd3","0x3e11","0xdd41","0xff12","0x2f00","0x3f23","0x0d0e","0x4c7","0x162c","0xe3e2","0x275","0xe2b3","0x0fe7","0xff17","0xe211","0x63d0","0xff1e","0xf001","0x110e","0x3127","0xf01f","0xf7f2","0x09a0","0xe40a","0x3fb4","0xf045","0x274f","0xf190","0xcf1c","0xfeae","0x45dc","0x4f00","0xeb9c","0x1410","0xca6c","0xc1fa","0x3bc","0xef03","0x0f30","0x210","0x091b","0x312c","0xf391","0x44c4","0xf4f3","0xc1f0","0x413d","0x0fcd","0xb294","0x51e1","0x9fe0","0xcdfe","0x12d9","0xbe90","0xd2f9","0x342e","0xdf00","0xf40d","0xeeb1","0x6300","0xff7e","0x0eef","0xf3f0","0x9ccf","0x124e","0x0e1","0xd0ec","0x11d4","0xe169","0x9ff0","0x540f","0x1510","0x11e0","0x0eed","0xccc2","0x0e14","0xdd3e","0x130e","0x2cd9","0x22ef","0xd00c","0x2ff7","0x4f3f","0x40b3","0xee1a","0xe4e1"},
{"0x40ed","0xd1ec","0x2620","0x2201","0xffa0","0xe260","0x1db6","0xe0f1","0xd272","0xf255","0x3f1e","0x1dc5","0xc6bb","0x7522","0x1db0","0x1e13","0x6993","0xa73e","0xcbb2","0xf91f","0x10fc","0xb2e2","0xfeb0","0x173b","0xdcd4","0x3141","0x1ade","0xe0c4","0xeded","0x3f71","0xc19e","0xe712","0x44eb","0xe412","0x2f0","0xebdd","0x77ef","0x113d","0xf7dc","0xef32","0x0ef0","0xb3de","0x4012","0x372c","0x4c14","0xfbed","0x5cb3","0xfb1d","0x143e","0xc0e7","0x0e12","0xedf0","0xff05","0xd030","0x1001","0x0ab1","0x50f","0x13bd","0x3f03","0x12c9","0xfd4d","0x1174","0x11cd","0x4e2f","0x2235","0xea32","0xf033","0xbd37","0xf104","0x2c2c","0xf3ef","0x0f03","0x2e2e","0xf70b","0x5e","0xc01a","0xfe11","0xe173","0x40d3","0x302e","0xef14","0x2e2","0x9b45","0x2bf2","0x132b","0x42fa","0xf232","0x304f","0x1bff","0x1d10","0xce4c","0xc64d","0x30","0xd223","0x3290","0x4ccc","0x9f0f","0xe05d","0x4fdd","0x13b3","0xe7a3","0x3a1a","0xc70b","0x1e17","0x144b","0xd44e","0xa72a","0x1f10","0x5461","0x2f75","0xbdc4","0xb1c2","0x1124","0x3c0f","0xf62d","0x320e","0xb4b0","0x1c34","0x72e","0xda03","0xf351","0x9b2c","0x375d","0x16e4","0x4303","0x13d","0x6b70","0x3b9e","0xc9d2","0xceb1","0x0fee","0x620c","0x544b","0x9e43","0x0c00","0xc734","0xed4f","0xaccb","0x260c","0x5e31","0xb394","0x7fcf","0xf40c","0x0c9d","0xf416","0x10fe","0x0c1f","0x9f12","0xee34","0x3344","0xf94e","0xddcb","0x1d01","0xab2e","0x1a90","0xe04f","0x0a1f","0x6531","0x160e","0xedb2","0x2f9e","0x30e0","0x1e51","0x7a30","0x1df2","0xeedf","0x6b02","0xe6bc","0x0ed4","0x0b7d","0xe2a1","0x2d2d","0xd01a","0x30df","0x12ef","0xceb2","0x32c2","0xb114","0x5bb2","0xd4e3","0x0ecd","0x5f10","0x0dbd","0x10b","0x3dff","0x20df","0xdfde","0x91e1","0x0c4b","0xf1ff","0x2cef","0xdf1f","0xdd31","0x23d9","0x600","0xdf22","0x1343","0xfcc7","0xe949","0x0d14","0xc205","0xfe23","0x613e","0x7eff","0x0ef0","0xff01","0xf37d","0xbef1","0xe32e","0x0da6","0x22","0x73c2","0x4347","0xdaa2","0xda57","0x93fe","0xcd33","0x47c0","0xfd39","0x990d","0xb61b","0x72fc","0x249c","0x17f1","0x43ff","0x5523","0x705","0x9214","0x7dd6","0xeacb","0x372c","0x7107","0x327f","0x13e1","0x30f6","0xeb02","0x2f52","0x727","0x449f","0x21e2","0x4205","0x6331","0xe522","0x5f22","0x11c4","0xcf27","0x1f0c","0x1002","0xf3f1","0x36ae","0xc52d","0x4e2b","0x222c","0xf0e2","0x4f66","0x40a3","0x0d50","0xeec2","0xf3c4","0x7eec","0x3dd","0xe937","0x502f","0x2044","0x2f15","0xf3e3","0x2061","0x60fd","0x131f","0x71f2","0xc054","0x11ef","0xc05c","0xc002","0xd223","0x5f9","0xf3c9","0x1007","0xf371","0x3e22","0x4f42","0x1000","0x612","0x74f7","0x1331","0x3d12","0x115d","0x1f1","0xcfbd","0xf0ff","0xa31e","0xc1c2","0xedfc","0x6134","0xee1b","0xcee1","0xb0a1","0xe2c1","0x3cf","0xc2fb","0xc013","0xf24e","0x14f7","0x21c1","0xc2be","0xf1f5","0x500f","0x59e","0xfe3f","0x650","0x3400","0x0c51","0xe297","0x0e9c","0x1574","0xfdf5","0xa351","0x342","0xff06","0xd000","0x0dd3","0x100e","0x463f","0x7051","0xeef1","0x4d12","0xfcb7","0x0afa","0xf0ef","0x5dd2","0x3ffc","0xf2e1","0xf553","0x344d","0xdf6b","0xf453","0xe5c0","0x541f","0x2d0","0xf43d","0x121c","0xd1e3","0x3db5","0x1111","0x1094","0x2c","0xfd40","0x204f","0x0cde","0x2351","0x1440","0xf33d","0xe41b","0x31f4","0x0c71","0x713d","0x4143","0xa300","0x1074","0x9d1f","0x1db4","0x116f","0xce90","0x401","0x360e","0x149","0x0edf","0x2f1f","0xe60d","0xf0d2","0xba50","0xa6f3","0xedae","0x22f3","0x5e7f","0x1114","0x1222","0xdb01","0xf1fe","0x5402","0x5421","0xce1e","0xbc4d","0xe0f6","0x34c9","0x5d2c","0x3213","0x44f3","0x3c0d","0x457a","0x0f0d","0xb3ae","0x9044","0x0d3d","0x1ffd","0x3031","0xbde0","0xcaa1","0xb012","0x21cf","0x313d","0x191d","0x200","0xd3b0","0xdd32","0x50d0","0x5d30","0xf1ce","0x9ff0","0x2e00","0xf61d","0x2b04","0x31c1","0x9efe","0xa17a","0xded3","0x4cad","0x0b60","0x1e13","0x5ebc","0xdf52","0xe1dd","0x0cf1","0xebec","0xc009","0x2d11","0x17fc","0xd2a4","0x5209","0xddef","0xef50","0xcfef","0x3d1","0xcdf1","0x1a11","0x9ce0","0xe736","0x6feb","0xc4a3","0xbdc3","0x400e","0xf232","0xdd0f","0x10bf","0x3f19","0x131","0x9ee2","0xfd13","0xe631","0xd403","0x9bf1","0x902f","0x1133","0x121b","0xc2f3","0x1374","0xef09","0xd11d","0xd90b","0xde95","0xedce","0x20c","0x41cd","0x1deb","0x361c","0xc132","0xa7f2","0xf4e0","0x2b1f","0xb2fd","0xe0ee","0x2d5d","0x3d12","0xf63e","0xef11","0xc4c1","0xdde2","0x2cd0","0x2dfe","0x6e1f","0xf432","0x3631","0xf511","0xbc22","0x3efd","0xc642","0x2dff","0x14ff","0x405d","0x225c","0x32ae","0x2012","0xa2ae","0x6a5f","0x16f9","0x6ba7","0xfb4d","0xef0d","0xede2","0x211b","0x2ff","0xcf3d","0x0912","0xef0e","0xf2dc","0x105c","0xf13f","0x2ae1","0xdfb9","0x2c50","0x913e","0xfdf5","0xeb3f","0x0cfb","0x203","0x2d0","0x6209","0x9ce0","0xe3ee","0x0fcd","0xdd63","0xe20d","0x3f5e","0x4d46","0xc3cb","0x2bde","0x1df6","0xf3d2","0x11e2","0xc3f1","0x1df","0xd1fd","0x301b","0x1379","0x0c52","0xf32f","0x2ebb","0x0ddc","0xf0fc","0x3ef0","0xe3d0","0x4eb0","0x1ff2","0x1302","0x3fb0","0xe600","0xdcde","0xc2bf","0x224b","0xce29","0xde42","0xc122","0x32d3","0x3140","0x10df","0xed00","0x435b","0xce2b","0xfda7","0x166d","0x0e22","0x0d","0xe3f4","0x0fee","0x22f3","0x299b","0xef2e","0x30b","0x32ff","0xe30f","0xa1db","0x420c","0x2370","0xf500","0x4101","0x442f","0x0d01","0xd1ff","0x0c1d","0xf11e","0xec15","0xfd04","0x0e05","0xfc1d","0x1101","0x2b2e","0x1025","0x2df2","0x42fe","0xbacc","0x1e13","0xc430","0x21e0","0xffef","0x942f","0xef60","0x09e3","0xecce","0xfde2","0x12d3","0x24cd","0xfc2e","0xbfcd","0xcd1b","0x3c51","0x9ed6","0xf20e","0x1c32","0x251","0xf114","0x4ce","0x2d4d","0x0cdf","0x2f92","0x1c6d","0x31f1","0xfeec","0xdde2","0x5f00","0x0b93","0x6e13","0xff32","0xe1fa","0x40a2","0x4eb0","0xefe0","0x302e","0x201d","0x0ce0","0xf5f9","0x09ef","0x3e2f","0x41e0","0x3e1c","0x52cf","0xe0f2","0x90d0","0x2e15","0xf491","0x2ed0","0xd4ed","0x7f1c","0x3d7d","0x40c4","0x5e2b","0x2ee3","0x491f","0x9b0d","0xf0b2","0xd9fd","0x5061","0x6e21","0xd616","0x7dfb","0x1479","0x2bf1","0x2f12","0x6e61","0xee7e","0x7021","0xff31","0xecf5","0x0e76","0x1216","0xfef5","0x1f1","0x5353","0x421d","0x7e0","0x70c4","0xed71","0x4c1f","0xfb77","0x5f4f","0xc14e","0x25dc","0x0dbb","0x6d99","0x1123","0x4e03","0x0edd","0x1c","0xb21d","0x4d1c","0xf735","0x4215","0xda30","0xe011","0xc325","0xeecd","0xe1c0","0x200d","0x2ab","0x4b9a","0x43","0x3130","0xf60f","0xe2dc","0x21eb","0x2afa","0x1320","0x0e50","0x4eed","0xd002","0xef0f","0x0fd3","0x0e07","0xeef0","0xd5a3","0x0b99","0x3cd4","0xf021","0xf3d4","0xebd4","0xacdf","0x135a","0x9ee4","0xc026","0x2ea2","0xe313","0x4057","0x3d0","0x40eb","0xecdd","0x0cbb","0xac0e","0xc701","0x0eef","0x30ff","0xcd77","0x462f","0x52bc","0xb5f4","0x4332","0x5e65","0xeeed","0xe2f1","0xbfc1","0x36e0","0xd3c4","0xe104","0x9f3a","0x110","0x29","0x4c5f","0xa943","0x1ee","0x1d0","0xcfff","0xce44","0x0ea0","0x10c2","0x144","0xc0d0","0xf4f0","0x11f3","0x4c1b","0x207b","0xede0","0x33d9","0xd003","0x122","0xcdd1","0x1bb3","0x4bf","0x3422","0x11fe","0x203d","0xd12c","0x0f3e","0x9f32","0x3012","0xae6f","0x10eb","0xe92e","0x3cd3","0xee90","0x33b3","0xc7b3","0x2fc1","0xd9de","0xfe03","0xac19","0x15fc","0x329c","0xe04f","0xadef","0x13d1","0x193c","0xf21e","0x1c42","0xdfd4","0xae0e","0x33d1","0xf5c1","0xccf2","0xbdd2","0x2efd","0xcedd","0xf1eb","0x1ec2","0x0d13","0xc1f3","0xeff1","0x39c0","0x11f9","0x2de2","0xedd2","0xf111","0x30ec","0xd003","0xf9c3","0x5ddc","0xd100","0x0ea","0xd0ff","0xed0b","0xee60","0x6c9e","0x4ff","0x417f","0xef17","0x1b7d","0xcf1d","0xeecb","0x2a00","0x2e9c","0x40cd","0xef30","0xddfb","0xe14c","0xc01f","0xbb3c","0x9d27","0x1d9c","0xaf21","0x3661","0xd0f7","0xfa7b","0xd2f9","0x4a0a","0x6252","0xf7a3","0x75e3","0x223f","0x0c2a","0x0e09","0x3111","0x2f07","0xaff4","0x21fd","0xe1bf","0x520","0x5bde","0x204c","0xc91d","0x19ed","0x1ed0","0x3b1c","0x7c15","0xd21b","0x1111","0xeb2b","0xc11f","0xcb9d","0xecef","0x0e1d","0x1b05","0x113f","0x1fcb","0xbb21","0x4aff","0xe2c2","0x102b","0x5aec","0xe9d9","0x1f3d","0x90f9","0xfd3f","0x1f10","0xd99c","0x422d","0xa9ce","0xeee0","0x112e","0xe1a9","0x0f10","0xccff","0xcd9b","0x31bf","0x1bee","0xdc0c","0xe01c","0xbefa","0x0f1","0x2df0","0xa9fb","0x1f","0x090e","0x10fb","0x172f","0x92a1","0x0cfd","0x0fcc","0xacc2","0x29d","0x29df","0xea1f","0xb3cc","0xa3c9","0x0e3f","0x2914","0x1fd5","0xfea3","0xb32e","0x7001","0x1f72","0xfd26","0x2d53","0xfdff","0xff45","0x1f2e","0x1212","0x452","0x6b1e","0x5f3d","0x0ed3","0xfc0c","0xe06e","0x3c77","0x3c03","0xbd1e","0x3373","0x1e05","0xef2e","0x3e11","0x23ef","0xe0b0","0x1ca2","0xa40d","0x1c21","0xaade","0xbf01","0xac03","0x1e9b","0x2f3d","0xfccc","0x432e","0x2122","0xfef3","0x3d50","0x9dbd","0x10de","0x34e","0x2dd6","0x931c","0x3ccf","0x9ed9","0xf5ff","0xfdf0","0xeef2","0x3174","0xe134","0x7ffc","0xdb14","0xb9d1","0xe102","0x11ed","0xd4f4","0x23ce","0x7c43","0xdbf3","0x103d","0x275","0x27e0","0x1020","0xf451","0xce94","0xe0bf","0x2d2e","0x1e91","0x1f34","0x671b","0x194f","0x5ff7","0xe219","0x1dde","0x7b21","0x7560","0xbd04","0x3e07","0x3d4","0xd544","0x3003","0xcb22","0xbd31","0xf9d3","0xd3dd","0x24ce","0xe22c","0xfa05","0x42bf","0xabb4","0x4f2e","0x1244","0xa912","0xe411","0x4","0x2246","0x91b5","0x2ce1","0x1ff","0x5e54","0xc1d0","0x2333","0x9e1c","0xf103","0x3eff","0x36ff","0x5f17","0x5722","0xf301","0x0e07","0x501b","0x1290","0x1022","0x702","0xef40","0x0e4c","0xf011","0x65bc","0x9001","0xe2ef","0xf910","0xc406","0x5254","0xd211","0xb1cf","0x0ff5","0x4e10","0x733","0x3e2d","0xe1de","0xe033","0x0ce1","0x341b","0x0ce","0x9f4f","0x203","0x114","0xde55","0x320d","0xbf00","0xb6ee","0x463","0x21e","0xed0c","0xf10d","0x7ff3","0x73b1","0x309e","0x0909","0x5a12","0x5044","0x905e","0x2f22","0x0b69","0xe106","0xa544","0x6d12","0xe0cd","0x711a","0x3bf7","0xfbed","0x7701","0x1f00","0x1e23","0xc97c","0xfa3d","0x30b6","0x902f","0x0cee","0xdc3c","0x6010","0x424","0x4fe6","0xd24f","0x7251","0x2b00","0xeeb1","0x1d13","0xefe1","0x3f10","0xbe30","0x0edc","0xd00b","0xd10f","0xcdc4","0x1d2f","0xe11f","0xc14e","0x4c1","0x344","0xfa34","0x4de2","0xad1b","0xd900","0xdf4f","0x33ee","0x2f0d","0x0f0","0xe311","0xfebd","0x0acf","0xe0cf","0xd20f","0xdcf1","0x35dd","0x1c0e","0x2f0","0x3092","0xdf93","0xe11d","0xc230","0x3e5f","0x11cc","0x0d7d","0x7136","0x1e2d","0x29dd","0xefd4","0x9f0f","0xf01e","0x40e","0x2ecf","0xee4d","0xef5f","0x2f44","0xfb1e","0xf332","0x2114","0x14f4","0xe55d","0x53b3","0x2e0f","0xd70e","0x3cb1","0xf1fc","0x4ef4","0xe210","0x0ece","0x1d50","0x3fed","0xf0f6","0xc2f2","0xce1f","0x1022","0xffc7","0x097c","0x11ce","0x22a1","0x2154","0x55e9","0x2e22","0xb023","0x92f3","0x9fc1","0xed22","0x10cc","0x1dc0","0xcd3f","0x1f0e","0x1e2","0xfe97","0xedea","0x20b1","0xdefd","0xa000","0x23a3","0xcf93","0x1f72","0xd1e9","0x0cd","0x0ae2","0x1ffc","0x11e1","0xe101","0x39d3","0x325","0xf5dd","0xfef2","0xe2fd","0x1e1d","0xee7d","0x1f05","0xcce1","0x2172","0xbf0e","0xe2ff","0xea60","0xdcf6","0x9f90","0x222e","0x1b42","0xe304","0xd2b0","0xdf49","0x0f1c","0xda10","0x1f27","0x2ee1","0xee07","0x5fed","0xc00d","0x4fcc","0x0f44","0xf017","0x350d","0xebce","0xffc4","0xe506","0xd45e","0x1f9","0xa2ff","0x2a0c","0x9db3","0x4e21","0x2a96","0xf14b","0x7e0b","0x0a1a","0x4fb","0x4012","0x11ef","0xf02a","0xe1b5","0x11bb","0xd2f2","0xfede","0xf600","0xec10","0xd41f","0xd21f","0x1a0","0x661f","0x56c2","0x195d","0x22ab","0xda1a","0xead6","0xcef3","0xafff","0x2201","0xda6b","0xf3df","0xc9e9","0xcc10","0x0c1","0x10ae","0x11d2","0xd313","0x3000","0x5b90","0x7e2e","0xfd35","0xddaf","0x2ff","0xc92c","0x3e21","0x0a7c","0xf3bf","0xd7bb","0xcd6e","0xd2bc","0xf6ec","0x6fd3","0xf252","0x60d4","0x21f5","0x313b","0x5de1","0x2e3","0x2fde","0xcafc","0x7924","0x21ec","0x15d6","0x2efa","0xfdbe","0x3f0d","0x10ed","0xcf1e","0xf134","0x3932","0x14c6","0x55f3","0x1cf6","0x0fce","0xed5e","0x5a31","0x4a1b","0x91f0","0xebe0","0x26df","0xef3c","0xc2fa","0xeed2","0x3e0d","0x1010","0x21ea","0x4f59","0xca12","0x2edf","0xf066","0xdcd2","0xdde1","0xf9d9","0xcf1c","0xfcf4","0x1e0","0x50fd","0xf01f","0xf2e7","0xef5f","0xe5d6","0x4fb7","0x1d13","0xf21f","0x1db4","0xf0b4","0xeafe","0x9a29","0x2d09","0x36e","0xd492","0x317c","0xf6d3","0x7ed0","0xd230","0x355d","0xce03","0x95e1","0x5fc2","0x3100","0x0c10","0xfccf","0xeee0","0xe1d2","0xd333","0xdd3e","0x17fd","0x11d3","0x5439","0xb3fe","0x401f","0xf9cb","0x7cdf","0xbe1a","0x2a","0xea0c","0xcd05","0xfd00","0xa711","0xf60d","0xa20f","0xae75","0xc173","0x1014","0x2f29","0xd91e","0x500e","0xc952","0x2b32","0x1065","0xf14f","0xc02d","0x22ff","0xc5e0","0xc932","0xf200","0xec19","0xb510","0xaccd","0x0c2d","0xfa0d","0xe902","0xeedd","0xccf0","0xdd31","0x2220","0xdbe4","0xc1b5","0xc4d9","0x0eef","0xd211","0xbd01","0x5304","0x1e73","0xcd7f","0xd016","0xb32f","0x34d2","0x0c3d","0x0cee","0x20f2","0x13cc","0xd310","0x312d","0x9d3e","0x33e0","0xf4cf","0xed44","0x40e0","0xc9ff","0xf2c2","0x0d9d","0xec2f","0x2095","0x6c0b","0xff20","0x5ea0","0x2bff","0x0f20","0x2334","0xcedb","0xd3a2","0x5523","0x2d2f","0x102c","0xebb0","0xe0f1","0x492","0x4122","0xed13","0x10ac","0xcdf2","0x73df","0xeace","0xfcce","0x1f23","0xfbcf","0xffde","0xd024","0x1d11","0x42ed","0x1eb1","0x42ec","0xe2bc","0xaf51","0x31e1","0x2f91","0x2d0d","0x1e32","0xd220","0x0dce","0x3115","0x1ac2","0x221c","0x112","0x4e2","0x0e1","0x1daf","0xe00b","0x54d0","0xdf3c","0xeee0","0x1ce1","0x2efe","0x212f","0xff13","0xf1d1","0x114","0xcb0e","0xee0b","0xfbfd","0x100c","0x200f","0xb29a","0xf1df","0xe29b","0x0d","0xadfc","0xecd0","0xdfb9","0x5ced","0xeddb","0x0cef","0xed12","0xf361","0x2e10","0x996e","0x336a","0x1042","0x519f","0xd24e","0x71f5","0xff5f","0x1c1e","0xd3c9","0x22e1","0x9b5e","0x900d","0xc269","0xa090","0x1e3e","0x3b1d","0x1edf","0x742d","0xe502","0x52ae","0xf05e","0xde09","0xc159","0xac11","0xc40e","0xd6e0","0xe2b1","0x5014","0x3f19","0xd09c","0x23f7","0xfadb","0xd302","0x10fe","0xe310","0xffa3","0x097e","0x13f2","0xfc3a","0xcfeb","0x965a","0x7f33","0x60c4","0x71e3","0x0c39","0x1ebe"}
}
};
const ap_int<12> conv_4_inc_new[2][32]=
{{"0x417","0x307","0x280","0x2b5","0x222","0x378","0x32c","0x2be","0x1ff","0x318","0x2b4","0x270","0x2df","0x318","0x2fe","0x201","0x203","0x25b","0x244","0x34d","0x362","0x285","0x24d","0x45d","0x2e9","0x63a","0x240","0x275","0x242","0x284","0x3d8","0x412"},
{"0x262","0x2b5","0x2a0","0x2a2","0x1d6","0x1eb","0x285","0x29b","0x2cb","0x243","0x46c","0x308","0x282","0x238","0x295","0x285","0x321","0x2d6","0x54e","0x23f","0x24c","0x258","0x27d","0x273","0x2d0","0x2f7","0x324","0x322","0x24a","0x36d","0x1eb","0x2af"}
};
const ap_int<20> conv_4_bias_new[2][32]=
{{"0x1d5b0","0x08e48","0x11d45","0x11d4f","0x0c042","0x33538","-0xae18","0x33074","0x263ff","-0x1461","0x155cb","0x1e824","-0x95bb","-0xded7","0x48e27","0x2cb5c","0x340e9","0x09a24","0x12e82","0x36d00","0x18b60","0x0b2fc","0x2fca2","0x31da0","-0x4ad","0x358c1","0x1b6c7","-0x1f0f","0x4182","0x27fa5","0x32495","-0x2d53c"},
{"0x1b75d","0x0d6a0","0x09dd2","0x772e","0x1c0b0","-0xe556","-0x46a8","0x1289e","-0xed4d","0x756a","-0x32be2","-0x1f6b","0x1a630","0x184f8","0x16b7","-0xec62","0x0ae9","0x2172c","0x525cd","0x0bd71","0x095c","0x19016","0x0ab","0x1857d","0x19db7","0x26a60","-0x103b6","0x37078","0x0bcb2","0x0a19","0x734b","0x1da3e"}
};
const ap_uint<16>conv_5_w_new[2][3][1536]=
{{{"0x30f2","0xeb0a","0x0f03","0x10de","0xf111","0x1fbb","0xfd9d","0x3cd0","0x1ef","0x0fd","0x114","0xeddc","0xfcf1","0x7d12","0x1dd","0xef94","0x14f7","0x4dd","0xd2e4","0x0c62","0x613f","0x1fdc","0x91e2","0x335f","0xb013","0x31cc","0xc254","0x0d7e","0x0b0d","0x5da4","0xff3a","0xf590","0x6e93","0x9a2f","0x94e4","0x40f5","0xd91a","0xdef2","0x11fb","0xa2cf","0xfaf1","0xf90d","0xfaa4","0xb7bf","0x25df","0xa191","0xdcee","0x20ad","0x331d","0xce1e","0xd0f0","0xfd3c","0x2d3b","0xe10d","0xf0de","0x0f02","0x532e","0x4030","0xe2d5","0xe152","0xf71c","0xfee3","0xdd41","0xe303","0xe091","0x32e2","0x2e02","0xfc07","0x9123","0xeeb0","0x6bfd","0xdc04","0xef13","0xe02c","0x6b20","0x322","0x65ff","0x4a2f","0x0eb3","0xf5c2","0x13bb","0x20ae","0x3dfd","0xee33","0xc002","0x4044","0x10bf","0xd205","0x12ec","0x2d10","0x2301","0xacc1","0xe0df","0x3b1d","0xefb4","0x22e4","0x651","0x37e","0x4c39","0x6f43","0x1d19","0x443","0xeef6","0x146d","0x4491","0x3230","0xe553","0xde6d","0xbc65","0x31f0","0xb49c","0x2071","0x2a19","0xd370","0xdeec","0x9d12","0x41b","0x2df4","0x6ee2","0x2730","0x109","0x6c3b","0x1344","0x5405","0x0e35","0xa129","0x3311","0xdf31","0x40aa","0xf2d0","0x950e","0xd106","0xce2a","0x2e24","0x2b91","0xdd16","0xce42","0xfc10","0xbffe","0x3d0","0x1d7f","0xb2fa","0xb43f","0x0c0e","0xbd23","0xcfdc","0xe391","0x630d","0xcba1","0x75a1","0x3e03","0x9f7e","0x6051","0x1160","0xd39e","0xd200","0x365d","0xc27d","0xff23","0xed11","0xcff2","0xd01f","0x6fad","0x1219","0xf100","0xe52f","0xbfee","0xc37d","0xdded","0xe614","0xfc3f","0xea0f","0x13cd","0x5a2d","0x1ed2","0xfc09","0x9632","0xa4b1","0x094e","0xa2d0","0x2711","0x41f1","0xfbaf","0xb272","0x134b","0x6be","0x0b0f","0x7caf","0x12cf","0x0992","0x3f2f","0xab01","0xb7a6","0xbe30","0x92c2","0xe42e","0x9dde","0x2ae3","0x5f22","0x2e21","0x2a36","0x7a07","0x24d0","0x712e","0xb0e1","0x104c","0xd69a","0x553d","0x1cbe","0xeb3d","0xf231","0xe0e0","0x93f2","0xbfce","0x320f","0x25d1","0xbed1","0xe0f0","0x4394","0xe7dc","0xfaf2","0xed02","0xde9d","0x11b2","0xdf01","0x2eab","0x31f2","0x222f","0x92e1","0x0c2e","0xde11","0x1cd","0x2a44","0xe0bf","0xb2f1","0xd1b2","0x5f03","0x4130","0xf190","0xbcd2","0x9f00","0xccf1","0xa4cf","0xea44","0x7b21","0x3a4","0x42f","0x2b21","0xdcd0","0xe144","0x3110","0xb210","0xff0b","0x27a0","0x90ad","0x31f6","0x90f7","0xee30","0x631","0xdd45","0x72f3","0x2e4c","0xc025","0x2de1","0x5f2","0x6ed3","0xcf0b","0x2ec2","0x0ff1","0x53e6","0x2d0e","0x0d2","0x4e00","0xbb41","0x3e1","0xa020","0x7f3c","0xe33f","0xf3f0","0xf2b0","0x1f91","0xfe33","0xdcb1","0x0f1","0x31f0","0xd0d1","0xfdd3","0xecb7","0x32e3","0xd3ea","0xc12d","0x60","0x3dd","0xbeca","0xacdf","0xefcd","0xddc1","0xfc12","0x0ffe","0x2037","0x2e3c","0x90d2","0x3cd","0x0f20","0xefff","0x2e27","0xed92","0xc322","0xc1aa","0xb2d2","0xbe05","0xa721","0x9fc0","0x1c2e","0xdbe7","0x5f11","0x364e","0x0cf0","0xeeb2","0x2710","0x1f6f","0x0eb1","0x1190","0xf0cf","0xb361","0x17c0","0x6121","0x0b23","0xe245","0xde00","0x9719","0x3d6f","0x106","0x1ae","0x2c11","0x641f","0xd3eb","0xb20c","0x0ef0","0xc7d0","0x2f4b","0x4162","0xf3fa","0x10eb","0x0dfd","0xfc6d","0xed10","0x4e0","0xd001","0x3200","0x12da","0x6d00","0xde01","0xb3f2","0xcdae","0xd461","0x710e","0x11f1","0x54dd","0x3100","0xc40c","0x733d","0xeee0","0x2322","0x202e","0xa2fe","0x0be2","0x0d31","0x4193","0xbe1c","0xd093","0xbf74","0x4449","0xfd04","0x541d","0x7a04","0xf1ed","0x525e","0xb13f","0xfbde","0x415c","0x123d","0xe001","0xe1d3","0xd21d","0xfd22","0xefa3","0x5b2a","0x35f2","0x91ce","0xdb0a","0xd3bc","0x1042","0xfed0","0xeb13","0xda9d","0x399","0x25e","0xbc7e","0xd2f3","0xd2ff","0x312b","0xf2d4","0x3f1a","0xff0e","0x9a22","0xb13e","0xb039","0x29de","0xdfdd","0xdf0e","0x23e4","0xf0de","0xe94f","0xf150","0xc3cd","0x9d1b","0xccf4","0x47ee","0x29bb","0xfae4","0xbff0","0xc01a","0x16fe","0xdfe1","0xb34e","0xe34d","0xff02","0x7cf0","0x0d53","0x146","0x109e","0x0de","0xfb0e","0x303","0xf6ce","0x1fd4","0x0f26","0xa16e","0x613f","0xf011","0xeec2","0xfc2e","0x553e","0x51d4","0x14db","0x2c05","0xe0cf","0x2e42","0xd055","0xf022","0xff41","0x22dd","0x37ba","0x9209","0x7d5f","0x7401","0x3fad","0x2605","0xb20e","0x11c0","0xfde2","0xda53","0x599e","0x3f34","0xbeba","0xca23","0x9d90","0x1e92","0xd0e1","0xd6fd","0x0c9d","0x5724","0x1292","0xd2e0","0x5300","0xabd9","0x34e4","0xd011","0xfb20","0x4312","0xefcc","0x4efe","0xb723","0x344c","0xf500","0x0a09","0xc03e","0x1a0","0x953f","0x4225","0x2e","0x3102","0xe09e","0x371f","0xa019","0xcf22","0xe2cd","0x0c06","0x2bed","0x7562","0x3cee","0xe1dd","0xeebf","0xfff9","0x0ed0","0x5001","0xee19","0x0c4f","0xa0a3","0xff72","0xa2f2","0xe1f3","0x1fc4","0x3fae","0x999b","0x730c","0x2a33","0x4441","0x33cc","0x10f","0xfd0c","0x7f0","0x0ffd","0x3d5","0x9ef2","0xe210","0xf90f","0x5cf3","0x20f7","0x0f17","0xfcfc","0x70f4","0x132","0xf77c","0x752f","0xd491","0x3d3","0xced1","0xb32f","0xdcec","0xdf73","0xb177","0xe43b","0x5e0e","0xf24f","0xf7e6","0xdbb1","0x513f","0xfa32","0xce65","0xb0bf","0xe73f","0xaf1b","0x9010","0x9eeb","0xee22","0x9253","0x373","0xae0e","0x5f0b","0x152c","0xb3cf","0x2aa6","0x3b4a","0xd32f","0xe423","0x2d03","0xc612","0xf50f","0xfe12","0xda31","0x0f00","0xde2e","0x9b1e","0x93f9","0x3c0c","0x2415","0xc32b","0xeef0","0x92b4","0x12bf","0x2f4f","0x97a0","0x0d50","0xa42f","0x7b32","0xbe15","0x551d","0x1b3e","0x1d1d","0xc0de","0x4d0","0x4431","0x0d9d","0xff06","0xc13f","0x3a0","0xddfc","0xf4a3","0x605c","0xf02e","0x1fc","0x92d5","0x17c","0xca5f","0xe043","0x41ff","0x3312","0x610f","0xd101","0x1e","0x1235","0xb4d2","0x6ef7","0xa7d0","0x20f","0xaef1","0x2e11","0xf20d","0xf12b","0x1b50","0x449c","0x41dd","0xcf5a","0xeb20","0x4eb1","0xda0d","0x1b2d","0xe63b","0x3039","0xd2af","0xff2e","0xadd3","0x5b2f","0xe30b","0x3190","0x53c4","0x2cd1","0x33f2","0x7b9f","0x2a00","0xd2e4","0xb134","0x71ec","0x191d","0xe53f","0x5b22","0x7201","0xfa34","0xe07d","0xaee2","0x7bdc","0xeb00","0x3009","0xd6ee","0x42fc","0xddf2","0xc721","0xf426","0x3f63","0x0c70","0x11e","0x3e1c","0xf432","0x1d44","0xc3bc","0xbef4","0x3032","0x9d0f","0x0f0c","0x20db","0x1d21","0xdc41","0xdec5","0xfe30","0x1222","0xefb1","0x1e10","0x9d10","0x3d42","0xe310","0xecf3","0xfdae","0xf1f0","0x1442","0xcf74","0x095a","0xc0f5","0x534","0xe0b1","0x9fe1","0x41dd","0x0c2","0x92db","0xf13b","0xf57a","0x7c42","0xee3f","0xd1ed","0xb2b1","0xde31","0xcf20","0xac14","0x74e6","0xe101","0x26fd","0xd991","0xfcaf","0xe005","0xf7ed","0xd724","0xd62f","0x3ef2","0xcca5","0x426e","0x0bba","0xd0df","0xbd39","0x13c2","0x9ec7","0xb011","0x21c3","0x3f0f","0x1aff","0xf1b0","0x0fd9","0x307f","0x5210","0x533e","0x7fce","0x3ffe","0xf100","0xeed5","0xd62e","0x9f15","0xbc36","0x64f0","0x4db4","0xb2d3","0xfd4d","0x22e6","0x0f10","0x7b5e","0x6a2b","0xd14d","0x6df2","0x0fbc","0xea6e","0x134","0x126f","0x192","0xb044","0x7fc3","0x77b","0xc0fa","0x2fd5","0x1cf3","0xed19","0xcefd","0x5bf6","0x3f49","0xfa12","0x3090","0xf1f9","0x5232","0x3142","0xee53","0xd4e4","0xe590","0x4c0","0xe1f0","0xce04","0xbc40","0xb97b","0xbe42","0x2f23","0x3cd1","0x17e","0x3ff2","0x41f6","0xd2db","0xfd1e","0xf65e","0x5052","0xa537","0xad31","0x1442","0x5722","0x77e","0xbfe1","0x5fcd","0x254d","0xb973","0x111f","0x4133","0x6712","0xe104","0x35a0","0x3bfd","0x9320","0x20d","0x192b","0xd220","0x24e2","0xdb21","0xf1e0","0xd06c","0xd22b","0xf042","0xf2ef","0x0acf","0x1fc","0xb21c","0x2ed5","0x234e","0x202e","0xef33","0x0fde","0xa372","0xfc4e","0x4102","0xf021","0x41df","0x32e","0x0a1c","0xcca4","0xd4e7","0x11a1","0xa9a2","0x2f51","0xeef0","0x72b0","0x6cf3","0x0f12","0x66e0","0x92ff","0x2ff1","0x79da","0xc6e2","0x55cb","0xfc2d","0x31e2","0xb2e2","0xabfc","0xcaef","0xc317","0x4e01","0x3422","0x12a0","0xedf1","0x202e","0xdd21","0x2bef","0xf11e","0x0cc0","0x21ac","0x3e51","0x273d","0x10d","0x222d","0xcdeb","0xc1c2","0x3fa2","0x37df","0x5bde","0x52a3","0xfd7d","0xa146","0x2e4a","0xff43","0x9f45","0xe0cf","0x5a50","0xebde","0x37e5","0x4e6c","0x9d01","0x3210","0x432d","0x12bb","0xf31a","0xefe0","0x3bef","0xa3bc","0x60f2","0xf1b0","0xad7e","0xb351","0xcde9","0xdb10","0x7330","0xf2f2","0xbfe2","0x324a","0x731a","0x2701","0x30f6","0x1bbd","0x3cba","0xeda2","0x5f5","0x317f","0x1b6c","0x6052","0xc63f","0x0f4d","0x5e3e","0xbc41","0x9bec","0x704e","0xffc1","0x4e69","0xea39","0x5000","0x4352","0x9060","0xed71","0xf07c","0xbb6d","0xd17f","0xe92c","0xde93","0x123a","0x9bbe","0x9bee","0x90f0","0x70b0","0xe1ed","0x3ae1","0x3111","0x2f1e","0x952e","0x492e","0xdbc2","0xee4a","0xee62","0x3baf","0x9eff","0x44dd","0xd9e0","0xa01f","0x22dc","0x2f31","0x09ff","0x34a2","0xc230","0xf3bd","0xadee","0x5ca9","0xff52","0xdd1f","0x7fe9","0xffb0","0xf2fd","0x0b1","0x11a0","0xd4e0","0x31eb","0xdeee","0xc21a","0x6bfe","0xfa57","0xccc2","0xc0fe","0xeaef","0x0df4","0xbf91","0x39e4","0x1fcc","0x6fcc","0x135a","0x44e9","0xd071","0x4fa0","0xc29c","0x10df","0x1020","0xd0b2","0xb022","0x1d0e","0xea73","0xb31e","0x1094","0xc912","0x0ddf","0x3af1","0xa23b","0xf119","0xd5f5","0xbe26","0x223c","0x21dd","0xd240","0xf603","0xf2dd","0xe3be","0x9b3b","0xebf1","0xd1f2","0x0930","0xcc33","0xd1ce","0xdc49","0x5e1f","0x210e","0x206e","0x1edf","0xeeab","0xd0ec","0x22d2","0xdca4","0x9fdd","0xbdb0","0x1d7b","0xb0ee","0x5913","0xd2ce","0x17d0","0xfb42","0x1dbe","0xed51","0x6fec","0xc2ca","0xeb2f","0xdb0b","0x6e75","0xd432","0xd5dc","0xdbcf","0xdbfb","0xbcbf","0x3d22","0x3435","0xf590","0xf3dc","0x2d5a","0x6235","0xfd4e","0x3303","0xf60f","0x124b","0x2c03","0xe05f","0x7c0b","0x2f03","0x37ee","0xde3d","0xdac0","0xfddc","0x30d","0x53c","0xca11","0x341c","0x440c","0x2416","0xe640","0xce9e","0x7fdf","0x309c","0x3fea","0x1c","0x6202","0xc6b0","0x2323","0x3d69","0x1150","0x0f02","0x41cc","0xafd3","0x2053","0x374","0x7ee0","0xda0e","0x14e0","0x6f9","0x436f","0xca61","0x1cd3","0xe99a","0x7e10","0x091a","0xb6a3","0x2ddf","0x3edc","0x90df","0xd1e4","0xfed1","0x5909","0x29a2","0x9ad0","0xf7db","0xa54f","0xa2b2","0x3c04","0x0d95","0x15e","0xef2d","0xf290","0x2cc3","0x3009","0x92e2","0x20c0","0xf32b","0x3ff3","0x2af0","0xbded","0xe1bf","0xceb1","0xdffd","0xaea9","0xa0a1","0xe060","0xfbf9","0xdcbf","0x191","0xfa01","0xedad","0xe0c6","0xe5d3","0x5d7","0xd3a3","0xd327","0xa1e5","0x3ea1","0xedce","0x2dde","0x2db0","0xf12e","0x7f1a","0xf1be","0x2091","0xeb7a","0x249c","0xa1c5","0x951f","0xa536","0x1001","0x0e04","0xd5fc","0x1513","0xddf5","0x231","0x500a","0x31ee","0x19bb","0x325c","0x42dd","0x997f","0x1ef9","0x99da","0x0900","0xec9e","0x97f0","0x200","0x2fb2","0xe42f","0x1093","0x50bf","0xfd23","0x2c91","0xc452","0xfc3e","0x36dc","0xf1df","0x1a40","0x30dd","0x166e","0xfdf2","0x9292","0x3d5d","0x92d2","0xa002","0x12b9","0x40e1","0x299d","0x093c","0xfff7","0x5fdf","0x0d","0xfbf9","0x552e","0x4eac","0xe02d","0xe2bc","0xfe1e","0x9f11","0xf334","0x0dff","0xe23e","0x36a7","0x2feb","0x3d61","0x5b14","0x6c41","0xd504","0xf1ec","0x7e26","0x7694","0x6dc6","0x5f95","0xb7d3","0xc221","0xdb9c","0xf0e5","0x3a22","0x1d12","0xe340","0xbf11","0x1f01","0xede2","0xdf0a","0x5e02","0xfe9e","0x2e20","0x1e1c","0xf494","0x67e4","0xcc0b","0xf2de","0x9bc3","0x0df5","0x3ed1","0xeba7","0x4b1c","0x9141","0x36e","0x6202","0xff11","0xfcbf","0x4f40","0x3b1a","0xceef","0x2224","0x220b","0x1644","0xc0ad","0x3130","0x0d02","0x33b3","0xcd30","0xfed1","0x132","0xd3e0","0xd0fe","0x3cfb","0x3","0x4f3d","0xedd2","0x3116","0xe361","0xef10","0xc11e","0xfb4e","0xc370","0x3b62","0xf430","0xe131","0xe21e","0xf5d3","0x3710","0x4fae","0xf034","0x0f0c","0xcfd1","0xd6d4","0xf5ac","0xedcc","0xc230","0x7b40","0xee46","0x1d5f","0x90c0","0xe01a","0x3130","0x5021","0x6035","0x7dd9","0xeeff","0x1cfd","0xf3c0","0x1bba","0x1e20","0xb0a6","0xceaa","0x23e","0x140e","0xebf1","0x13e2","0x6435","0x1161","0xe410","0x20d","0xd2e1","0xdc0f","0x4df1","0x92d1","0xf4ff","0x9299","0x9ec1","0x70c0","0xbe00","0x500d","0x4f03","0x4e92","0x1eb0","0x61f0","0xaee2","0x9105","0x1eca","0x10ce","0xdfe2","0xebc1","0x7bbe","0x471c","0x634","0x6f31","0x9b1e","0x220a","0x2d3c","0x711d","0x10d3","0x103a","0x2f02","0x39b1","0x5e","0x59eb","0x3143","0xf5da","0x0de3","0xe11f","0xf2ff","0xcd60","0xed3f","0x4042","0x24d0","0x30f","0xff2f","0xdd3e","0x213","0x4930","0x32fc","0xb13c","0xf2c3","0x26bf","0x50e1","0xf03f","0xb044","0xfe22","0x1e1","0xdf50","0xbb91","0xc00e","0x201c","0xf3f3","0x16e2","0xc210","0x0ddf","0x22d1","0xa21f","0xe5c5","0x10ff","0x4e01","0x30c5","0x51f0","0xb437","0xa3f5","0xcf90","0xfc91","0x6d15","0x0c20","0xf01c","0xcf2f","0x1e9f","0x1fbe","0x54f4","0xb25f","0x52e","0x2f9d","0xebc3","0x4fe5","0xde31","0xed17","0xbf56","0x0e9d","0x3d0d","0x2f72","0xfd31","0xfd01","0x0bab","0xf792","0x5300","0x45d1","0x11ee","0x31ec","0x43c2","0xb2c3","0xff0e","0x6011","0x2e0","0x2dbd","0x7fc0","0xb030","0xf290","0xc019","0x7f60","0x2009","0xd20c","0x113e","0x1dea","0x1ed1","0x46d1","0xe52e","0x2ff9","0xec3a","0xce1b","0x4c25","0x1e5","0x72ae","0x47fc","0xce5f","0x4703","0xe491","0x3492","0x3e","0x71c2","0xf2d1","0xfff1","0x0d35","0x0dec","0xd642","0xe02a","0xdf9d","0x273e","0xeee4","0x13","0x35f","0xea25","0xe0d7","0x7205","0xcfd6","0xe950","0x1fed","0xef17","0x15dd","0xdd2e","0x0ace","0xd10f","0x5b15","0xfedd","0x4ef","0xddcf","0x51f","0x57fe","0x0e2d","0xfc2b","0x0a01","0xfcf1","0xc02f","0x332c","0x3f49","0x21cf","0x1fd1","0xee3c","0x1fbe","0xa04d","0xecc1","0xdec0","0x352","0xf2f2","0x5ef9","0x21d","0xf91e","0x2a23","0xbaf5","0x1fed","0x742d","0xcf0f","0xee6c","0xf0f0","0x42b2","0xc57d","0x0be","0xbd5f","0xbf10","0xe2b1","0xd2d1","0x19de","0xeca2","0x0da5","0xfd56","0xfe3b","0xa03b","0x1e2e","0x9be3","0xbea4","0x33a1","0x2001","0xc140","0xd115","0x521e","0x20ee","0xea4f","0xee95","0x90c1","0x4da","0x1c4","0x1bb0","0xa2fd","0xfc10","0x69d2","0x9fc1","0xd021","0xcd4a","0x21d3","0xcf14","0x7f50","0x7a3a","0x41e","0x31d1","0x9f3f","0x30a0","0x1b5c","0xfb23","0xdfd3","0x0c23","0x4432","0xfea4","0x3a00","0x2022","0xce1f","0x109e","0x2c1c","0xe2fc","0xfe32","0x0f31"},
{"0x2d31","0xaf10","0x233e","0x39d","0x1f11","0xf6d3","0x9109","0x513","0x3f0b","0xe462","0xb25e","0x6e23","0x0eb6","0x1064","0x1101","0xaddd","0x4ff2","0xb536","0xfc20","0xb2f1","0xf2a0","0xa2c3","0x25ee","0xa725","0xd300","0x5f6c","0x31d","0x0d33","0xff09","0x6324","0xe332","0x1693","0x5190","0xa1c7","0xa3c3","0x7c05","0xdb2c","0xd2d4","0xf3fe","0xeda0","0xee9b","0xff0c","0x1aff","0x1b2","0x2f2d","0x0c05","0xe57f","0x57a3","0xfc40","0x17e1","0x122d","0x1fc2","0xaeb7","0x1efe","0x7d30","0xdae6","0x30d3","0xa572","0x0c1e","0xe1b2","0x7732","0x66ce","0xfdcb","0x520d","0xc29d","0xfd35","0xefd4","0x2f52","0xf0fa","0xd4ba","0x4ae","0x7aec","0x7cdd","0x7d5f","0x9772","0xaff9","0xd435","0x24ad","0xecaa","0x3002","0x4e0","0x4a34","0xf60e","0x9232","0x2fbd","0xe2ce","0xce12","0x332e","0xee15","0xff1c","0xaaf1","0xd71f","0x3e22","0xdef1","0x57b3","0x5fa2","0xa7a5","0x3319","0x4215","0xec25","0x1252","0xed5f","0x7f23","0xe32a","0xfaa6","0x7322","0x162d","0xff2d","0x1c75","0x17f6","0x20d9","0x0a73","0xf69d","0x5004","0xc572","0x500","0x235e","0x0aef","0xd0c2","0xd012","0x4b57","0xa312","0x6cde","0x90a1","0x3d3f","0x1213","0x64b9","0xe115","0xf6df","0x712f","0x91c4","0x1025","0xef39","0x2b33","0xef13","0x9113","0x224b","0xe034","0x6ff4","0xf21f","0xf20f","0xd411","0x4ef","0xd1f3","0x5f2e","0x1d1d","0xa102","0x23c1","0x31e0","0x31cc","0x24e4","0xc250","0x39e4","0x4750","0xf0c2","0x3053","0x42fd","0xee10","0xbf00","0xbb10","0xdc2c","0xc0fc","0xcfc1","0x22a","0x3be1","0x322f","0xa220","0xc71f","0xe9d6","0xd714","0x0dfa","0x91d3","0x40bf","0x3245","0x1fec","0xbb0c","0xc02f","0x90f3","0x1edd","0x2641","0x2201","0xe133","0x0dbe","0xcf5a","0xe54d","0x7ea","0xf0d3","0x3c93","0x7211","0x1d4","0xf34d","0xc3d1","0xc0b7","0xab41","0xed34","0x14f0","0x7f3d","0xe500","0x9301","0x712f","0x3703","0xece6","0x1d75","0xbc1f","0x27ef","0x7f11","0x3141","0x2103","0x1cf4","0xeede","0xcd21","0xb134","0x115d","0xc600","0x2f50","0xfbe2","0xfe1f","0x5e03","0x4b12","0xe3b4","0x3f12","0xd51d","0x10e5","0x2214","0x4ee0","0x31","0x31f7","0xfce2","0x0e51","0xe042","0x533f","0xffa1","0x51ff","0x9ece","0x1e06","0x3","0x23fd","0x4dff","0xec01","0xcd0c","0x3f3d","0xbd51","0xe4c7","0x4f2d","0x40be","0xd4de","0x97bc","0x234f","0x3fdc","0x45dd","0xf14e","0xce13","0x401f","0x500","0x2530","0xf0cd","0xf30d","0xc61e","0xfec2","0xd402","0x75a5","0xdb6e","0xb26c","0xff31","0xffe9","0x422d","0xfbe2","0xb291","0x22dc","0xb93c","0x1e0f","0x31bd","0xe51e","0xf3d5","0x900f","0x1dce","0xf3e2","0xc123","0x13f","0xef1f","0xf100","0xf11e","0x0b34","0x4f32","0x0af0","0xbb11","0x9e0a","0x6ec","0x3111","0x37f1","0x1339","0xf21c","0x9076","0x0fc","0xcdfe","0x9f3f","0x09e2","0x2021","0x21c1","0x31ce","0xde30","0xcafb","0xf0c4","0x13c1","0xd5a0","0x2719","0x51db","0x1ee","0x906d","0xc509","0x9ae5","0xdc7c","0x79f5","0x3fe5","0xf6e6","0x50dd","0x0b","0x10d9","0xe71d","0xc57c","0xe7cd","0xcee0","0x1079","0x4ee","0xc0d1","0x4fed","0x1f37","0xf104","0xf9dc","0xe41f","0xa910","0x109f","0xf043","0xebce","0x43dc","0x4d22","0xe0ff","0xbf41","0xfac9","0x20f4","0xe0f0","0x30d","0x5e4b","0x43fc","0x095f","0xf3d1","0xf074","0xafe0","0xf5b7","0xeefb","0xbbb2","0x3e09","0xae91","0x1ee0","0xce9d","0x3510","0xee34","0xc7f6","0x5d70","0x3d31","0x2fa","0x2500","0x0c2d","0x9df6","0xa0f0","0x4ded","0x14bc","0x400e","0xe0b5","0x239c","0xa634","0xef10","0x13a0","0x0ee1","0x22ae","0x2ba2","0x102d","0x2442","0x09bf","0xf1ac","0x5d19","0x77bf","0xf90c","0x102","0xd01a","0xed72","0xbdb7","0xf12c","0x3101","0xf372","0xcc42","0xd09f","0x0c73","0xdb09","0x3bd","0xb3fe","0x53b","0xb5e4","0x9a7d","0xc02e","0x9d25","0x0d2f","0xce62","0x19fa","0x4112","0x4d1a","0xf069","0xd1fc","0x112f","0x216c","0x30ed","0xf1d2","0x3342","0x1c79","0xe0f3","0x9fac","0xc9ee","0x3dd7","0xf22a","0xfdb9","0xbce1","0x935d","0x10f9","0xd661","0x26e1","0x2712","0x0f5f","0xee10","0x10de","0xe972","0xe2eb","0x4ec1","0xf3ae","0x304","0xa509","0x0cff","0xed5b","0x203a","0x1cdb","0x0f30","0x0d44","0x20","0xeafd","0xc151","0xadbf","0x7f0d","0x3e4","0xefad","0x6ee1","0x2d71","0xf307","0xe0cc","0xfce7","0x7efe","0x11dd","0xcb2f","0xe6c2","0xe006","0xaeb9","0x4d69","0x2d9","0x4de6","0xa301","0x3b34","0x700f","0x11c9","0x3c2d","0x90d1","0xc121","0x4247","0xfa6f","0xd93d","0x4c1","0x1eef","0xfadd","0xecf2","0xc159","0x22e","0x3132","0x1222","0x45c2","0x4be2","0x2ed","0xbf03","0x51c","0x2f06","0xd05f","0x16cc","0x50d1","0x2200","0xfbe3","0x7ef7","0xf1f0","0x2cc","0x52e0","0xe31e","0x54f1","0x1c2","0x0ed1","0xcbdf","0xf523","0x6c5","0xc2ce","0xdf95","0xcf0c","0x23e4","0xe4de","0xbfe9","0x1bf3","0xaee5","0x34a3","0x1003","0xd55f","0xd310","0xbf10","0x5cf","0x36c2","0x4fc0","0x7cd","0x1ccf","0xb1ad","0xbc5d","0x6792","0xee0a","0x4f1c","0xfecf","0xe2d6","0xfcc2","0x0ee4","0x0d7c","0x49fd","0x14cb","0x7ae5","0x2b24","0xc5e4","0x149c","0xe19c","0x11fe","0xf1a0","0x1000","0x6bcb","0xf96f","0x573","0x126e","0xc210","0xe2f5","0x9354","0xfda1","0xaa3f","0x3a0a","0xf303","0x94b3","0x6e2f","0x0bdb","0x1fe0","0xf0f1","0x2c05","0x1e20","0xff59","0xe3f2","0xff1c","0x25e3","0xcfef","0xe09f","0xaef1","0xef3c","0xd6cb","0xf24e","0x104","0xadb2","0xaeaf","0xfc02","0x6fa1","0x3b00","0xdf2b","0xef20","0xa21d","0xf62f","0xf5fe","0x0eaa","0xf243","0x43e2","0x0e","0x67c0","0xfa0f","0xb003","0xcb12","0x1","0x1ed","0xd24f","0x3df0","0xf26d","0xe242","0xb1f5","0x2f4e","0x51bb","0xd70e","0x3bb7","0xb933","0xd9e4","0x41cc","0xc2de","0x0b1c","0xec39","0x5ddf","0x93fe","0x0dc4","0x109c","0x1125","0x10de","0xb0fe","0xc222","0xc604","0xeeff","0xb2c1","0xe2b2","0x2ec0","0x5439","0x7dce","0xb4fc","0xfd26","0x4dbf","0x1e96","0xf1e1","0x0d13","0xadf7","0x213","0x2f30","0x1d7a","0x3556","0xf2eb","0x77cf","0xf44d","0x3cfb","0x3f2a","0x10e","0xc2ff","0x6314","0x1d65","0x15c3","0x60f9","0xe943","0xf30d","0xadd3","0x130e","0x7940","0x2169","0x77dd","0xf70f","0xdf10","0xdd00","0x9eec","0xe21e","0x4c23","0x2fd4","0x97d2","0x14e","0x1cd2","0xa242","0xb136","0x1fc0","0x0e7f","0xb31f","0x9e21","0xc7fe","0xfb10","0xa2fd","0xbd31","0x2229","0xde1e","0x42d0","0x46d5","0xe432","0xff54","0x34fd","0x3f","0xd6d5","0x2f13","0xba22","0xa0eb","0x496f","0x5c1","0xc0b0","0xdbf2","0xd1cf","0xb510","0xb32c","0xaefb","0x313f","0xb3ef","0x1bf0","0xd6be","0x27d3","0x9741","0xcbe3","0x9160","0x5c7d","0x131e","0xf0ad","0xbccf","0x129c","0x9b12","0xbc1d","0xef90","0xe0f0","0xc2a4","0x9cff","0x2fa3","0xedd4","0x9424","0xe49d","0x9b02","0xdc72","0x94db","0x19b1","0x3ffe","0x10dc","0xebf3","0xa340","0x69b","0x9ff0","0xfe15","0xf419","0x1220","0x923c","0x2bde","0xfd42","0xfd3c","0xd2bc","0xede9","0x30d0","0xf153","0x4f21","0x1e3","0x5e10","0x15f1","0xb77b","0xffdf","0x110c","0x59f","0xf41e","0x72ce","0xfe01","0xfef2","0xbe34","0x1ffa","0x2fe0","0x3b59","0x1c17","0xe212","0x6fee","0x31d9","0xb711","0x1ee4","0x9650","0xba2d","0xefe3","0x5ee2","0x923c","0xd9ee","0x5d34","0xe5f3","0xfb20","0x11d3","0x104d","0x233c","0x2ffb","0x112d","0xd213","0xd6f1","0x16ac","0x13f0","0x32fc","0x1072","0x1e2f","0xdeb2","0xe144","0xed5f","0x101f","0x1fc1","0x17f3","0x0","0xe1fe","0xe7f2","0x13f6","0x631e","0xd530","0xe4f3","0x302","0x7404","0xfb2e","0xa0db","0x1300","0xc97d","0x2ff1","0x2d20","0xe72d","0xe135","0x1397","0x21cb","0xa313","0x631e","0x2c0e","0xe3cb","0xccfe","0xab6f","0x2fd","0x475f","0xd6a2","0x197f","0x9c3d","0xdc0f","0xc5dc","0x3e0d","0xf3e0","0x0e5a","0x1af2","0x23af","0x7152","0x5cf2","0xc0f4","0xf100","0x9a0d","0xd012","0x7adf","0x9255","0xd724","0x1dd3","0xe5c1","0x5eec","0xeec9","0xc110","0xbe0f","0x5a0","0xc5b1","0x13fd","0xa119","0x102b","0x9c22","0x703a","0x7907","0x5e60","0x4057","0x3749","0xbf55","0xc7f9","0x102d","0xc1e1","0x2ee","0xcae2","0x323c","0x5671","0xee94","0x5c0","0x4f12","0x0e2b","0xee0e","0xe31a","0xc9bc","0x2704","0x306e","0xf5ea","0x2020","0xe1e2","0xae45","0xe10d","0x7fce","0x1f12","0xad2b","0x900c","0xcccb","0x947c","0x1fd1","0xffe4","0xfdbf","0xfef0","0x3122","0x2fac","0x72e2","0x7601","0x2e41","0xec12","0xe099","0xd32d","0xe5ee","0xe6fe","0xb4f1","0x924c","0xeaa0","0xb416","0x7fee","0x512e","0xb3f0","0x5f3c","0x1db9","0xe40a","0x3ba7","0x10b2","0xf3f4","0x430d","0x24ec","0xcebd","0xd4fd","0x99d1","0x3de3","0xc4f7","0x1122","0xef0f","0xfeb2","0x4210","0x15b","0xa00e","0xde1a","0xfa39","0x47fa","0x53d1","0xb02d","0xbd74","0xdaec","0x9f71","0x1034","0xb913","0x1994","0xcf1f","0xcda9","0xabbe","0xd1e4","0x60e4","0x9d2a","0x5ebf","0xd5fd","0x51b3","0xc4d1","0x0d12","0xa411","0xec2c","0x2e2d","0xd012","0x090","0xc1f0","0x2f4a","0xcf51","0x4e1d","0xeb27","0x0dfa","0x0e91","0xd1e0","0x26d0","0x0fb3","0xddee","0xfc51","0xb217","0xdd9e","0x3ed1","0xf1f3","0xb29e","0xf43e","0xf102","0x5d0e","0xb094","0xdd13","0xfe1f","0xff02","0x20e","0xdfdb","0xed11","0x312c","0xeeb0","0xeb40","0x59c3","0x0a20","0x1200","0x323c","0xe2de","0x2c7","0xfef5","0x0e43","0x3b32","0x5b6","0x30de","0xfba2","0x1eed","0xbfd6","0x9b95","0x3d14","0xfaf2","0xf14f","0xad2e","0x3220","0xc00e","0xf1f5","0x10e7","0xf592","0xed04","0xe3b2","0x6c0d","0xbcea","0xab22","0xa1c3","0xee91","0x301f","0xd2e2","0xe3fe","0xae52","0xf1c1","0x5e92","0x0d1","0x22cd","0xaec9","0x2a34","0xb1eb","0xfcc1","0x4d3a","0x5d6e","0xe17e","0x2ae4","0x57fd","0xdb04","0x1543","0x991f","0x2cc5","0x1f0f","0x4b20","0xdf0b","0xba20","0xf05d","0x1673","0xc6af","0xaa9c","0x1952","0xf971","0x0c03","0x6765","0xf240","0xf21d","0xe7f0","0xcf7d","0x6320","0x3ba9","0x3101","0x4342","0xc23e","0xf524","0x0efe","0x3ecf","0x1fe3","0xfeae","0xb2be","0x241d","0xcd30","0x4110","0xe72d","0x29fe","0x65d1","0x1f50","0x1222","0x54f","0xaed2","0x642d","0xf0fd","0x2041","0x42f","0x702e","0x1bf","0xdc75","0xcf70","0xfe2a","0xec26","0xe3be","0xc215","0xe62d","0x9fe5","0xd6ff","0xe0ae","0x32d3","0x6d33","0xee24","0x9575","0x19cf","0x0bcf","0xac3e","0xfe0e","0x15c3","0x0bc6","0x13ce","0xb033","0xdc3e","0xa3c0","0x3d1","0x6def","0x0912","0xb3ce","0x91ef","0xefff","0x59e3","0x5033","0xe2de","0x11e","0xcbe0","0x37a2","0x91d9","0xb653","0xfa0c","0xb16d","0xf5e2","0xfb10","0x0e4e","0x21ee","0x349c","0xd0e1","0xf013","0x0f0d","0x224e","0x6c4e","0x1dde","0x44","0x4534","0x5e1e","0x1f30","0x11e3","0xe617","0x415","0x23f3","0xf3cd","0xd2ee","0xd520","0xf012","0x5bf0","0x0bf0","0x426e","0xede1","0x1650","0x17ca","0x340b","0xd14c","0x4fae","0xfb41","0x3e03","0x5e75","0xc0fa","0xe4fc","0x30f1","0x9110","0x0d2","0x2dc","0x3d70","0xddee","0xefec","0x9442","0x315c","0xaa0b","0x69f1","0xb9dc","0xedf7","0x9ec4","0x1021","0x311d","0xf0c0","0x6ed1","0x4ce3","0x22ee","0xee20","0x4bd0","0xd250","0x7e1","0x42f6","0x3bb1","0xaa2e","0xefed","0x6e07","0xd3cb","0xd34e","0x2f2f","0xee03","0x34f","0xdab2","0x930f","0x5f0d","0xff2c","0x6fe1","0xf051","0x5040","0xfaba","0xdd10","0xf50a","0x3d","0x9406","0xb20e","0x224e","0xffa7","0x0d90","0x1343","0xd31f","0x520a","0xedae","0x4700","0xdce1","0x2dc","0xff93","0xfe1e","0x23d3","0xc6c3","0x61d","0x913a","0x94bd","0x31da","0xf6e4","0xdbf1","0x6ef","0x2da1","0x420","0x32a3","0x6215","0x0b10","0x24cc","0x920b","0xc0bf","0xe3e7","0x0ba9","0x35c6","0x10c9","0xf62c","0x1601","0x70a3","0x702b","0x721e","0x9d7d","0x1273","0xa1af","0x10c","0x34fb","0xfa32","0xe12f","0xdeed","0x533f","0xb002","0x414a","0x26e","0x0f4c","0x4dd2","0xffe2","0x21f2","0xd240","0x1f11","0xfefd","0x4e0b","0xdd10","0xf052","0x221d","0x0f1f","0xfff0","0x2f2c","0x1240","0xfc15","0x6324","0xf25e","0x2fd","0x1ff3","0xc6ef","0xc23a","0xd73c","0x723f","0x1fec","0x64d1","0xd364","0x41b4","0x2521","0x52fc","0x1132","0x5d1f","0x27c1","0x0dec","0x530e","0xdbe5","0x342e","0x75c7","0x2fd5","0xd029","0x30bb","0x5093","0x7e2b","0x4ff2","0xd3f3","0x3463","0x0dfe","0x27ed","0x1f0","0x42b0","0x35da","0x61dd","0x9143","0xf2d9","0xb33f","0xe606","0xf303","0xbe33","0x3fe2","0x1972","0x0ebc","0xfb4b","0x7302","0x72fc","0xa0b0","0x42fc","0x542d","0x9c1c","0xe20e","0x9f19","0xc11d","0xd207","0xfd51","0x999c","0xee9b","0x7d3e","0xc521","0xf30e","0xfbf9","0x0929","0x427c","0xff23","0x675f","0x745d","0xe2fb","0x1f52","0x22e4","0x3e3a","0x3910","0xdf4b","0x0fe0","0xff4e","0xf45e","0xf1ef","0x292d","0xdc2d","0x0c1d","0xf4d2","0xf220","0x915a","0x10cf","0x13f3","0x400e","0x4f3","0xf201","0xd45d","0xe0f0","0xf1bf","0x2542","0xfd31","0xcdb2","0xdf5b","0xd3a2","0xf190","0x424e","0x1efd","0xf720","0x6597","0x0f4a","0x4dde","0x76bc","0xffad","0xe1ee","0x5e7","0x1d42","0x0cbf","0x09bc","0x15","0xcfe6","0x291f","0x7a11","0xef67","0xa9ce","0x63ec","0x9f7a","0xc0ae","0x5f97","0x30b3","0xccf2","0xb3df","0xc4bc","0xf1bb","0x14df","0xd0cf","0x4bb2","0xc177","0xffca","0x110f","0xd163","0xfd4a","0x3192","0x4df9","0x17d7","0x0fa6","0x1b31","0x5c0e","0xc412","0x0c4f","0xe13e","0xc231","0x5d10","0x3e5e","0xfeeb","0x3abd","0x12c5","0x422e","0xf1ae","0x10fe","0x6fec","0xf27c","0x1ef0","0xe110","0xf29b","0x727d","0x0be2","0x10e","0x492f","0xe005","0xa500","0x202a","0xa303","0x1e47","0x2e70","0x37de","0xdba1","0x3133","0xe05f","0x0d1c","0xd323","0xd1cf","0xefb3","0xbdc0","0xa4df","0x6a2f","0x11f3","0x91f0","0x4e3","0x5d69","0x4edc","0x1f1","0xe2f0","0x11f3","0x0ff","0x5bde","0x1c31","0x133","0x2610","0xf22d","0xe013","0x30f4","0x19ef","0xddba","0x41ed","0x3ce4","0xffdd","0x1f31","0x12da","0x326e","0x5a2c","0x0eeb","0x1235","0xf05a","0x7431","0xd2fb","0xedda","0xede5","0xeb1f","0xa16d","0xff02","0x2f3d","0x0f01","0xc1a0","0xcdac","0x442c","0x192d","0xafa5","0x901e","0xa10c","0x37e1","0xb0fd","0x0c3c","0xfd3e","0x291d","0x9441","0x0f2d","0xce00","0xde1d","0xbba2","0xb023","0x7d0c","0xe09d","0x1fb4","0x33f2","0xdfdc","0x9e61","0x09e0","0x5c2e","0xb050","0x1d0","0x4f02","0xb101","0xd291","0x6215","0xad01","0x2e90","0x1743","0xe403","0xbef0","0x4f5e","0x5e57","0xe42f","0x70b","0x1590","0xb5c3","0x1db","0x10cc","0xd7cf","0x9106","0x5d33","0x56f2","0x22fd","0x72c4","0xe40d","0x1c41","0xfdcd","0xab0f","0x529c","0xbcbf","0x330e","0x44ce","0xf313","0xd1e1","0x9456","0x14de","0xcb6f","0x31da","0x2ef0","0x1f32"},
{"0x70bd","0xee55","0x30d","0xb3ce","0x2af9","0x20e1","0xcd1c","0x1e22","0xf21f","0x3321","0x1fde","0x2aa","0xdce1","0xefc3","0x22ac","0x9f54","0x6fec","0x094f","0xf2ab","0xaf67","0x0bfe","0x3a92","0xe20f","0xca3c","0xb4bd","0xd599","0x33db","0x9fe1","0xdfee","0xb241","0x594e","0xd05f","0xd30b","0xcad0","0xc3ed","0x5dd7","0xb92a","0x33df","0x2ce4","0x2b93","0x2efe","0xef5c","0x0abd","0x1d1f","0x1616","0xca0e","0xc1dd","0xc706","0x3e1","0xbe3f","0xf46b","0x744c","0x213d","0xde6e","0x507c","0x14df","0x0dd","0x0fff","0xf20c","0x0fe6","0x25f7","0xfdfa","0x13d3","0x24b1","0x2496","0x0e53","0xe1f1","0xfe75","0xf9e5","0x1b1d","0x11d0","0x7e0c","0x94b9","0xfcc2","0x95bb","0x9c19","0x432","0x19e7","0xc0de","0x113f","0xecb0","0x2d13","0xdb22","0x4ec7","0xe100","0xe511","0x0ec3","0x3766","0x1e59","0xbf21","0xf1f2","0x15f0","0x50c0","0xd3ed","0x1ffc","0x1fe0","0x203","0xf223","0x4c19","0x6076","0x417b","0xbd10","0x1337","0x612c","0x5a4","0x5e07","0x420f","0xbf25","0x2d50","0x137","0xd3de","0x7f22","0xffd0","0x3f1","0xb420","0x5f46","0xe12f","0xb9ca","0xc4e2","0x1221","0x313f","0xfd11","0xbe50","0xed0c","0xce2f","0xa0de","0x93af","0x30f0","0xca11","0xe0dd","0xc6a0","0x0c1f","0x1f3d","0xccb0","0xcff0","0xe2d2","0xe202","0xeedd","0x31ee","0xd5e1","0x1f1","0x0e6f","0xf0f1","0xffdc","0xf3f9","0x0e3","0x9f2f","0x259d","0xb4fa","0xd451","0xe4df","0xcf4b","0x5d0f","0x2e61","0x4e0e","0x3004","0x1ed3","0xe912","0x2104","0xee6f","0x4fcd","0xbe64","0xbecf","0xce29","0x1d7f","0x7ab1","0x4e2","0xde6a","0x3d00","0xf035","0xad7a","0xf130","0xfee2","0x9ffe","0x34f1","0xbfe2","0x4cda","0x9b70","0xfdfd","0x2220","0x3dec","0xba35","0xf4c3","0x0b49","0x12ff","0xf3d2","0x20e2","0xd105","0x2701","0x90b2","0x4110","0xb23c","0xfd24","0x1ee5","0xe105","0x9f1e","0x2d30","0x74c4","0x1eef","0x5ace","0xf725","0xbf0d","0x411e","0xccfd","0x45d","0x1fd6","0xd171","0xce19","0x9dca","0x5c14","0x19a0","0xd110","0xce5f","0xd443","0x3fcf","0x3cef","0x37ed","0x9ce1","0x0d13","0x43d3","0xf4f2","0xdec0","0xef20","0x23e5","0x115c","0x7015","0x35b3","0x1de1","0xfc73","0x3330","0x5fa2","0x0bb3","0x7f4","0xefea","0xeee4","0x51e","0x423","0x1cd0","0x220","0x30fe","0x7333","0x2c33","0xb6eb","0x9f10","0x324","0x6514","0xfbdd","0x1f1c","0x50f9","0xdeb1","0xe1a9","0x0d04","0xc2e1","0xb543","0xb27d","0x9dd1","0x7f1d","0x3f41","0xdb2a","0x90c0","0xf013","0xdbff","0x3bb","0xd0e0","0xdf49","0xb321","0x1b9","0x94d1","0xe033","0x3a3c","0xb0e0","0xf9cf","0xee2e","0x1222","0x092e","0x2ce4","0xae11","0x9170","0x2392","0xe1d6","0xf04d","0x5334","0xcf11","0xdb21","0x0eef","0x4e20","0xe4fd","0x21d","0xae90","0xa1cb","0x3d2","0x14ef","0xe3dc","0xa0bc","0xceae","0xa4eb","0x4bfd","0x2fe3","0xd0ec","0x13f3","0x6f19","0x5c0b","0x21f2","0x4041","0x90e1","0xd1db","0x3f03","0x15f","0xd2ce","0x9306","0x9390","0xa341","0xca09","0xce0c","0x1d49","0x1001","0x5129","0x321d","0x0dae","0x410","0xfef1","0xfd16","0xfebf","0x263f","0xd71d","0xf5ff","0xc1c3","0xc732","0x4e2b","0xa9da","0x0c3f","0xd710","0x2ccf","0x5e3","0xfdaf","0xe422","0xb220","0x2eb2","0xedf1","0xca94","0x2041","0xc33e","0x213f","0x0b3a","0xd039","0x70a4","0x453c","0xcf26","0x16e2","0x114","0xdd22","0xddeb","0xe0f0","0x1e51","0x3ffe","0xec31","0xd204","0xd242","0x7000","0x24a2","0x1509","0xb4f4","0x22cd","0x9ffc","0x26d3","0x4ce7","0x10dd","0xef9c","0x10ff","0x16ad","0xd50d","0x4c34","0xd1b6","0xf130","0x7305","0xcc66","0x0e29","0x463b","0x0e94","0x1f06","0xfd3f","0x20a1","0x0bef","0xd35a","0x3dea","0xad30","0xce00","0xc1de","0x1df4","0x7011","0x3de6","0x4ac1","0xef56","0xec49","0xef3f","0x2e33","0xbae0","0xf2ff","0x9d33","0x3e1b","0x5f1e","0x5164","0xdc12","0xc9fb","0x91b1","0x5019","0x12bd","0xbf3d","0x11c","0xd96d","0xeff0","0x1dec","0x9dd3","0xef11","0xd1d1","0xb0ed","0x41ea","0x4344","0x10e2","0xbb4c","0xa2df","0x1d6d","0x5bb","0x0f40","0x72ed","0x42","0xfefd","0x0bf3","0xebc1","0x2e33","0x470a","0x367","0xef2d","0x293","0xe11f","0xefff","0xff5f","0xee30","0x1ef0","0x0f04","0x2ad0","0xe04d","0xdccf","0xd1fd","0x2ca","0x2fea","0xc29d","0x42ff","0x91f2","0x3f94","0x31f","0x1f10","0xd402","0x393f","0x2aed","0xcf90","0x6d03","0x10f","0x0cc2","0x421d","0x12ff","0x7f3d","0x30bb","0x11f4","0xc412","0x5e5","0x1d95","0xffd1","0xcd40","0xcf10","0xfbf2","0xed93","0xee10","0xeb1e","0xdb15","0x113c","0x2510","0xecfe","0x30ac","0x23fc","0x1454","0x1492","0x0dfa","0x2f32","0x1040","0x2af0","0x2017","0xb7e7","0xffee","0x25fd","0xdfae","0xfaf2","0x110d","0xd0bc","0x1fcb","0x20ce","0x70b4","0x40cf","0x0e10","0x6012","0xae6c","0x21f4","0xe600","0x1691","0xe4de","0xf0e3","0xe2e0","0x1e30","0x2cfc","0xd034","0xfeb9","0x1dd0","0xc0d3","0x4f00","0x312","0x250f","0x0fdc","0x31e5","0xf5eb","0x2cc2","0xcf00","0x112e","0x3405","0xd0ea","0x5060","0xd1de","0xed01","0x21c2","0x1ed3","0xab7f","0xf3f1","0xee1f","0x30","0x3df3","0x1df4","0xffcf","0x3e0c","0x4d","0xc22e","0xf6ce","0xc244","0x2000","0xf173","0x1021","0xfde1","0xfc6e","0x4522","0x0e24","0x1ebe","0x0efb","0x1ee0","0xff12","0x5239","0x3b4d","0xffe0","0x1234","0x1531","0x4000","0xa31e","0x9226","0x4e1f","0x2ee3","0x26b1","0xf012","0x0a9","0x9eea","0x3ed","0x431d","0x24e","0x4f12","0xedd5","0xbf41","0xf312","0x3f53","0xa560","0x1fd1","0x1e0","0xd566","0xa51b","0xad1f","0x233c","0x57b3","0xb0db","0xdf90","0xcff1","0xa60e","0xcfbb","0x52","0x4ec","0x0b6","0xffd2","0x2d0e","0x12f5","0x3374","0xd6f9","0x09f4","0x4ff2","0x09ce","0xed00","0xedd4","0xefeb","0x23d5","0xebc3","0x665e","0x0ab5","0xf9cd","0xce00","0x55b5","0x2b20","0xf26e","0x24e4","0xdb13","0x1f33","0x9030","0xc1e2","0xd305","0x13fd","0x1be2","0xd4f2","0x1379","0x40d1","0x171","0xfc9a","0xfbb6","0x9dff","0x093","0xe7cd","0x0caf","0xea7e","0xfec1","0x3b60","0x2fae","0x2fef","0xa3c1","0x2e0b","0x091e","0xf9ae","0x6310","0x1cf0","0x3403","0x9f5e","0x2d91","0x47d3","0x1b30","0x3d4d","0x3915","0x09f0","0xde24","0xeca5","0xeef2","0xef2c","0x9121","0x50de","0x2dd2","0x3f0e","0xf2e1","0xe53e","0x13a2","0xf526","0xfb33","0x222f","0xfb22","0x29be","0x633f","0x4f1","0xc919","0xe0fc","0xe531","0xf0f2","0x5202","0x10eb","0x91f7","0x3f3","0xd271","0x74f","0xff55","0x7320","0x43d2","0xe00e","0xe01c","0xfc72","0xe6fd","0xc1bf","0xeef3","0xe0df","0x17fc","0x22d","0x91cc","0x3d6f","0xd57f","0xf2dc","0xbe1c","0xb0c0","0x240b","0xd391","0xd12a","0x0d79","0x0ff0","0xd6b9","0x96f2","0xfddf","0xd1d0","0x2b33","0xac99","0x392f","0xe23b","0xf12b","0x3924","0xe221","0x92e6","0xe7bb","0x912d","0xc57e","0x1596","0x3edd","0xb5b2","0x43dd","0x3d41","0xe0f2","0xf3d2","0xda4f","0x4efa","0x16f","0xd3ca","0x0f75","0x712c","0xcf0e","0xa72c","0x0eb1","0x326c","0x52d1","0xe2ef","0x4011","0x3ee2","0x2400","0x1c0","0xc4ff","0xff1e","0x9cc0","0xf020","0xfd13","0x75d1","0xfce0","0x7133","0x3dd5","0x500e","0x402c","0xe01e","0xfd1a","0x1423","0xffcf","0xe2fd","0xa700","0xf6d1","0x9f5e","0xb0e2","0xd346","0x10ba","0xc334","0x3d9e","0x0ff3","0xe3d9","0x0c5f","0xb00e","0x1419","0x6e5e","0x249","0x2e06","0x2f0f","0x1fe2","0xc34f","0xbd0c","0xf10c","0xcec1","0xfdf0","0x91fd","0x1240","0xc043","0x10","0xc5d1","0x14fb","0x31","0x12dd","0xd1db","0xb3da","0x5dd0","0xc32b","0xdff9","0x342b","0x3d30","0xba01","0x9c00","0x1c3e","0xce3e","0xef01","0xe0f0","0x371b","0x423d","0xd3f0","0xe2f4","0xdf1f","0x0e2f","0xe29f","0x1d12","0x2e0e","0xbcf0","0xd902","0xa3e5","0x20e","0x1b30","0xfff2","0x6fcd","0x22ae","0x225e","0xa4f2","0x13f1","0xacd2","0xeecc","0x2000","0xf19c","0xf01c","0xdfde","0x4000","0x9ddf","0x2b29","0xff1f","0x3ee9","0x0e1e","0xfe2f","0xd034","0x0fd0","0x359f","0xaea1","0x4ee9","0x243c","0xf30e","0x41fe","0x4be7","0xaed5","0x0a63","0xce19","0xa24f","0x13e9","0xcfb3","0x3b2b","0x2f7e","0x4daa","0x3e1","0x41a3","0x30cf","0xff10","0xd33c","0xc254","0x0ff3","0x0daf","0xd4f4","0x292a","0xfcf3","0xe903","0x1514","0xd30e","0x2005","0x23da","0xff2f","0xb220","0x3ccd","0x4eb","0xf134","0xeea9","0xf7ae","0xfff4","0x305d","0x2b32","0x17e","0x32f0","0x1603","0x1d3f","0xc233","0x6cac","0x4171","0xf5f9","0x1a2d","0x1300","0xc31e","0x32cd","0x61ec","0xd03f","0x0e20","0xd10f","0x27f1","0x6f31","0xfe41","0xf2c6","0x2ef1","0x5f2e","0xf34e","0x72e3","0xe9f2","0x5b30","0xe561","0xb2e1","0x5693","0x1b65","0x2f6e","0x3d6","0x2e4","0xb24f","0x0a44","0xe1f4","0x103f","0xe3f1","0xc0fd","0xc44d","0x2bed","0x6fa9","0x34fc","0xa2ae","0xef2b","0xdde3","0xac5a","0x104d","0xb117","0x29f2","0x93ee","0x9deb","0x11de","0xb293","0x6b1d","0xbfed","0x5ef0","0x11d9","0x1224","0x9ccc","0x2e20","0xfe44","0xe9fa","0xde2b","0xaf20","0xfd14","0xa2f3","0x25ec","0x3412","0xc2b2","0xf9dc","0xaeee","0x2fbf","0x1dd2","0xf2ff","0x61b4","0x1702","0x41ce","0xa953","0x0dfe","0xcaff","0xf46f","0xefb2","0x10f0","0x5111","0x2332","0x21fd","0xe511","0xce51","0x2314","0xe305","0x0f1","0x112f","0x2fc0","0xa23d","0x52a","0x4037","0xd12f","0x1d2","0x31f4","0x213f","0xff70","0xfe12","0x34ee","0xe97f","0x172","0x3bf2","0x6fc0","0x45fb","0xb39f","0x1d9c","0x0ed","0x7026","0xed3d","0x1b3f","0xe450","0x3421","0xf230","0xa0e2","0x2723","0x515f","0xf042","0x24","0xa2df","0x2fe4","0x1690","0x3b9c","0x0de0","0x2c35","0xae60","0xb2a3","0xc2ed","0xf112","0x9516","0xfd1e","0x9529","0x35b3","0xdf19","0xeedd","0x71f4","0xfe70","0x2e2f","0x1cbd","0x1ca3","0xc933","0x35f5","0xc92e","0xba2b","0xce0b","0x2ce","0x30cc","0xe1be","0x17fe","0x11bf","0xdda4","0x10e1","0x5e24","0xca41","0x21c2","0x1bc4","0x3e7e","0xfc2f","0x2ae0","0xeabd","0x5dba","0xeb9a","0x5fb2","0x444c","0xf341","0xd2df","0x4fe1","0xfe43","0x0ff","0x9b02","0xef51","0x9a3d","0x4c29","0xde11","0x20e0","0x345","0xb74d","0x1f7d","0xe10f","0x7e17","0xd1c2","0x41eb","0xc3ca","0x2c10","0xe3de","0x4fbe","0x249a","0xdc62","0xdfdc","0xde6e","0x9d95","0x1ece","0xdd95","0xed3a","0xd102","0x1022","0xfdfd","0x20f9","0x36d0","0x9c40","0x9b3e","0x1cd2","0xbfb1","0xbf1f","0xd03b","0x2f30","0xedaf","0x7f0d","0x1013","0xff2e","0xc1d0","0xd613","0x2d3d","0x0d3d","0x500e","0x13","0x201e","0x1a0f","0xa225","0xbfd0","0x1acf","0xfdd1","0x2e9e","0x724c","0xf644","0xae04","0xe241","0xfde5","0xfefa","0x3f3","0x14a0","0x41a1","0x2deb","0x0f02","0x94d4","0x10ce","0x20ff","0xe1a2","0xce94","0x4f31","0xfadb","0x402f","0x14b4","0x7c15","0xc20e","0xf390","0xe2c0","0x41bf","0xce0e","0x0ff4","0xb4d2","0x51a6","0x2c7d","0xc331","0xc4c1","0x65f1","0xebfe","0x1e0f","0x142e","0xb913","0xebef","0x2f5","0xdaf9","0xb25b","0xf12f","0xe21d","0xb2c1","0x1e20","0x0ae9","0xf41f","0x20db","0xb722","0x9a1c","0x2c09","0x49bc","0xecbe","0x27c","0xf21f","0x1d3f","0x27f0","0x5d13","0x2df0","0x10c1","0xffb1","0xc033","0xf2e4","0xce1e","0xe406","0x37a","0xd4c4","0xc0e0","0xfd31","0x114a","0xff50","0xe2ee","0x310","0xd214","0x212","0xf421","0x421","0x9214","0xffe0","0xf40d","0x1ea7","0x0e3d","0x549d","0xa140","0x0aec","0xcce1","0xcb5d","0xf0c5","0x4df4","0x13b0","0x2c1c","0x3c74","0xa42d","0xd6ac","0x5a0c","0xb300","0x511","0xbddb","0xcccd","0x6cfd","0x20f0","0x3193","0xbe46","0xca96","0x1d4d","0xd137","0xc063","0xe1b0","0xf214","0x4f39","0x4206","0x62eb","0x1d03","0x6342","0xf0bb","0x942e","0x72d2","0x569e","0x6e95","0xd1c2","0x5523","0x702f","0xe1fc","0x1fa7","0x2f34","0x7f3a","0x360d","0x914d","0x0ff1","0x2207","0x13e","0xe0a1","0x32df","0x7141","0x1dfd","0x4543","0x522a","0xf2fe","0x9eb2","0xd2d2","0xc103","0x5e49","0x1200","0x31c7","0xaffa","0x20ed","0xdd34","0x34f5","0x2fde","0x5111","0xe0f0","0xec0e","0x20bf","0xdc3f","0xee24","0x20d1","0x364b","0x10c5","0xd15c","0xb1f2","0x129","0x3102","0x43bb","0xe4d1","0xd202","0x34be","0x1dcb","0x1f2d","0x377a","0x22c1","0xc7b2","0xfcbb","0x12ef","0x9fdf","0x6cbf","0x7fd1","0xfda1","0x3e9","0x12ee","0x603","0x7d3f","0x3ccc","0xe240","0x435","0x34f","0x45b1","0xd420","0xb1a6","0xa2b2","0x90ac","0xce0d","0x12cd","0xb1bd","0x6505","0x3c3","0xd03d","0xf00e","0x21d0","0xd331","0x0dee","0x5df4","0x795d","0xeb50","0x2f20","0xfdd1","0x20eb","0xe3ea","0x936b","0xf901","0x14f7","0x925e","0xe1af","0x21ec","0x607c","0x51ff","0xe9ef","0xcdfb","0x703c","0x1ea2","0xacf2","0x34b4","0xdd3c","0xa109","0xa0c3","0x23cc","0x4e31","0xd322","0x74e7","0xf3ff","0xdf20","0xcccf","0x1d01","0x2e41","0xbd00","0x0cff","0xf203","0xc11c","0xbcff","0xef13","0xf25f","0x1fdb","0xe301","0xef34","0xf4f6","0x31e4","0xd190","0x7ee2","0x54f5","0x0fac","0xe0af","0xc1cd","0xed9d","0x2210","0xddba","0x31d5","0xeee1","0x6ced","0xd05e","0x1dc5","0x2223","0x2ed6","0xc3ce","0x0d16","0x1cde","0xccd9","0xeeb7","0x1bcf","0x2143","0x3c3f","0xedbc","0x1112","0xaef7","0xfa70","0x142f","0x0c97","0x7cd0","0x2","0x2cee","0xbece","0xda07","0x1f4","0x249c","0x6bd2","0xd07e","0x24c4","0x4d9e","0x9230","0xd31c","0x6da2","0x4e99","0xee31","0xfad1","0x1d43","0x5fe3","0x1fdf","0xd131","0xc4eb","0xdf01","0x4cd6","0xa50e","0x2c21","0xeabc","0x40c6","0x1ff0","0xedfc","0x1cfc","0x2d01","0x4e12","0xc3e4","0x1135","0xd0af","0x6c42","0x4023","0xc124","0x0af5","0x0a90","0x5e1e","0xfd0c","0x1f21","0xab53","0xfbd0","0xc527","0xddb9","0x3010","0x41b2","0x3032","0x4210","0x2901","0x461","0xdfb1","0x23ff","0x4e44","0x6005","0xe3d5","0x3ee3","0xfb61","0x2a13","0x1015","0xe1df","0xe51d","0x4531","0x3c2b","0x3f5f","0xa5d0","0xd4e0","0x3ecb","0xffd3","0xfaf2","0x3bcf","0x0d9d","0x1d30","0xe330","0x11ec","0xfe33","0x25e0","0xe97d","0x502b","0x2c20","0xe04e","0xeedd","0x309b","0xecf0","0xd9de","0xcdcd","0xfe4b","0x1f4f","0x200f","0x1d","0xe114","0x14d1","0x1eef","0xdefa","0x49d9","0xeaef","0x9d0b","0xfaf1","0x7df","0xf30f","0x3e10","0x2f9","0x191a","0xa022","0xc033","0xd0fd","0xcc2a","0xa210","0x0b6","0x5fc2","0x11e1","0x3dc0","0xe31a","0x30fe","0x91f1","0x9adf","0x3d0e","0xc31b","0xd1fe","0x26ce","0xf120","0x5fb","0x33f4","0xff5d","0x7092","0xd7e5","0x7414","0xce90","0xe1d1","0x53ef","0xd3f0","0x17ed","0xf399","0xb0a2","0xf3d1","0x2202","0x41e","0x3fe2","0x1ff1","0x1de4","0x0d91","0x33c1","0xf7e0","0xff13","0x4fdb","0xa427","0x2b1","0xf106","0xe509","0x2e20","0xf1ed","0x10cc","0x1e3a","0xe097","0x2eef","0x73c0","0x0be0","0xed4d"}
},
{{"0x20f","0x22a1","0x1152","0xb102","0xe6f1","0x592f","0x14f3","0x1f60","0xd343","0xcd6e","0x3023","0x4131","0x763e","0xde01","0xad2b","0xaff3","0x2400","0x2219","0xf9f1","0xcb17","0xb3bd","0x20d","0xd3b5","0xe6de","0x4cf1","0x4b32","0x511b","0xec2e","0x404f","0x690f","0x39a","0xbdef","0xef22","0x70ec","0x3d31","0xd020","0x2ce4","0xf222","0x1091","0x32d5","0xc0c0","0xac3d","0xed0f","0xc10e","0xdde0","0xfd40","0x26ef","0xcdb3","0x0fe","0xc142","0xf500","0x2e6e","0x3e2d","0x200f","0xf3ee","0xc310","0xdbdf","0x0e53","0x200f","0x20c3","0x1d1e","0x9ce1","0x21ce","0x2231","0x22fc","0xc42a","0xa010","0x131f","0xcf40","0x3ef0","0x3cfd","0xa63b","0xbad1","0x6a0e","0xf099","0xf047","0x0de9","0xca1d","0x7de","0x40f0","0x16df","0x29e4","0x226a","0x0fad","0x92ac","0x1f04","0xbf34","0x2322","0x495b","0x1311","0x4b5d","0xa4bf","0xf251","0x0d9d","0x57de","0x50e2","0xf296","0xfe2e","0x90e3","0xd640","0xbf22","0x3d3e","0x3aed","0x22da","0xff14","0x2f01","0x40","0x1ee2","0xfbf3","0x505b","0x2129","0xc419","0x91d0","0x6203","0xcebe","0xf4c9","0xef20","0xd0be","0x40e3","0x22c2","0x12fa","0x132b","0xf47b","0x4d23","0x4d11","0xa11e","0x100f","0x902b","0xeb99","0xc10f","0x2f2f","0xe591","0xd79a","0xd0be","0xdce0","0xf193","0x4bbd","0x2ba","0x90be","0xf5fd","0x2fed","0xfed2","0xf1b5","0xe0e1","0x3119","0x220d","0xd221","0x1d0","0x6135","0xf0ba","0xe2ed","0xbc9f","0x2b3a","0x2","0xd240","0x29d","0xf210","0xdf9c","0x1e9d","0xe7e2","0x1ce4","0x7fc7","0x6f42","0x7143","0x6cff","0x5f0f","0x1be6","0xddb2","0x0910","0xe0f1","0x9b7d","0x410c","0xe900","0x3fa0","0x2491","0x501f","0xf4ce","0xf320","0xf3e5","0xef43","0xc1f7","0x20b2","0x2a0e","0xbecf","0xa9f4","0xc54c","0x4112","0x3f0d","0x5134","0x2dba","0xfed2","0x102e","0x3ec3","0x3602","0xf47c","0x225e","0x0cf","0x6fbf","0xd003","0x10a","0xfffd","0xddbe","0x2c24","0x2f3","0x254e","0xfac2","0xdeaf","0x1dc","0x0be","0x2115","0xbe01","0xa13f","0x3ef9","0x43b2","0xed1d","0xe7d3","0x21f9","0x2eca","0xc315","0xc33e","0xc2ef","0x19cb","0xd7d3","0x11a0","0xe11c","0x1db3","0xabf3","0xded5","0xecbe","0xcc02","0x0de4","0x11d3","0x7930","0x2b2e","0xb91c","0xa1bf","0x193f","0x0dec","0x2fb6","0x1c5","0xf3f0","0x710","0xd695","0x3f3e","0x9c12","0x0b7d","0x509","0x2002","0xeee0","0x632e","0x2f3","0xf205","0x111","0xa3ee","0x59e2","0xb2ed","0x5e75","0x130d","0xb34c","0xf33e","0xddd0","0xb74a","0x3d0b","0xd000","0xad2c","0x1f5d","0xdea1","0x3d7","0xb310","0xc2d1","0x5fdf","0x0f93","0xa5f2","0x0fd","0xf1b0","0xef12","0x13ba","0xf14c","0xd99e","0xf1c5","0x1ade","0xbd6d","0xe200","0xa002","0xe61b","0xc02f","0x1e0f","0x1ce0","0x10f9","0x10b5","0xdcff","0x3bdb","0xa93a","0x1f11","0xa1fa","0x36f2","0x7b15","0x257e","0xd0de","0x6032","0x91ff","0xa4b4","0x40c9","0x9921","0xad69","0xdb5e","0x3fc2","0x1bdb","0xeafb","0x631c","0xe4bd","0x6203","0x320e","0xe53d","0x0d00","0x0c1d","0xd70e","0xbec0","0xd019","0x24d1","0x504b","0xf9ee","0x104","0xce3d","0x1dfe","0x3fa2","0xb14e","0xc11b","0xc12e","0x4df0","0x3fdb","0xf130","0xfc3a","0x5a15","0xe331","0x5123","0x1526","0x22d3","0x3fe5","0xf3bb","0xa1fd","0x0fa5","0xcb3a","0xd477","0x0cb0","0x3523","0x9093","0x13ed","0x3bf4","0xed9e","0x9130","0xd221","0x6ff5","0xffc1","0x0b11","0x5af3","0x9c00","0x26d0","0xbb09","0xb067","0xedd2","0xe1fb","0x75e6","0x202f","0xffeb","0x6f0c","0xad0f","0xf36f","0x34b3","0x4213","0x34e4","0x49e4","0x111e","0x4321","0xa2ef","0xe79f","0x2120","0x3edf","0x19d0","0x0dcf","0x93ce","0xe12e","0xeade","0x16e2","0x0fd7","0xe392","0x603f","0xad12","0xee2f","0x20df","0x41ad","0xee42","0x325e","0x122f","0x3dd3","0xb272","0xd76b","0xfc96","0x41e4","0xec03","0x70df","0xfda2","0xbd23","0x0d5","0x100","0x4c12","0xe4d6","0xa0b6","0x4943","0xaee3","0x310","0xc6be","0xe531","0xaf91","0xe6d3","0x9ca4","0x40ef","0xce32","0xfd70","0x11f2","0x131c","0xbc1c","0x2d1f","0x6fd5","0xd27f","0x2910","0xe223","0xf0ee","0x3f11","0xcfe0","0x0f5b","0x6b13","0x0e1c","0xeb0d","0x3e69","0x33e4","0x2c12","0xc4fe","0xbf4e","0x7dc1","0x536d","0xd1b2","0xcdbf","0x5f13","0xc121","0xd12f","0x2054","0xccb4","0xc2ed","0x39d0","0xe160","0x4c0f","0x4fce","0x0d12","0x4f22","0x70bc","0xc703","0x3310","0x6ff1","0xe336","0x1340","0x0c17","0x2655","0x105f","0xf205","0xe231","0x413c","0xe01e","0x6726","0x4771","0x7310","0xc012","0xc39f","0xde50","0x7571","0x7402","0x1f27","0x2e3b","0xa16e","0x244a","0xf1f4","0xc2df","0xd004","0xdd1f","0x4efe","0xdbae","0x5173","0x2136","0x0c02","0xbf92","0xd9ef","0x2c1d","0xf9ee","0x1e","0xca14","0xefab","0x21d1","0xfca4","0x250f","0x0cbc","0x3af","0xec0e","0xd11d","0xbd50","0x2b21","0xa0b3","0xebf7","0x22f2","0xeaef","0xf4da","0xc24d","0xb2be","0xf4ce","0x0a01","0x71ff","0x1000","0xd62c","0xe0e9","0x3d0d","0x1aef","0xd022","0xb014","0x3fe2","0x0f3f","0xed1e","0x1a14","0xba1f","0xb103","0x3e21","0xea31","0x30b0","0xc6fc","0x504d","0x33ee","0xb4de","0xdeee","0x3100","0x4347","0xeb52","0x4702","0xaef4","0xcc2e","0x0c2f","0xe3ef","0xf1e0","0x3c10","0x91f0","0x3500","0xc1f0","0xd617","0x5c32","0x92f1","0x12f2","0xf513","0x21ef","0xe011","0xfe4d","0x6401","0x1db7","0x4c2","0xfcde","0x2d1c","0xa70e","0x2b10","0xaff5","0xf455","0x141e","0xf231","0xca06","0x97d2","0x22f2","0xbdb4","0x2cd3","0xa3e2","0x3c7","0x0ed7","0xd229","0x63cc","0x30e5","0xc1a2","0xd130","0x0eed","0x2a11","0xc07e","0xddbb","0xfadc","0xe7e5","0x12f","0x1ded","0x12be","0xe53b","0x622","0x24d9","0xed11","0x4ec","0x700","0x4e42","0xddbf","0xd900","0x1271","0x0dfd","0xfdc0","0xdebf","0x3fbe","0x50c1","0xf4f0","0x15df","0x4034","0xccd0","0xe0bc","0xd041","0x17f3","0xb924","0x7d01","0xcbbc","0xa43c","0x1f41","0x3134","0x2de7","0x3ecf","0xff21","0xde0d","0xff13","0x5333","0xd20c","0xa6f0","0x6cd3","0x2901","0x2ac2","0x1fc0","0xdbd5","0xcfdf","0x3f1f","0x6c0e","0x401c","0x6031","0x49","0x1dfe","0xf409","0xdf6e","0xe722","0xa4c9","0x7bf2","0xfbdc","0xd0af","0xfd95","0xd0c3","0xe254","0x19b2","0x0cbf","0x4bc","0x2104","0x251","0x7ab","0xf7a9","0xf30b","0x3ca5","0x1fce","0x7195","0xa706","0xc91e","0x73f9","0x4b5e","0xab0e","0x3d2b","0x1b23","0xf0e5","0xf07e","0xdff5","0xd240","0xf56f","0x2e32","0x90d0","0x2eb2","0x2bec","0x6ee0","0x9fed","0xd01d","0x2ce9","0x9ddd","0xdf01","0x72a2","0x4ff0","0x3200","0x2440","0x3ef3","0xdfee","0xdcbe","0x0f9e","0x409c","0x7de0","0x4b23","0x4eca","0x163c","0xd2bc","0xecee","0xa9d0","0xfb07","0xfe42","0xe391","0xf936","0x4c9d","0x32b","0x9cd7","0x6b90","0xd1d2","0x1ff0","0x29df","0x11cb","0x5340","0xebda","0xd42f","0x3bc1","0xa142","0xa23f","0xf7b2","0x3e27","0x2af","0x12df","0xec3e","0x7311","0x1577","0x23ff","0x4341","0xe1c3","0x9ec2","0x1b92","0x4a2","0x0c21","0xd7fd","0x12b2","0xecd0","0xb993","0x2bc","0xe02e","0x0f9a","0x3dfe","0x2741","0x4c0d","0x524","0xf6f0","0xbfb4","0x49f","0x222d","0x27b","0xa22f","0xf0ec","0x1e2f","0xfcf5","0x0dea","0xda17","0x2dbf","0xedd6","0x270d","0x0ec5","0x15db","0x6e50","0xdf21","0x63f5","0xeece","0x322b","0xfebf","0x1041","0x6ed2","0xdabf","0xc3ee","0x123f","0x21d","0x514f","0x4ee0","0x434e","0x3120","0xc07f","0xfb94","0xf14f","0x45ee","0x0eec","0xf1f1","0xdfe4","0xc0fe","0x34f1","0xbff1","0xd2fd","0xd5d3","0xfc95","0xf3df","0x0de1","0x4dad","0xb150","0x3df1","0x2cdd","0x1f3","0xce4f","0x4024","0x292","0xcffe","0x4ef0","0x4fd2","0x3e0f","0x9743","0x60fc","0x3ed2","0x41ce","0x2aae","0xacc0","0xf021","0xab1f","0xddf2","0xd0f0","0xbe5f","0xf546","0xb2cd","0xddcf","0x21cf","0x2f3f","0xb23e","0x1327","0xb3f3","0xbcfd","0xd2fe","0x50ed","0x1da4","0xde4a","0x42f4","0xb452","0xc120","0x2e2a","0x4edb","0xf731","0xdd1d","0x1d41","0xe1f6","0x2752","0xc309","0xb19f","0xcb29","0x90f0","0x2f32","0x2731","0xaec2","0x4bf3","0x30ff","0x3b44","0x0c5f","0x30d9","0x46e","0x4f63","0xf194","0x7eec","0xfa49","0xe6e0","0xfc03","0x1019","0x3e7b","0xb319","0xa09f","0x1e02","0xeb02","0x13d6","0x2411","0xa60e","0x9421","0x0ffb","0xdd91","0x5ec","0x32c","0xff2e","0x4f9f","0xc9cd","0x12ae","0xcdfe","0x9557","0x1930","0xb1fe","0x21b1","0x7d3e","0x4fd7","0xc0be","0xee21","0x2006","0xf1d5","0x0e0","0x6bbb","0x21d3","0x9df4","0xd5d4","0x19a3","0x24f0","0x09ce","0x0f4b","0x3dfe","0x3fb5","0x0dfe","0x4df1","0xf5fe","0xa1dc","0x2dce","0xfe12","0x2f3f","0x1fc","0xf01e","0x2cfe","0xca3b","0x220f","0x9926","0xd21d","0x4e10","0x4e10","0x0b2b","0x313a","0xfe2b","0x1fbf","0xc0dc","0xd5e1","0x9411","0x22e3","0x92ed","0xfb5c","0xfb40","0xbccf","0xaefc","0xcf5c","0x37a0","0xf0e0","0x2fc0","0x0dcd","0xd0b4","0x411d","0x1e19","0x0cd1","0xc3dd","0x1043","0x23f3","0x111e","0x2f31","0xbc90","0x2ee0","0x4eba","0x1104","0x40b1","0xde20","0xcc2d","0x3dfe","0xe5cd","0x35cc","0x7ffb","0xbdf1","0x3213","0x4e57","0x22cb","0xec01","0x7190","0xd0ce","0x41d2","0x1ff","0xfb20","0x0ff7","0xf0ef","0x3ff5","0xf3d9","0xc72a","0x3c5","0x09","0x7d7","0xdf21","0x2051","0x2210","0xd00f","0x66ee","0xb0ed","0xd692","0x1dff","0xf232","0x3de0","0x0c0d","0x3fef","0x941c","0x4df2","0x2aac","0xf4a6","0x2c2e","0xd1dc","0xdf3b","0xe099","0x79d2","0xeb24","0x9f51","0x7e2e","0x927c","0x141c","0x5eb2","0xdf1f","0x321e","0x634f","0x0b66","0x9412","0xed0e","0x602f","0xbf91","0xf7af","0x1900","0x1b52","0xeb22","0xb7f0","0xe90f","0x45a0","0x55d6","0x3c4a","0xc0b1","0xaf14","0x0e0f","0xed79","0x9c1f","0x15","0x10f0","0xad30","0x4b74","0x1115","0xf0df","0x634c","0xe713","0x104e","0xbdb3","0xfb12","0x99f2","0x753f","0xdee6","0x5011","0xeb23","0x2f7","0xb3c0","0x9a12","0x1c33","0xedc5","0x10e4","0xbeb3","0xf401","0x51f1","0x1ebc","0x370a","0xe1fc","0x4421","0xc4e2","0x1c2","0xe1de","0xffb0","0xd9fe","0x9db3","0x34c0","0xe4a9","0xfcd3","0xed10","0xfe32","0x20ee","0xddff","0x302","0xfbff","0x120f","0xff10","0xe232","0xec24","0x2bc1","0x4bdd","0x91f3","0x2e","0xf19e","0x2d1e","0xfeda","0x1b3e","0xfed1","0x30c1","0x3cde","0x1212","0xe356","0xafc5","0xe4ea","0xdd16","0x1efd","0x6b12","0x9e0f","0xdd4f","0xcf04","0xf1ea","0x633c","0x722f","0xdd0f","0xfb11","0x2ecf","0xa2fd","0x4f94","0x5c62","0x37f0","0x92d0","0x2ef1","0x5102","0xd912","0x90fd","0x2fe3","0x124d","0x202f","0xe610","0xcbf4","0x1230","0x50b1","0xc2ff","0xe252","0x7dad","0xf500","0xc312","0x2ad","0x35fe","0x0dff","0xfad3","0x1f4f","0x2ff3","0xa211","0x2746","0x21e4","0x2f16","0xd195","0xffef","0x5901","0x0d70","0x317","0x9f00","0x09db","0xc10b","0x19a1","0x697e","0x5f57","0xa5fd","0x32d1","0xb14c","0x239e","0x1ac0","0x20cc","0x6dcd","0xdff2","0x20e2","0xd3ff","0xfeae","0xfaef","0x2d4","0xd60f","0xda43","0x9f1c","0x65fc","0x11c6","0x0f60","0xd1f2","0x161d","0xdd02","0x41ff","0xd473","0x6dfb","0xe203","0x0bfd","0x16f7","0x1179","0x0a24","0xcee6","0x2732","0x15f","0x1dc5","0x4b0","0xe41e","0xcd1d","0xb611","0x2c02","0xcb02","0xfa6f","0x1c03","0x3ff2","0x2031","0xe3e0","0xdab3","0x422d","0xdd06","0xdfef","0x1fc6","0xa07e","0xb007","0xc7ff","0xa19e","0x6bf1","0xfd37","0x0e05","0xeddf","0x42ff","0x1c4d","0xcfbc","0x2ddc","0xfcc4","0xe2f3","0xfef1","0xf0df","0x754d","0x100d","0x0e4e","0xd3d1","0xd39d","0x5bfd","0xbc11","0xb31d","0x42f2","0xbd32","0x3d5e","0x0e0e","0x50de","0x90df","0x5def","0xde10","0xaf02","0x2e21","0x2444","0xe361","0x239f","0x312a","0x103a","0xd2fc","0xf56d","0xb0ea","0xc33f","0x0a9a","0xddd2","0xee19","0x20be","0x0f4","0xb0e2","0x2171","0x46b6","0xc504","0x1ed1","0x1c30","0x1f4e","0x1fc","0x6ee","0xcfee","0xef31","0x791e","0xe9dc","0xee79","0x31e0","0xeacb","0x24","0x5f30","0x0cc1","0xd032","0xd0d1","0x0c9d","0xd20f","0x095","0xc01f","0xcb44","0x3ff9","0xcc61","0x4675","0xffb4","0x411d","0x3f09","0xe0d1","0xbff3","0xe61e","0x4e33","0x42cf","0x9ab2","0xcf15","0xecc5","0x0e3b","0x9c3c","0xe6f9","0x321d","0xc253","0xfe44","0xe0be","0x6fa0","0xe1c1","0xd1b6","0xc930","0xf3d0","0x3c01","0xcfff","0x152","0x3e33","0xeb60","0xc150","0x1c","0x420e","0x1f4d","0x2b13","0x1142","0x6d30","0xcc1e","0xfe43","0xb13d","0xe3f2","0x10f4","0x17f0","0x42e0","0xcbf0","0xf22c","0x1cfe","0xedf5","0x960f","0xc314","0x0d41","0xfe10","0xd11d","0x143c","0x2fc4","0x13f2","0x120a","0x1011","0x1e1a","0x45a2","0xbfe1","0x0e0a","0x1bd1","0x9242","0x0c0c","0x6f50","0xdfe4","0xaf3a","0xd40a","0x41e0","0x1e0","0x732d","0x1bdd","0x202","0x0e4","0x93fe","0x23dd","0xefa1","0xf114","0xfb41","0xd524","0x132f","0x22d1","0xf903","0xb11b","0x2dff","0x21e1","0xf110","0x11fe","0x6f0c","0x2d0e","0x296","0x24e7","0x9053","0xe4ff","0xfceb","0x9e61","0xea3e","0xaf1a","0xe9f1","0x590e","0x1bef","0x0e3f","0x4305","0x10fc","0xed54","0x2eb","0x246","0x23ed","0xcceb","0x2efa","0xce99","0x0e40","0xe000","0xe0ec","0x0ed3","0xf0fc","0x3d90","0x9d41","0x214b","0x7270","0xdee3","0x17e6","0xb1b0","0x134c","0xa102","0xc0d2","0xa9b3","0xdbd1","0x1cfd","0xab3c","0x1dc2","0x46b0","0x1a1","0xcd1d","0x166d","0x0e4b","0xb027","0x40a3","0x6f73","0x220f","0x6f0c","0xfc45","0xf2e4","0x0971","0xd032","0xbac5","0xe740","0xf905","0x5ca0","0x3fc1","0xfd2e","0x517f","0x6e27","0x2af7","0x5ee1","0x3ff3","0x1a2b","0xee02","0xb06f","0x70c2","0x201","0x69a2","0x1656","0x293f","0x0e","0xe3d3","0xfe04","0xef12","0x7f22","0x3d31","0x9427","0x2123","0xef21","0x9e10","0xfbf3","0xf014","0xab01","0x3ffc","0x3406","0xe211","0x513f","0x59f","0x30b6","0xe422","0xf4e2","0x5e3d","0xf00e","0x0ee2","0x544b","0x45b3","0x97fd","0x193","0x715e","0x6222","0xdd9c","0x7039","0xdc05","0xe50c","0x2406","0xcd32","0x3c31","0x3e32","0x2f41","0xf3ed","0x6b11","0x1544","0xf4de","0xf6e2","0x36ff","0x3f30","0x1ec3","0x11c","0x5041","0xdeee","0x6c2","0x4fe3","0x132f","0x0f5f","0x1d24","0x100e","0x46","0xf30d","0xcc0e","0xce66","0xf6f4","0xadf3","0x12","0xfe4d","0x21f3","0xe0eb","0xefb3","0x4a50","0xce4d","0xf511","0x6c1","0x0e0","0x9d0e","0x273","0xe2da","0x275f","0x2010","0x124f","0xa310","0x1fd0","0xff33","0x1411","0x0d0","0x400f","0xc249","0xb20f","0xef4d","0x203e","0xe120","0xdd72","0x61cd","0x97ef","0x4ebb","0xd62c","0xee50","0x0ced","0xce10","0xdf30","0x3ff0","0x30fe","0x539","0x0bd2","0xdc34","0xf5fa","0x2062","0x5c44","0x260","0x3cd","0xf9a9","0xd921","0x1e5b","0x0e01","0x0f16","0xf013","0xf33e","0x11ca"},
{"0x6a1","0x601","0x55da","0xe1e0","0x0efd","0x1eb1","0xc14e","0x2355","0x49f2","0x1b04","0xdc72","0xfdfd","0x64eb","0x10ca","0x409d","0x45c3","0xf4f2","0xce97","0xbef7","0x2052","0x21d3","0x4356","0x1eaa","0x30c5","0xa1eb","0x3e1e","0x61ec","0xceb9","0x6001","0x9ac7","0xf39c","0xfece","0x3201","0x40e7","0x3cd9","0xf152","0xfe1e","0x64d3","0x2fd0","0x733f","0xc521","0x4d13","0x33f0","0x231","0x10df","0xbc02","0x0d67","0xc1d0","0xb1b0","0xd1de","0xd52f","0x4dc3","0xffb1","0x0cd2","0xae5c","0xa30e","0x2ed0","0x6045","0x0cfe","0xabb9","0x132b","0x3ef9","0xd21f","0x164f","0xc1d1","0xdf97","0x7e97","0x50e3","0x9e21","0xc1aa","0xabb5","0xc42a","0xe9e9","0x7bfc","0xd3c5","0xcad9","0x2e59","0x0c27","0x179b","0x4020","0x5d72","0x4f01","0x9e0f","0xe41f","0xb3ed","0x0dfe","0x9002","0xc77f","0xa94f","0x912d","0x7f9","0x4e13","0x20b9","0xd499","0x729b","0xbe0f","0x20a5","0x2ed0","0x9ef1","0xf030","0xffee","0x3a00","0x099","0x230f","0xf0e3","0x4004","0xbedd","0xb3e4","0x41b4","0x7e3f","0x1f1c","0xb25b","0x31e0","0x5f49","0x2a5d","0x32b9","0x325f","0x11e3","0x40bd","0x53ae","0x7dd4","0xb11b","0x557e","0x40f5","0x71be","0xe27f","0x6e0c","0xdeec","0x0baa","0xa3c0","0x3112","0xd6aa","0xf1c9","0xd5ee","0xbd00","0x9cb4","0x0b9a","0x40f9","0xef00","0xd1d3","0x10fd","0x1004","0xffce","0xf421","0x1b3d","0x0fe4","0x6472","0x1e02","0xe10f","0x2f9c","0xe201","0xdec4","0xcc1a","0xdf04","0x34d0","0x20e7","0xc71c","0xeede","0x1d2","0x2df3","0x5e90","0x330e","0xffba","0xa1cf","0xeed5","0xe9d9","0xad40","0x9f45","0xdc3b","0x25e","0xc905","0x32b0","0x4133","0x2cd9","0x4995","0xe6a4","0xf495","0xeec5","0x440d","0x22d7","0xe15b","0x24ef","0xebb0","0xab0d","0x71d2","0x672b","0xf466","0xb6f9","0xe0a1","0xcd13","0x1abf","0x51cc","0x33f0","0x17ed","0x524f","0xce02","0xbe02","0xf022","0x5f1e","0xff09","0xbcef","0x0fde","0x349f","0xf03b","0x4330","0x3422","0x4009","0x5e0f","0x9e36","0x4a09","0x7f12","0x415","0x11ea","0xbe1e","0x799e","0xd010","0xc96d","0xaf35","0xde99","0xff22","0xe62d","0x1e2d","0xd6fd","0x100e","0xe4ef","0x59d1","0x7b52","0x261b","0xdbc6","0xfcce","0xffd3","0x41ee","0xba5b","0x5c41","0x1ed4","0x9dde","0x0bf3","0xdf17","0x41f0","0x1d93","0x30f3","0x4050","0x23d1","0xdcc1","0xe2fb","0x442c","0x3041","0x0eb","0x2100","0x7617","0xff42","0xd1e9","0x20f0","0x3eb5","0xbb31","0x1273","0x2404","0xcdc9","0xe0f0","0xdb03","0xf011","0x613e","0x2047","0x1cf1","0x7b04","0x1e7","0x653e","0x2fb4","0xef74","0x77ee","0xebae","0xd794","0xe04b","0xcdfb","0xa031","0x6e44","0xd01c","0x37fa","0xdffe","0xf3a4","0x4c27","0x2b7","0x0e01","0xe0e3","0x11fe","0x101","0x51dc","0xc2dc","0x0db","0x11c1","0xf22e","0x49a9","0x9bea","0x9219","0xf44a","0x553f","0x7ce3","0x160","0xf1ff","0xe071","0xb49c","0x9492","0x61ae","0xb2e3","0xace9","0xdfb2","0x52f4","0xffec","0x0f1","0x3fcf","0x19","0x6f2c","0x29f6","0x0d72","0x2d4f","0xab6e","0xe797","0x3e91","0x6c1a","0x743e","0xce3a","0xa0ee","0x44f4","0x2eb","0x5f31","0x0c02","0x191d","0x2a3e","0xcb30","0xfeef","0xdf0c","0xd222","0xdff6","0xfefd","0xfe2b","0x0eef","0x9a30","0xb629","0x5d10","0x1fdf","0xfe3b","0xeda1","0x5179","0xdd15","0xf39e","0xa34c","0x3ea4","0x0d9","0x7195","0x731a","0xe2ed","0x0edf","0x0d34","0x2b4a","0x34e9","0x721e","0xa0c5","0xf21a","0xc2d4","0xa614","0x20b4","0x12fe","0x6ef5","0x2110","0x3fbd","0x5b10","0x161a","0xf04e","0x3421","0x112f","0x511","0x0ef1","0x0e5e","0x5df1","0x0ed7","0xf7ba","0x5f0e","0x23fe","0xfcf1","0x3ecf","0xd116","0x4072","0x21e4","0x3e1c","0x64d1","0xd702","0xc6e0","0x2dc5","0x0f0","0x3303","0x1f2e","0xad4f","0xa6d3","0xc20b","0xe39f","0x902e","0x41f","0xf3d1","0x64dd","0xbf71","0x14ad","0x21df","0xd2de","0xd293","0x0d6d","0x09b5","0xa0c3","0xf4c1","0xf1f2","0xda1f","0x2d24","0x4f92","0x107f","0x1f09","0x3fd7","0xd090","0x322c","0xb020","0x3120","0x21f","0x3a","0xf013","0xfae6","0x7fb5","0x0c4d","0x5e00","0x1322","0x2daf","0x20b1","0x093e","0xe0d9","0x3b11","0x60b0","0x20f0","0x7cbe","0xc7d0","0xa101","0x3513","0x470f","0x0f13","0xe001","0x0f1c","0xfee5","0x2f3d","0xeee6","0xe2ce","0xbe3e","0x3131","0x4c62","0x45ee","0xc355","0x7510","0xc5d7","0x1933","0x7db2","0x723a","0x3457","0x9f03","0xf0f2","0xf0ee","0xfeef","0x2557","0x0f23","0x60fd","0x1f7","0x9470","0x3a5e","0x146b","0x320d","0x542","0xe312","0xe60b","0x34cd","0xdf07","0x3330","0x110f","0xdcc4","0x7c75","0x701c","0x200d","0xec52","0x156f","0x14d7","0x43d2","0x401f","0x9efb","0xdf1d","0xd133","0xfaf1","0x2219","0xfe02","0xd2fb","0xf1cb","0x0f0c","0xd072","0xdcaf","0x1ff3","0x1400","0xf4c4","0x11f","0x4ee0","0xf911","0x1d","0x91dc","0x404f","0x0e71","0x3eff","0x3f20","0x41fc","0x365c","0x1f1d","0xdf05","0x3f3d","0xfe25","0x4240","0x222a","0x4eff","0xf31d","0x5042","0x0dde","0xb7ce","0xcd51","0x10c0","0x4f11","0x1e6","0x2f42","0x4c3c","0x0ef1","0x5142","0x239f","0xbbec","0xf143","0xe243","0x10bc","0x1fe3","0x92ab","0x0b00","0x51f1","0xc123","0xe3b3","0x11f1","0x341d","0x710e","0xebeb","0xc3e3","0xe2e7","0x9099","0xcd7e","0x2cbe","0xce1d","0x171f","0x5dec","0x1ec2","0x4fef","0xc022","0x5cdf","0x1471","0x3703","0x0fac","0x460f","0xee10","0xfd51","0xb7dd","0xbedc","0x5dd7","0x2d4d","0x6c0","0xb33d","0xeebe","0xd2c9","0xf7de","0xf522","0x1fec","0xe1a2","0xeeae","0x32e2","0xbe1c","0x12bf","0xffe5","0xd0b3","0xded2","0xd2df","0xe9e0","0x12c4","0x0c1b","0x9acc","0x57d7","0x143d","0xdd0d","0xf320","0xcdb4","0x202e","0x6ed0","0xe002","0x9e10","0xd202","0x3f11","0xe0e0","0xec1f","0x5dc1","0xdf3c","0xb150","0x34dd","0x132d","0xe221","0x2203","0xfe97","0x0bcf","0xcf32","0x0c4e","0xfa20","0x11e3","0xf230","0x21fd","0xffcf","0xa0d0","0xf001","0xad60","0x1e20","0x0f4","0xe2e0","0x302","0xddd2","0x3f2","0x200d","0xd6f2","0x2c31","0xfeb0","0xd0a7","0x0d4b","0x4c13","0xe321","0x3050","0xc317","0xe5d1","0xccae","0xf53c","0x23e","0x1339","0x602f","0x0ec2","0x1eed","0x74f6","0xfafe","0xd12c","0xbaf1","0x9b6f","0x9222","0x9bea","0xd53f","0x12a2","0x1326","0x5742","0xf7bf","0x4119","0xd594","0x52c4","0xe2e2","0x6ee1","0xc3ed","0x3cf1","0x09","0xfe20","0x90ec","0xe1a3","0x514b","0x13a1","0xff12","0x10d1","0xec6d","0x200c","0xfbf5","0x5f02","0xeb1e","0x151b","0xf2ad","0x1dbe","0x46df","0xdd2a","0x92e0","0x0ff9","0x5fd5","0x2f0d","0x42e3","0x352d","0x2a5d","0xfde0","0xacc2","0x5b12","0xc2f0","0x72c1","0xa0ec","0x34ff","0x360f","0xb2ba","0x91e1","0x199","0x0e04","0xe331","0x1a9f","0x4b79","0x0f","0xfc25","0x9237","0x1c9e","0xfde3","0x11df","0xe9ae","0x72c","0x10e0","0xe3fa","0xeaad","0xf0f2","0xcdf9","0x413","0x1295","0x7063","0xe9d6","0x70f","0xf7e1","0x72f2","0x3436","0xc73e","0xa2fe","0x23ed","0xeea6","0xfc30","0xa9c9","0x0e6a","0x2fe5","0x31ff","0xf306","0xcb02","0x344f","0x5b44","0xb01d","0x53e3","0x6c54","0x0cd","0xbd41","0x4c3","0xe5b4","0x7311","0x6fbf","0x103d","0x21cd","0x21b0","0x95fc","0xeed3","0x0c4","0xe160","0xdc10","0x1113","0xcefc","0xedf3","0x6c62","0x20e","0x91bc","0x1ec2","0x0fc4","0x6f23","0xe2fd","0x0c1d","0xb0d0","0x250","0x0f11","0x0c3","0x2f02","0x10bf","0xd153","0xf40c","0xe3d5","0xd022","0x0ac2","0x2e1e","0x44d5","0xc1c0","0xbdf5","0xf1e0","0xa1fb","0x760b","0x4a1c","0x0fe","0xa6e4","0x92a2","0x1d14","0x41f5","0xceba","0xaf10","0x6ae","0x2c9f","0x9d9f","0x21fa","0x51c1","0xd3cb","0xeda0","0x0c2d","0x49e0","0x7e09","0xfd92","0xdcf1","0x2","0xe32c","0x9ab9","0x1005","0x11fe","0xd9ce","0xb7ab","0x2bd0","0xbdd1","0x9e34","0x12d2","0x096d","0x2010","0xed15","0x1c4","0x510f","0x654","0xde10","0xd5cc","0x400","0xf5f0","0x0f79","0x734","0x0d7e","0xe774","0x3b1b","0xe02b","0x55a5","0xbc2d","0xf024","0xefaf","0xda3d","0x12","0x93d4","0xc11b","0xedd3","0x245b","0x176b","0xcda5","0x436d","0x422e","0xfb6d","0xcb1c","0xd6c9","0xbfd1","0x9b62","0x253f","0x3e2d","0xcbd3","0xf39e","0x4b70","0xb219","0xd22e","0xf032","0xafcf","0x1d5e","0x4b2e","0xef1b","0x1415","0x1179","0xb114","0x3762","0xb200","0xe322","0xd90d","0xfac9","0x31ff","0xd0ca","0xb1ee","0xe114","0xfd16","0x5cf7","0x2194","0xf342","0xfb06","0xff46","0x7ad","0xffc0","0x1fe2","0x9ae5","0x9dcf","0x15ff","0xf116","0x3be0","0xeb2d","0xf63f","0x139f","0x1d32","0x430c","0x36c","0x534e","0x6311","0xd0d1","0x7324","0xdcc0","0x4fe3","0xdce0","0xcf34","0x6e2b","0xad01","0x1d13","0xd10b","0xd5f1","0xeb66","0x4c30","0x9c30","0x53cd","0x4b","0x11b1","0xb301","0x096b","0x13e2","0x10d2","0xd20e","0xf350","0x15b0","0x4a19","0xed3f","0xf1be","0x105d","0xf444","0xf1ee","0x0f4b","0x0ef4","0x3f5e","0xfd9f","0x5e9f","0x5f64","0x2ae4","0xb5d7","0x2b5f","0x331f","0x0e2d","0xf1f2","0x3cc4","0x72ec","0xe370","0x4c22","0x4f00","0xf2bc","0x2272","0x3009","0x0b9c","0x2edd","0x4ec0","0x322f","0xf19d","0x2ae1","0xc3e0","0xcdc1","0x63ee","0xdfe1","0x3e45","0xf193","0x11e3","0x6dd4","0x10fb","0x13c","0x2dda","0xc712","0x159f","0xe7f6","0x2fed","0xd951","0x7f20","0x9cd0","0xa2dd","0x2fef","0xff10","0x2d90","0x2201","0x30f0","0x7f72","0x0eaf","0x2b0","0x1fd2","0x65c2","0xe6b4","0x1151","0xb9f3","0x7b06","0x9b50","0x4def","0xa4f9","0xebfb","0xcf9c","0xbeb5","0x5201","0x2a13","0x5cfa","0x1421","0x30ff","0x6e","0x9ee1","0xd13f","0x1e2d","0x0f36","0x0e13","0x2122","0xed4e","0xe129","0x0ff0","0xc2cf","0x5214","0xa32e","0xd90c","0x1123","0xb731","0xcfca","0x15de","0xe333","0xffec","0xf01b","0x1035","0x9922","0x4d43","0xe144","0x3f33","0xf760","0xe4de","0xd32d","0x21ef","0xaa76","0xea2d","0x2535","0xc3dd","0xf315","0xfc3e","0xb7e2","0xf3f4","0xbb33","0x1f1b","0xff63","0xd202","0x144e","0x2710","0xcb01","0x32c0","0xd1e2","0x1c4b","0x35e","0x1124","0x1027","0xed41","0xaf92","0x2c43","0x9192","0x302e","0xf1db","0xf0c0","0xd32d","0x2660","0xeeee","0x21bf","0x1df1","0x1","0xe01b","0x90b1","0xd201","0x4d0","0x3d13","0x1b0c","0xa113","0x1e0e","0x1dce","0x2ace","0xeeff","0xde00","0xfcfa","0x12cf","0xfe9e","0xd2e4","0xf515","0xf2f2","0xe42b","0xaf20","0xfdfe","0x2d92","0x9d4e","0xdad2","0x30fd","0x3cd9","0xf2f4","0x50e4","0xc9f0","0xddbf","0x3bf2","0x2f04","0x54b0","0xeccb","0xef3f","0x94b1","0xffdd","0x2b57","0x0f21","0x590c","0x1cdf","0x2724","0x7223","0xc137","0xe0ca","0x2f0d","0x31b3","0xf520","0x1d5d","0xd122","0xfebf","0x6e02","0x74ec","0xd4ec","0x242c","0xe1eb","0xe921","0xf226","0xd234","0x790","0x0f02","0x1eed","0x0c04","0x0f3c","0x2ff4","0xdcbb","0xbfc7","0x9cb0","0xb925","0x0e33","0x69df","0xc60e","0x6f7a","0xa512","0x4d17","0xdf7c","0x3f9e","0x1bd5","0xdf7d","0x7031","0x9c2c","0x31c0","0x441","0x222f","0x111e","0xc9bd","0xcfd2","0xfce0","0x95ed","0xec30","0x2010","0x6a34","0xe354","0x34c0","0xf592","0xed3f","0x3140","0xab9c","0x2beb","0x32ed","0x3237","0x15c","0x5c3e","0xeb4f","0xce4f","0xe111","0xccb0","0xe79f","0x3a16","0xf1f0","0x3d0f","0xc0ec","0xb41c","0xabf9","0x2b15","0x7c24","0xeee4","0xcb2c","0x1112","0x7df","0x0ff2","0x1051","0x4017","0xe970","0x1164","0x9f00","0xa6f0","0x4b20","0xe22d","0x52f1","0xed12","0xe0d3","0xe27e","0xbe1a","0xe1cf","0x11f5","0xc09c","0xdcb6","0x6433","0x5ca5","0x3f7d","0xc42c","0xf0ce","0xb090","0xf951","0xde40","0xceac","0x7d4e","0x0da0","0x141","0xf0ed","0x3ec1","0xced0","0x4ffb","0xb342","0x3c42","0xff3f","0x302e","0xcfb2","0x0d92","0x2b30","0xcefc","0x6cc2","0xc01f","0xbb99","0x72","0xecdf","0x2ea0","0x3bcf","0x2fdf","0x4f2a","0x22bd","0x2d09","0x32cb","0xf3fd","0xf0dd","0x22b4","0x3b4f","0xd223","0x3bb6","0xee01","0xdf91","0x4d4a","0x0def","0x3f23","0xfd43","0x1f1e","0x12d0","0xf50e","0x2acf","0x3f2e","0x2693","0x3d91","0xf5e9","0xb192","0xe251","0xeabc","0x61f1","0x9cc1","0x223","0x3fef","0x2cef","0xfef3","0x33d5","0xde4c","0x33cf","0x0ea3","0x72b7","0xf0cc","0xf11e","0x31bf","0xa309","0x0a0d","0x0ed","0xcd1f","0xf442","0xffef","0xf2f1","0x6052","0x7c1","0x4433","0xc3de","0x324","0x09d0","0x0d6d","0x1132","0x2a76","0x3f11","0xe250","0xe126","0xc0d0","0x60f","0xe0f7","0x6f4b","0x3c1d","0xef2b","0xf72f","0xadfb","0xf452","0xa340","0x3ea0","0x3393","0x221b","0xeffe","0x7e0f","0x7cb3","0x9bfe","0x2ba5","0x7c20","0x792a","0x357e","0xc43b","0xecc4","0xc09d","0x523e","0xceb2","0x5f0e","0x403d","0x5fcb","0x9f17","0x4c94","0x491c","0xe9d4","0xe599","0x4b3c","0x7ed9","0x93b3","0xb0c2","0x0ead","0xdebd","0x3cef","0x11d0","0x15da","0x3f0e","0xefe3","0x903e","0x0ecd","0xa9ff","0xfbdf","0x62e2","0x0f0e","0x7552","0x2ac","0x3d4","0xef11","0x421e","0xfe30","0x0f0b","0x2cdc","0x132","0x9020","0xe35e","0xa1f0","0x516e","0x092f","0xfa2b","0x1372","0x0af0","0x1df0","0xe3f1","0x11ef","0xe604","0xccb1","0x1b","0x0ea1","0xed2c","0x21b","0x5ff","0xbbed","0x502b","0xec4c","0x1d1f","0x4474","0x21b4","0xc463","0x24dd","0x437e","0xb7f4","0x2b26","0xc410","0x0df","0xb14a","0x4f6c","0xbeee","0x1a05","0x4fe","0x0a90","0xb90e","0x2020","0xbfcf","0xafd1","0x3fe","0x7545","0x54a","0xcc94","0x913f","0xd6f5","0x176","0x7153","0x400a","0xfd22","0x11e1","0x940f","0x15e2","0x22e5","0x0d77","0x111","0x0cbb","0x50dc","0x1191","0x31ce","0xa064","0x490","0xaf77","0xbbf0","0x53cc","0x69d2","0x2e3","0xfde0","0x0ce7","0x33f3","0x0e53","0xf1b3","0xdad2","0xac37","0x25a6","0x1123","0x0e6a","0xe1ff","0xc1f5","0x2272","0x5e2e","0x415","0x1c23","0xb626","0x27e","0xfe1e","0x1d21","0xd1bd","0xe122","0xcf9f","0x0da4","0xf13f","0x5e0c","0x0c30","0xcecd","0x3291","0xc50e","0x4910","0x2f00","0xeafb","0xb63c","0x7f7f","0x1b0","0x13ee","0x137e","0x40d2","0x6227","0xf210","0x14c2","0x0c47","0xaf41","0x5193","0xf053","0xce1e","0x0fff","0xbdef","0x5e23","0x3e0c","0xc156","0xf219","0x302d","0x9d11","0x37bd","0x112e","0x31b1","0xcfb1","0xdbd0","0xef00","0x9516","0x204f","0x1bb1","0xb2d1","0x0e01","0xb005","0x1071","0x1312","0xc034","0x0f12","0x4da7","0x4023","0x25ed","0x9dff","0xc41d","0x2cdd","0xc1ff","0x1c4d","0xefde","0x211a","0x1bf2","0xbc64","0xc20c","0xd2ec","0x12d4","0xa23e","0x1bb2","0x490a","0x1f4b","0x0ae2","0x33d","0xe52c","0xd31c","0xbe3e","0xb9ee","0x5aea","0xed2f","0x91ee","0xc4c2","0x1231","0xddde","0xff31","0xfcee","0xf9c9","0x0f2c","0x7ae3","0x371","0xf7ea","0x1aa6","0x4105","0x4f21","0xcd24","0x1934","0x2032","0xfc11","0xb7d3","0xb031","0x514f","0x7e3c","0xec1f"},
{"0x7050","0xaf0e","0x100","0x139b","0xea6f","0x22af","0xef22","0xd175","0xd0f4","0xe04d","0x30f1","0xae0f","0x462c","0x2ffd","0x2ade","0xe361","0x9c1b","0x1ced","0x1e23","0x3efd","0xeafb","0xfc11","0x222","0xe722","0x5cee","0xc679","0xfec7","0x202f","0x4420","0x3d39","0xfb92","0xd524","0xa24d","0x5c9d","0x2fd0","0x22f1","0x49f1","0x42a2","0x0af0","0x99f6","0xa906","0x121f","0x2aff","0x1530","0x543f","0x221f","0x4dd","0x51c5","0x1021","0x10ed","0x23bd","0x3fc","0x1e0f","0xf3bf","0x9fdf","0x4ef2","0x3414","0x23e6","0xec0e","0xb20f","0x551c","0x3f2e","0xd69c","0x1430","0x2b0","0x14ec","0xd179","0x307c","0x1c3a","0xb10e","0xfdca","0xf203","0x3a42","0x1022","0x7797","0xf4ee","0x475f","0x2133","0x6c6","0x11e4","0x7cf3","0xefd7","0x1f13","0x5ffd","0xe220","0x5ed0","0xdedc","0xef23","0xfc1c","0xc24a","0xce60","0xc0fa","0x1201","0xe5c1","0x31bc","0x2013","0xc5f5","0x5c22","0xa2c1","0x2009","0x3d02","0x0be4","0x4bef","0xfeb0","0x3e2","0x1214","0xbdee","0x1113","0x2ee1","0x5ce9","0x3109","0x2dc","0xe1e2","0x11e1","0xbd22","0x4fee","0xd1ee","0x20c3","0xe9f2","0x30a4","0xe2e9","0xfff1","0xd5e4","0x550","0x511c","0xdf3e","0x39da","0xe2b1","0x4009","0xe0f9","0x40d2","0x52f0","0xf79b","0xb5ce","0xfd94","0xd1a4","0xac00","0x1e9c","0xacb2","0x561d","0x210e","0xa431","0x2fdf","0xb1d4","0x31dc","0x23f2","0x1210","0x1243","0x4a9a","0x12b2","0xe3c3","0x3cb3","0x0bf9","0x57b1","0x11d5","0xeda1","0x0f34","0xfed1","0x11d6","0x3bf","0xe0b5","0xd4c3","0xe312","0x32c0","0xed1d","0x91d9","0xdde1","0x9e43","0xd942","0xf5f3","0x1e35","0xa391","0xfb2c","0x7f09","0x529d","0x40e0","0xb017","0xefdc","0xc171","0xba40","0xc340","0x60ff","0x0d9d","0x942e","0x5d92","0xe6f0","0xb5f2","0x12d0","0x511b","0xde5d","0x1ba6","0x1dd5","0xc551","0xedbd","0x61c7","0xef4d","0xadfd","0xfeac","0xbffe","0x905a","0x20cb","0x2f9e","0x452e","0x4f07","0x0e1d","0x4671","0x5fb9","0x4f1","0xaed2","0xefb2","0x7390","0x533d","0x224","0xcd0b","0x30ed","0x305b","0x33aa","0x30ee","0x3ad0","0xa900","0xde24","0x4d33","0x32bb","0xefbf","0xcfd2","0x6c1f","0x9f0b","0x3219","0x2213","0x9fc1","0x0916","0x1441","0x321d","0x611b","0x753f","0x94dd","0xeb0c","0xd3ad","0x32b2","0x0c0b","0xc6e7","0x31f4","0xcf52","0xd91e","0x7119","0x43f4","0x910c","0x7692","0x1446","0x2c0","0x1c33","0x0df1","0x42fd","0x230","0x1e2","0x0cf4","0x310e","0xdb12","0xe04d","0xfc0d","0x7312","0x60f1","0x77e","0x6be3","0xe75f","0xf4e0","0x70f9","0x3ff9","0xf022","0xc3b0","0x5f2d","0x2e95","0xfb21","0x4ce1","0x0d3d","0x0e0f","0x70","0x5516","0x35f1","0x2cf","0x0d27","0x60cd","0x1102","0x2e02","0xef30","0x92c2","0xf076","0xdf0d","0x0b2a","0xff9d","0xc90f","0x6adc","0xed1e","0xc31c","0x12b9","0x341f","0x69f3","0x6240","0x3f0f","0x357e","0x22de","0x4231","0x0d34","0x9b91","0xe91b","0xb1e1","0x19c2","0xe2ee","0x3ee1","0x32be","0x39a9","0xd4d0","0xf2c3","0xe257","0x2060","0xa15d","0x6d2","0x4f10","0x3ea2","0xbdd0","0xeb0a","0xb2c3","0x0bec","0xeec1","0xec3f","0x2efa","0x2a1b","0xedeb","0x11bf","0x6df2","0xef6f","0xd3e3","0x49e0","0x4e0d","0x22cd","0x0e27","0xc22e","0xbc0c","0x5cfe","0xf0f3","0xa2cf","0xfd2c","0x2563","0x0f21","0x260b","0xcfed","0xd5a3","0x2f92","0xf2e5","0xddb2","0xa0ae","0x6db3","0x0d63","0xfe71","0xd62c","0x0b4","0x0adf","0x51a","0xf60f","0x7b4f","0xf327","0xf21a","0xff94","0x24b1","0xffef","0xdfc1","0x0e92","0x1a5","0x0f00","0x501a","0xf6e1","0xd304","0x236e","0x40a4","0x0f5c","0xfc0c","0xb4ee","0xf339","0x6b92","0x11cd","0x3edd","0x3f0f","0xd0f3","0x5fd1","0x3c15","0x0eff","0x7ac4","0x22f9","0x9b7e","0x5c3f","0xb4cb","0xefc0","0xf290","0x090f","0xbfdb","0xee20","0xf4d2","0x2ebf","0xe222","0xef3e","0x2fd3","0xfefd","0x1aff","0xde17","0x4c79","0x23c0","0xc9f5","0x23e6","0xcfda","0x4ac9","0x4111","0xcd3f","0x134c","0xf542","0x0c01","0xff0d","0x0e4f","0x3202","0x0df","0x22de","0x5f4c","0x9fed","0x3bb1","0x26a2","0x3f20","0x4ae2","0xb22e","0x411","0x2fbc","0x1310","0xcd3a","0xd9f6","0x3140","0x2d9e","0x1de1","0xf0ee","0x0d94","0xf602","0xc2b0","0xfe40","0x33e","0x93ef","0xfdc2","0x4ef1","0x0ed0","0xdf25","0x0db","0xb451","0x70ec","0x4d44","0x2d9f","0x1cce","0x2102","0x46f6","0xcd2e","0x7cdf","0x33ef","0x1ba6","0x2ee2","0x7b04","0xeeb1","0xb507","0x26e","0xe0ff","0x60e4","0xdf30","0x6c1e","0xbf1d","0x3ff","0x73e1","0x20c2","0x600a","0xe7a1","0xf4d6","0x3352","0x2bfd","0x14e2","0x0c4e","0x2511","0xc0df","0xc0de","0xf37c","0xeec6","0x41","0xf200","0x9c11","0xddd1","0x13b4","0x09e0","0x4f4c","0x2e5e","0xa1d2","0x0ce0","0x1201","0xbf6c","0xe1ce","0x31e","0xec3e","0xdf5f","0xda1c","0xa01d","0x7101","0x4faf","0x0f9a","0x143e","0x422","0x1222","0x9c1c","0x0a0e","0x22f0","0xede0","0xb4bb","0xb735","0xea41","0x4f42","0x204","0xa29b","0x734b","0x7e95","0xfe92","0x71b","0xee12","0x3ef","0x521f","0x2fc2","0x1e4d","0xeecd","0xffae","0x2e32","0xe091","0xcadf","0x40dd","0x92c3","0xbe3e","0x0eae","0xde9c","0xe9f4","0x1d5","0xec01","0x0fe3","0x9cd1","0x425b","0x6f90","0xee0d","0xca45","0x42c0","0x9d03","0x14b2","0xbfb0","0x4e15","0x1c0","0x3001","0xdac9","0xcffe","0x1b03","0x6bb4","0x60ec","0x145b","0x0edd","0x621c","0xdb2f","0x3b30","0xe430","0x2cf1","0xe4d7","0x3ff1","0x0a32","0xfdf0","0x6df5","0x44d9","0x2f02","0x6df","0x4ff4","0xb6dd","0xa01f","0x22f0","0xccc0","0xe1ef","0x3500","0xfa97","0xde92","0x2bab","0x34e","0x2a03","0x206d","0xf0f1","0x37eb","0xd4b2","0xdb1d","0xffcf","0xb0f5","0x14b4","0x15ce","0xe102","0x93ad","0x1e93","0x92d4","0xde2d","0xf06e","0x1f32","0x1d10","0xd0e1","0x202d","0xded1","0xebd1","0xceff","0xf1c7","0xf095","0xb21e","0xac24","0x1992","0x2cd6","0xac12","0x2ddf","0x2231","0x2300","0xee0e","0xcd31","0xec41","0x1ba6","0xbebd","0x225c","0x1ff1","0x11a1","0xe0de","0x11ae","0xbb01","0xfd00","0xdc3c","0xb134","0xbfe0","0x24bf","0xf0fe","0x15f6","0xfc41","0x4dab","0x2d21","0x1064","0x4f09","0x5c32","0xffef","0x3a4","0x55ff","0xf201","0xdd2f","0xb9f2","0x2fb1","0xe32a","0x2e1a","0x11df","0xf553","0x2d9d","0xf4c3","0xc0fd","0x1cf9","0xf1d0","0x1dd2","0xc0df","0x4329","0xe3f1","0xef20","0x6fdf","0xc9ff","0x933b","0xde0f","0x593d","0xf60e","0x30ad","0xf2c6","0xd1f1","0xd4d0","0xe1dc","0xf6ee","0xe0c2","0xec1e","0x21cf","0xfc3e","0x7f3c","0xfc4a","0x92fd","0x3ede","0x6e5f","0x290c","0x6e12","0xf616","0xdb71","0x2d9b","0xf0fc","0x796d","0xbed3","0x23e0","0xc6b4","0xec30","0x0ebe","0xc24f","0x90e2","0xe1fd","0xce0d","0x6b33","0x09c3","0xefee","0xdf75","0x1e2f","0xe4e2","0xff2f","0xea31","0xecbf","0x9ea5","0x0dfc","0x3d90","0xde1f","0x2dba","0x3fee","0xce2d","0x6f91","0xfed3","0x4310","0xcf25","0xffdd","0xc5f2","0x7192","0xe992","0x2e33","0x9231","0xaa3d","0x7042","0x091c","0xdb2b","0xfa0d","0x7d43","0xe632","0x243e","0xedff","0x210f","0x9073","0xd20d","0x2d25","0x39d0","0xa513","0x1c51","0xedd2","0x4ff1","0x6d0a","0xadd3","0x23a1","0x5c2e","0xdf5e","0xeffc","0xf1d0","0xd034","0x1d5f","0x4343","0x22ee","0xebfd","0x69a","0x1af7","0xff99","0xcc16","0x0901","0x0b7","0x3ec0","0xf03c","0xb9f1","0xe035","0xf2fb","0xb2f4","0xeefe","0xb307","0x442d","0xdf67","0x145e","0xefb2","0x0fa","0xdde1","0x1cc7","0x42ca","0xeb0f","0xffd7","0x3ee","0xce9f","0xe1d4","0x0c2b","0x0eec","0xc41e","0x9215","0xd121","0x3313","0x43c9","0xc9fa","0x0bd0","0x0c95","0xd293","0x2ccc","0xbcb2","0xe30a","0x3dfd","0x2cd7","0x09ff","0x72ef","0x1","0xcc23","0xd1e2","0xf3e1","0xe0ff","0xeef1","0x45af","0xc0e4","0xe311","0x2ed1","0xaae4","0x1fd4","0xe00c","0x40d2","0xce61","0x2fe0","0xdcb1","0xc0f9","0xf254","0xcffe","0xdec9","0x3e1b","0x0d7d","0x4bc","0x50e1","0xfe5e","0x1354","0x153a","0x379","0xcfac","0xa011","0xa413","0xf122","0xe249","0x2e20","0xf5f4","0xbf1c","0x201e","0x3d13","0x2901","0xcfa2","0x130e","0x712c","0x1f3a","0x1eef","0xe7c9","0x9436","0xee6e","0x4743","0xedfb","0xaf51","0xd43c","0x3f4c","0x2e79","0xc0e4","0xeb03","0xab9d","0x110f","0x2a59","0xe01d","0xc32f","0xf31e","0x9010","0x124f","0xc5ba","0xde03","0x1941","0x1b13","0xf1d2","0x705b","0x5df1","0x220e","0x3f25","0xf4ff","0x37b2","0x441","0xeb54","0xdd41","0xa173","0xe310","0xb011","0xfc1c","0x9029","0xc03e","0xcd06","0x342f","0x6940","0x6640","0x29b4","0x720","0x421","0x303a","0x933d","0xe343","0xed6d","0x7f23","0xce12","0x20fe","0xf31c","0x952d","0x2b45","0xb120","0x2d3","0x3ee4","0x2d2d","0xd406","0x1b5b","0x133e","0x3211","0x210c","0xa1ba","0x13f6","0xb010","0x1013","0x49a0","0x9e01","0x5ee","0x1753","0x0e4","0xf592","0x1bbe","0xefff","0x4ecd","0xaee3","0x3b2c","0xfb0f","0x0d4e","0x209c","0x2ed1","0x4d4f","0x2012","0xc50f","0xc313","0x3422","0xfae1","0xb2b3","0xef94","0x0fc5","0x5ef0","0x3ef0","0xff1e","0x2ada","0x3bfd","0xed1a","0x2cbf","0x79c2","0xc076","0x0f52","0x12ec","0xf6d2","0xb9d1","0xb0f3","0xaea3","0x0cf","0xfa16","0x0f31","0xfcdc","0x491b","0xdfba","0xc4fb","0xee91","0x3b22","0x1e5","0xa01e","0xe03b","0x26f1","0xfb0c","0x30ed","0xf03e","0xf2c9","0x0fa2","0x41bc","0xb52e","0x3fc2","0x1f2c","0x2bd","0xe4b1","0xedd4","0xd337","0xf520","0xf5c3","0x43f2","0xe62e","0x30f3","0xc3dc","0x0e2f","0x3c13","0x21f1","0xd333","0x16e0","0xd1b0","0x43cb","0xf12e","0x121","0xf0f2","0xfbd0","0x222d","0x1d33","0xce9b","0x2b01","0x21ef","0xfe3d","0x40cd","0xff1d","0xece0","0x4110","0x3de","0x1e4","0x4de1","0xb73e","0x9cf0","0x6f3d","0x3b3d","0xaf9c","0xf919","0x0b1e","0x9e30","0x1ab3","0xde21","0x245","0xce13","0xffd2","0x2dd1","0xf1c0","0xd1fd","0xbf22","0x0ea0","0x400","0xf12d","0x1ddd","0xdfdc","0xdd10","0xe2b1","0x3fdf","0xae52","0x11f","0xd11f","0x6dca","0x2c44","0xf109","0xe3ec","0x3efc","0x26e1","0xd0f3","0xedd2","0x3caf","0xcfea","0xd300","0xdd9b","0x1e0","0x30db","0x3c2e","0xe4de","0x5d1b","0x201d","0x7ecf","0xb011","0x3f00","0xe2df","0xb0ee","0x17bf","0x26d4","0x0f0f","0x2ce2","0x9eb0","0x402c","0xed1f","0xfe4d","0xf4d5","0x2d12","0x3c1a","0x2ebe","0x71ed","0xd134","0x330","0x7d03","0xf22e","0xeed3","0x96ca","0x1dd","0xb22d","0x4de1","0x0bd5","0x2747","0x3022","0x1ad2","0x7f3b","0x2ff2","0x5992","0x5634","0xa1db","0xdc7e","0x4d50","0x9007","0xc60f","0x5327","0x2bed","0xb9d4","0xb1d7","0x724f","0x31e3","0x0c56","0x3224","0x7dec","0xde50","0xa203","0x71df","0xe20d","0x332e","0x3df1","0x7f5b","0xa9ed","0xf3b0","0x2daf","0xe063","0xb10d","0x60ad","0x57f3","0x7bf0","0x32bc","0x527","0xc0e2","0x1f0b","0xc0fd","0x3e0","0xc17c","0x0ef7","0x1bc2","0xcea3","0x0fff","0xdf7c","0xccd4","0xb4c4","0x63c1","0xc140","0x32bc","0xb334","0x2e0","0x0fed","0xce35","0x10df","0x3fff","0xd4fb","0x311","0xf3e0","0xeb11","0xe4dd","0xdeef","0xf66b","0x3d22","0xe022","0xcccc","0x9fc0","0xf32f","0x249d","0x11ed","0x60fb","0x7302","0x51e5","0x52dc","0xc4f0","0x4937","0xdd77","0x25d0","0xc4a4","0xc5e3","0x192f","0x1dd4","0x21f1","0x6329","0xe6ee","0xbdf9","0x0e5","0x10f5","0xf207","0x0e1b","0xa1f5","0x1cce","0x0a35","0xc121","0xa136","0xcf01","0xfe71","0xc503","0xd096","0x3a33","0x1e1d","0x1eed","0x1110","0xb995","0x1f2f","0x0f1","0x906b","0x5f4","0x0fe1","0xdcc5","0xb261","0xff46","0xff5d","0xb6e0","0xc5c1","0xde03","0x0bf","0x22ff","0x1123","0x1ded","0x7f9d","0xfdd7","0x4b22","0xf3f2","0x13a","0xff1d","0x35dc","0xef39","0x3cbc","0xc020","0xecde","0xe612","0x37d4","0xe0ed","0x502d","0xd20b","0x140b","0x2f93","0xa1bf","0x71d0","0x5e41","0xc14d","0x7e2d","0x9d19","0x1adc","0x919f","0xf0e5","0x130f","0x77c0","0x1c61","0xb2e0","0x1eff","0x396b","0xca04","0xcc4e","0x3ccd","0x3c37","0xb963","0xee15","0xe0fd","0xd04f","0x2e0a","0x4004","0x20e4","0x3ee0","0xd300","0xa1ce","0xe21c","0x3bbd","0x3d2","0xcbce","0x722","0xeebc","0x3aa0","0xe3c9","0x74fd","0xecdf","0x5bd3","0xf4a1","0xb2f6","0x20c3","0xf14d","0xe1a6","0xb349","0x2114","0x31f1","0xdc01","0x0d24","0x0fc0","0x1226","0xf703","0x40f","0x0fe5","0xe9cf","0x1ef","0x40be","0x6022","0xc1fe","0xd007","0x21ef","0x2311","0xd15e","0xe2c3","0x1fe3","0xc7f2","0x4cbc","0xcd10","0x9f19","0xcdf1","0x9f41","0xc203","0xf012","0x17f1","0xf279","0x4034","0xdfd4","0x90de","0x200","0xc1cf","0xd00b","0xbff4","0xe227","0x20f7","0x36fd","0x4a0c","0xd19f","0xfffc","0x9175","0xd4c5","0xf272","0x6e04","0xe509","0x9509","0x2ed2","0xc7e0","0xddf3","0x0fc1","0x62d7","0x1153","0x0f1d","0x6dd3","0xc210","0x52","0xe4d2","0xfde0","0x604b","0x46dd","0xf32d","0x0c0d","0x1d14","0x2e3f","0xaa10","0xcef9","0x951c","0xd172","0x136","0x1d00","0x11","0xe343","0xb05d","0x25c","0xf60e","0x9fff","0x2056","0x91fe","0xeb1e","0xdf4d","0x116a","0xbdc1","0x10d2","0xfdec","0xea01","0xcceb","0xe29d","0x4c92","0xef50","0xe5c4","0x2d01","0xdd1e","0x53fe","0xf04b","0x66ce","0x0f3f","0x33cf","0x22cd","0x3ddc","0xe213","0xecf4","0x240","0x9305","0x4321","0x9442","0x3fd","0xafc0","0x5f0e","0xd199","0x3e1f","0x221a","0x2be1","0xf1fb","0xfe1d","0x111c","0x2ed5","0xd204","0xe544","0x7f3","0x0ed0","0x6c45","0x1ef2","0xe030","0x1e1e","0xdfef","0x1be1","0x52f3","0xe24e","0xe7c9","0xd7d4","0x0d37","0x3352","0xf3db","0x2ff5","0x70ed","0x0efc","0xb043","0x2ef2","0xf4d5","0x2395","0x312e","0x43af","0xc5e2","0x1c1f","0xe609","0x212","0x3ebc","0xe5d5","0xe031","0x6032","0x1324","0x3f9f","0x9211","0xb249","0xe25c","0x200","0x3e4d","0x41e2","0x0ce1","0xb71f","0xde0d","0x1d01","0x102","0x449f","0x502e","0x1bfd","0xd6e0","0x203e","0xfcf7","0x1f","0xcdbd","0x9e6d","0x74a","0x126b","0x0c9","0xae2e","0xe001","0x4b24","0x2c4","0x3cc0","0xc21f","0xe403","0x2de","0xf0d0","0x2fa0","0x67","0x2dc9","0x2dc","0x63cb","0xdf4c","0xd7e2","0x20d1","0xfde2","0x11bf","0x9c32","0xd1d0","0x2e00","0xed07","0xf2e9","0x6f00","0x1f1","0xfb0f","0x1fe2","0x3d2","0xc554","0x243d","0xc920","0xe1f6","0xdef3","0x51d4","0xe752","0x2201","0x113e","0x2d40","0xdc3f","0x700a","0x3d3d","0x149b","0xb6dc","0xff3f","0xf4ed","0xeae0","0x90cd","0x1cd4","0xf963","0xcf10","0x13d2","0x61d","0x711a","0x0d14","0x4e21","0x1ccf","0xbbee","0x45da","0x439","0x91f0","0xeaf1","0x9e21","0xef22","0x71e5","0x9a0f","0xda3f","0xefd1","0x2bc1","0x1cfb","0x4d21","0x0cb9","0x2aee","0x3bec","0x0fd6","0x0f2f","0xf6f9","0x39af","0x9d33","0xd1cc","0xc137","0xad64","0x2b69","0x175","0x3e0f","0xac10","0x3612","0x415b","0x2402"}
}
};
const ap_int<11> conv_5_inc_new[2][32]=
{{"0x259","0x1cc","0x1d8","0x31a","0x224","0x33f","0x2bd","0x1f1","0x336","0x22d","0x243","0x210","0x1db","0x253","0x37b","0x24f","0x255","0x228","0x2ff","0x3b3","0x29d","0x2b9","0x2ef","0x3a5","0x253","0x1d2","0x1d3","0x2b9","0x276","0x1f5","0x2ad","0x1e6"},
{"0x204","0x253","0x2ca","0x2bc","0x1ce","0x213","0x328","0x1fc","0x27e","0x196","0x282","0x2ef","0x3a4","0x1ed","0x2c6","0x24e","0x2ff","0x2a7","0x24b","0x290","0x258","0x32b","0x248","0x216","0x257","0x316","0x2c4","0x1f8","0x26d","0x1b0","0x213","0x2a0"}
};
const ap_int<21> conv_5_bias_new[2][32]=
{{"0x39029","0x23eca","-0x187b0","0x21b1e","0x33cb","0x1fa9a","0x2f445","0x4b4a8","0x452d4","0x2e972","0x22fc7","0x24880","0x35fd2","0x15d89","0x5105c","0x4b68","0x58dc","0x3aa7d","0x0d96","0x08a4fe","0x1f136","0x1cea0","0x36211","0x36668","0x25ff2","0x0ee49","0x0c06e","0x20b0e","0x2b527","-0x7fa3","0x6bc87","0x19283"},
{"0x0f829","0x15b35","0x49634","0x2f711","0x3c145","-0xc569","0x4e951","0x24a11","0x24ecf","-0x26266","0x4329a","0x5fd6","0x48ba9","0x31dde","0x4d4ab","0x11d97","0x5f350","0x7cb6","-0x84e","0x337d2","0x1e362","0x2ac59","0x0fc2","0x1d4cc","0x78af","0x3dba2","0x335cf","0x1be92","0x48204","-0x2536e","0x4def","0x310be"}
};
const ap_uint<16>conv_6_w_new[2][3][1536]=
{{{"0x6144","0x29f3","0x4fd5","0x2fec","0xd11b","0x1efe","0xf0b6","0x0f99","0xd2ff","0xfef1","0xe000","0xff32","0x21e1","0x200d","0xfbac","0x1de","0xf4ed","0xcac7","0xc644","0x4f52","0xfe94","0x21f0","0xb0c4","0xfc99","0xd626","0xe24b","0x5273","0x1711","0x6cf","0x216a","0xfe01","0xfdd3","0xddc9","0xece0","0x0fd1","0x1d22","0x40c1","0x1c72","0xbe04","0xfd99","0x31a9","0x2331","0xa69c","0x309","0x2154","0xc2e2","0xbff1","0xfab2","0xfe1f","0x1335","0xd9dc","0x3cca","0xf4fd","0xe2dd","0x1aef","0xc6c9","0x0b11","0x3c3","0xe4ef","0x201","0xf90e","0x1911","0xee01","0x4110","0x9696","0x2c9","0xcd5f","0xc127","0xd411","0x5990","0xe36c","0x0f30","0xe45c","0x12e3","0xfe4d","0x5150","0x97f3","0x9409","0x304","0x3dc","0x5d11","0x3060","0x21f7","0xe1f4","0x2e0a","0xffd0","0x79","0x20eb","0x1ed0","0xe002","0x1412","0xb51d","0x11f2","0xeefc","0xde1e","0x3ce","0x30c3","0xd0d5","0xe6cc","0x94c2","0xb10e","0x1f95","0xce5c","0xe370","0x9ffb","0xd540","0x0e40","0x0df3","0x97ff","0x9fda","0x4aec","0x5de2","0x0ee4","0xfe42","0xf007","0xb1e5","0x2a5b","0xc10c","0xdb7a","0xb425","0x701e","0xf0b0","0x67c2","0x429e","0xdf22","0xc7de","0x33bd","0x2f34","0xf4cc","0x20d1","0xee01","0x2dee","0xdbed","0x20d1","0xd731","0xd20d","0xdd0e","0xe03e","0x2902","0x9ed2","0x9f2b","0xf903","0xde9f","0x3f61","0xb2fb","0xced1","0xb10d","0xcff0","0xf002","0x4113","0xfd02","0x3cd4","0x10b2","0x1c41","0x0edf","0xdbaf","0x1130","0x5dc","0xec1b","0x20de","0x10f2","0xc3cf","0x510d","0x9b2c","0x4cff","0xe2c7","0x2cdb","0xcd15","0x21f1","0x1add","0x21d","0x20de","0x1912","0x320d","0xa4fb","0xdbe1","0xd2ee","0x1ec1","0xf9c1","0xd20e","0x4fb0","0x5237","0xcfd0","0x11c7","0xfede","0x0c9e","0x9fcd","0xdbff","0x4cd4","0xc230","0xb113","0xb0ff","0x619","0xdff1","0xef0f","0xd26d","0xbcf0","0x6335","0x1f31","0x9de4","0xee95","0xd200","0xfeef","0x9cfe","0xd31f","0xd119","0x1139","0xee20","0xf24f","0xdd00","0x51c4","0xb72f","0xc997","0x4df","0x3f9c","0xc214","0xce07","0x9a73","0x1215","0x94b2","0x4dc0","0x1efd","0x10ab","0xfb2f","0xfc36","0x0f3f","0x0ecb","0x1012","0x9fd0","0x1be9","0x1ec0","0x11c3","0x30f1","0xcb0d","0xf4ff","0x531f","0xf0fe","0x2f0","0x12fd","0xf60d","0xedb4","0xff1f","0x110a","0xb09d","0x2e1f","0xdf30","0x9a01","0x1b24","0x111b","0x510f","0x5","0xc427","0x21ce","0x0f2c","0xceef","0xf110","0x6020","0x2ff0","0xed6e","0xbe91","0x11fc","0xb3f2","0x39bf","0x2c1c","0x6cf","0xdf9f","0x5006","0x11f3","0xe3d1","0xc9e2","0x1330","0x6310","0x34f1","0x102c","0x1b7d","0xea91","0xbf0a","0xe32d","0x199f","0xf3fb","0xdfd1","0xdfd6","0xebfc","0x4ea3","0xc202","0xe2fe","0x1e11","0xf113","0xd012","0x30e0","0x12e0","0xde9e","0x450f","0xf90f","0xf22f","0x6152","0x94fe","0x0ef","0x20be","0xd1d2","0x0fed","0xf0be","0x22ed","0x1bc1","0xc40b","0x300e","0xf3fc","0xc300","0xe06f","0x23d1","0x1cf","0xf45c","0x3f05","0xc19f","0x101f","0xf1c2","0xef10","0x2e1","0x1d20","0xbc06","0xffe1","0xf61e","0xc3bb","0xd510","0xee3e","0x3303","0x4dab","0xf000","0x4eeb","0x63d3","0x3a0d","0xef11","0xb521","0xcee3","0x13d","0x9de3","0x2d19","0x2e4c","0x2c2d","0x5ca0","0xff03","0x42e","0x0ece","0xceaf","0xe2b6","0xda51","0x12fd","0xbcd1","0x2f3c","0xa12c","0x2a77","0x3202","0x5d5b","0xe1fa","0xfb1d","0xd304","0x1e5f","0x4e34","0xe91e","0xec9c","0xe411","0x230f","0x10ed","0xc6c0","0x2ccf","0xfcec","0xc262","0xa0f3","0xe40d","0xe524","0x29ea","0xf9e2","0xdc51","0x2c71","0x1991","0xd19e","0xd1f2","0x47cf","0x593b","0x0c00","0xc0df","0xaffe","0x2401","0xe100","0x30dd","0x21b4","0xdc09","0x137a","0x2","0x22c6","0xf2ff","0x0f2c","0xe2a7","0x3e9c","0x2feb","0xecac","0x29dd","0xdfde","0x9700","0x9ee1","0x5e50","0x1fae","0x1d3e","0x1d1f","0xd326","0x7ca2","0xf1cf","0xf1cd","0x4506","0xbdaf","0x0bf2","0x12c1","0x5956","0xf07c","0xc2f1","0xa0d0","0x2242","0x3cdd","0x1d13","0xed0f","0x1033","0x3edf","0xca3c","0xf0e0","0x35f1","0x903f","0xe0e1","0x200e","0x5d10","0xff6f","0xf0f0","0xd1fe","0x4fe1","0x14da","0x29f1","0xd213","0x0e3c","0x0ce0","0x2b5d","0x92d0","0xf0bc","0x2be","0xe1f4","0x102f","0x1000","0x1df2","0x2bad","0x22f5","0x1ddc","0xbc0f","0xc32b","0xe3f1","0x0e0f","0x5bf2","0x1b00","0x2cc","0xd45d","0x1d0","0x1e20","0xfa1f","0xe20b","0x3f4d","0xdfd9","0xa23d","0x0b2f","0x3d94","0x10f","0x543c","0x1eb7","0xed9d","0xe0f4","0x1e9c","0xdf1e","0xe16a","0xe2f2","0x2fc","0x432f","0x12e4","0xcbff","0x6020","0xe330","0x420d","0x3cee","0x29a","0x201","0x5e09","0xf1fe","0x29ff","0x1ef","0xf02d","0x1d10","0xd2fe","0x46fe","0xc022","0x611d","0xfe32","0xea90","0x3fae","0x1da5","0x2e","0xf03b","0x2dfb","0x21b","0x2eff","0x3dc","0xdf0d","0xd311","0x200e","0xf3d1","0xc210","0xc11e","0x241","0xf2dc","0x7002","0x4fcc","0x53fe","0x150b","0xff3a","0x2f1f","0xd3af","0x12b3","0xfe1b","0xbdf0","0xa073","0xfbeb","0x13f1","0x9edf","0x1160","0xa130","0x0ce","0xdc6e","0xd1ff","0xfb10","0xe222","0xfefd","0x1030","0x2f01","0x0ff1","0xf110","0xcf20","0x25b3","0x3930","0x3ee","0x4122","0x21f7","0xf0ed","0x223","0xd9ee","0x2eca","0x33","0x1d34","0x703d","0xf300","0x3f11","0x220e","0x40d2","0xd7f5","0xaf24","0x43","0x6caf","0x251e","0x3f3c","0x115d","0x1eb","0x502c","0xf023","0x9907","0x11df","0x901d","0x2fd3","0x0a31","0xe1c1","0x9e34","0x4cee","0xef5c","0xdf1f","0x2fdd","0x0a02","0xfce0","0xf2dd","0xed22","0xc57a","0x2412","0x9223","0x1ea","0xca50","0x0ece","0x10d2","0x32c0","0xc2ec","0xeb35","0x2944","0xf141","0x2af1","0x0e23","0x9b05","0x91e1","0xa207","0x4cae","0xd3ce","0xafff","0xdad1","0x9c30","0x9de2","0x1ae6","0xdd39","0xfd00","0xce01","0xee5c","0xe0dd","0x37e3","0xf035","0x1ea2","0xe711","0x0f11","0xd3d6","0x9ee4","0x4304","0xee01","0x9bf1","0x33e0","0xda5f","0xfc0e","0x1de","0xcfcc","0xbde0","0x9fe3","0xd0fc","0xf3ee","0x5446","0xfe6f","0xeef6","0x3f5f","0x409c","0xc4cd","0xe5db","0x1f1c","0xbba5","0xe330","0xc7de","0xf21f","0x22f","0xbbd2","0x21fd","0xf25e","0x460d","0xde12","0x517","0x2c4e","0xcf99","0xf5c1","0xf5e0","0x6e3c","0xcb3c","0x3723","0x1e37","0xef3a","0x2200","0xe9d9","0x6e0d","0x293","0x64ec","0x5bc5","0x4bc3","0x410f","0x2fca","0xdce0","0x39e","0x2239","0x0930","0xf521","0xd1b1","0xe0e1","0x11","0xf0ed","0xfe21","0xc0d3","0x333","0x20d0","0xd3d4","0x1d12","0x1cef","0x3f40","0x91b1","0x3e21","0xb1e0","0x5f3d","0xefbd","0x10dc","0x1fff","0x0e6","0x34","0x0a2","0x2304","0x41cd","0xbdc5","0xae15","0xeff1","0x5221","0x97d4","0x51e0","0x0","0xdc3f","0xc4cc","0xbc4d","0xfe22","0xc1e2","0x4700","0x7ae","0x37c1","0xb5dd","0x1246","0x5f5f","0x7c1f","0xa2f0","0x10d","0x7aad","0xe0c3","0x1923","0x2dbe","0xc131","0xf150","0xb336","0x0e14","0xeef0","0x4be0","0x4fd","0xcec0","0x5fe3","0x92ae","0xee00","0xb3fc","0xe41b","0x11f2","0xeeee","0x1df","0x9361","0x9401","0x97e5","0xe24c","0xf194","0x2e23","0x30b9","0x3122","0x3207","0xbb0e","0x2dc0","0xa0b9","0x4f0","0xde23","0xdabe","0xf500","0xa5c4","0xfdf1","0xc417","0xcfff","0xa452","0x0f2f","0x3d49","0xe076","0x11c7","0x3919","0x13be","0x31de","0x6ab3","0xe0f0","0xed1f","0xf1a2","0xe430","0x1309","0x2f10","0xd3e0","0x3c3a","0xd04f","0x6f4","0x100c","0x30c","0x41b0","0x1fee","0x333d","0xc62f","0xefa0","0x0f00","0xc943","0xa9e3","0x11dd","0xe9d1","0x1532","0x1fe1","0xfb39","0x090c","0x3cb","0xf045","0xf0ef","0xfd1f","0xf6fe","0x102","0x1954","0xedfd","0x2700","0xa130","0x150b","0xf041","0x5144","0x444a","0x3a0d","0xd071","0xdb5e","0x33f4","0xf215","0xcd1e","0x2672","0xa4ce","0x3112","0xee04","0x374e","0xfbd1","0x0f29","0x21e","0x0ddd","0x5c2d","0x1931","0x5c22","0x11f7","0x5d11","0x41cd","0xea13","0x2056","0x6e91","0xdec1","0xec70","0xfee6","0x400e","0x3d2a","0x139b","0x9d47","0xcd0d","0x3999","0x3192","0xdf15","0x3443","0x26b5","0xe932","0x5a32","0xe3d1","0xeae2","0xdf32","0x6d79","0xe232","0x1c3d","0x2fbf","0xf0f5","0xeeea","0x3fcb","0x2494","0xe071","0x60b2","0x2427","0xb700","0x6020","0xef24","0x50ef","0xebe0","0x610c","0x2017","0x303f","0xfac1","0xdecb","0xd511","0xefe1","0x33ef","0x111c","0xa5fd","0xc00f","0x203e","0x50f","0xe2ef","0xd203","0x1014","0xb0d1","0x2411","0x22ef","0x09fd","0xfeed","0xd424","0xdd41","0xe0f1","0x1f10","0xe1ff","0x2fed","0x1112","0x26f0","0x4edf","0x0d1","0xfeea","0x30f1","0x1211","0xf1d0","0xfcf2","0xcdff","0xe3de","0x21ff","0xec00","0xe10e","0xf121","0xf103","0x0f0","0x1dce","0xde1f","0x1d13","0x3e32","0xedf1","0x26b1","0x6ffe","0xfd20","0xb2fe","0x2df","0xc000","0xe1f3","0x3120","0x7d2","0xe03f","0xf2f3","0x1c30","0xffbe","0x23ed","0xede0","0x2c01","0x53ff","0x7f1f","0xdace","0x61e4","0xd61b","0xfd24","0x10c7","0xed0f","0x1031","0x3cbd","0xf2d2","0x509c","0x19ed","0x4fd3","0x9c0e","0x7b3d","0x27cb","0x0c5c","0xeabe","0xe3c6","0x923f","0xfd6e","0xe1b2","0x1203","0x262a","0xf0e3","0x5af0","0x55b1","0xe10e","0x9de0","0xddb1","0x0ed1","0x4e0b","0x2d3b","0x2f6","0xdfe5","0xcbd1","0x3e4e","0xf1c2","0xd1a9","0x1b","0xff10","0xd403","0x9576","0xd61b","0xc52b","0xdd1a","0xf40c","0xdbbb","0xedeb","0x157","0xc507","0xbd2d","0x7072","0xddd0","0xf119","0x25ec","0xf331","0xe62d","0xdfed","0x44ce","0x900a","0xca37","0xe9e9","0xfecd","0x1cfd","0x1efe","0xfff0","0x4321","0xfd53","0xee3d","0xee0e","0x2fc1","0x203e","0x222f","0x4d9f","0x20e1","0xfde3","0x2cd0","0x56b0","0xb2c5","0xde54","0x65e","0x1ae0","0x4f51","0xaceb","0x42de","0xe02c","0x1dc","0x3e39","0x11dd","0x94f5","0xf1fe","0x0c0c","0x0e17","0x36df","0xb04a","0xf2fd","0xe33b","0x1e1f","0xefd1","0x443","0x114","0x21e","0xa520","0x2ee4","0x1a0e","0x2eb0","0xc4e1","0x2aef","0xdbee","0x3d1c","0xe43f","0x0dd2","0x2035","0x1afc","0xfcdf","0x1213","0x1deb","0x110","0xe001","0x2f22","0x4502","0x5e91","0xd3f1","0x191d","0x0dec","0x3df3","0x21e0","0xd3fe","0xf023","0x9303","0xebef","0x1ec6","0x4cfe","0x20b0","0x2131","0xc4c2","0x2dc3","0x1d14","0x70b","0x0fba","0xdc19","0xfdfd","0x69b7","0x2bfe","0x566","0x0fc6","0xfd30","0xeedd","0x10fe","0xd513","0x5fc0","0xb16e","0xddc4","0x341c","0x54f","0x96e3","0x201e","0x230b","0x1e0c","0x2107","0xfbe0","0x63fd","0xfff2","0x5c4d","0x3f4","0xf7f9","0xe1f1","0x2d","0xbcd0","0xd003","0x1fea","0x1901","0xcac0","0xb401","0x460","0x20dd","0xdc53","0xfc10","0xabcc","0xeffe","0x3fc5","0xfd4a","0xdb03","0x21ff","0xd4d1","0x46d1","0x0dd1","0xffd1","0x1d0c","0x721e","0x5e1a","0x4013","0xc99c","0x0f35","0xca11","0x4bbf","0x260b","0xe029","0x6713","0xc5d4","0xdd34","0x421f","0xd032","0xd12e","0x0f1f","0x1dfc","0xd02c","0xe113","0x1923","0x3300","0x3c3b","0x13f0","0xf5e1","0xbf20","0x1f14","0xf1f1","0xe7ef","0x5c01","0xf020","0x3d0","0xefd3","0xe011","0x7160","0x121a","0xe90e","0xd40e","0xa012","0x4020","0xad0e","0x410f","0x130f","0x0f1b","0x0d2","0x7f1","0x132e","0x6902","0x1d0f","0xcb00","0xe91e","0xf017","0xfac5","0x4d1f","0xeef1","0xcae2","0xda9f","0x9090","0x2eee","0x3cfd","0xd501","0x7e5f","0xef6f","0x7df7","0xe2df","0x13cf","0x3a1","0x2fbc","0xc37f","0x5020","0xb010","0x0d1f","0xab93","0xf243","0x631","0x0efc","0xfdec","0xfecf","0xb44e","0x59fe","0xfafd","0xd032","0x2020","0xfe1d","0xd90b","0x4e1f","0xef11","0xabe5","0x142b","0x12da","0xddd1","0xf0a1","0xcebe","0xdef1","0x0dfd","0x7a3e","0x110c","0xe944","0x20f9","0xd327","0x091a","0x7202","0x434e","0xf01d","0x6666","0x2ecc","0x3cf6","0x15ec","0xf4f1","0xf22e","0xedb9","0x3a03","0xd0c7","0x2371","0xf9dc","0xe21f","0xd9dd","0x40f4","0x1c3f","0x0e1a","0x57f0","0x1b24","0xde52","0x132e","0xf1f1","0xe1e4","0xeea9","0xe3b3","0xceff","0xdb50","0x2edc","0xc512","0x93e9","0xff3a","0xbd12","0x4231","0x206e","0xaee1","0xf619","0xdda7","0x6ffd","0xeaec","0xc127","0x0d0e","0xe204","0xcd39","0xc7d3","0xa19b","0xa4ff","0x22d","0x9fe3","0x7175","0xab1a","0xd104","0x24ef","0x3921","0x4abe","0xaaad","0xe245","0x95c0","0xcedd","0xb1ed","0x2337","0xea9e","0x0b51","0x93cd","0xfeae","0x76bf","0xbbfb","0xd6d0","0xe5b4","0xdf40","0x99e1","0xd1ba","0xeb46","0xf355","0xc4df","0x3ef2","0x0f0","0xbcfe","0x2e1a","0x1133","0xce00","0x12b0","0x3d20","0xfd39","0xf3f1","0x0fcf","0xfef1","0x11a9","0x1bef","0xa2e1","0xfe50","0x30d","0xf32a","0x0c2d","0x26e3","0x721d","0x0de1","0x15f5","0x0bce","0xadd9","0xc0f1","0x0ccf","0xdd2f","0xef0f","0x1111","0xe13e","0x3ca","0xa24b","0xd30a","0x2e16","0x601c","0xd0ed","0x74f2","0x2241","0xe3e1","0x1cec","0xe4b1","0xd51f","0xed42","0x2c15","0x3e47","0x53ef","0xe0c1","0x4e0","0xeae3","0xf2d0","0xf90e","0x2be","0x11","0x1f0d","0x0ef0","0xf2e1","0x4310","0x461b","0x1f0e","0x230e","0xbe2e","0xcd21","0x1f1f","0xdf10","0x3c1","0x6f3e","0xb1e0","0x2141","0xc036","0xa42e","0xd90a","0x1057","0x1db","0x246b","0x12f4","0x230e","0x121e","0xdaff","0x4021","0x950e","0x1d0","0x5ded","0x23f","0xf323","0xed31","0x1f15","0x2fa1","0xde54","0x5fdd","0x2232","0xfe1d","0xf021","0x12ef","0xfe34","0x2f63","0xcf0f","0xf04b","0xe3f4","0x09db","0xdfa1","0xf310","0x0e21","0xee2c","0x22b2","0xe1d4","0x1c9f","0x9031","0xe33f","0x42fb","0xfc0e","0xcdfe","0xd0e5","0x6fff","0xa2fe","0xc999","0x11e","0xb201","0xfef1","0xb1de","0x122","0xddf0","0x40af","0xce50","0x13f2","0xb3e0","0x91b0","0x1fe0","0xa124","0x63e2","0x4e0a","0x1433","0xf0d2","0xcc14","0xd030","0xa400","0xbdf9","0x0ee1","0x70e5","0xbffb","0x0ea2","0xb7ed","0xcfee","0x62d0","0x1342","0x6c0a","0xf2f2","0xfe02","0xf3fc","0xffea","0xbe42","0x210e","0x0fe3","0xf2b4","0x20cf","0xef3c","0xe199","0x11e5","0xf9f0","0x337d","0xf9c0","0x0946","0xb3f1","0xe2a5","0x462e","0xe070","0x5333","0xed93","0x2d22","0x2d25","0x191d","0x0df2","0x2ec9","0xe5fb","0xbf10","0xf716","0xbf10","0x1d","0x0e2f","0x2cb3","0xdfdf","0x1f2f","0x75eb","0xb09b","0xd1eb","0x1fa1","0x2c1e","0xdd1d","0xcecf","0xd126","0xf97d","0xe1e0","0x0e03","0xe115","0x14c0","0xf91e","0x3042","0xc33d","0x1ffe","0x3ff7","0xaf19","0xf220","0x1c0f","0xb3e2","0xdf2f","0xde1b","0xe024","0x221c","0xbd10","0x1c0c","0x30a0","0x392d","0x6f01","0xc211","0x0d52","0x0f06","0xfefe","0xf2f4","0x2c1e","0x0f00","0x31d1","0xa201","0x3e36","0xec30","0x21f1","0x0bef","0x13fe","0xd02c","0xf32e","0xd1e3","0x41eb","0xf102","0x2304","0xb451","0x1edc","0x3e00","0x52bf","0x117f","0x3d41","0xcfd3","0x21fd"},
{"0x31c3","0x1d0d","0x2de0","0x24e1","0x343f","0x250f","0x2cd1","0xe092","0x9d5b","0xf33c","0x0e13","0xeae0","0x4bff","0x2c2b","0x40ae","0xecce","0x45dc","0xc2ee","0x9959","0x307","0xed0e","0x42de","0x1cee","0xef91","0xd062","0xefde","0x203c","0x57e0","0x2b9b","0x1eb4","0x402d","0xd093","0x1f09","0xad25","0xbc9a","0x3b20","0x4309","0x1e75","0x2f4e","0x9f94","0xbdcc","0x34ee","0xd3ed","0x2eda","0xe1ef","0x92bf","0x2eff","0xbac5","0x95a3","0x7f0e","0x0e44","0x1713","0x9e0b","0x0c31","0x1c2f","0xd249","0x17f5","0x2b12","0x12b3","0x4f91","0xc1d3","0x91e1","0xb035","0x1cd4","0x795e","0x2c3","0xb919","0x1d19","0xd2ac","0xcda2","0xe424","0x1da","0x2940","0xe61d","0x1a60","0x3be","0x9aae","0x1910","0x713f","0xecdd","0x7dc","0x100f","0x09d0","0xcf13","0x1cf0","0xc1eb","0x3113","0xcef2","0x2ff2","0xf4df","0x113f","0x0f33","0xea52","0x7311","0x91ff","0xfe0f","0xdbfd","0xf102","0x2f40","0xe264","0xdfcf","0x4240","0xe24c","0x1c5b","0x4e29","0x13ef","0xd043","0xf521","0xc000","0x3f4e","0x7e10","0x0911","0x3c0","0xe171","0x4244","0x653d","0x0a02","0x1d7d","0x217e","0x4ff","0x12d0","0x76d1","0x154f","0xe743","0xb342","0x4610","0xbf4e","0xf413","0xe3cf","0x1def","0xb641","0x3d10","0xbc02","0xa23c","0xe713","0xe212","0xf6d3","0x7cec","0xe9dc","0x9610","0x936e","0xfe01","0xba21","0xeb00","0x12ae","0xce03","0xde26","0xfbf3","0xd112","0xd47b","0x2404","0xd101","0xe114","0xcc1d","0x4011","0x23df","0x304c","0xd0ed","0xfd32","0x0c3f","0xdf0b","0xedf1","0x2d1c","0x091e","0x9b0e","0xddec","0x62ef","0xc0f4","0xd105","0xf4ec","0x2121","0xf7f1","0xcef1","0xfc2c","0x2452","0xc1e5","0x229","0x1ffa","0x2bf3","0x4d0e","0xf9b1","0x3f2e","0xecd5","0xdda0","0xbf36","0x65cd","0xbbf1","0xb7e4","0x52f0","0xdf2b","0xb054","0xdf0f","0xe249","0x90ed","0xb3c2","0xf41f","0x0a4","0x2772","0x2f1","0x9ff6","0x9103","0x9efa","0x3dfc","0x9b09","0x44ec","0xe0eb","0xef29","0xdb4f","0xf0d2","0xa3b1","0xff12","0x13e","0xc5c0","0xe490","0xd191","0x116","0x2125","0xea5e","0x56e2","0x2fdd","0x7ca2","0x3325","0xef01","0xef1b","0x3911","0xff0e","0xfe3e","0x32ef","0xe273","0x49c9","0xbcc0","0x4df0","0x6e2c","0xcbb2","0xf7e6","0x7411","0x0d5b","0x2713","0x14ea","0x24ba","0xade5","0x21f","0x4fbf","0xaf9d","0x1ded","0x0d13","0x0e1c","0x1a21","0xd131","0x2bc0","0xfdf5","0x27b7","0xd1fe","0xfff1","0xd24e","0xddee","0xaf0b","0x204c","0xf95e","0x33a5","0x26ef","0xec4b","0x4abf","0x3c2b","0xfb3f","0x329d","0x7f22","0xc720","0xf0be","0x7de0","0x1bf3","0x3e01","0xebcc","0xc210","0x3d3c","0xe2c4","0xeaf9","0xc020","0x1992","0xdedd","0xbdcf","0x0c32","0xfd1f","0x0ec0","0xc1ef","0x14e0","0x1a14","0xdcae","0x1dce","0xf1f2","0x1fde","0x1e9e","0x7df0","0x2d61","0xf1d0","0x29f","0xb4fe","0x6bf2","0x4c2f","0x9e04","0x1449","0x40fe","0x1321","0xdc4f","0x70ec","0x332a","0x122","0x1ef0","0xede4","0x122e","0x1bd1","0x9eb2","0x4fe7","0x1636","0x602d","0xe647","0x2dde","0x1d02","0x5231","0xfdf3","0x3e2f","0x1000","0xb000","0xfd11","0xdbc1","0x334f","0x3b9f","0xbf9d","0xb0f3","0x717","0x5b0b","0xd204","0xdcae","0xea01","0xe374","0xbed2","0x601f","0xd352","0x15d2","0x1bde","0x0de0","0x4330","0x1ee4","0xcde0","0x14b7","0x0976","0x7cfe","0xf913","0xdf3b","0xdfeb","0x2d64","0x90f3","0x3ace","0x3111","0x22ff","0x31da","0xf1f3","0xfb3e","0x19bc","0x9ecc","0x52e4","0x0b46","0x1ef1","0xe736","0x400","0x0b0c","0xb04e","0xcda1","0x3e2d","0x42ff","0x091f","0xbee1","0xfe34","0xddff","0xc99f","0x09e","0x122c","0x6724","0x7ef6","0xc414","0xac21","0x30e2","0xb441","0xc0e4","0x140e","0x16cf","0xe9ec","0xe5fd","0xff11","0xf355","0x3fc","0xef4c","0xb2c3","0x4aab","0x2ff4","0x4cfa","0xc99f","0x0e01","0xe171","0x94e4","0xd0e3","0x24ee","0x3a5a","0xe0cd","0xff06","0x3c4e","0xf1ef","0xefd1","0x12f6","0x6df9","0x2911","0x2703","0x0d20","0xf37c","0xb140","0xc245","0x310","0x3ce","0x1f1d","0xeed1","0x0ee6","0x31f3","0x1c1d","0xdfe3","0x4321","0x3120","0x5d11","0x531","0xdf2b","0xd031","0xef5e","0x1f0","0xdc00","0x51ee","0x39d0","0x5c5","0xbe0c","0xede2","0xdd0d","0x4722","0x4006","0x20f1","0x35c1","0xe1ce","0xdc11","0x2c11","0x3250","0xd1de","0x51cf","0x99db","0xf21a","0xc024","0x1ec6","0xdc6c","0x3232","0x369e","0xe412","0x53fc","0xf1fe","0x9c76","0x94ef","0xf2cd","0x2c09","0xf05d","0x9afd","0x09a2","0xd22f","0x173e","0xc391","0x1eee","0x36e","0x1f9a","0x1fab","0x2e45","0xd74a","0x3daf","0x6f43","0x40f2","0xa03f","0x5fca","0x371","0xc2ef","0x2dec","0xe11d","0xf2e0","0x79f0","0x401","0x1eab","0x211","0xdcee","0x606c","0x13fe","0xd4c2","0x1c5f","0x555e","0xdb01","0xa205","0xd1c2","0x1d13","0x1b01","0x0e51","0x522c","0x2eee","0x21ee","0xe3d4","0x72f0","0x3710","0xd641","0x326","0x1513","0x767e","0x277f","0x22f","0x34e0","0xb022","0x193e","0x50a2","0x344d","0xdffb","0xe1a3","0x11e3","0x4c63","0x213","0xe271","0xd303","0x2f21","0x6a","0x4230","0x2972","0xc3ef","0x492d","0xeefc","0xe419","0xd2de","0x3030","0x471d","0xfc35","0xfe9b","0x2f27","0xbd60","0x110d","0x291e","0x5ed","0x0c11","0xb9db","0x7032","0xf90c","0x12fa","0x9f29","0xa0dc","0xc02b","0x60fb","0x199f","0x90a3","0x3265","0x5a6d","0xacce","0x73d7","0xd340","0xada1","0x291f","0x33e2","0x3bec","0x14d","0xe9c0","0x1611","0x22eb","0xdde1","0x0e0e","0xf0ee","0x403d","0xb273","0x9f19","0xa9f1","0xc34f","0x4331","0x1acf","0xcdef","0x0bf2","0x0d02","0xcb53","0xd14d","0xc3d7","0xf211","0xc11a","0xdc29","0xe3be","0xe420","0x1ab2","0x11fe","0xfd34","0xb911","0x2101","0x12ed","0xe230","0xddc0","0xe1c2","0xe22d","0x211b","0x3e01","0xad29","0x5fbf","0x20e","0xc3ee","0x0da6","0x20ec","0xf0fe","0x2e21","0x30fe","0xc5ed","0xf35f","0xe211","0x3092","0xfe2d","0x311","0xde05","0x9114","0x73ef","0x31f","0x9440","0x64bf","0x4003","0x0cec","0x3e11","0xed2c","0xc3fe","0x0fdd","0xf0ff","0x21e3","0x2441","0xc5f2","0x4304","0x1de2","0x10a1","0xedff","0xc0d9","0x5cfa","0x0c35","0xd0e2","0xd1ee","0x104e","0x2141","0x293c","0x430a","0xf161","0xe0fe","0x0a1","0x234","0x49e6","0xfbbb","0x0ff3","0x4b1f","0x3b2c","0x16e","0xb60d","0xf1e0","0x303d","0x31fe","0xd919","0x3f1f","0x0c1","0x53cc","0x2aac","0xc1c4","0x1f3","0x1b39","0xcaa4","0xedfe","0x100f","0x09f0","0x2700","0x4204","0xeffe","0xc102","0xdb4e","0xf1f1","0xe2d1","0xff42","0x3003","0x0c1","0xff23","0x5cdd","0x5312","0x14d2","0xffdd","0x21e","0xee3e","0x3014","0x1fef","0x911d","0xd0d1","0xdf03","0xeb90","0xea3f","0xf0ee","0xfa0d","0x9af5","0x4dcd","0x55d3","0x97e1","0x319d","0x3fe3","0x1e50","0xe5d2","0x1d0e","0xf401","0xeed2","0xfd30","0x17a2","0x6500","0xb311","0x300e","0x302f","0x4ebe","0x321","0xd222","0x6d9b","0xf0d3","0xfc22","0xdd2f","0x432","0x3011","0xddfd","0xf32c","0x0ceb","0x20f4","0x1225","0x961f","0x1f12","0xf2e0","0xfe21","0xd1f0","0x12a0","0xf0ff","0xf25b","0x3f02","0xc642","0xcf02","0x2a","0xf13f","0xf1c4","0x311e","0x21ea","0xf1ba","0x1517","0x333f","0x4012","0xeffd","0xdec2","0xeb2d","0x6c20","0x2a0f","0xe76b","0xfb45","0xf0f9","0x1c1e","0x31c","0x6fc4","0xc0fe","0x1ded","0x5716","0xfc2b","0x540f","0xc3de","0xdc51","0x5232","0x0","0x142d","0xe332","0xf01b","0x211d","0xc3ed","0x30d9","0xdf19","0xd20c","0x163c","0xf21f","0x1dbc","0xcde3","0x93b9","0x95cf","0x0f10","0x2b21","0xa913","0x7964","0x90fc","0x19ef","0x0e11","0xbeda","0x0f90","0x5a0d","0x23d2","0xfd54","0x6ded","0x1ee9","0xb632","0xdfd1","0xd935","0xbc0e","0x77ef","0x2324","0x21eb","0x92a0","0x3aa4","0x117c","0x3014","0x57e","0x0ae2","0x72d5","0x337","0xf05b","0x6e75","0xb022","0xe30c","0xc1d1","0x30","0xc2c1","0xc219","0xc3fd","0x41d","0xaefc","0xbbef","0x7ce4","0xce12","0xf0ed","0x0bee","0x0cc2","0xd3a2","0xd4fd","0x1646","0xe074","0x5de7","0x42dc","0xff4c","0xf0b3","0x9105","0x20f9","0xdcab","0x7da4","0xe024","0xec27","0x34c5","0x5b52","0x50af","0xab01","0xc942","0x3911","0x3902","0x3ee","0x3a41","0x1d1f","0xcc24","0x4f29","0xf0e0","0x1093","0xc070","0x22f1","0xe1f6","0x1b22","0x5eae","0xaf41","0x1e41","0x12fb","0xd911","0x779d","0xddfb","0xda12","0x1f37","0xe1bf","0x10bf","0x0a32","0x1cb9","0xf27a","0x1efe","0xfdad","0xaf10","0x33cd","0xd92b","0x1f1c","0x263d","0x99dd","0x5f73","0x1114","0x2b04","0xfd4c","0x522e","0x327c","0xa00b","0xf69c","0xeec3","0xe2a2","0xd1ad","0xc17d","0x9f0e","0xe903","0x1bff","0xd4de","0xf1e5","0x4ffd","0x212b","0xefac","0x1104","0x2314","0x3001","0xb0f2","0x4ffb","0x3911","0x7f20","0xc1c4","0x2941","0xaf02","0x1bde","0x3cfb","0x2cea","0xfc4d","0xfd02","0x1d0b","0xd0ea","0x0bf","0xeefe","0xff13","0x1dc2","0x2f20","0xe222","0x1e0","0xd31f","0xe072","0xf23b","0x4fc9","0x2ebe","0xfb0d","0x92f1","0xd119","0xbb94","0x251c","0xd2ea","0xc55e","0xdcc7","0x253c","0x10d5","0xf4ff","0x91fe","0xed14","0x35ce","0xe4d9","0x1114","0xb979","0xd3de","0x1f29","0xeced","0x4f06","0xd5f0","0xe91f","0xb32f","0xfc0d","0x1393","0xdd1a","0x99b5","0x9101","0x326f","0x4a4f","0xdf4b","0xeb03","0xcee0","0xf1d7","0x1320","0x14f3","0xe3f9","0xe2e9","0xf510","0xe42d","0x9394","0x1ff1","0xe304","0xdf3d","0x09e1","0x6d09","0xeae3","0xb02d","0x9acb","0xe6b2","0xddf1","0xd006","0xbe59","0xd90c","0x7b7","0xc572","0x3123","0x49e3","0x75f4","0x4ee4","0xb94a","0xd10e","0x3905","0xebee","0xf243","0xa743","0x0b3e","0xd431","0xdf1b","0x1111","0xd022","0xf7ff","0x1ed3","0x5c3e","0x1bd1","0x1b01","0x3ed6","0x35a7","0x2f3f","0xf1d1","0xefa4","0x4b49","0xf9c2","0xd15d","0xde32","0x334c","0xed54","0xf42e","0x213f","0xc552","0x4f29","0xf337","0x210e","0xd10e","0xb235","0xbf4a","0xeed0","0xcebf","0x2224","0x740","0xffc0","0xcfe3","0x6ce0","0xf92c","0xa1fa","0x94dc","0xe9fa","0xd9bf","0xa971","0xb11e","0xccdc","0x4004","0x0f3c","0xaf0f","0x4630","0x55d0","0xec1c","0xf1f2","0x5ee2","0x1b1f","0x13b0","0x9ec0","0xd34c","0xd24f","0x13bd","0x1560","0x3230","0x13ad","0x6061","0x40f3","0xdc26","0x1544","0x0ef2","0xc417","0x32ce","0x29e0","0xc7ef","0x2dfd","0xac15","0xff21","0x9dfd","0x0e7","0x9afc","0x0a2","0xefe3","0x9930","0x47cc","0x3e50","0x0f90","0x0d17","0xc4af","0x5a2e","0x7164","0xe5e2","0xd30f","0xd6f2","0x172d","0xf21c","0x2b33","0xa003","0xd3f7","0xd9fe","0x4120","0xc260","0xe03c","0x713","0x1f","0x10bf","0x30bf","0x53e","0xbc10","0x2a07","0x2a1f","0x19ce","0x7e01","0xbacf","0x6f5a","0x0c5d","0x0f26","0x2c1f","0x2019","0xc9e6","0xeccf","0xf1c2","0x73dd","0x0f21","0x635f","0xa554","0xfad5","0xe7aa","0xaf4f","0x095d","0x217","0x1afa","0xed0d","0xebf4","0xd039","0x13fe","0x33ad","0xeb01","0x3fe3","0x932d","0x992c","0x5bee","0xf40e","0x1d","0x11c","0x11b5","0x2114","0xb94a","0xf3ee","0x2fe","0xff4f","0xf7c4","0x2e11","0x332e","0x3c91","0xc30e","0x9dbe","0xfe10","0xff9f","0x7fe0","0xb1bf","0x2c9f","0x2d61","0x09dd","0x6da1","0xc02c","0x260c","0x36ed","0xd2db","0x0c02","0x52e3","0x12fe","0xc909","0x1e0f","0x3620","0xbef1","0x6921","0x215e","0x14ef","0xebf1","0x7bfc","0x1def","0xd10e","0x46e2","0xef1f","0x3de2","0x7ad3","0x0f4a","0xf427","0x20fe","0x7b02","0x2a0e","0x20dd","0xfb0a","0x60f9","0x30c","0x3cf4","0x5e2","0xf12b","0x2b15","0x33dd","0x2f33","0x4b02","0x9e30","0x79f3","0xcfc3","0x2df0","0xf46c","0xcf0d","0x23f2","0xd504","0xfdd2","0x599c","0x3dda","0x20ac","0x1919","0x0f5e","0xbfc1","0x9d5f","0xd62a","0x3c59","0xd29e","0x47fe","0x41a1","0x69","0x16e7","0xf16c","0xf135","0xfa49","0x2362","0xdf5e","0x63a0","0x33f4","0x16ef","0x7030","0xe70e","0x61c","0xb214","0x12af","0x0b1c","0x2f42","0xe317","0x0d44","0x2d5f","0xe030","0x253f","0xdb7f","0x1fd","0xd250","0xd00d","0x31c1","0x1be0","0x92d4","0xfff1","0x300b","0xe331","0x4521","0xb2de","0x20dd","0x7cec","0xe1c4","0x4d2f","0x35d7","0xb124","0x6ac2","0x5de1","0xe0d0","0xf021","0x235e","0xf46e","0xe71c","0x6c4","0x27a9","0x9e9e","0x25a9","0x292d","0x1126","0xf660","0x2234","0x1d0f","0x19bf","0x69dd","0x4ddd","0x10bd","0x9369","0xe470","0x9fb3","0x1c77","0x10ac","0x0c0e","0x12bb","0xcf2f","0x7adb","0x0e0b","0xe1d1","0x6e56","0x7eb9","0xdae4","0x77cc","0x0dc2","0xd41e","0x9331","0xc02f","0x1fb","0x0f1a","0xd4d4","0xfd3b","0xe0e0","0x1240","0x40e0","0x2e3","0x43f1","0x5011","0x3fd3","0xbe1b","0xf2ef","0xc2d1","0xbe4e","0xd6f9","0x53c9","0x44db","0x554","0x0f36","0xc09f","0x0a6e","0x4302","0x1203","0xc503","0x5210","0x5bf1","0x931e","0x22f3","0xaff1","0x9f09","0x3e21","0xb0f1","0x20ce","0xee5a","0x2e1","0x70a3","0x50fc","0xd4a4","0x1272","0xb5df","0x1ed2","0xe0fe","0xf1d4","0x70f6","0xfe5f","0xcbe2","0x0fe3","0xd7c3","0x0f1f","0xe95b","0x44bd","0x0c00","0xb1f9","0xf331","0x340","0xc31e","0x113c","0x0e2e","0x36ec","0x1c3f","0xed44","0x6ff1","0xba42","0x423f","0x0e2d","0xeebe","0x3623","0xff4d","0xdfa7","0xec7c","0x0f53","0x1c23","0xe02e","0x4c31","0xe095","0xd011","0xd91f","0xc136","0x2520","0xdadf","0x192d","0xf344","0xf90e","0x3a1a","0x1e11","0xef43","0xf032","0xfff6","0x16e0","0xf9f0","0x9e53","0xf01c","0xee01","0xce2e","0xdf0b","0x6219","0xfdbf","0xd1de","0x9630","0xdd0d","0xfa4d","0x3e03","0x4f99","0xd4d3","0x227e","0xb30f","0xd1f5","0x212e","0x600e","0xeef0","0x3f41","0xe6aa","0xe0d0","0xcbea","0x3136","0x0d5f","0x3dbe","0x7121","0x1be","0xd601","0x232c","0x53d3","0xf0b3","0x30ca","0xe5de","0xdefe","0x117b","0xf3bc","0x0f2e","0xf35d","0xf11d","0x1e0","0xabd1","0xde4d","0xe720","0xfbf2","0x701d","0x10e4","0xeee3","0xd3be","0xddaf","0x5b2","0xf220","0xee3e","0x21d2","0x2c12","0xe21d","0xf1ec","0xc90e","0x1fdf","0xf3d2","0x66af","0x1191","0xf030","0x5b9","0xf24f","0xfb55","0xe3fb","0xfa0f","0xd921","0x5421","0x22ff","0xf050","0xf27e","0xfc11","0x149f","0x2ce2","0x335","0xea10","0x701c","0xd41b","0xa1cb","0xee3f","0x9167","0x100d","0xd51c","0x3929","0xe340","0x42de","0xbd20","0x6cd","0xe4ab","0x3ff0","0x1e02","0x1d02","0x7ca2","0xb0c0","0xed15","0xec72","0xcc11","0x1003","0xd7c2","0xb511","0xff4e","0x3426","0x23a4","0xd994","0xe92e","0x323","0xe27c","0x3340","0xdfdf","0xb021","0xd713","0x1b30","0xfff9","0x72ed","0xc9ee","0x2c3f","0xf2f4","0x4cb2","0xd21f","0x1c0e","0xeb71","0xbde1","0x2791","0x601f","0x35f1","0xe2f0","0xfb50","0xe514","0x4a14","0x2c10","0x0adf","0x2023","0xbf2f","0x2af1","0x20ed","0xd3d1","0xd722","0x30dc","0xf435","0x3391","0x1a3d","0x2204","0xbfee","0x11f1","0xe12b","0x42d3"},
{"0x3026","0x21e3","0x210f","0x20e0","0xd13f","0xe503","0x51fe","0xb6ed","0xfc40","0x3f50","0x224","0xdcf3","0x25f","0x0a3e","0x4b2f","0x0f62","0x51f0","0xc29f","0xbb2e","0xecd2","0x0929","0xfaf1","0xc0f2","0xef9d","0xef57","0xe056","0xe1e0","0x45f1","0xf120","0x2c32","0xde5c","0x3ef","0xef69","0xfc0c","0x9dca","0x392f","0x4909","0xfe40","0x30ee","0xfe92","0xffd2","0x37f1","0xdf1f","0xe01c","0x0d2e","0xeedf","0xabea","0x30f3","0xe21f","0xe1f2","0x3442","0x1ef4","0xefcc","0xd252","0xfe03","0xfc11","0x1229","0xfc1e","0xfe1d","0x1f34","0x123d","0x4721","0x2eb4","0x13d2","0x1cfd","0x2f52","0x32f5","0x350d","0x3a09","0x522e","0x2c0e","0xa101","0x221e","0x093e","0xd793","0xd06e","0xc13d","0xecd4","0xdd51","0x1454","0xfe4e","0x2020","0xf011","0x13fd","0x0b1d","0x1cf3","0xd3d3","0xd400","0x11f3","0x3df0","0xdefe","0x1f0e","0x303","0xde12","0x4100","0xece0","0x2c1c","0x0cf1","0x4fc3","0x1d3e","0x0fdb","0xe2ef","0x6033","0xb1eb","0xb11f","0x50a0","0xa6e2","0xfea1","0xd1f5","0x3f02","0x5230","0x52ae","0x442d","0xdf41","0x24e3","0x2d2b","0xb9fc","0x1203","0x5074","0xdf23","0x9311","0x5fd4","0x430f","0x7f1","0xe621","0x235","0x33e4","0x3390","0xe1f1","0xfc14","0x1f2c","0xdf4f","0x9b0c","0x2d23","0x11ef","0x0dd0","0xa021","0x4dd5","0xf110","0x30de","0xb24f","0xef1f","0x2a00","0xfdcd","0x1fd","0xe21e","0x0ece","0xfff1","0x2b07","0xf04d","0xc3d6","0xec54","0x0fe3","0xde0f","0x30b","0xdcd1","0x5ddc","0xe0c3","0x2fc","0x2e","0x1edb","0x0eed","0x212a","0xfee1","0x0bef","0xbffe","0xf6d1","0x0fe5","0xbd25","0x10ce","0x3cfc","0xf0ff","0xfffe","0xe4ff","0x1fde","0x1ff0","0x304d","0xb2fc","0x69fe","0x361f","0xf993","0x552e","0x2c00","0x91c6","0x9ee3","0x71fd","0xaac4","0xfe11","0x50d0","0xf031","0xd021","0xe121","0x9f19","0xf30d","0x1ff0","0x2521","0x2037","0x0e5e","0x0fe1","0xe2e1","0x90e1","0x92da","0x5c0d","0xc9dd","0x40c9","0x123e","0x0f1f","0xdbff","0x13f6","0xa3bf","0x0d1e","0x2e6c","0xd343","0x2e0e","0xced2","0x7bbe","0x3d2f","0xb9eb","0xe100","0x7ef0","0x6c0c","0xf455","0xb3f1","0xdfad","0x1d54","0x2010","0x2f00","0xd00d","0xf075","0xee01","0xedf2","0xd0f1","0x50ee","0xa0f1","0xe5f4","0x24ef","0xc02c","0xe030","0xd0f3","0xe001","0x0edf","0x13f","0xf03e","0x229a","0xf01e","0x3d20","0xe9ef","0x113d","0xcfcb","0x21dd","0xcbe4","0xe7c7","0x1fbe","0x0a14","0xb3e3","0x3d1f","0x7209","0xde9c","0xd9bd","0xfc9d","0xf43d","0x1e0c","0x3bd1","0x5ad9","0xf01c","0x3b5","0x5a7d","0x35f2","0xdef3","0x6103","0xd5d2","0x4a2d","0x11fa","0x0e23","0xce1c","0xded2","0x29","0xdf1c","0x099e","0xbfed","0x90e5","0x205","0x20","0xebf1","0xdf3e","0xd21f","0xfff1","0xbff3","0xce09","0xc2e0","0xfadd","0x0d9e","0x4dc1","0x0dba","0x23bf","0x0c90","0x92ca","0x4d0b","0x1b44","0xd1cf","0xd253","0x52a0","0xe042","0xcd30","0x11d1","0x1500","0x5b00","0xcddd","0x31","0x12ff","0xfda1","0xeace","0xa2ff","0x470f","0x4ef7","0x2e16","0x6ee4","0x3e2","0xb400","0xd2f2","0x3f15","0xe2d1","0x203f","0xd0ef","0x9a3e","0xd4fb","0xb9ad","0x6da0","0x0dbf","0x2615","0x21ef","0xbfc4","0xece2","0xa2d2","0xe30e","0xcde1","0x0de4","0x31db","0xd260","0x7bbe","0x0cdd","0x2d3e","0xabc3","0x4223","0xff41","0x3c7b","0x54d0","0xfc0d","0xb15e","0x6ffb","0x0b71","0xc3e0","0x2fd3","0xd71e","0x4f9","0xe290","0xd200","0x1b21","0xcbbc","0x3121","0xd0ec","0x3b4e","0x1cd1","0xe3f1","0xa1df","0xeecc","0xaff0","0xe731","0x3020","0x74d","0x5c4e","0xce92","0x2b20","0x1cfe","0xaabc","0xa1de","0x2d1a","0x73c5","0x1212","0x0df1","0x3f","0x2dc1","0xddbe","0xb124","0x4ed0","0x192","0xd9cc","0x3173","0xe00e","0x2211","0xbc0f","0x37e","0x3fc1","0xdbdc","0x4fcf","0x59eb","0x10ef","0x1cc5","0xdff2","0xdd99","0x102","0xf29f","0x19bd","0x0eff","0x1ed4","0xede1","0xccd3","0xf0ed","0xcfe3","0xee19","0xddf0","0x1dd1","0x25d","0xf001","0xefc1","0x21dc","0x11ea","0x4dd0","0xea13","0xff30","0xddf5","0x4de3","0x2a12","0xdcdc","0xa010","0x0c2c","0x20fe","0x301e","0x417c","0x202","0xa1ce","0x1eef","0x21c5","0xf1fb","0x0f0d","0xd3d1","0xaf4e","0xdd0c","0xcf1d","0xff55","0x4ee3","0x5230","0xf2fb","0x124e","0xce01","0x2041","0xee4f","0x3ef1","0x0bb2","0xe19d","0x0e13","0x5b3","0xd05f","0xd422","0x0d30","0xf0be","0xc11f","0xe104","0xd212","0xd9ff","0x9df2","0xfa01","0x1cfd","0x3f41","0x11fd","0x2ab2","0xbf3a","0x431f","0xe20e","0xff04","0xe114","0x1e90","0x103e","0xf31d","0xee13","0x6b01","0x1006","0x0f41","0x4bdb","0x0f1c","0xe3f2","0x6ec2","0x621c","0x330c","0xe2cf","0x3ec0","0xe9b2","0x0cf4","0x93dc","0x4e19","0x0f3e","0xf44b","0x1af0","0xfd2f","0xe35c","0x2ac0","0x3352","0x4dbb","0x12c0","0x32ef","0x0edf","0x4d5f","0x1904","0x11","0x9410","0x3ec0","0x2ef6","0xdc61","0x2f23","0x1f23","0x633","0x3f3c","0x0f10","0x62ae","0xd0f2","0x1e27","0x77bc","0xc45e","0xba2e","0xdc12","0xcbc2","0xc027","0xcfee","0xfa71","0xa0f4","0xff4c","0xee22","0xd3fe","0xc1f2","0x3e50","0x4fee","0xf3e1","0x4c3a","0x4a01","0xef04","0xe129","0x1dd1","0x5114","0xc2e0","0x6e0d","0xfe35","0xf131","0xe242","0xfff0","0x47a0","0x9f46","0x3bb1","0x3326","0xb2e3","0xf9f0","0x2405","0xfd29","0x1730","0x3270","0x401","0x60d0","0x23e1","0xa409","0xe20f","0xf13c","0x91da","0xbc6a","0xf944","0xffe7","0xdf3d","0xfcc0","0x13dc","0xe269","0x2113","0x2e44","0xf50e","0x1fff","0x1021","0x3ee","0x30e5","0xcdeb","0xeff2","0xde0d","0xd2f2","0x2fff","0xc312","0xc3da","0x0f12","0x341f","0xff1c","0xcfde","0xd210","0x3ef3","0x64de","0x1671","0x733f","0xeb2e","0x120d","0x4ed","0xf32f","0xdbf1","0x3c25","0xdfec","0x4ce","0xfd01","0xe22d","0xfcfc","0xc90c","0x1912","0x311d","0x12c0","0x2c41","0x4200","0x41ff","0x2690","0x11d3","0x12e2","0x1097","0xffdd","0xbdd0","0x2fc0","0xc1e2","0xfef2","0xdae3","0xe93c","0x1ebc","0x23d1","0x1b1d","0xfe2e","0x3b15","0xfee1","0x4ecf","0xe1ed","0xe5d5","0xc9fb","0xb100","0x6f1d","0x33ce","0x2c93","0x139","0x103f","0x0f03","0x103b","0x3f10","0x11e1","0x3c14","0x123","0x1d33","0xbcdd","0x26d4","0x0f0c","0xc0fd","0x7ed1","0xf30b","0xca0d","0xf001","0x1d60","0xffc5","0x536e","0xeff9","0x2011","0x2e62","0x70db","0x390c","0xd100","0x4fe5","0x66ec","0x1f1e","0x1cb4","0x1032","0x0bd9","0xede1","0x322c","0xfe12","0xee02","0x0d0","0x0fe5","0xd14e","0xf00f","0xdb41","0xf3ee","0x1141","0xcdfd","0x2f4f","0x0d1c","0x5f5d","0x121f","0x5df3","0x5b10","0x12f","0x0cf2","0xf01d","0x4e30","0xd33f","0x15ff","0x091c","0xfed2","0xfd3e","0x112d","0xff10","0xbd4f","0xf0f2","0xfaee","0x0b01","0x41ef","0xe2c2","0x13e1","0xfc3b","0xd3ff","0xc219","0xc5f5","0x2bfe","0x0e0b","0xb3c2","0x2e21","0xd013","0xc20d","0xc0e0","0x3bfc","0x1e0e","0x0e3f","0x2fb1","0x1d29","0x112e","0xe2d0","0xfd12","0x32ea","0x0d1e","0xd133","0xdbfc","0x2022","0xfdf5","0xdeed","0x41ee","0xdebe","0xf92f","0xc1dd","0x3611","0xe261","0xf7eb","0x2df1","0xec11","0x412d","0x1cfd","0x1153","0xfbc0","0x1402","0x49f4","0xb021","0x0fee","0xc6d3","0x6ec2","0x0f0e","0xf13b","0xdc42","0xc02d","0x2d2d","0x0f4e","0xe109","0x910e","0x2e01","0xf9fc","0x32e2","0xc956","0x953d","0x30a","0xc000","0x50d1","0x31d6","0x0f21","0xc04e","0x230f","0x3d0a","0xe242","0xd2fe","0xfc0f","0xfbb0","0x12fa","0xeefc","0xb310","0x1e00","0x126c","0x30ef","0xcb02","0xd021","0xc31e","0x3f70","0xdd4f","0x2eff","0xbc25","0x0f0d","0x1c01","0xdd0e","0xa93d","0x131e","0x79fe","0xb1d9","0xd101","0x7fbf","0x0b0","0xe210","0xb1d5","0x3f12","0xb3f1","0xed2f","0xc102","0x3e41","0x9ae0","0x3e10","0xf129","0xfde1","0xe351","0x4dfd","0x20a3","0x7ff6","0xd06e","0x6276","0xaec2","0xdb13","0x3d31","0xc069","0xa32d","0xa0df","0x12ee","0xf00f","0xe12c","0x0ef0","0x1321","0xdf51","0xb00d","0xfe1e","0xde06","0xc2d1","0xd1ee","0x1134","0x4e03","0x2054","0x10da","0xce1e","0xf4f5","0x22f2","0xd91c","0x14fd","0x44b1","0x13d","0xc014","0x4e0d","0x41d0","0xcf90","0xef0d","0x513","0xbcf1","0xdd61","0x300a","0xedf3","0xfdaf","0x442","0x0903","0xdbe2","0x402","0x0c","0xc57d","0x503d","0xceb1","0xd1bd","0x2001","0xfe7e","0x21fe","0xec30","0x7b2c","0xc0f9","0xf90f","0x0df9","0xee09","0x6cde","0xf326","0xd0ea","0x594f","0x2151","0x3b60","0xd732","0xcac0","0x190d","0x0910","0xec02","0xa9db","0x712e","0xcd0c","0xa5fa","0xc959","0xad3e","0x46d","0xbe1d","0xc9aa","0x23b7","0x445e","0x2d04","0x9031","0x5313","0xeacb","0xecaf","0xffe1","0x2cf","0xdf11","0x3f3e","0x62cb","0x2503","0xf513","0x1d21","0xa500","0x2f1a","0x091e","0x2fe","0xf2a0","0xd9e2","0xfb32","0xfb14","0x31dc","0xf321","0x0efc","0x11ed","0xcffb","0x2d13","0x1ef5","0x1000","0x2137","0x1db2","0x1fe0","0x1111","0xc120","0x1e59","0xc020","0xe0ce","0x0ccf","0x13f3","0xea30","0xf416","0x2e1d","0x0c42","0x3014","0xc53f","0x9f37","0x23d1","0x0d0","0xf242","0xcebd","0xac1f","0xdc20","0x1eb2","0x7c1a","0x50fc","0xdb0e","0xfc0a","0xfc5c","0xf9d1","0x15ee","0x1e2f","0x291e","0xe2e4","0x1a0c","0x2015","0x13d6","0x7922","0xb0f5","0xae14","0xf0f1","0x0eea","0xebee","0xcf11","0xbd40","0x3e6","0xce30","0x91fd","0xd0df","0x0e1f","0x3d0","0xeff1","0xeffe","0x2d36","0x1e41","0x3044","0x21e","0xe15a","0x4fd0","0xdf29","0x1a10","0x1ecd","0xde3f","0xaf41","0xfe2c","0x2efb","0x2b9f","0x32ef","0xd1ef","0xca3f","0xca3e","0xe0f1","0xf00c","0xcb0f","0xc12e","0x201d","0xe9ed","0xdd1f","0x36fe","0x3f1e","0x3230","0xecac","0xee1e","0x3fd0","0xf0c0","0xee16","0x403","0xe922","0x7315","0xbd35","0xccdc","0xef3e","0xe269","0x3c13","0xe570","0x4e22","0x7d2e","0xfe45","0x1c22","0xe5e4","0x90d2","0x3e1f","0x5de7","0xc114","0xdecc","0x5d30","0x0e4d","0xff03","0x197c","0xc34a","0xe63c","0x9f2e","0x2e0","0x19e7","0xca0b","0x99fd","0x9e3f","0xf9ae","0xe9d7","0xc021","0xcbb1","0xd1cf","0x0e1","0xffee","0xa3ba","0x274f","0x11e3","0x1e2e","0xf1fd","0x6392","0x491b","0xf0ee","0xa2a3","0x3b00","0x1603","0xd0ff","0x1211","0xa1f3","0x50b","0xb531","0x31ee","0xcffe","0xe1d0","0x4053","0x0cbf","0xf5a2","0x1dff","0xe4ff","0x23bf","0xde24","0xdc0e","0xcad4","0x3e75","0xceff","0x4e0d","0x303d","0xd36c","0x1ecc","0x6ad1","0x40c","0xc2ae","0x460f","0x09c9","0x519e","0xcccd","0x1dde","0xb000","0x6e4d","0xceda","0x0c1c","0x3f00","0x1f09","0x992f","0xebde","0xf4d9","0xf209","0x2a01","0xff2e","0x0b50","0x3f91","0x0ff1","0x4ff5","0xa30d","0x3b73","0x7de0","0xc164","0x2a45","0x2025","0xdd2f","0x0b12","0xc9f0","0xefea","0xd2f2","0xf111","0xe0d0","0x1330","0xf9e3","0x1907","0x2ee2","0xd6d1","0xf620","0x21d","0xdb21","0xcaeb","0xc43e","0xfcd0","0x0fd1","0xf900","0x201e","0x52e2","0x1f12","0x7cf4","0xa2f9","0x7ce9","0xcf42","0x4ca4","0x1294","0x1001","0x2414","0xf0ea","0xde00","0x0a11","0x1fcd","0x2eff","0x3d02","0x1c00","0xf301","0x0c1d","0x1b13","0x2132","0x0f00","0xe243","0xd33f","0x2da2","0x0ef2","0xf123","0xfff0","0x59cd","0x2e0d","0x6ae2","0xd213","0x1efe","0xddc0","0x26ed","0xdfe1","0x1a17","0xfe51","0xc41e","0x7621","0xdc03","0x12ad","0xd1f0","0xafa2","0x0bec","0x32c2","0x5c1a","0x30f2","0xc0f1","0x201b","0x2cff","0x221c","0xf35e","0xadef","0x42f2","0x10ed","0xed30","0x593e","0xd020","0x7f21","0xc324","0xb122","0x1f19","0x32e5","0xd4fe","0xc3af","0x109f","0xc212","0xc92d","0x2d0c","0x3e10","0xcb73","0x1adf","0x0919","0xc9db","0x91e0","0x2990","0x51ce","0xf1a9","0x0944","0xe52f","0x1eef","0xca34","0x12d0","0xfaec","0xdabd","0x6c33","0xfde1","0xcff0","0xd90d","0xc202","0x90e1","0x401b","0x6544","0xdb4d","0xc20e","0x11f4","0x1749","0x2270","0x23cd","0x220f","0xf044","0x0a0","0x112e","0x0922","0x49fe","0x42e2","0x124c","0x6e2a","0x2131","0x0f6e","0x4ef0","0xdf02","0x43c","0x2ff1","0x5e2f","0x14f6","0xb340","0x3cf","0x3ffd","0x32ed","0x25ec","0x4f60","0xcef1","0xfe2d","0xe21e","0x245c","0xf2db","0x1ec0","0x1fd0","0x1cc0","0xeefe","0xe5d0","0x3efd","0xb00e","0x3dfe","0x15a0","0x213d","0x7d4b","0xcfe5","0xd02e","0xd40d","0x7c20","0xee09","0xfba9","0xf9f4","0x2fc3","0x0cbc","0x344c","0x4cfd","0x0f4d","0x5434","0x6293","0x2cd9","0x212e","0x19e","0x2040","0xfcf2","0x29c4","0x90ec","0xf539","0xe9e7","0xe500","0xe47b","0xf210","0xe030","0x424f","0xe279","0xe30b","0xf2fe","0xcb0d","0xd3f1","0xdcb3","0x4001","0x62db","0xcff3","0xd3cb","0x2da9","0xd90a","0xdfed","0xc196","0xaf00","0xc1fb","0x0bb9","0x34ee","0xe224","0xd90a","0x1db0","0x1d1a","0xce1f","0x41ff","0xbfdb","0x5db","0xd1ff","0x991d","0xcf91","0x5425","0xcbdc","0x9f41","0x260e","0xd599","0xdf1b","0x305","0x4f2","0x70dc","0xc20c","0xde1e","0x10fa","0x3fda","0x9435","0xfb50","0x70ce","0x2003","0xb9bf","0xef20","0xe4c2","0x4b2b","0xdd2d","0xc29f","0x73f1","0x131b","0xb00c","0xf2f4","0xedfd","0x2f20","0x0f23","0x26be","0x202","0x2c10","0x1f10","0xeaed","0x7d0b","0xcd3d","0xf92d","0x6f0e","0xf01a","0xed21","0x3e34","0xe921","0xdd5f","0x5df0","0x0d11","0x9636","0xfd9e","0xd904","0x0b41","0x1521","0x5bee","0xf9e4","0x0fd2","0xdde1","0x2a5a","0x505f","0x1022","0xb54e","0x40ee","0x2727","0xd9fb","0x1e72","0x204","0x71cf","0x9074","0xc099","0x2ed9","0xbfc3","0x2d2f","0xfe01","0xfeef","0x3fe3","0x24ab","0x9f9c","0xc09f","0x4470","0xe272","0xb546","0xe614","0x1e1f","0x5b1b","0x7c90","0x5deb","0xa4ef","0x590a","0x5adc","0xff09","0x0d0b","0x3dbe","0xe2ae","0x1a0e","0x35d7","0x6651","0xf347","0x1b2","0x34c4","0x154e","0x1b2","0x102d","0x10d2","0x2f3e","0x9ff1","0x2ff1","0xf0d2","0x0c16","0x2025","0x0d00","0x1333","0x4ae0","0x2411","0xdc20","0x19c1","0xcbc2","0x3f36","0xd13e","0x2e4d","0x4012","0xd023","0xefcd","0x3afc","0x2a0e","0x0de2","0x21d0","0x9fbc","0xe221","0xe529","0x2e0f","0xeb23","0x911f","0x3e0d","0xf006","0x6ef1","0x3134","0x121","0xe000","0x59b1","0xd1f1","0x31e1","0x102c","0x7f1","0xff20","0x423f","0xcf2c","0x1bfc","0xed00","0xa401","0x42dd","0x6ffb","0xe371","0xeef1","0xe93d","0xf3a4","0x2d0","0x549e","0x51f0","0x25e1","0xfd1f","0x1ef0","0x137d","0x2fe3","0xc9ad","0xe2c0","0x3123","0x9395","0xebaa","0x43d","0xa2f1","0x4c91","0x43ad","0x233a","0x254b","0xb3f2","0xdb4f","0x105e","0x90c9","0x4a49","0x0e19","0x203e","0xcba3","0x7131","0x3242","0xe7ea","0xe219","0x1dde","0x235e","0x0e4d","0x7f9b","0xddf1","0x261f","0x49e0","0xbad1","0xf641","0xbefd","0xbf0f","0xfcec","0x3b10","0xfe5e","0xfefe","0x7b30","0x120","0xe73e","0xd1c9","0xfecd","0xeb21","0xd9e3","0x9e5c","0x901f","0x1a03","0x2aac","0xf16d"}
},
{{"0x76ee","0xfe2e","0x0de0","0x2003","0xf210","0xc1ff","0x32f1","0x242c","0xe213","0x3fd0","0x0e10","0x101","0x1c1e","0x6d3f","0xcc20","0x2911","0x2029","0x1045","0x29eb","0xe4d9","0xef5f","0xb10c","0x4ef7","0x0cfc","0xc9d5","0xf797","0xfe6e","0x3fe1","0xac33","0x790b","0x2022","0xae5a","0x10fa","0xde22","0xdace","0x0e1c","0xc00e","0x10d1","0x2ffe","0x0f0d","0xdf30","0xfe4e","0xfc12","0xffd5","0xec1e","0xf910","0x201f","0x1423","0xff99","0xa20c","0xc7a4","0xad0f","0x9d4f","0xb757","0x2be3","0xcd17","0xf1c0","0xdcfe","0x3fcd","0x9e9c","0xb626","0x92ed","0xce5d","0x119f","0xbecf","0xf92c","0x17a4","0x9d2e","0xef14","0xa2f3","0xf9d0","0xd764","0x5ebe","0xca3a","0x4494","0x47ad","0xed2c","0x93f6","0x1c25","0x2bc3","0xcd32","0xd0f2","0x410c","0xcead","0xcd32","0x5001","0x2039","0x3d00","0xddfb","0x3ecc","0xc4b2","0x221d","0xe0fd","0xe23c","0x5fd0","0x4ee4","0xfeba","0x2147","0x9991","0x4204","0x3725","0xe7d0","0x570a","0xfe3b","0x7fe7","0xd121","0x2630","0x63ae","0x642b","0x1d9","0x770b","0xecc0","0xbe3b","0x2007","0xf9dc","0x0be1","0xf61c","0xf3df","0x2ee","0xff00","0x0e17","0x223a","0x4e41","0xf5ab","0x3201","0xd03e","0x1f1c","0x0a1e","0xc4ac","0x2144","0xebed","0xd402","0x370e","0xdea1","0x2e40","0xff54","0x1c20","0x12bd","0x0d2c","0x4f9e","0x600f","0x0b51","0x2013","0x2122","0xec0e","0x72b0","0x0aec","0x22","0x0ee0","0xfdd6","0x1b21","0x7c2","0x31f2","0x42f2","0x2e22","0xbed2","0xf20e","0x2937","0x4efe","0x2e00","0x664e","0x95f0","0x176f","0xfe24","0x100f","0xe901","0xf513","0xee56","0xbfc7","0x2606","0x5c4e","0x2672","0x3401","0xb111","0xa0ea","0xc5de","0xafff","0xb09e","0x0e06","0xe240","0x3291","0x276c","0xe3e1","0x1db3","0x91d6","0xddfb","0xb6e0","0xb3b2","0x61b5","0xe332","0xcb0b","0x0b0","0x6f10","0x0d19","0x93d0","0xaea0","0x9f02","0xff43","0x244c","0xf1f3","0x1621","0x1e0","0x4cf0","0xfd3f","0xd0e1","0xaab1","0xef1f","0xe1fb","0x4dc6","0x5dee","0x17e1","0x102","0xeebf","0x2031","0x09","0x2626","0x26d1","0xf0b2","0x2f11","0x542c","0x212f","0xe2f0","0x1fcc","0x33a2","0x23d1","0x1010","0x1f1","0x2f3","0x1e0d","0x3130","0x3c0f","0xd0c2","0x20dc","0xe013","0x1ff5","0x70dd","0xd301","0x10dd","0xcee4","0x2d4e","0x26b4","0xd22e","0x93f0","0xfd0c","0x4e59","0xc941","0x34d","0x363f","0x6322","0xe41d","0x26f0","0x513e","0x2520","0xf0ea","0x3307","0xe94b","0x4d19","0x3f10","0x224f","0x470d","0xe903","0xe104","0x645","0x94a5","0x9122","0x436","0x19d0","0x9d1e","0xcc1d","0xb9e2","0xfec9","0xec03","0xf6f2","0x0e14","0xb4a5","0x4f33","0xbdc1","0x1f1d","0xe01c","0x41e1","0xfe4e","0x23b0","0xc4c1","0x11c4","0x22e0","0x9fb2","0xb0f1","0xef64","0x1ecd","0xf103","0xfede","0xdd62","0xba11","0x1c2b","0xefff","0xe000","0xf25f","0x4c9c","0x1c75","0xe34f","0xd2fb","0x4a1e","0xb64b","0xd3fe","0xde1e","0xb1eb","0x1299","0xee25","0x9b94","0x120c","0x11e2","0xc00f","0xa641","0xcced","0xdd3e","0xeece","0xb3de","0xac3f","0x907b","0xd3df","0xdf42","0xe7d0","0xeda1","0xd007","0x3b4","0xd6f0","0x50e1","0xf020","0xa225","0xcebe","0xde1f","0xdfc2","0x20b9","0xa73f","0xce70","0xe35c","0x3c2","0x3007","0xfe13","0x1320","0x1e00","0xa011","0x11c0","0xed1d","0xd222","0xee11","0x221f","0xff9e","0x2f12","0xf9ff","0xcced","0x220f","0xc210","0x1101","0xfdc1","0xd15e","0xeec2","0x0ee","0x0ae","0x2e5c","0x0fd7","0x2e03","0xf230","0x1292","0x5aae","0xe900","0xcb2e","0x2012","0x4e","0xdf1d","0x20c","0xf421","0x2221","0x6d1d","0x0ebb","0xfefc","0x0ed6","0xfa01","0xf4cc","0x53b3","0x2eef","0x0ede","0x1e31","0xe104","0x212f","0x2af9","0x4b1e","0x29cf","0x11fe","0x301e","0xaffa","0x50eb","0xd37e","0x9a11","0x3a29","0x3eee","0xffc1","0x0cd3","0x10bc","0xb531","0xd0c1","0x21fc","0x33c3","0xcef0","0xde1a","0x0cdc","0xf522","0xedec","0x922f","0xbe13","0x49cf","0x0d4c","0xc6c1","0x113","0x1b4","0xb0b3","0xa511","0x2d11","0xfd02","0x5d0e","0xfc9c","0xc521","0x0ce2","0xbf3f","0x9af7","0x0bdf","0xa9f6","0x9fba","0xf1ec","0x2c02","0xe332","0x90ae","0xc12d","0xdcdd","0xfc5d","0xdf0d","0x3f09","0xf434","0xabed","0xbddc","0xe3c1","0x52ac","0xcb23","0x19e7","0x2059","0x0dd6","0x1ebd","0x35e2","0x1f59","0x902f","0xcdfa","0x14b0","0x515c","0x322f","0x9d9f","0x129b","0x901c","0x57ed","0x173f","0x7a06","0x15b1","0xef1f","0xc1fe","0x3434","0x1eda","0x23f1","0x11f0","0xf021","0xc9c1","0xc1a3","0x94de","0xec9c","0x413","0xf7d3","0x6dcb","0x20b2","0x4263","0x1e1","0x5d04","0xb351","0xf6fe","0x1def","0xd96c","0xede1","0xfe12","0xcf20","0xa00c","0xf7ab","0x21ff","0xf2cc","0x11cd","0x200f","0x150","0xe3c3","0x2f2f","0x2fe3","0x5431","0xf2d1","0xdec2","0x0c03","0x0eff","0xa0ff","0x31d4","0xf01d","0x7026","0x17ee","0x0e03","0x12be","0x1530","0x3dfd","0x101e","0x1fc5","0x2021","0xf3c1","0x0fdf","0xeae0","0x4d01","0xf134","0x6dd5","0xd3f0","0x1030","0xe2ec","0xd1df","0xf3ad","0xa50b","0xd34c","0xf012","0xecfd","0x412","0x1010","0xeccb","0x257d","0x0c0f","0x2cc0","0xe9d3","0x11a","0xd015","0x409d","0x11c2","0x3ddc","0x222a","0x1961","0xd2e0","0xe0ef","0xfe02","0xd0ee","0x264e","0x144f","0xacf0","0x6f30","0xdb3f","0xcb70","0xc536","0x41d","0x3034","0xded1","0xd010","0x0b13","0xa4bb","0x0e30","0x0dc5","0xc220","0xe61e","0x19e9","0x9c4b","0xef1c","0xfd0b","0xdffd","0xf60e","0xe1e9","0xe204","0xaeff","0xe90e","0xed22","0xeee3","0x13a5","0x0a0e","0x40ee","0x10","0x2cb","0xd21f","0xe201","0xf11e","0x0f24","0xcf22","0xf01f","0x5edf","0x20f1","0xec11","0xd010","0xf012","0xf3d0","0x3c40","0x1240","0x2d2d","0xfdd3","0x254e","0x120e","0xf227","0xd041","0xd5f2","0x3eaf","0xf500","0x1fe0","0xf021","0xb5c2","0xcde4","0x1bf2","0xd200","0x202f","0x1972","0xff1f","0x11fb","0xecde","0x310c","0x3309","0xfd20","0x1e00","0xdcbe","0xe1be","0xde0b","0x39f2","0x501c","0x21f2","0x111f","0x41dc","0xdae0","0x9e04","0xad0f","0x1023","0x24f1","0x21e3","0x4723","0xa03f","0x1f06","0x30d","0xd5e0","0x5f3","0xf20f","0x7df3","0xfd5f","0xe010","0xf9f4","0x3e3e","0x9c4d","0x11f1","0xe0be","0xf1ef","0x16d6","0x1e","0x7e2","0x100d","0xeef0","0xf321","0x4ec","0xa0de","0x30ef","0x4d01","0xcaf2","0x0df","0xee20","0x2d0d","0xd290","0xe200","0x1440","0x3fed","0x291f","0x32ba","0xe403","0x21d3","0xc2ef","0xfe5c","0x30ab","0xfd1a","0xc0f2","0xf04c","0xbbfc","0x1913","0xdd37","0xe5f2","0xf5ce","0xe3e0","0xdbb2","0xbf99","0xf6f1","0xf321","0xcb21","0xf201","0xf790","0x99fe","0x7722","0x2310","0xa903","0x4e36","0xfa5b","0x9bf1","0xb0ee","0x3d73","0x2c04","0x9c9c","0x3432","0xdecb","0x30ac","0x344b","0xf733","0xedc3","0x21d3","0xdcf1","0x31ef","0x515e","0x2de9","0x4f1","0x1eb4","0x1940","0x3d02","0xf705","0x50","0x4d","0x43e0","0xdf32","0xe730","0x90c3","0xf0f9","0xc520","0xe0cb","0x9b22","0xb211","0xfe50","0x200e","0x29e","0xf1e7","0xd13d","0x22ed","0xb2ba","0xc7bf","0x2e0e","0xefe4","0x0fdf","0x43d0","0x3d17","0xbfea","0xe974","0x2dae","0xbbe0","0x17df","0xc10d","0xe131","0x34eb","0xc2a4","0xa3be","0x1e","0x9ce3","0x222f","0xced1","0x2747","0xf51f","0xe94d","0xcef1","0x40c9","0x1a0","0x3fa9","0x303e","0xe303","0xc0be","0xc996","0x0fe6","0x44cd","0x20d5","0xefe0","0x6e2e","0xf591","0x0ef0","0x1fc1","0xcd31","0x3ecd","0xdf10","0xf2f5","0xfdfe","0x23e5","0xffe1","0x50","0x2e11","0xe2df","0x0c10","0xf69e","0x940b","0x97a1","0x1227","0x9bd1","0x1f5f","0x1ec1","0xf302","0xc77e","0x0b2b","0x2a90","0xd20e","0x902c","0x9b1d","0xfecf","0x2a3","0x2935","0x2d42","0xd3c7","0xde17","0x191e","0x3f10","0x2e5c","0xc316","0x24e1","0xa0e2","0xf1eb","0xe19d","0x6afd","0x933e","0x3bd0","0x1dd0","0x7f0d","0x11","0x1cb0","0xeef4","0xef1f","0xf61e","0x1c1f","0x111f","0xd116","0x20","0xe00c","0xf32e","0xef11","0x1cff","0x2c30","0x0d1f","0xf640","0x1d3","0xd9ee","0xe9f2","0x201c","0xde20","0xfe46","0x1d2f","0x2a04","0x1ce2","0xe15f","0x4ffd","0xa0f2","0x5041","0xebe7","0x2201","0xad6c","0x10a","0x1cd3","0x4465","0x7b22","0x4363","0x2037","0xdd52","0xaef1","0x3321","0xfece","0x9c5f","0xf155","0xa92b","0xa5e9","0x3600","0x35d5","0x7e1d","0xef14","0xf404","0x560f","0x4a09","0xfea4","0x3d5e","0x223f","0xe03a","0xd5de","0xf19e","0xe1a6","0x67fd","0xf139","0x15ae","0x17d4","0x1021","0x1b0f","0x1227","0x2632","0x712a","0x1342","0x1efc","0x115d","0x23e1","0xa610","0x5e9d","0xf395","0x340f","0xef0e","0x3c3f","0xa624","0x10f","0xce74","0xaf03","0x335","0xf20f","0x731b","0x0ef1","0x13d0","0x2e0d","0x9310","0x409f","0xe106","0xd32f","0x5126","0x4da0","0x5ee1","0x2f3c","0xcabc","0xcc22","0xcefa","0x0c41","0x5cf1","0x12d9","0x2031","0x25fd","0xbfdf","0x1203","0xf501","0xf9c7","0xcede","0xf2ec","0x60e0","0xdbe9","0xce9f","0xfaf7","0x9f42","0x392f","0x437e","0x0f2a","0x173a","0xe537","0x352d","0x452","0x2523","0x27a0","0x1fc7","0x70bb","0x4e3d","0xbe23","0xffd5","0xc0d0","0x2f5c","0x2f12","0x237e","0x1f2a","0x3fee","0xf3f4","0x5f2","0x6000","0x1002","0x6ee0","0x1b2f","0x2fe0","0xaf10","0xff2e","0x2720","0xb150","0xe40d","0x69d1","0x1be5","0x295f","0x12d9","0xe01f","0xb0b7","0xab34","0xe3f7","0x2f10","0xd0b9","0xc7bf","0xa41e","0xdde1","0x433","0x5d33","0x1f2","0x69ed","0xcf34","0xdb5c","0x2ffe","0xc250","0xc497","0xf9fb","0x1167","0x10d","0x095","0x51eb","0x3150","0xd9e2","0xfb60","0xf9c3","0x2df2","0x0999","0xb759","0xd120","0x3302","0xae10","0xd523","0xfbbb","0x293f","0x5e23","0x6ee7","0x7efc","0x4904","0x0e12","0xfad1","0xdee1","0xbaed","0x5aee","0xe0ff","0x20eb","0xf420","0xfcc1","0x3325","0xfe03","0xebb0","0xb901","0x2c0d","0x0a2e","0x27af","0xb7fa","0xf4ed","0x6302","0xf210","0x1a53","0xafbd","0xbdd4","0xde63","0xf2fc","0x23f1","0xa790","0x3121","0xfbfb","0x0cf9","0xe20e","0xe0e3","0x2a4e","0xffb5","0x3bc1","0xec30","0x2a10","0x3d22","0xace1","0x26dd","0xd03d","0x3f0","0x2cb","0x5342","0xb0b1","0x1dd0","0x2a32","0x22f2","0x26a","0xcdab","0xce43","0x1f43","0x11d5","0x5e24","0xf0f3","0x9f57","0x311c","0xa30e","0xc611","0x22f9","0x0d62","0x0eee","0x302c","0x2fe4","0x1211","0x9fad","0x2cd0","0x0d40","0xff16","0x203f","0xd03c","0x1225","0x9ebc","0x729","0x120","0xd0df","0xf7e9","0x31cf","0x304b","0x0d20","0x1f3","0xf0e4","0x3ef1","0x50cd","0xd2c0","0x222f","0xd325","0x74e0","0xe105","0xb060","0x2a0","0x4d9b","0x1a1e","0x6544","0x7f00","0x3c1f","0x1c","0xdefe","0x2d23","0x5e","0x4aef","0xfaa7","0x3c00","0xa403","0x20ec","0x1bd2","0xfeec","0xcd04","0xc906","0xfe02","0x7be","0x37c2","0xe00e","0xc21a","0x4201","0x1f21","0x4ed5","0x520a","0x0f02","0x505","0x22fd","0xe5f2","0x1e92","0xf1df","0x91f1","0x91e0","0x1605","0x60c1","0x6cdc","0xb554","0x0e21","0x7d34","0x2fcf","0x73c9","0xd032","0x0f1e","0x0f9e","0xbfdd","0x2292","0xee4c","0x90c7","0x40dd","0x20c2","0x191","0xedc7","0x9eae","0x0dde","0xee47","0x97e7","0x2129","0x1314","0xa240","0xb131","0x3f00","0xd3f1","0x09ee","0x1fc6","0x707f","0x1d1f","0xffc2","0x3f1","0xc4bf","0xf12e","0xeae0","0x0fa2","0x0e11","0xfe02","0xf1f4","0xeeae","0xef2c","0xaf61","0x90ec","0x2fe5","0xab59","0x7b16","0x0b17","0x21b","0xffa4","0xf124","0x2cc1","0xd3f0","0x5f0f","0xe142","0xf40e","0xeff1","0xc23d","0x3d11","0xada0","0xdc05","0xc261","0x7c22","0xd2d9","0xafe2","0xff0e","0x2e1c","0x2fd1","0x2772","0x3306","0xf3d4","0xe90b","0xfd25","0xfdce","0x0ebf","0x5f10","0xc3dc","0x2aeb","0xebe1","0xc119","0xcdda","0xce10","0xd13b","0x9edf","0x41d2","0x5a9b","0xe094","0xfed3","0x191c","0xffce","0x39de","0x79ee","0xe11f","0x2d99","0x1a0f","0x9414","0x1220","0x1dfe","0x6cc","0xfe32","0x23dc","0x7acf","0xe0df","0x4ff6","0x1b2e","0x0ff","0x6f3b","0xfe04","0x124d","0x770f","0x341c","0x70f3","0x41df","0xa0e3","0xa224","0x9010","0xe14f","0xe1cb","0xd41c","0xe32d","0x10ce","0x201f","0x441","0xc45e","0xc107","0x23f1","0x1201","0x1442","0x4dd0","0xb5c7","0x9305","0x9e01","0x3f53","0xdc2e","0xb072","0xc75b","0x30d0","0x33df","0x51df","0xe400","0x1df","0xbc0f","0x35f","0x21bf","0xfded","0xc7f6","0x23","0x0f32","0x1b04","0xeee9","0xcccd","0x770c","0xfead","0x3392","0x731d","0x370f","0xd2e1","0xfed2","0xfccf","0xa1ff","0x220f","0xae9f","0xe1a1","0xf111","0x330f","0xde0c","0x1e15","0x1001","0x4fcc","0x0f01","0x0e51","0x5f24","0x2e1f","0xe100","0x14d3","0xdc93","0x1c1e","0xfffb","0xfc03","0xaa01","0xff1d","0xc115","0x2d26","0xd433","0xf406","0xc01e","0x169d","0xd61f","0x93ff","0xa104","0x0f13","0x4d51","0xa246","0x9afd","0xdbfb","0xefed","0xbd0e","0xdbd3","0x51b","0xddcf","0xd2e0","0xfdd4","0x143d","0x11ba","0x5905","0xfd04","0xd200","0x09d2","0xd0ec","0x232d","0x0abf","0x0e01","0x10f3","0xbe02","0x1215","0x213","0x1040","0x0eee","0xfd0f","0xfd30","0x1011","0xc3ef","0xc0fa","0x16ce","0x1f01","0x2e4e","0xd263","0xdd10","0xd621","0x40fb","0xf021","0xeef4","0xe1ee","0x2de3","0x634","0x13ae","0x1a24","0xf301","0xffd4","0x7a3f","0x11a","0x999f","0x251b","0xaf03","0x5fff","0x17df","0xbd41","0xee43","0xe0bc","0x0b3d","0xe21f","0xe119","0x3993","0x3b10","0xfffe","0xef0f","0xf12d","0xcaef","0xc3dd","0xfd5f","0x2bdf","0x4042","0x22f7","0xe003","0xc3bd","0x2ae2","0x1f09","0x6f00","0x1df1","0xfec1","0xfbf6","0x42c1","0xd091","0xd705","0x3e51","0xf104","0x190d","0x0e1f","0x9d60","0x714f","0xe20e","0x0ec4","0xdcdb","0xef70","0xfb0c","0xdedb","0x40ee","0x4ff1","0xdf9c","0xcc11","0x4b1f","0xbd07","0xebdc","0xc3ef","0x223e","0x7011","0x207b","0x11f5","0x7fbc","0xcf42","0x3117","0xe1c6","0xe026","0x11e1","0xd47d","0x2b0e","0x39bd","0xe501","0x0def","0x3bfd","0xcdf0","0x137d","0xbfcb","0x32ec","0x3f2","0xc00d","0x0ecc","0x191f","0xc340","0x9fae","0x576d","0xffe0","0x3ce2","0xdf52","0xeb3e","0xe372","0xcfe2","0x31de","0x1eca","0x15d3","0x152d","0x1749","0xfe0f","0x79fd","0xb22e","0x1a1c","0x6f71","0x311f","0x1cce","0xdb45","0x2e72","0xd47f","0xceed","0x5d0e","0xedcd","0x4eaf","0x1a9b","0xc61b","0x0dda","0xfe00","0x9d03","0x14f5","0xff21","0xb142","0x0f1b","0x0e54","0xe020","0xf4e1","0xc511","0x3f17","0x3ad5","0xe22c","0x1952","0x5019","0x102d","0xe15b","0xe993","0xd211","0xece3","0xff2e","0xce9a","0xce40","0xae1e","0x2efe","0xdd1a","0xf1d0","0x19f1","0xf0f2","0xf9ef","0x2e0","0xe2ff","0x1ff0","0xea22","0xf2fd","0x510","0x2dff","0x9ede","0xfe16","0x214c","0x4d06","0xf14d","0xfe5e","0xfbf0","0x1d00","0xd03d","0x2ddf","0xde3b","0x2e16","0x5c10"},
{"0xff22","0x0f0e","0xcc01","0x0e0c","0xe9f3","0x2f14","0xc32a","0xf11f","0x1107","0x0f0e","0x3320","0xf350","0xfd1c","0x300","0x120e","0x30f0","0x7f0c","0xb1e9","0x99bd","0x1939","0xcccf","0x2ffc","0xe10f","0xd43f","0x1906","0x4c9c","0x339e","0x443e","0x1200","0xcb0a","0xa22d","0xc2c1","0xbbbf","0x10c9","0x196f","0xe1f9","0x9e11","0xfe4f","0x132d","0xf33f","0xcbf1","0x4ec3","0xd0a0","0x52cf","0xd212","0x2634","0x2310","0x0cdb","0xf3e2","0x9f0c","0xe6fd","0x391a","0x6a0f","0x9267","0x4101","0x21f3","0xd1e1","0xdac9","0x729c","0xaf0c","0xf22d","0xf62d","0x0e14","0x415e","0x1fde","0xc42c","0xc3de","0xf1dd","0x4110","0xbee0","0x2247","0xe015","0xf9f7","0x4a9a","0x55ed","0x77c4","0x1eed","0x3e04","0x9235","0x3ed2","0xce0f","0xef01","0xe93c","0x5f10","0x5a14","0xff0c","0x3f31","0xb1fb","0x2122","0x4dfd","0xe421","0x7e3","0x9fff","0xfde0","0xf56e","0xfef0","0x22fa","0xdee7","0xf403","0x165d","0x122f","0xc2e4","0x5fcf","0x105","0x33f","0x0fe4","0x43e2","0xeec0","0xf43e","0xf01d","0x2f1d","0xce14","0xee23","0xf2db","0xe212","0xf242","0xcc1f","0xe9b1","0x2dde","0xd0f0","0x1f27","0x0aef","0x104d","0x11c1","0xd114","0xe34e","0xea4e","0xdf20","0x40d2","0xd03f","0xf12c","0xdfd3","0xeee2","0x3cee","0x22df","0xddfd","0x120e","0x1ecc","0xdb2d","0x13ce","0xd3f1","0x1c2b","0x3f35","0xfe5e","0x101c","0xffb3","0x2c0a","0x3e","0xcefc","0xe99e","0x30a6","0x33e4","0x20e","0x11ed","0x4dff","0xcba3","0x232f","0xf945","0x50","0x3e30","0xf50a","0xc52c","0x34fe","0x4b02","0x26f3","0xdefe","0x64c3","0xccee","0x0dc7","0xe70e","0x7e10","0xf2f2","0x122d","0x2200","0x2fd","0xee03","0xfd0e","0xb1c4","0x9f40","0x3fe1","0xd0a5","0x5b","0x93ee","0x9ee3","0xa124","0x3fc","0x1fff","0xc3ae","0x7f90","0x1113","0xce11","0xb3ff","0xb39d","0x2230","0x73ea","0xf713","0x5b1d","0xc612","0x0c36","0xa717","0xdfdf","0xd1a1","0x0ed2","0x1ebe","0x20b","0xc91c","0x744d","0xac53","0x9dcc","0xc236","0xd0cd","0x22f5","0x5ac0","0x23e4","0x09e5","0x93b5","0x0df4","0x111b","0x5d21","0x932f","0x09aa","0xcc05","0x7bef","0xe703","0x120","0xeb1e","0xd0be","0x0f1e","0x09e1","0x40d","0xdde1","0xc1c3","0xc2ed","0x20f2","0x2e12","0xc003","0xf221","0x1321","0x2a00","0xfaf1","0xaf52","0x1f","0xdccc","0x93fd","0x5c29","0xe904","0x1dd1","0xe040","0x2121","0x4015","0xc31d","0xf07d","0x9159","0x3c3c","0x41e7","0xe1df","0xd1cd","0x3c02","0x3f2d","0x430d","0xc991","0xe7dd","0x36d1","0x5cd","0xd3e2","0xf241","0xb9ff","0x99a2","0xd031","0xf927","0xecd9","0xfb70","0x1e3e","0xc3d0","0x7d02","0x10b4","0xe52e","0x1da3","0xee0e","0x5efa","0xfb1f","0xd1b0","0x311d","0x5e3d","0x0fd0","0xf0f2","0xe12e","0x111a","0x33e4","0xa131","0x4f","0x223","0xbdef","0xdc50","0xe421","0xef03","0x223e","0x4b00","0x4f62","0xf10d","0xc03b","0xfe1c","0xc003","0xe21f","0xede1","0x1fec","0xcde0","0x20f7","0xaca4","0x3161","0xf23f","0x149","0x3313","0x3d0b","0x26fa","0x5bd","0xaecd","0xcc1c","0xff32","0x0c1c","0xffef","0xf40e","0xdbfe","0x1ee3","0xde11","0x09ef","0x430a","0x4dea","0xdcff","0x4bb9","0xe2df","0x5c2","0xafdc","0xacf0","0xe06f","0x12f","0x1212","0x4036","0xffeb","0x2ece","0xd1f3","0xbddc","0x11d","0xbe0d","0xf25f","0xeec2","0x5100","0x0ff","0x0fee","0x2f00","0xcbfb","0x0e02","0xe040","0xcf0e","0xbefc","0x1ffd","0x1cc1","0xe13d","0xe2ea","0xeec1","0xc044","0x5fa1","0x4433","0x1fc3","0xffcd","0xd921","0xb90d","0xdefe","0xff5f","0xbfe0","0xecdb","0xd301","0xe300","0x1f2e","0xcfbb","0xf1ef","0x1124","0xe3af","0xf11f","0x24d2","0x2b2e","0xfdd1","0xc102","0xff0d","0x417","0x10f9","0x3c2c","0xd1af","0x500c","0x2f4f","0x4b31","0xfffd","0xf361","0xdee1","0x43ca","0xd7e1","0xe3d1","0xfa10","0x26f","0xa1fc","0x3ee6","0x7d00","0x3cee","0xb7ce","0x4ff","0x1101","0xdf41","0xfd2f","0xbe30","0xfccc","0x1fd","0x153f","0x32ec","0x124f","0x1f29","0xf74c","0x12c4","0x6f24","0x10fe","0xeffd","0xdcd9","0xf57f","0xdc1f","0xef44","0x9f21","0x2cdf","0x1a13","0x23e0","0x490b","0x0ecb","0xdf44","0x9b02","0xffe3","0xf2b1","0x2ff1","0xf1f2","0x343e","0xea2b","0x3201","0x2ed2","0x311e","0x75cb","0xc22f","0xdba7","0xce32","0xee11","0x314c","0xcff2","0x119","0xfc21","0x3e0d","0xe5ff","0x110f","0xd11a","0x223e","0x709c","0xf2d0","0x473a","0x27f1","0x39f7","0x23f4","0xf2f1","0xd62e","0x1da1","0x2dfb","0x2e20","0x1d25","0xdd24","0xe40a","0xc0fd","0xa003","0xbe9f","0x611d","0xc517","0x7211","0x30d1","0xc401","0xd5be","0xd6e3","0x950f","0x430f","0xe1fd","0x2a2e","0x9e41","0x11ef","0x0c0e","0xf202","0xa3bc","0x1cdd","0xe00f","0x61ad","0xdbed","0xeb3c","0xdaff","0xeefd","0xdd2d","0x1e1c","0xe1a1","0xbc1e","0xd100","0x4bee","0xdffb","0xd310","0x91c9","0x306","0xd732","0x742f","0xc0bf","0x2100","0xff50","0xe22e","0x20d3","0xc06f","0xf0c1","0x0a0c","0xff0d","0x7acd","0xbe22","0x3bf0","0x4bb","0x1224","0xe3e0","0x321c","0xee02","0xb32f","0x2324","0xd1cf","0xf7f6","0xb70f","0xc502","0xb00e","0x1032","0x1cc2","0x3901","0x40fa","0x3103","0xf0ae","0x53db","0x4231","0xde20","0xb40e","0x590e","0xf021","0x422e","0x2ff4","0x9411","0x5ff1","0xe73d","0x30c4","0xfdf7","0x261","0x1d75","0x7ead","0x4423","0x345c","0x44d0","0xd4e0","0x7c1","0xac19","0x1ddf","0xdf14","0xbef4","0xed13","0xddea","0x4471","0x4be9","0x40","0x9e2c","0x6fdb","0x52fc","0x7cd","0x7623","0xed51","0x175e","0x331c","0x4ddf","0x4a0d","0xa1de","0xfc0d","0x1bef","0x2e3d","0x3cf","0x3d02","0x120d","0xed30","0x4d53","0xf2af","0xc42f","0x0f13","0x2d29","0xdd23","0x1702","0x9992","0x7a0e","0xfaf0","0xb2f1","0xe96e","0x211d","0x390d","0x9f3d","0x39f","0xad05","0xdd60","0x1bb0","0xb221","0x3325","0xf2f3","0xf9d5","0x2760","0xbeef","0xb0fc","0x1ed5","0x979c","0x2e03","0x24ff","0x6d3b","0xf07e","0x6f20","0x291d","0xf443","0x90cf","0xb91b","0xcdf6","0x2020","0xd20f","0x450d","0x1030","0xf43f","0x3001","0x1304","0x0fcf","0xe1db","0xee0f","0xe0bd","0xde43","0x1de3","0x1ffe","0x293f","0x604d","0xe220","0xa5ef","0xe03e","0x2544","0x35e6","0xeb11","0x7afd","0x492d","0xef7c","0x447","0xe334","0x24d1","0xfece","0x31a","0xb4ef","0x0eff","0x7430","0xfb0e","0x0e15","0x0be2","0xf0ed","0x0cef","0xecae","0xc07e","0x1110","0x2014","0xffe0","0x5100","0xa4a0","0xde0d","0x2012","0x0a30","0x22dd","0x0f19","0xe631","0xd0c2","0x5e1f","0x20a3","0x3d40","0x3393","0xb2a7","0xd634","0x99e1","0x0a1c","0x9e9d","0x132f","0x3910","0xbe2c","0x2dbe","0xc0bd","0x963a","0x9096","0x1d3b","0x0a16","0xb462","0xb3d1","0xe727","0x1cd2","0xb933","0x60cb","0xff9a","0x70de","0x94ed","0xe027","0xedf1","0x1a4d","0x2e3b","0xed0f","0xf12f","0xf47d","0x1229","0xbbff","0xe1e5","0x1c03","0x594b","0xf2b0","0x7f00","0x79e3","0xf143","0x33d","0x21a0","0x1e0","0x9430","0xd9ed","0x774f","0x0b2c","0xe443","0x2f90","0x3e1d","0xef2d","0x5af0","0x5e5","0xc4de","0x314f","0x0eca","0xc322","0x1c1f","0x20b0","0x23d","0x2b6d","0xd023","0x0944","0x203e","0xd29e","0xbd23","0x0e43","0xe022","0x2d52","0x171f","0x30f5","0x621f","0xa373","0x1b1f","0x3042","0xa1a5","0x2167","0x3fdf","0x5113","0xd12d","0xe2d2","0xcfd5","0xef1c","0x4c5e","0x15e2","0x92be","0x5cdb","0xb302","0xb942","0xe64c","0xa324","0xee2f","0x1941","0x125e","0xeeb0","0x303","0x32f0","0x14e9","0x4e0","0x10c1","0x4f","0x129f","0xf2d1","0x2f1b","0xef4f","0x100","0x0b4d","0x92c0","0xfd6d","0xcbc9","0xffe3","0xbee4","0x6e3","0x540f","0xe91d","0x4612","0xfb7f","0x4b3","0x0dca","0x5e71","0x2","0xfc2e","0x911e","0x6fdd","0x2b39","0xc1da","0x171c","0xdf1e","0x10f2","0x213d","0x09f1","0x3f7","0x26","0xf1e3","0x210","0x2d7","0xbedb","0xe250","0x52de","0xe12e","0x1d42","0x14d4","0xfe1d","0x730","0xc01e","0xe00f","0xb211","0xd00f","0x210f","0x11c0","0x2d0d","0x1010","0x4f23","0x312f","0x9510","0x7e6f","0x2f6e","0xca01","0x7e4b","0x2323","0x2d4d","0x2a7","0xa1a3","0x43fd","0x0dd3","0xeded","0x3f10","0xcb35","0x2dd0","0xe2e2","0xfe6c","0x239b","0xa3c2","0x6022","0xd3b7","0x4040","0x1634","0xf0e3","0xc164","0x604a","0x395c","0x9140","0x6ebd","0xce0e","0xf999","0xc41f","0x5220","0xfdec","0xbb00","0x13cf","0xb21d","0x3ffe","0xf419","0x5206","0xf25e","0x3e00","0xab4f","0xe115","0x1e14","0xf7de","0xebcf","0xd30e","0x2130","0xdea9","0xa1ae","0xa405","0xcf0b","0x74d6","0xb36f","0x1b00","0xc659","0xec01","0x2f02","0x0c02","0x325","0x9cf2","0xf9e6","0xcade","0xfde2","0x1f3c","0x594","0xf1ef","0x2677","0xd314","0x147d","0x3d1e","0x9ffb","0xd1e0","0xfd2d","0x7d0e","0x4e4d","0xd95e","0x4bd","0xf39e","0xb1b3","0xee2b","0xf401","0xe300","0xeff9","0xeac4","0x4e31","0xb111","0xf231","0x13cd","0xe0f0","0x30f","0x132b","0x9b2e","0x47f","0x0ee4","0x99fc","0xd441","0xcd01","0x0f11","0x4cdc","0xc65e","0xd043","0xa2fc","0x1fac","0x493","0xfc7c","0xf7d5","0x2fd","0x4927","0x7b2c","0x9ffe","0xd1b9","0x2ecd","0xcd06","0x112f","0x4909","0x222f","0xf036","0x0d","0x119","0x5cb3","0x241d","0xb2f2","0x94ed","0x99ff","0xec02","0x1f34","0x2a17","0x70d","0xb600","0xb3fe","0x5fe6","0x1f5f","0x54e1","0x1661","0x771e","0x36a2","0xae2f","0x4730","0x1b0","0x32d5","0x9e40","0x43d3","0x24d5","0xf219","0x24cd","0xb39d","0xc4d7","0xf4fe","0x674c","0x4d5f","0x3f0e","0xf0e4","0xf14f","0x3471","0x2e17","0x2301","0x9d72","0x30cb","0x0d05","0x105d","0x193f","0x22b2","0x161f","0x2e9","0x473f","0xcb73","0x731c","0x19f0","0xd3ec","0x36b1","0xf924","0x1e0e","0x1054","0x7dd0","0x2fe6","0x2b12","0x2932","0xc11b","0xc90e","0x5e1c","0x5c02","0xd6c7","0x2f1","0x61d2","0x1535","0x0edf","0xdda4","0x0903","0x2d70","0x2c2a","0x5734","0x95b0","0xc2cc","0x415f","0x1ed2","0x0fef","0x2333","0xf217","0xf076","0x3602","0x32fc","0xc7d3","0xc46d","0x1f3d","0xd23c","0x60c","0x9ac2","0x502e","0x90a2","0xd00f","0xe47e","0x30d6","0x147c","0x0e0a","0x7dc0","0xdedd","0x222e","0x61e2","0x4ff1","0x34fe","0xc232","0xdb25","0xe111","0x339","0x0f1c","0xee30","0x93ca","0x7dc3","0x7210","0xa03e","0xdfe7","0xf2dc","0x4d3f","0x2425","0xbfd9","0xec4d","0x1411","0xff02","0x2db0","0x7cc","0xa29b","0x0f23","0x7f00","0x2f4","0xc05c","0xb47b","0xb5cf","0xe0bc","0x2253","0xbc01","0xbfcd","0xf21b","0x5add","0x2a0f","0xcad2","0x2cd3","0x11b","0xfb1c","0xd52c","0xd1ad","0x9ee7","0x9f0b","0x3f29","0xd0b3","0xd03d","0xeddb","0xb2e6","0x1111","0x6fc0","0x0cb2","0xd323","0x7170","0x0b53","0x0e10","0x2dfe","0x6d12","0x6933","0xadfd","0xc223","0xdeee","0x0fc1","0x3211","0xd2f2","0x0d15","0xcc31","0x4dfc","0x9424","0x241f","0xa320","0x365e","0xc5ef","0x3c3e","0x323a","0xfd03","0xf953","0x620d","0x2430","0x5ef","0x96d4","0x2b3b","0xac24","0xb6ac","0xe3f6","0xff29","0x321f","0x4c15","0xcfd3","0xdf6d","0xea2c","0xea22","0x2a6c","0x4bd0","0x27ef","0xb5ff","0xeec2","0xb0d2","0x192d","0xe2af","0xddbe","0x1b7","0x0f31","0x5dce","0x0dfe","0xb733","0xb14d","0xf19f","0xc0d1","0xe9ee","0x711b","0x13fd","0x5c10","0xfcd2","0xfe33","0x1d12","0x1f14","0xcfdd","0x5e33","0x2ff","0x20d3","0x3ad1","0x402","0x1de4","0xaec4","0xfd91","0x130c","0xf710","0xf20e","0x24f2","0xee3e","0x31c1","0x0c01","0x3f10","0xa3c5","0x1fd2","0x2301","0xb3ed","0x51a1","0xeb62","0x1ff","0xf121","0x93e2","0x26a1","0xcfc1","0x11b1","0x1f30","0x3001","0x61fc","0xb4e3","0x7e1","0xf01f","0xffcf","0x147e","0xc4e5","0x5e1","0x304e","0xbf13","0xf12b","0x14e3","0x452d","0x25ca","0x20e3","0x2c03","0x0c49","0x9db1","0xfd33","0x90ad","0xce95","0x1c31","0xf3d0","0x16c7","0x9ee0","0xe9eb","0x3e21","0x9a9c","0x3b0c","0x30f","0xde1d","0xca21","0xef2d","0xd0df","0x24fe","0x4f2e","0xb411","0xe00c","0x1ccf","0xefcf","0xf237","0x7d01","0x62fc","0x350f","0x7f30","0x3153","0x0e40","0xe09d","0xd0e1","0xcde7","0x7b2f","0x53ef","0x135d","0x3120","0xf11e","0x239","0xffc4","0xf202","0x5034","0xe213","0xf0f2","0x1b01","0x7401","0xecdf","0xec5f","0xf247","0x4c0b","0x7fed","0xc7b4","0xde3b","0xf270","0xd22d","0x13a5","0x253c","0x4074","0x0d32","0x1dde","0x490f","0x095e","0xbe6f","0xaf9c","0x1123","0x19eb","0x0fea","0x340f","0x0e4e","0x4e35","0x1fa0","0xf6b1","0x2c15","0x2d43","0x5e42","0xc03c","0x1005","0xb9fe","0x4301","0x3405","0x9102","0xeb5c","0xeea0","0xd61d","0x3e43","0x4041","0x21","0x0d41","0xe09d","0x1d4e","0x24be","0xf921","0xcc0b","0xf253","0x3ef","0x99ec","0x502f","0x0dcc","0x3c1d","0x3951","0x0e1b","0xfa41","0xe42d","0x9f43","0xf4ee","0xd033","0x17c1","0xe4ea","0xedfd","0xed53","0xa3ef","0x530e","0x3f0c","0x9ea0","0x0b07","0x0c69","0x4ace","0x0c0c","0xe419","0x3734","0x32f","0x6bc0","0x3502","0xf1db","0x990e","0xd2b3","0x51ed","0x91f0","0x7cf0","0x4e","0x2ddf","0xeb22","0xc2c4","0xf91e","0xa0c1","0xc343","0x1e12","0xff13","0x20b3","0x1ded","0x2b16","0xc065","0xf4c0","0x777f","0x92be","0xacba","0x4d0c","0xfcb9","0x1fe0","0xe326","0x4d10","0x3c6f","0xde01","0x2b4d","0x2052","0xfeb3","0x0c5b","0xe252","0x241e","0xd910","0x5a2c","0x3f44","0x22c0","0xed30","0xec19","0x15c","0x915e","0xffc4","0x6","0xf2d1","0x0f92","0x916e","0xc90d","0xf21e","0xef32","0x9b7c","0x614d","0xfbee","0xa643","0xbc3c","0x490b","0x6bd3","0xe4f2","0x5027","0x510f","0xded3","0xec49","0x0a0","0x1ea1","0xccde","0x1e1f","0xd21d","0x1ed","0x2b23","0xe102","0xdb07","0x5c9b","0x3eec","0x1b5d","0x3df3","0xf72b","0xc501","0x39c9","0x131c","0x0a6d","0xf1ce","0x50fa","0x34f","0xee31","0x0e5f","0xce9b","0x2017","0xfdbf","0x2e2d","0x147d","0x5391","0x2e0b","0x330f","0x59cd","0x9c4e","0x3203","0xb4ef","0xf102","0xf365","0x19d9","0xd010","0x2ad0","0xa1e0","0x3011","0xbf72","0x0c20","0x227c","0xe3d0","0x0c29","0x2730","0x4202","0x0c13","0xc253","0xc10f","0x3350","0x1b5d","0x10b0","0xbe12","0x132","0x5df3","0xd472","0xec22","0x1f7d","0x40f","0x6d20","0xd33f","0x1311","0xd3d9","0x21c1","0xc4df","0xfc01","0x5d34","0x6630","0x1423","0x3ddc","0xd24d","0x1579","0xff0e","0xe040","0x40d9","0xb9dd","0xadbc","0xb32c","0x494d","0x3d05","0x0ff","0x171e","0x11df","0x40f","0x40fb","0x1312","0xff11","0xf3e1","0xef0d","0x51c5","0xfce2","0x4200","0xfce3","0x401b","0x1bba","0xfd25","0x4ad2","0xf4ed","0x1012","0xeabc","0x14e1","0xea20","0x1c22","0xc2ef","0xde1a","0xed2f","0xdbab","0x3c12","0xece6","0x0cec","0x0fd","0x3e23","0x2af2","0x0d3c","0x3640","0xb9c2","0xe2e2","0x0b24","0x4013","0xbf11","0xde9e","0xe002","0x26b3","0x3100","0x1c1c","0x4c0a","0xdd22","0xdf4b","0x1d13"},
{"0x2fce","0xdc00","0x2ce0","0x111","0xde0a","0xfa00","0xf0e3","0x21b","0x1101","0xd003","0xfff4","0xff21","0x201c","0xb9e1","0x1e20","0x3efe","0xe2a9","0x0d03","0x0924","0xe1f7","0x4a3d","0x2cd2","0xeba1","0x2bf9","0xb760","0x11e2","0xf1df","0x20ef","0xffe9","0x910e","0x4af1","0xee11","0x50fd","0xe203","0xfc50","0x1321","0x091b","0x4100","0xdf3e","0xf1fa","0xf220","0x1302","0x20f0","0x4213","0xafce","0xe9fd","0xfff1","0xeef1","0x60fe","0x90cc","0x241a","0xcc52","0xf211","0xede0","0xfdf4","0x7f6f","0xf02e","0x1aff","0x12d1","0x1b9a","0xfefe","0xdec0","0x4d1e","0x0cfb","0x2102","0xd1f3","0xd1fa","0x0f12","0x1443","0x4ecf","0xe150","0x7df4","0xfc05","0x0e31","0x3d04","0x0eed","0xffec","0x2f42","0x1cf0","0x33df","0x1124","0xbe1f","0xee2c","0xe20f","0x123e","0x4203","0x0d60","0xefc0","0xf4f3","0x9eec","0x0e1d","0xcb0e","0x0c5d","0xfe23","0xefdd","0x33ed","0x0e0f","0xff07","0x3bee","0x3d0","0x111a","0x9fe1","0xf2d1","0x3d","0xe0d7","0xc411","0xf311","0xdcfe","0x310f","0x101e","0x219d","0xefd3","0x110f","0xffbe","0x30ff","0x4def","0xf11d","0xfce5","0x31ae","0x1e1f","0x43ff","0x2ecf","0xf050","0xce2f","0x21b4","0xdfe0","0xcdef","0xb4af","0xef2d","0xeff1","0x3e11","0x2e00","0xf0d0","0xe00e","0x7b91","0xf22b","0x12da","0x0cca","0xee1e","0x1ffd","0xcf02","0x22ee","0xce0a","0xd203","0x0e","0xb1ce","0x49ec","0x2ef","0x92ee","0xe9e4","0x2004","0xc1bf","0xfed2","0x1e20","0x1cfd","0xe121","0xfff0","0xde01","0xa1f3","0x0f21","0x2cdd","0x103e","0xeb41","0xfd11","0xfe20","0xefae","0xd102","0x1a1d","0x102","0xde01","0x2f0f","0x11ed","0x2ddd","0xf115","0xe22e","0xc15d","0xffd0","0xf1fd","0xf02e","0x20df","0xf347","0xe0eb","0x3041","0x0a1f","0x9f06","0xd34b","0xdcb2","0x1302","0x41de","0xf120","0xb0b0","0xd12d","0x131","0xf4b5","0x433d","0xc11c","0xc9f2","0x0e1e","0xe331","0xce23","0xe319","0x2dcb","0xdd26","0x91df","0xb21d","0x2df4","0xee4f","0x4ee3","0x1b21","0x3ffd","0x1d52","0x4109","0x0c37","0x50fb","0xcfcd","0xdf20","0x2e41","0x1b0e","0x7fd2","0x23d5","0x2520","0x6c1","0x955f","0x3001","0x9d01","0x300f","0xde21","0x32f","0xc1e3","0xeffd","0xb9b4","0x3100","0xef0e","0x13","0x4a07","0xf300","0x2e3f","0x150","0xea1d","0x0f61","0xf320","0xed1b","0x2f2b","0xff0f","0xd0f9","0xe121","0x0d3","0x19b","0x4fe0","0x2fc3","0x22a3","0xc2df","0xdf0f","0xed03","0xdc63","0xfdf3","0xa00d","0x2bc1","0xfe2d","0x2e42","0xeddd","0xe44f","0xa2d0","0xd1d9","0xbc22","0x30a2","0xf24e","0xec00","0x2330","0x2c50","0x0d0e","0xbdfe","0x10c","0x3ff4","0xeb04","0xeff3","0x150f","0xfe3c","0x611e","0xf23a","0x20fe","0x11e","0x45ff","0x13d2","0x1fc2","0x1e1e","0xc04f","0xe1e0","0x4013","0xb25d","0x9c2c","0x1f32","0x0bcd","0xf02c","0x35f","0x0b2","0xf461","0x362c","0xbf44","0xedf1","0x4ed","0x31ee","0x9fc1","0xedc0","0x4e13","0xe0aa","0xdb2d","0xd0eb","0x1dee","0x0f20","0xf670","0x70f9","0xc062","0x1e1d","0xed2f","0xeefd","0xa0de","0x25df","0xc341","0xe19d","0xd1f4","0xd003","0x9002","0xb63f","0xed0d","0xd01f","0xff4c","0x620c","0xf10c","0xfd53","0xefee","0x3c13","0x9e15","0xf5cd","0xd031","0x092","0xf1e0","0x3055","0x2ddb","0xef2f","0x2522","0xcc20","0xe000","0x7f0","0x0efd","0xfcd3","0x3ded","0x0f4b","0xd40d","0xf9fe","0x2e3e","0xe1c2","0x213e","0x0f19","0xfd2a","0xb3e3","0xfde5","0xcbde","0xc2bf","0x1db2","0x1d02","0xebf0","0x392e","0x4ee2","0xefed","0x1dbb","0xe92c","0xa1fd","0x223d","0x2feb","0x4c2b","0xb4dd","0x1f0","0x1d0e","0xeedf","0xd0b6","0x3f2d","0x0db1","0xb120","0x4021","0x20af","0x0f3d","0x12f","0xb15d","0x4423","0x2069","0x1f0b","0xec9e","0x330b","0xf7f1","0xf0fe","0x92c0","0x121","0xe000","0x2ee","0xa7d6","0xf3a1","0xe104","0x434f","0x91da","0x1f1b","0xe972","0xfd13","0xf2ce","0x402f","0x35dd","0xdb33","0xd202","0xb515","0x47d3","0x1300","0xd41d","0x2bb4","0xed12","0x3b3d","0xd0f0","0xfe32","0x1b14","0xcff0","0x10dd","0xfd49","0x9e1d","0xd904","0x2d0c","0xafef","0x3efe","0x2dff","0x5cfe","0xbeef","0x2dcd","0x2d4","0x0b25","0xdecf","0x59d","0x2035","0x601f","0xe130","0x0d50","0x4fd1","0x960f","0xb2d4","0x1e51","0xa01c","0x59d6","0x9be0","0xf261","0x3e20","0xde11","0xc12f","0xf2fd","0xfe20","0x2201","0x0f5f","0xf0fe","0x0ce","0xe29c","0x2de","0x372e","0x2f62","0x4eef","0x0fcf","0xfd12","0x3142","0xcfef","0x0e4d","0xe2f9","0xe0dd","0xafc1","0x19b1","0xa1fd","0xcb90","0xefdf","0x33de","0x515f","0xeca5","0xceb6","0xe012","0xff00","0xf220","0xf1e5","0x1220","0x0fb0","0x7071","0xf22f","0x4f41","0xfe5e","0xd434","0xa0ff","0x41fc","0xe256","0x1490","0xfe3d","0x4112","0xfeee","0xb151","0x0d2c","0xce62","0xe40f","0x6b52","0xee21","0x5b3f","0xf030","0xa5d0","0xaedf","0x1034","0xb743","0x41d2","0x2f7c","0xcb33","0xceef","0xc6e1","0xf12d","0xcf77","0x0f01","0x0a10","0x202c","0x794f","0xd06f","0xff31","0xdb71","0xed31","0xbf4a","0xfdd0","0xff7e","0x9140","0x6f1","0xd3da","0x5dd","0xf14f","0xa0af","0x090c","0x45d","0x131b","0xe9b4","0x71b3","0x33fd","0x9c4f","0xe7fe","0x12d7","0xf911","0x9111","0xf919","0x2cc1","0x3f10","0xffa2","0xc3c0","0x1d23","0xee7c","0x2fcf","0xb195","0x9110","0x4e22","0x24b9","0xc630","0x242f","0xcccd","0xf1b0","0x67e4","0x0b0b","0xdbbe","0xd0b5","0x2e1f","0xb3ec","0x200f","0x0d5d","0xdacd","0x1f60","0x6ea0","0x5dea","0xe13d","0xe72b","0x4200","0xbdde","0xd712","0x1f31","0x2192","0x51ee","0x0cf1","0x203","0x09a","0xfdfc","0xf3e0","0xa11f","0x2441","0x203","0x2de0","0x13","0x33fe","0x1d03","0x150d","0x0f","0x1ee","0xbde3","0x4f1f","0xfb01","0x15d4","0x2931","0x0f3e","0xda30","0xa202","0xc23f","0x3bf2","0xc322","0xdfee","0x1e2","0x1d05","0x1ff","0xfde0","0xe20d","0x2e1","0x1901","0xdf0e","0xc199","0x30","0xe4f2","0x302c","0xfd21","0x1fc3","0x0c20","0x4321","0x92ee","0x39ff","0x2f15","0xdfec","0xed41","0x341f","0x1b7e","0xe2db","0x910c","0x200f","0x7be5","0x301f","0x0d13","0x57bc","0x2ef0","0xe0de","0xbdfd","0x5931","0xaf7f","0x1d00","0xbc60","0x5100","0xccbd","0xc319","0xb33c","0xecb5","0xf120","0x6f5f","0x49e3","0xe7bd","0x3e7f","0x2002","0x93ee","0x744e","0xddc0","0xcb2e","0xf23e","0x3f5c","0x1c2e","0xe30c","0xfc3d","0xde3d","0xee41","0xcfed","0xfce0","0xdf0f","0x24e1","0x36c5","0x9225","0x3343","0xcebb","0x1c50","0xf05a","0x35fd","0x390c","0xbf11","0x39a4","0x19fd","0xafa5","0x5fe2","0xd4c7","0xb9c3","0x9d3b","0x2de1","0x100c","0x3f1f","0xcd4f","0x21ed","0x1120","0xd30c","0x0b2f","0x0acc","0xa224","0xcff0","0xb111","0x7be1","0x6","0xc9a0","0xea0e","0x33b0","0x40ac","0x3264","0x2c11","0xef4f","0x1214","0xf4dc","0xebe9","0x1200","0x157e","0xbfef","0xba0a","0x19dd","0xfe2d","0x1909","0x14c7","0x4f51","0x4e3b","0x2130","0x9edf","0x2f1b","0x2fb0","0x9f04","0xcdde","0xef0c","0x3e11","0x1117","0x6492","0x3cfd","0xf06a","0xe0ea","0xa4e2","0x30e","0xb00f","0x21e9","0x204","0x1d1c","0x2ff5","0xf566","0xc9ef","0xb220","0x0f2a","0xd75b","0xf1d0","0x0c5f","0xee1f","0x2212","0xc15f","0xe03e","0xdd9e","0x50ed","0x2e5f","0x3bf2","0x1227","0x95bd","0x1e7f","0xfddf","0x4f75","0x9ce9","0xde2c","0x3f3f","0x6ee1","0x3e12","0x42cd","0x2acf","0x2e20","0xd0f1","0xb41e","0x2122","0xe033","0x31e1","0x3aed","0xd1c1","0x11f0","0xfe00","0xe2fd","0x0c0c","0xd411","0x0ff0","0xfd1e","0xfd01","0xf2ff","0x2dff","0xfd00","0x251f","0x333e","0xef0c","0x5f14","0x6e59","0xa041","0x44dc","0x09ff","0xfc09","0x21f4","0x2000","0x2eb1","0x2301","0xc2e2","0x1c01","0x0c3f","0xf1f1","0x41ea","0x2c52","0xe212","0x0e0e","0xe4b0","0x130f","0xed14","0x1a","0xb30f","0xf03f","0x3b20","0xcdcf","0xa232","0xff2f","0x3e13","0xf110","0xfedd","0x2303","0x1c0d","0x2edf","0x1ef1","0xf20d","0xc1f0","0xff42","0xd04d","0xfc11","0x2fe0","0xf020","0x2efe","0xec01","0x2ef1","0x1e","0x5f1e","0xeff4","0x0b1f","0x0cf3","0xbfca","0xfcf0","0x5e","0xdcd5","0xb135","0x0f","0x0cd0","0x0af2","0xe0d6","0xfd11","0xb4f2","0x313f","0xaa1b","0x3e20","0x3f31","0x3c20","0x34c1","0x4f2c","0xfe2f","0x90f3","0x9af4","0xd71c","0x1e00","0xc02f","0x3c1e","0xfb6f","0xee9e","0xcf2e","0x7efc","0xafc4","0xf041","0x0f3e","0x74f","0x2922","0x74d9","0xc009","0x0c16","0xe470","0xa0bd","0xd2e4","0xd003","0x3c1a","0x0c1c","0xeec0","0xdde3","0xff02","0xbf12","0xa63e","0x2402","0xbdf2","0x270f","0x1919","0x29b9","0x32d3","0x95fe","0x1f11","0x0ad3","0x64df","0xfbf5","0x9cae","0xdf9e","0xf024","0x21f4","0xa01f","0x923f","0x2a26","0x4540","0x6ab9","0x220d","0x2515","0xb35c","0x0ef2","0xe403","0x2dcd","0x0fe3","0x491","0xe226","0x10f4","0x1f1f","0xe10d","0xc42a","0x0e00","0xdf20","0xd20e","0xc230","0xdc1e","0xff20","0xc3be","0x1b10","0xd102","0x0b01","0x2b17","0x0c11","0xcc4c","0x2b43","0xff00","0xcb0f","0x1d31","0x721c","0xc2ed","0x0eff","0x7df9","0x34b2","0xa2d1","0xa0f1","0x0af2","0x9e4e","0xd020","0xa2e3","0xf91d","0x3f2e","0x100e","0xa000","0xfa0e","0xf0fe","0xf4f0","0x2c4c","0x4efc","0x0a10","0x2ee5","0x105","0x723c","0xd00f","0xeed7","0x1b00","0xcc5b","0xfbfd","0x9aff","0xc42a","0xf9bd","0x6fca","0x5249","0x7037","0x13e1","0xa029","0x0f03","0x1c7","0x107","0xae11","0x1efd","0x31c9","0x2b10","0xf0a0","0x0bd1","0xaee6","0x0fe1","0x5161","0x7b09","0x3b4c","0x2606","0xce1b","0x0abf","0xcf5d","0x4431","0x700","0xf00b","0x201e","0xdc06","0xfe60","0x10f4","0xc16c","0xef32","0xf774","0xee29","0x311c","0x6c3e","0xb330","0x3bcb","0xe06f","0x10d1","0xc1a0","0xe0a2","0xe010","0x50cf","0x1b2f","0x2e1d","0xf93f","0x401c","0x4f02","0xdcfb","0xf60c","0xfec3","0xd10f","0x0cc0","0x4041","0x3f21","0xfe3f","0x10fb","0xe316","0xe0f0","0x30e2","0x105e","0x401e","0x1b23","0xffef","0x3ce","0x1a33","0xf3c1","0xb5df","0x15c1","0xd0cf","0xfb21","0xa6ee","0xcdef","0xe101","0x0b25","0xfe40","0xc936","0x47fc","0xce01","0xc01e","0x7ff0","0x1dde","0x21c","0xf15b","0x1031","0x25f","0xfe31","0x21f4","0xcfce","0xf251","0xf3f9","0x0ecc","0xd011","0xe711","0x19ae","0x19f2","0x122e","0x2df7","0xffcd","0xef3f","0xefc0","0xd4fa","0xe0fe","0xf3fc","0x0d3f","0x2d34","0x23c0","0x0f01","0x1950","0x37f7","0xf1c1","0xcc6f","0x71ec","0xf2ba","0xf39c","0x3304","0xdd9a","0xd3fd","0x127c","0x2a41","0xfb10","0x1335","0x2db1","0xe41e","0x4b22","0x945c","0xb2b0","0xfd15","0x7a9a","0x3efb","0x2bba","0x0d20","0x3c90","0xc20f","0x159","0x0cee","0x2df","0x0e6d","0xaf0e","0x3e4c","0x2c2f","0xd9cc","0xe9dd","0x3dd4","0xb2f2","0xad07","0x3edf","0xe1ea","0x9f1d","0xb222","0x1cc6","0xaf32","0x32ff","0x3119","0xe151","0xfe1e","0xa02f","0x52fa","0x9012","0x70d2","0xf1c3","0x9e07","0x952d","0xd1d3","0xdeff","0xbf09","0xfb11","0xb911","0xe101","0xfef0","0x12f0","0xb02e","0xe20f","0x5bd1","0x943d","0xf253","0xec50","0xc12d","0xe4d6","0xb020","0x3c5e","0xe0bd","0x0c","0x2401","0xd19c","0x2db4","0xbff7","0x6152","0x2ee2","0xee13","0xa47d","0xba3d","0x2d11","0x309","0x3f6a","0x7124","0xef6b","0x5923","0x092","0xd2c2","0xc023","0x3dd3","0xf1c9","0xd0dc","0x1df","0xd24f","0x134e","0x211b","0x1120","0x1113","0xcbfc","0x2003","0xdd1e","0x9dfe","0xf0a2","0x0933","0xff13","0xcce0","0x20cb","0x94c4","0xe303","0x2640","0xf33f","0xffe9","0x3a2c","0x3300","0xdf0f","0x421","0x5e10","0xac0c","0x401c","0xef1c","0xf2ed","0x16d0","0xcf02","0x5fcf","0x151e","0xb0d6","0xbccf","0xe1e7","0x6e76","0xf01c","0x9201","0xafc9","0xd90f","0x10cd","0x1302","0xf3ce","0xfeee","0x210f","0xe3bf","0x591c","0xaddc","0xfff4","0xdedb","0x9ef0","0x4ee1","0xa31d","0xaed9","0xd910","0xe9fd","0x122d","0x2dc3","0x9ec4","0xd20f","0xe001","0x16a0","0xfddd","0x121f","0xc4ce","0x3eeb","0xf214","0x3eff","0x2ff","0xe2ee","0x2e17","0x1e10","0x33d2","0x5f1f","0x0b03","0x111f","0x66b3","0x30d2","0x45b1","0x32ff","0x0e2f","0x3203","0xd5e0","0x6d2f","0x4f2a","0xf110","0x0e54","0x133f","0xec01","0x3de3","0x6020","0x1312","0x1412","0x2e1","0x1223","0x41c","0xb923","0x501f","0xc029","0x0ef1","0xf5ba","0xeef4","0x2411","0xce7d","0x500c","0x13ef","0xdb1e","0x2031","0xee00","0x311","0xa702","0x32eb","0xe9f1","0x3f1","0xad30","0xf014","0x292","0xfb12","0x4e05","0xa073","0xe3d0","0xff11","0x0b01","0x2f5b","0xe004","0xe11e","0xecf0","0xd6b0","0x3500","0x0c0d","0xbe11","0xf332","0x3015","0x3f21","0x102","0x223f","0x2d51","0xdb00","0xef32","0xf02f","0x4ecb","0xb222","0x5eec","0xe02e","0x1b3f","0x1900","0x2c22","0x9232","0x1a23","0x17d3","0xbf24","0xf0df","0x22d","0x422c","0xb161","0xb0d4","0xfd59","0x0c1","0xebdf","0xaf46","0x31fb","0x1af4","0x0ee4","0x9e2f","0xeb10","0x1707","0x6b40","0x205f","0xcfc3","0x3e02","0x3ff1","0xf4f3","0x23f4","0x31fc","0xe5dd","0x4a1","0x1b36","0xf4ff","0xf9e3","0xb1d6","0x1fe7","0x0bbf","0xd0ee","0xf131","0xd22f","0x25f0","0xac50","0xff11","0xcf51","0x1f1d","0x1102","0xaf22","0x3c50","0xf41e","0xdf03","0xd2d5","0xd3fa","0xe111","0xf030","0xc3d0","0x3fa0","0xff09","0x327f","0x3bf1","0x3e15","0x4f61","0xe0e0","0xf4f1","0xd93d","0x12fd","0x2de0","0xe207","0xefe3","0x6fb2","0xf12b","0x92ef","0x0ed3","0xced1","0xe403","0x1fe","0x134c","0xb51f","0xcefd","0xe03a","0xeb52","0x39fe","0x35d6","0x259e","0x7537","0x1ebc","0xeb42","0x2929","0xe107","0x21c1","0xcd20","0x70ef","0x11ee","0xb0fd","0x1b20","0x0d4c","0xce62","0xea92","0xf0d1","0xc12c","0x6253","0x25d2","0xc40c","0x29af","0x7254","0x1e5d","0x1fee","0x0de0","0x23ff","0xc2ec","0xfbf0","0x7022","0xd214","0xdec0","0x6107","0x4f","0x13f2","0x0c0b","0xf1de","0x3cae","0x9d3c","0x2e33","0xcf4b","0xcf23","0xd43f","0xff5d","0x5121","0x1d9a","0xbffc","0x30df","0x9b34","0xd0fb","0xff7c","0xeee0","0x1cc0","0xf702","0xbad0","0xeec3","0xef31","0xa3ff","0xd030","0x1c6c","0x1ad0","0x9eef","0x21ee","0x0f1","0xae74","0xb000","0x1cbc","0x13e","0x41ee","0x1714","0xbe30","0x2673","0x4e26","0xbf0b","0x655d","0x4b61","0x0f03","0xe1db","0x59ac","0x903b","0x957a","0x34ef","0x0f00","0xb1ea","0x13ce","0x0bcc","0xdffd","0xadf2","0x0e01","0x09e4","0x9000","0x23","0x3403","0x43c1","0x45ff","0xf253","0xfebf","0xaf2f","0x3f27","0xe933","0x2d15","0x490f","0xe30d","0x0a49","0xd963","0xdd33","0x75fb","0xd44d","0x3a0c","0x65ad","0xee3a","0xf9f6","0x0cce","0xca9d","0x0e0","0x70d1","0xf90f","0x2037","0xf9d5","0xd9fe","0x0b3f","0xfd03","0x705b","0x57eb","0xf9ab","0xa1c0","0xc1f9","0x3d21","0xecef","0x549e","0xcffe","0xd7d7","0x7052","0x2f37","0xc92e","0x21f3","0x1f25","0x2f70"}
}
};
const ap_int<12> conv_6_inc_new[2][32]=
{{"0x2e8","0x263","0x1a1","0x3c2","0x329","0x2cf","0x36c","0x279","0x4ff","0x2d1","0x247","0x1d8","0x3dc","0x3f6","0x323","0x2c8","0x230","0x2d8","0x3bd","0x276","0x291","0x32b","0x20f","0x23f","0x1c4","0x194","0x2d7","0x23a","0x22a","0x244","0x410","0x1f6"},
{"0x2db","0x246","0x2c8","0x31b","0x200","0x22b","0x2ae","0x610","0x281","0x3e4","0x389","0x201","0x30c","0x2c1","0x2d3","0x1c3","0x2ea","0x225","0x195","0x243","0x1b2","0x25c","0x1e5","0x163","0x2c2","0x375","0x215","0x272","0x255","0x29e","0x36e","0x323"}
};
const ap_int<20> conv_6_bias_new[2][32]=
{{"0x2546b","0x2140a","0x7bf3","0x37958","0x27129","0x487ea","0x17018","0x2ff60","0x3927b","0x1ab88","-0x3fb5","0x1b25d","0x0df2b","0x3da5","0x1c49b","0x0809e","0x1a05d","-0x88ab","0x35a43","0x275bb","0x2d3ff","0x30821","0x15812","0x297d7","0x2e621","0x1d7f9","0x1dfc5","0x2f19e","0x125e3","0x2caf4","0x2637","0x08c4"},
{"0x42a93","0x23e95","0x2a183","-0x2188","0x21fea","0x29606","0x55c9e","0x6c87b","0x19304","-0x1708b","0x4f38","0x215d","0x31285","-0x11da6","0x17bbe","0x1cd61","0x1646e","0x1cb24","0x289e6","0x30401","-0x879a","0x0f8aa","0x28899","0x35e20","0x30efb","0x266eb","-0xab95","0x2710d","0x1d203","0x0e307","0x13337","0x142cd"}
};
const ap_uint<16>conv_7_w_new[2][3][1536]=
{{{"0xfed9","0x67e","0xbf1f","0x53bf","0x3c29","0xc02c","0x1d5c","0xf013","0x0f12","0x1de4","0x616c","0x4e01","0xc903","0x11ef","0x306","0x9b2d","0x4da9","0x2ec1","0x9e03","0x9f12","0xed29","0x0e90","0xc0e3","0x99f3","0x0e4f","0xd315","0x7150","0x6126","0xec02","0x2de5","0xdfe7","0x927d","0x1fcd","0xfcc0","0x9fe5","0x9109","0x33e4","0xedcc","0x101","0xe0fb","0xeee4","0x12","0x252","0x2003","0x2c03","0xf915","0xa9e3","0xd459","0x3f0c","0x3fe","0x1110","0xe020","0xf0e0","0xee00","0xe21e","0xeed0","0xe010","0xf1df","0x0ef0","0x301f","0xe1fe","0x0f0","0x4ff3","0x0f0","0x31ed","0x3420","0x0e0","0xde0f","0x1011","0xb0d1","0xc02e","0xcffe","0x2101","0x30df","0xdde0","0x2221","0x1efe","0x2002","0xfee4","0x0d11","0xf023","0xf602","0x21ed","0xdd1e","0x0f3f","0x50d0","0x33f2","0x2121","0x3120","0x2ffc","0x0c00","0xef2f","0x3fe2","0x310","0xedf3","0x2cf0","0x1021","0x0a1e","0xf540","0x100e","0xf0bf","0x70e1","0x3efe","0x0fe0","0x2e10","0xfd00","0x1f","0xf10f","0xb1d0","0xff01","0x21f","0xff20","0x3efd","0x3e0f","0x1e1d","0x0fd0","0xe153","0x9e1e","0xcc0c","0xc1c4","0xf201","0x13df","0x44ef","0x32d4","0xaede","0x3ef0","0x100f","0xf2e2","0x1012","0x74f","0x11f9","0x11","0x0df","0x631f","0x61f2","0x1142","0x22fe","0xfd0b","0x0e01","0x11c","0x10ee","0x605","0x2ffd","0xfc20","0xe0f9","0x132f","0x293e","0xb43c","0x2af2","0x3eee","0xe3c1","0xf23c","0x5cc","0x0c53","0x33bf","0x4c0c","0x11e3","0xf404","0xb412","0x9323","0x1e99","0xb3ff","0x09a1","0xd309","0xfcd7","0x2be1","0xe31f","0xe11b","0xc2de","0x119","0x33ec","0xfa1e","0x39ad","0xefe4","0x293b","0x999d","0x714f","0x110d","0x2de","0x741c","0x1c17","0x2d34","0xe000","0x320","0x2f32","0x0d5a","0x3efd","0xffd6","0x09fe","0xf6e2","0x3c1b","0xeb96","0xf0f0","0xfe12","0x0f01","0xd121","0x0f","0xe7f0","0x90ef","0x1da3","0x1f0","0xb9f2","0xf0ee","0x0e2c","0xe924","0xbe3f","0x0e","0x0ff0","0xe17d","0xd014","0x4e22","0x9112","0xfe1f","0xf7e1","0xa06d","0xef92","0xd0e2","0xf9b9","0xc20f","0x1e12","0xab12","0xdb79","0xd93e","0x0dbf","0xe04e","0xf1d3","0x100c","0xcf10","0x0f00","0x4f2","0xa200","0x1f92","0xe0ef","0x1ab9","0x0ef0","0xd23d","0xfb01","0xbf51","0xfb2f","0x11d0","0x20e5","0xe00b","0xf2fc","0xc111","0xdedd","0xffef","0xbcf0","0x12a0","0xef10","0x4e0","0xcffe","0x92e1","0xfeec","0x1ecd","0xf33f","0x6f2c","0x3047","0xf7e1","0xfeeb","0xf0e3","0xdf4c","0x26c2","0x2e11","0x32d3","0xfe0d","0x2db9","0x0b90","0x1cdc","0xac2b","0xf611","0xfe96","0xe1ff","0xe0e2","0xc01f","0x4de6","0xcb10","0xe2ef","0x23de","0xdcdf","0x60af","0xfa11","0xf13e","0xfe41","0x2bfe","0x1e","0x130","0xebec","0xd70c","0x2f21","0x10f0","0x2e13","0x2e31","0xfd13","0x133d","0xf0e0","0x11d1","0x0e02","0xe0f0","0xc2e0","0x2f5e","0x13e","0x1f1d","0x4f","0xf212","0x2f2f","0x12dc","0x2914","0x130","0x101","0xfc1f","0xa340","0x20a0","0x5e00","0xe4fa","0xdfff","0x1c32","0x1a1d","0x2ff0","0xed44","0xeae0","0x2e10","0xf3ef","0x63","0xf011","0x0e0d","0xf1eb","0x0f2f","0x2e3","0x2f1f","0xde09","0xefde","0xf240","0x2030","0xedef","0xce01","0x19df","0xfef1","0xdf1f","0x20f","0x212d","0xfe51","0xe0ff","0x0c10","0xfe0e","0xd4ff","0x3f","0xfd5f","0xfd3f","0xeffe","0x0f0f","0x40ff","0x21e2","0x2ed","0xcee3","0x141e","0xcc32","0x3e4f","0x4f22","0xfd32","0xb10e","0xf1f0","0x12f2","0xf312","0x0d20","0x30be","0xf00e","0x2d12","0x40","0x23f","0x3161","0x213","0x5f03","0x1c3d","0x1021","0x3212","0xd2f5","0xfe02","0x1111","0xe1b2","0x2030","0x11e1","0x0d3e","0xdc11","0x3274","0xc203","0x2def","0x1101","0x32e0","0x402","0x3e0","0x0f4f","0x1170","0xe1f3","0xdb40","0x2f00","0xe2f1","0x4200","0x1f40","0x2f2d","0xfff0","0xe091","0x0cfd","0x10d0","0x2fe0","0x3f1","0x4e1f","0x9e20","0x1f71","0xd01f","0xc414","0x3e2f","0x1201","0x2f22","0xf033","0x0d4d","0x0e31","0x320","0x1cfe","0x100e","0x1de1","0x11f0","0xf02f","0xed1e","0x1130","0xff1f","0xf1f0","0x221f","0xffc3","0xfe12","0x0d3f","0xf1fe","0x1e20","0x3dc2","0x140c","0x2fe","0xc0a1","0xf2bd","0x75db","0x62af","0x3d6c","0xb209","0xfd6d","0x232","0x43a","0x1702","0xd5f3","0xed24","0xf3e1","0x6113","0x210e","0x0b65","0x0924","0xfe31","0xed3f","0xeb22","0x62d1","0x0e15","0xf1e4","0xd01f","0xe904","0x70f9","0x5f0d","0x33c","0xc7d1","0xe3fe","0x12c0","0x1fdf","0xf1d0","0xf21d","0xc0ef","0x202f","0xfedf","0xf2ff","0xf0d0","0x1120","0xf10d","0xfd11","0x2200","0xeffe","0xecf3","0x1110","0x3d01","0x0e1e","0xeff2","0xf1ef","0xe021","0xf11f","0xfe0f","0x3e1e","0x11d0","0x0","0x1ff0","0xffe0","0xf00f","0x0f2d","0xef0f","0x20de","0x10f1","0x0e2e","0xe1f0","0xe12e","0xc0ff","0xc1ed","0xef00","0xb102","0x111d","0x3103","0x20f","0x11fd","0x12f2","0xefd2","0x1fcf","0x3ef5","0x1501","0xf2ff","0xed1f","0x1dee","0x61ef","0x3301","0x1021","0x30fd","0xef3f","0x0911","0x310","0x3200","0xe614","0xeee1","0x0e1f","0x2f2f","0x0d1f","0x1f00","0xf13f","0xf200","0xfe0d","0xe0f0","0x0df","0x102e","0xf0df","0xf1f1","0xfc1e","0xc01d","0xfe0e","0x2fd","0xde2e","0xffff","0xfd13","0x2e0e","0xff41","0xf101","0xbe01","0xcd00","0x0d1","0x0f0f","0xffe2","0x1ff1","0x2c2e","0xdd1c","0x2e01","0xe00f","0x1cff","0x0f1f","0x2022","0x0fea","0x200f","0x11ef","0x2121","0x1011","0x13f1","0x1110","0x1c11","0x2df2","0x2fef","0xffef","0x101f","0xff02","0x1cf0","0x4f00","0x20df","0x0f00","0x21d2","0x330","0x1","0xf101","0xff40","0x30f2","0xee31","0x4041","0xe021","0x1eff","0x0d10","0x0e3b","0xe120","0x3e20","0x1200","0xfc1f","0x42f2","0x32f0","0x1221","0xc214","0x2051","0x21f3","0x122a","0x2f71","0x1e21","0x3d02","0xce45","0x13e","0xfb11","0x2ff0","0x0f0d","0x31","0x30be","0x1ff0","0x300c","0xd202","0x1033","0x0f0f","0x123c","0xe050","0x0e01","0x1e31","0x2d14","0x21d","0x0c10","0xf111","0x1a40","0x211d","0x13b5","0xfd7d","0xbf2b","0xbe21","0xcf04","0xe3d1","0x200c","0x1dd1","0xebef","0xcc1e","0x1fef","0x4227","0xede4","0x33fc","0xe920","0x103c","0xe3f3","0x0d7f","0x1fff","0xe07f","0xc0f3","0xf2e0","0x1132","0x742e","0xdfd3","0x9911","0x29f1","0x4b37","0xbd76","0x5201","0x3e1b","0x2ffb","0x12df","0xde4e","0xeef3","0xe2e2","0xe1e4","0x3ecc","0x1f40","0x13e0","0xa324","0x0de4","0x4530","0x2ccf","0xfb76","0xe002","0x43","0x10","0x2001","0x1ad0","0x32de","0x33f4","0x1d1f","0x0fd","0xe11f","0xd100","0x2130","0x5e72","0x1201","0xe310","0xe02f","0xdfee","0xfd12","0xe1ef","0x1120","0xeee0","0xe121","0xe301","0xbeaf","0x11ef","0x1103","0x4af","0xf0f1","0x1e6d","0x3e2e","0xfffd","0xeed1","0xf0fe","0x0d42","0xffe0","0x361","0xff1d","0xaf32","0xd30d","0xcece","0x1412","0x1ed2","0x1e9e","0x3e0f","0xfe0f","0x190d","0xdd31","0x12b0","0xe120","0x1a21","0x1ff0","0x1e","0x23f1","0xf303","0xe10e","0x0f2","0x1121","0x0aef","0x2ff0","0xd1cd","0x0e00","0x0f20","0xf01c","0xcee0","0xf26d","0x0923","0x0cee","0xf10e","0x400f","0x413","0x9fee","0xf221","0xe222","0x2519","0x3121","0xe000","0xeff2","0x130","0x1e1d","0xdaf0","0xe12f","0x2f10","0x0eed","0xf002","0x201d","0x200","0xcdef","0xd1ff","0x1020","0x0fc9","0x2f32","0xf110","0xfff2","0x312d","0xe0e1","0x2e2f","0xf121","0xcb54","0xff1f","0x2010","0x1fd0","0x20e1","0x21f5","0x2f0e","0x21d","0x2110","0xd1f1","0xd0f1","0x2050","0x21","0xf2ff","0xb020","0xdf1d","0x0921","0xf1ff","0x23","0xdff3","0xc022","0xedec","0xd1df","0x11","0x1efe","0x4ad","0xfd11","0xb04e","0x4f1d","0x2df","0xbde0","0x1e00","0xfc23","0xfec0","0x1160","0x10f","0xf114","0xdcef","0xb2ed","0x4614","0x0bd2","0xf1be","0x1e00","0xe2fc","0x2e1f","0xeff1","0x22de","0x20f7","0xa3c0","0x311","0xcfdf","0x1ec0","0x5ffe","0x6fd6","0x5f21","0x1f1a","0xef33","0x211","0xdf0c","0x23f4","0xc112","0x1f3d","0x0d30","0xe1fd","0x0cef","0x0e13","0x0ee1","0xe10f","0x9ffe","0xee1d","0x0e2","0xc001","0xe2f4","0x372f","0x2ef2","0xcee0","0x2a0d","0x22c","0xf2fe","0xe10f","0x1ce0","0x11f","0xe0e2","0x111f","0x0e","0x0f10","0x10f0","0xde0f","0xffe4","0x1201","0x10ff","0x11f0","0xfb0e","0x1120","0xe42e","0x1","0x1b11","0xf111","0x1000","0xffee","0x4100","0x4eef","0x4010","0x3f10","0x2f0f","0x1121","0xe1fe","0x1e0","0xff0f","0xf23d","0xe000","0xe11a","0x30ff","0xfc21","0x1e1","0x124f","0xb11f","0xcf0a","0xf000","0xd013","0x13df","0xf510","0xfef1","0xcffd","0x2f1f","0x1311","0x13f0","0x132","0x501","0x2100","0x220e","0x1","0x620e","0x1103","0x2040","0x0ff","0xfffe","0x0e00","0x1f1","0x20f0","0xf301","0x2e0","0x121f","0x101d","0x3d10","0x3ff3","0x7d21","0xf104","0xcf23","0x411e","0x23e5","0x71e1","0xee1d","0xdff0","0xc019","0x10e0","0x3320","0x459","0x401","0x233e","0x0c33","0xb4de","0x7509","0x141","0xb434","0x1201","0xa4e4","0x11e0","0x23d9","0x29fe","0x2bd7","0xb9f0","0x40fb","0x0e7","0x291c","0xdf1d","0x1e2f","0xe251","0x3f11","0xfef2","0xedf0","0x30f0","0xf022","0xe010","0x141","0x2f3","0x1411","0x1725","0x0e1","0x3303","0x3002","0x2eee","0x0ef1","0x11ef","0xd111","0x10c0","0x1f0f","0x0f1","0x0eff","0x1000","0x0c0e","0x1fff","0x121d","0x32e","0xfff1","0x100e","0xef21","0xf3fd","0xf3f0","0x0c1d","0xbe02","0xf471","0xc3e2","0xaf0c","0xae0d","0xd315","0x16d9","0x1ed0","0xefe6","0xe3cb","0x440e","0x0df7","0x39af","0xe117","0xe700","0x421c","0xb11c","0x2edf","0x70e2","0x4105","0x305f","0x2ffc","0xed22","0xf910","0xe4ff","0x42f1","0xf724","0x21fb","0x0e4e","0x20","0x5d3e","0xf402","0x732d","0x2103","0xb101","0x4120","0x401","0xe001","0xe440","0x101f","0x4337","0x0ef5","0x4e31","0x3e2f","0x2df3","0x0d5c","0x3cec","0xd52e","0x7e00","0x3e90","0x9a1d","0x51ff","0x2d4","0x211","0xb2f1","0x27ff","0xe210","0xc302","0xdb02","0x2519","0x0f46","0x240c","0x0f0e","0x0ae9","0x34f4","0x0de3","0x1e","0x2ef","0x24d0","0xe0ef","0xf1fb","0xd1e0","0x1c41","0xfaf2","0x301","0xeb0e","0x1c12","0x4203","0xc40e","0x2e1e","0x0e2","0x1ebf","0x7fee","0x60e2","0x6022","0x220a","0xfb2b","0xcf11","0xce39","0x341d","0xb402","0xde1b","0xeef0","0x202","0x2de0","0x0b13","0x2ff4","0xee3f","0x921d","0xdc1e","0x1e4","0xff23","0x20f4","0x240","0x3b03","0xfe3c","0x3e1f","0x42e","0xe4b0","0xd10d","0x1cd0","0xe101","0x120","0x11c","0x100f","0x1d","0xeff0","0xc1fd","0xf0e1","0xe101","0x11ef","0x0e01","0xfc0e","0x110","0xf0ef","0x5fd3","0x3a23","0xb50f","0x6920","0xe1fc","0x90d1","0x0df5","0x0ba2","0x0a0f","0x34ff","0x0e12","0xba1f","0x19ce","0x12e1","0x6cf0","0x36e","0x22f3","0xeca5","0xb34d","0x9a05","0x7f2a","0x1e2","0xddd0","0xf997","0x3911","0x5cc7","0x0d5","0xfd30","0x0ddb","0x3f19","0x36e5","0x1071","0x2edc","0xcd94","0xf2fc","0x9d07","0xe259","0xd213","0xcf1f","0xd0b1","0x9a01","0x2dd5","0xf091","0x0bfb","0xfe3b","0x7133","0xe713","0x9f4b","0x2016","0xe60f","0xf330","0x0d","0x2dd1","0x73f2","0x71d5","0x4f4f","0x3e2b","0xfd2f","0x2030","0xe0f0","0x2f34","0xd02f","0x1f20","0x2270","0x2119","0xe90d","0x0d05","0x1dd2","0xe431","0x9b1b","0x911e","0xefce","0xbf04","0x27f1","0xd7de","0x1c24","0x1f2f","0x4a0d","0xf319","0x94ff","0x400f","0xfb22","0x421e","0x2241","0x21e1","0x712e","0x12fd","0x1fd","0x4220","0x0c0e","0xfef0","0xf100","0x13e","0xebfd","0xdf2c","0x2f1d","0x1f00","0xfc13","0x0c00","0xe030","0x2ff","0xf022","0xf1fe","0x0ef2","0x1213","0x1030","0x10d1","0xe02c","0x31ee","0x0e0","0x2ef","0xaf0f","0x1000","0x0b05","0xfc11","0xe020","0x210e","0xf02e","0xdee0","0xdf32","0x2010","0x3ee","0xf110","0xff1e","0x0cf","0x202e","0x100","0xeb00","0x310","0x2ddf","0x110e","0xf01f","0x203d","0xf211","0x4ef1","0xf2e0","0x2d21","0xfdee","0x0d0","0xf1ce","0xf2ff","0x2d","0xe1ee","0x1ffc","0x703e","0xe242","0xd1f2","0x0fe","0x3cd1","0x9df2","0x0d11","0x302f","0x1ed","0xf033","0xe100","0xfc0f","0x3a1b","0x1f2e","0x5129","0xb001","0x3fc","0xd2fe","0xd9b1","0xf10c","0x1f1e","0xd911","0xae03","0xcef0","0x5cf2","0x311a","0xb0e4","0xc9cc","0xe9fd","0x23ef","0x0dec","0x09ca","0xf22e","0x300","0x1031","0x412f","0x1f10","0xcf12","0x4f01","0xe0e4","0x32ef","0xef3a","0xf9d1","0x34d1","0x2d03","0x17f2","0xdfff","0x3bd3","0x0e20","0x1d2e","0x3101","0x20f","0x1010","0x3d01","0x2051","0xf16c","0x111f","0x23ff","0x1231","0x3435","0x372b","0x7410","0x3f01","0x120f","0x2f90","0x2a3c","0x1392","0x3ef0","0x1df1","0x2911","0x2f22","0x0f7c","0x212f","0xf775","0xfe20","0xf444","0x473d","0x33c4","0x2d1","0x1363","0x11f","0x2040","0xf2c2","0x3202","0x203","0x3c1c","0x41e0","0x2f70","0x2f01","0x574","0x42","0x1f32","0x620","0x22ee","0x20ee","0xe143","0x1f1e","0x10f2","0xec10","0xe112","0x0eef","0xe600","0xb4d1","0x0fc3","0x330e","0xb922","0xe0ff","0x0e3c","0xfe32","0x50","0xfe30","0xb100","0xe31e","0xfff3","0xec02","0xd301","0x1022","0xd414","0x9210","0xfe92","0x1103","0xe409","0xd2ee","0x0e30","0xce1f","0x1b5e","0xca0e","0xc9a2","0xf11f","0xefe1","0xdd10","0xfd1d","0x1f13","0x311","0xc100","0xe1e3","0xf102","0x1f9","0x1fc2","0xf020","0x1d11","0xef42","0xd90f","0x2cd2","0x0f1e","0x4132","0xeee3","0x12","0x21ff","0xc103","0xd401","0xe02c","0x33f4","0x1221","0x321f","0xdf3f","0x15d","0x2df0","0xff21","0xef01","0x3011","0x1154","0xff10","0xf010","0x120b","0x0ef3","0xe500","0xeff1","0x54f4","0x21fe","0xf010","0xdd3e","0x1e4c","0x0de2","0xf011","0xeee1","0x1001","0x2e41","0x0d10","0xe131","0x11fe","0xe000","0xd300","0xee30","0x2404","0x11ff","0xe020","0x111","0x1f4f","0x1cf0","0xff20","0x0ce0","0x2112","0xc1df","0xf102","0x100","0x121f","0x4111","0x31f5","0x5020","0x2f1d","0xfe10","0xff1f","0xcf1e","0x2002","0xde3e","0x2230","0x21","0xe10e","0x0de0","0xee13","0x20e3","0xf23e","0xbe10","0xe0fc","0x10d0","0xb003","0x12f1","0x410","0x2c11","0xef0f","0x2b0d","0x21e","0x2f0","0x10","0x0fe0","0x0f1","0x10ee","0x110","0x2fef","0x2f2e","0x0fe","0xdf0f","0xf2f0","0xf1f1","0x1201","0x102","0x0dff","0x0f1","0x0f2f","0x2d13","0x2055","0xecf0","0x1ed0","0x111","0x5e2f","0x101d","0xb313","0x52f1","0x1002","0x5001","0x523e","0xf9ff","0x9d02","0xe3f0","0x9e11","0x1cde","0x3134","0x1901","0x4df2","0x7","0x4915","0xe71e","0xe1f0","0x41d0","0xe23f","0x53e1","0x7022","0x2930","0xeec3","0xf9f5","0x9356","0x0ee","0x0ef1","0x32fd","0x0dd3","0x2ef1","0xfd22","0xd4e3","0xecfb","0x2202","0x3d11","0xd3d0","0x5e12","0xf90f","0xfd90","0xf9ef","0x2127"},
{"0x4efa","0x357f","0xea2e","0xfbf5","0x19e2","0xc10d","0x3a7d","0xd2f0","0x10f6","0x23c4","0x5e49","0x413e","0xb947","0x1410","0xf767","0x105f","0x0fea","0xefd5","0x9d1e","0x9937","0xf974","0x392","0xe754","0x2f22","0x9fe7","0xecc4","0x7d1b","0x56d7","0xdd33","0x3c22","0xcf57","0x275","0xf0de","0x93b1","0x329b","0x9e1f","0xe427","0x0f94","0xc70f","0xfdea","0xc001","0x31df","0x9739","0xf1b7","0xfff4","0xa9f1","0xc9b3","0x217b","0x0ffd","0x1dff","0x0fe","0xd031","0x1200","0x0d0","0xe02e","0xe0fe","0xffe4","0xede0","0x4efe","0x1f00","0xc001","0x0fd2","0x10c3","0xf00f","0x0fec","0x6e01","0xe0dd","0xd14e","0xe42e","0xc0e3","0x9eec","0xdf0e","0xf0f5","0xfedf","0x4edf","0x41f0","0xcd00","0x30f3","0xeec0","0x3ede","0xe004","0xf510","0x3110","0xf041","0x1efe","0x7110","0x10f6","0xf022","0x5211","0x200c","0x0b14","0xff2a","0x30f2","0xe50f","0x0de2","0x2df0","0xe2e1","0x09fc","0x322","0x11f3","0xf1c1","0x7f20","0x2f9c","0xef3f","0x4f1e","0xf010","0xf142","0x0f0f","0xc020","0xccf3","0x1142","0xde31","0x39fd","0x7d22","0x0d0e","0x0e","0xe031","0x9d12","0x90c9","0xf0c0","0x0ef5","0xfcdf","0x6600","0x20f5","0x9f0e","0x30ef","0xeefc","0x22b0","0xff11","0xf70c","0x1f1a","0xde03","0x10ed","0x72de","0x2e17","0xf025","0x4203","0x101b","0xfd02","0x1dfc","0x2ff2","0xf731","0x0bf","0x1d10","0x0cfc","0xf4df","0x2942","0x1ac9","0xca9f","0x0e3e","0xf590","0x7ce1","0xde1b","0x425","0x3092","0xfb5b","0x71f2","0x90e3","0xc7b3","0x7dbe","0x29f9","0x16d9","0x193c","0x0e1c","0xfaa3","0xbbb6","0x97a6","0x1d00","0xec1d","0xd9e9","0xc21f","0xcd4f","0x49df","0x0fc0","0xebac","0x2b90","0x111e","0x6ff9","0xf373","0x7003","0x1197","0xf2e3","0x2213","0x2137","0x42","0x202a","0x3912","0x202","0x29d0","0x2421","0x1a42","0xfc93","0x93c2","0x0c03","0x1cf1","0xfb31","0x1f1f","0x0eb2","0xf13e","0xfde4","0x109f","0x53ae","0x101","0x97b5","0xe7ea","0x454c","0xffed","0x21ed","0x9994","0xaac0","0xed9f","0x9a60","0xf2de","0x29e5","0x59cb","0x0bfd","0x2f92","0xb0b7","0xe0f9","0x97fd","0xe4c7","0x46d9","0x7fe","0x17eb","0xd7e3","0xa100","0x1fd0","0x9451","0x0ee2","0x1903","0xbaf0","0xefeb","0x4e30","0x4f07","0x10f","0x191c","0xe2d7","0x4529","0xf744","0x171c","0x54ff","0x6720","0xdcdc","0x1432","0x0d35","0x0f0","0xcbf0","0x4ffe","0x5003","0x1ee1","0xf12f","0xacd1","0x41fb","0x12","0xe1a1","0x31cb","0x0a31","0x2711","0x616c","0x6f46","0x2f73","0x4ae5","0xde97","0x2d37","0x6e40","0xb0a1","0x4103","0xdf12","0x324c","0xa702","0xbee6","0xe1e0","0x3f64","0xce2b","0x9117","0xec42","0x3ed5","0x402e","0xceea","0x2f47","0x1c43","0xd17d","0x3944","0x69df","0x2660","0x2501","0xcc5c","0xf4ee","0xcfef","0x2df0","0x0f2","0x1f12","0xfe02","0x1351","0x0da0","0x32e","0x0eca","0x45c0","0xb1de","0x21fd","0xe1ff","0xff30","0xe031","0x0f","0xcebe","0x0dff","0xf4ce","0xf32e","0xf1ed","0xbf12","0xd1de","0xe13e","0x3bc4","0x3ecd","0xc1c9","0x3240","0xe9f4","0x2f1d","0xf123","0xfecd","0xf1e0","0xf000","0xf10f","0xf220","0xfeec","0xef2d","0x0f00","0xe011","0x1ef0","0x1d0f","0x0bcd","0x231","0x0ff2","0xee0d","0xe044","0x0ee0","0xde10","0xdffe","0x260f","0x1f0e","0xf040","0x0fce","0x0f20","0xfdde","0xc1f0","0x1e0","0x2f","0xfe0f","0xe0c0","0x2e2e","0x10c4","0x3233","0xe0fb","0xdfbf","0x12fc","0xcfff","0x305b","0x610e","0xcb22","0x9f9b","0xefff","0x12d2","0xf31c","0xfd0e","0x5fc2","0xffff","0x10e3","0x227d","0xd010","0x5f10","0x4025","0x7f0f","0x3d3b","0x227f","0x3d21","0xa2d3","0xf0d1","0x11f1","0xe2ed","0x205e","0xff0f","0xfe30","0x1f02","0x1172","0x2de2","0x2d10","0x1cf","0x0e3e","0x1d01","0xefef","0x31ce","0x7a3","0xc37d","0x579f","0xf0b2","0x13fd","0xbf1e","0xa05c","0xf1b3","0x4214","0xf6f1","0xffe4","0x2d1","0x211d","0x0e23","0xceee","0xf1d0","0xf6a3","0xf66e","0x7ffb","0xc0ca","0xe523","0xe0e1","0x3f6a","0x1f93","0x1d3","0x1030","0x2e1","0xf3de","0x1220","0xff32","0xffe0","0x2ff0","0x2ae","0xf210","0x4ffc","0x2fc3","0x3dfe","0xdfde","0x4e","0x3dff","0xe4ff","0x7443","0x47cc","0x5fa3","0xded5","0x11b2","0x7e0c","0x4497","0x7f50","0xcf59","0x9e7a","0xe464","0xf17a","0x7709","0x94f6","0x2f74","0x1f31","0x69e0","0xb207","0xbe73","0x2221","0x1b16","0x2245","0xd055","0x7fc2","0x6ac4","0x0fa4","0x9ef0","0x99b7","0x7d35","0x4dfe","0xc39a","0x7d0","0x1f1","0x61e0","0x511d","0x12e1","0x0eb","0xccd0","0x1e10","0xf1c3","0x12fe","0xf2eb","0x423e","0x20fd","0x0f4f","0x2031","0xd0ce","0xfbe2","0xff11","0x1bff","0x10d","0xff21","0x1fe2","0x3f10","0xe02d","0xe1e1","0x13","0x1ee0","0x3e0e","0x2","0xe321","0x2f0e","0x1f1e","0x11ee","0x221e","0x7300","0xe0dd","0xf020","0xf300","0xac00","0xc3af","0x22ee","0xdf17","0x1cec","0x51ed","0xf1f1","0xe00d","0x1f","0xffad","0x1fad","0x0c02","0x151d","0xdf22","0x3c00","0x10fe","0x511c","0x3115","0xe202","0x600e","0x3f0f","0x19f3","0x0f2c","0x6f0f","0xf741","0xfef1","0xf123","0x0f1e","0xcf11","0x2e21","0x2101","0x0df2","0x21","0xd0fb","0xf2b4","0xefed","0x10cf","0xf2f2","0xdee0","0xb21e","0x1e1d","0x2ee","0x12e0","0x2fe0","0xfd12","0x10ea","0x2e32","0xece3","0xccd5","0xe119","0x2292","0x20e1","0x2fd2","0x11ff","0x2001","0x9dfd","0x0f2","0x210","0x0b1","0x0d1f","0x2e21","0x2029","0x3e31","0x0f1","0x1e01","0x1ff0","0xd2d2","0x1110","0x0d00","0x31ff","0x10fe","0xdd0e","0x214e","0x10f1","0x1ec1","0xee10","0xe912","0x12ff","0xf11c","0x1003","0xce0e","0x2200","0xf7f3","0xd15f","0x53af","0xcfce","0x103f","0xa00f","0x2e7e","0x10d1","0x2101","0xad62","0xeb12","0x24bf","0x200d","0x1f11","0xf10e","0x5f13","0xf6e2","0x224f","0x7fd1","0xa0cd","0x432","0xfed3","0xf25b","0x2f9f","0x302","0x0f2f","0x1e06","0x22b0","0x2f23","0x121","0xf0fd","0x212f","0x1b3","0xd312","0x400f","0x10b0","0x240","0xdfbf","0x1d1c","0x1cdf","0x111","0x1e","0x295f","0x331f","0xe7d6","0xa975","0xef2b","0xd069","0xbff2","0xc002","0xdf1e","0x2002","0xbcd0","0x9003","0x2f0d","0x4337","0xae74","0x2e9","0x39f1","0x11fc","0xf5f1","0xa96e","0x2cd5","0x239","0xb0cc","0x6f07","0x3002","0x30ec","0xe1d5","0x9ab1","0x2ed1","0xcdf7","0xbf77","0x120","0x2c0b","0x625a","0x4100","0xe252","0xcd91","0x212f","0xc00f","0x4fef","0x3de","0x31fe","0xe014","0xfdf2","0x2443","0x2e11","0xfc76","0xf2f1","0x9d23","0x2e17","0x6f2e","0xeae1","0x5113","0x32c2","0xfeb2","0x1dda","0x231e","0xc2f2","0x2000","0x5e20","0xe4d0","0xf512","0x1ef","0xef0e","0xcdd5","0x1ecd","0x424d","0xecff","0xfde3","0x2fd9","0x0fb1","0xb9e9","0xbef1","0xd7ee","0xf3f0","0xfd2f","0x10de","0xc2f2","0x2f1d","0x0ef1","0xfee2","0xeff0","0x106e","0xcf1b","0xa144","0xdfee","0xf0ad","0x0f00","0xdf01","0x110d","0x2cf","0x1f0e","0x1bfe","0xd0d1","0x14bf","0x2ab1","0xdf03","0xf400","0xe01f","0xfd12","0xfcef","0x6bf1","0x37c6","0xd12b","0x45bf","0xbfcd","0x62c1","0xd3e0","0x52","0x3a2","0x6d0c","0xd993","0xe3f0","0x27c0","0xcf0e","0xece0","0x10fd","0x6cd1","0x7f6","0xdfbc","0x59e4","0xc299","0x57e1","0xd0be","0x1f6a","0x1190","0x27db","0x4fd1","0xe3f2","0x21df","0xec11","0xf1ef","0x2f20","0x2f12","0x0ed","0xde12","0x20e3","0x21b1","0x0dcf","0xe0d9","0xef30","0x4ff0","0x6df","0x10e1","0x9230","0x0f04","0x2f01","0x0cde","0x5021","0x1ef4","0x1be1","0x3eec","0x2110","0xc215","0xbff0","0x4041","0x0f02","0x4f2","0xa112","0x21fd","0x0d32","0x1c3c","0x1033","0xbf0d","0xef23","0xbfd9","0xeeef","0xcafe","0xdf2e","0xc5ff","0x1102","0xb04e","0x3e01","0xb321","0xe0cd","0x300e","0x0d1e","0xef1f","0x2e51","0xed0e","0xf225","0xefed","0xe3fe","0x2300","0xed01","0xe1cf","0x1fee","0x11e","0x3bf0","0xe1ff","0x40bd","0x30f5","0x96c0","0x2232","0xded3","0x3ce1","0x7f12","0x50d7","0x5c24","0x7119","0x4572","0x9f15","0x9f2d","0x73f0","0x92e2","0x3163","0xcf63","0x2bef","0x39e5","0x101f","0x0ff0","0xf303","0xdec4","0xb0f9","0x2001","0xcefb","0xafe2","0x47ff","0x15","0xdd30","0x39de","0x123b","0x40f","0xe01f","0xee01","0x1ee","0xe0f0","0x0f31","0x30d0","0xf0f0","0x2f20","0xef0f","0x1002","0x1220","0x0e2","0x30f","0xfcff","0xf1d2","0xe000","0xeff1","0xeb10","0x2026","0xf0f3","0x2fe2","0x6313","0x2ef3","0x134f","0x52da","0x5f2e","0xd061","0xfe1e","0x50e0","0xed11","0x2161","0xef23","0x200e","0x7f03","0x0f1c","0xf0e1","0xf532","0x9112","0xc1f9","0x121d","0xefe7","0x3ede","0x6200","0xf0f4","0xaf21","0x401f","0xe2ef","0x2ff","0xe200","0xf61f","0x51","0xffe0","0x310f","0x720d","0x115","0x1061","0x3f01","0xf20e","0x0d3f","0xeef0","0x2f01","0xe222","0x0e1","0xf031","0xc3ee","0xccf2","0x7e66","0x2bf1","0xf92f","0x9227","0x5f40","0x1292","0x7db9","0x21fd","0x92d0","0x9d59","0x1d1","0x320","0x1cb","0xc0c6","0x920b","0x5914","0x9379","0x52ed","0xe7ee","0x9a1c","0xf999","0xd2fe","0xa3e7","0x9e39","0x4dfa","0x5524","0x99fd","0xbe7b","0x3027","0x3e40","0xb9fd","0x2a3d","0x9f12","0x1ec","0x112f","0xe7b0","0x100d","0x10b","0x0ff2","0x3f42","0xffe5","0xdff4","0x97c3","0x0dc1","0x10c3","0x2115","0x21fd","0x0cf0","0x1ff0","0xfc11","0xedff","0x40e1","0xcf4c","0xa011","0x5ee2","0x12de","0x1ff","0x3ecd","0xaf12","0xee2f","0xe213","0xd4f2","0x112e","0x77f5","0xb019","0xc101","0xf63c","0xb9d4","0xac91","0x4002","0xd127","0x9aa9","0x7fe9","0xf2f5","0xc0cc","0x2300","0xdca0","0x5cbb","0xe914","0xc71c","0x91f5","0xdf21","0x6eee","0x730b","0x2e67","0x1d32","0x5301","0x2455","0xd917","0xc91c","0x6512","0xf713","0x40af","0xfe42","0xafe0","0xf95d","0xd524","0x52ed","0xf3f2","0x904f","0x7dbc","0xc7fc","0x9121","0xd250","0xdfce","0x1423","0xcee1","0x1c40","0x3e7f","0x2f35","0xeeee","0x591e","0xbef9","0xe0df","0x096e","0x963d","0x5339","0x34ce","0xe1e9","0x11d7","0xb2f3","0xa012","0x94a1","0xcaa3","0x33de","0x1341","0xb61c","0x0e20","0x7d39","0xe1ee","0xaf1b","0xdbd1","0x21a1","0xa29c","0xe00f","0xbe09","0xe4ea","0x23eb","0x2cff","0xc23f","0xdfbe","0x0ad0","0x6e01","0xc70e","0x7b44","0xee04","0x3bd0","0x7c02","0x5397","0x6013","0x6e09","0x4b","0x9145","0xac5b","0x75fe","0x9511","0xef7e","0xee31","0x2912","0x0ce4","0x9f23","0x210f","0x1f01","0xc12f","0xdc40","0x12f4","0xfdf3","0x1ef3","0xba01","0x1ca4","0xfe6f","0x3eef","0xd3cd","0xf3d0","0xf1f0","0x2e01","0x420c","0xef1e","0x3e","0x21ff","0x10fd","0x0f1d","0xf2fd","0x1d0","0x150c","0xf0e2","0xdf21","0x1b0f","0x12f1","0x0ee0","0xdeef","0x2953","0xc640","0x2369","0x71cc","0xa193","0xdd3c","0x1993","0x10e5","0xf6e1","0x511f","0x9b14","0xb9f3","0x6f49","0x7c50","0x637a","0xd213","0x19b5","0xb499","0x9179","0x7d69","0x4fe6","0x1a49","0x499d","0xe015","0x7bb7","0x7ec3","0xfb01","0x9ccd","0x4029","0x5475","0xcf7c","0xd230","0xb2a1","0x0db9","0x9d35","0x7119","0xe166","0xb9d1","0xfc9b","0xb90e","0x5dd3","0xa694","0x3eff","0xf26d","0x712c","0x6c3","0xae59","0x1213","0x93fd","0x1115","0xffd0","0x3bd1","0x7c11","0x6f97","0x6030","0x4129","0x77c","0xaf34","0xd20f","0x7ffd","0x9f02","0x2e66","0xfd72","0x290d","0x09f6","0xae1d","0x1310","0xe921","0x90c2","0x9ed9","0x2190","0x9c9c","0x1013","0x97ef","0xf037","0xde21","0x7afd","0xf29b","0xe5ef","0x0ffe","0xfc21","0xde0c","0x3f30","0xdee0","0x721f","0x12d","0x20d","0xdfff","0x201b","0x1e30","0xfeb0","0x120f","0xb92f","0xdfef","0x0dff","0x0e00","0xf001","0x1eed","0xfe3f","0x300c","0xfff0","0x1fee","0xf2e4","0xe0ce","0x33b0","0x0ce","0x1ffc","0xd1de","0xef11","0x1c3","0x130f","0xeef0","0xef02","0xf202","0x103f","0xff1f","0x110","0x0ec0","0xf3d6","0x0f95","0x60ce","0x1ffa","0x231c","0xc1ef","0x40fb","0x2291","0xe2ff","0x1e","0x1ef1","0x12f","0x20f3","0x3f10","0x1100","0x2e00","0xe012","0xfef0","0x0ff1","0x11e0","0x10dd","0xe02c","0x0e4f","0x2f1f","0xe02f","0x5aee","0x930f","0xdeee","0x3efd","0x0ab1","0x9102","0xf094","0x3def","0xbd09","0x16e2","0xc010","0xaedf","0x293e","0xcdfe","0x117c","0x2001","0x2bed","0xc2ef","0x0ed0","0xd01f","0xccfc","0xade3","0xa3e2","0xffee","0x7af2","0x3b1e","0x9012","0xe00a","0xe9e2","0x2f2","0xa0ec","0x1c99","0xc4df","0x52e9","0x3052","0x3053","0xf411","0xa34f","0x5f04","0x13c6","0x5102","0xfe1f","0xf9ef","0x24f4","0x2dd5","0x700","0xe01f","0x2ac2","0x17f3","0x39ff","0x12e2","0x111f","0xf1fe","0xcb4c","0x13cf","0x17e1","0x117f","0xbb01","0x0fd6","0x2c19","0xa905","0x992d","0x22d1","0xff33","0x479e","0x4907","0x501","0x64cd","0x104e","0xd6ee","0x963b","0x27b0","0xc57f","0x79d9","0x7","0x5cd2","0xc9d9","0xe93b","0x09ed","0xdbf3","0x29b2","0x4016","0x210d","0x7401","0x2f","0xd401","0x1210","0xf09d","0xd1df","0xcbf9","0x2fd7","0x13b2","0x0ca9","0xecf0","0xf0e2","0x1b05","0x92af","0x0f01","0x350f","0xd06e","0xeb10","0xcfe1","0x610f","0xdee1","0xddbc","0x11ce","0xefdf","0x1211","0x10e","0xf22c","0x15a4","0x50de","0x9990","0xfb13","0x47ef","0xbe5f","0xddff","0x2bf4","0x69dc","0x1fe0","0xfd90","0x09d3","0xafc9","0xf7e1","0xc115","0x3109","0x109f","0x57ef","0xc3cf","0xed15","0xf3e2","0xc142","0xd2e0","0xf320","0x3c3d","0x1fe0","0xd020","0x1fe0","0x40dd","0xfbfe","0xefff","0xd229","0x5241","0xf7e1","0xfe10","0x2d43","0xfffe","0x0f1e","0x0fee","0xde0f","0xf21f","0xf4b0","0xf301","0x40e0","0xf0cd","0xc222","0xb06f","0x332e","0xe1ff","0xdee1","0xfd21","0xbe52","0x11df","0x0f20","0xfc0d","0xe011","0xdff1","0xe7c1","0x121d","0x4ff0","0x1f9d","0xe21f","0xf5fd","0x3040","0xc0df","0xfede","0x1010","0x0e33","0xf1df","0xf050","0x100e","0xf110","0x30fe","0xd0b0","0x601","0x2def","0x2fa0","0x10","0x3ff","0x301e","0xedcf","0x2ecf","0x2122","0xa3e1","0x21e3","0xe00f","0x3ff1","0x6120","0x4097","0x4031","0x3f19","0x1242","0xb143","0xd11d","0x71f0","0xce2f","0x3253","0xd042","0x1bdf","0x2df3","0xe02f","0xf1f2","0x114","0xc113","0xf2ea","0x23f1","0xe1c3","0x11f1","0x151d","0xf213","0xfd23","0x1b1f","0x11fe","0x110","0x210f","0x0ff2","0x12","0x10f0","0x1011","0x40e0","0x321e","0x20","0xd0f0","0x10f0","0x111d","0x1100","0xf011","0xee02","0x0f11","0x1002","0x3d04","0xf253","0x0b1f","0x103d","0x9900","0x104e","0x24f9","0xcdf1","0x5e20","0x45d1","0x3019","0xf20f","0x0ae0","0xad01","0xb402","0xcf24","0x5c0f","0x112e","0x2f42","0x330e","0x9abf","0x1353","0x0f2f","0x0dee","0x5f22","0xf9d1","0x7fe9","0xf303","0xe902","0x2fbf","0x3b43","0x2d46","0x3ed0","0xddf1","0x0fcf","0x2f1","0xd2bc","0xee54","0xff00","0xe1da","0xce0f","0x390e","0xc5d9","0x222f","0x19e3","0x2dc2","0x0a4d","0x1034"},
{"0x30d9","0x111e","0xfdfd","0xdae3","0xecfb","0xed29","0x2f1c","0xe220","0x6025","0xe101","0x5059","0x6f11","0xadc7","0x1624","0x407","0x5dfe","0x2f9","0xdfe5","0xa1e0","0xc922","0xe06e","0xd200","0xd702","0x2222","0x2ed3","0xf000","0x7d5b","0x3eb7","0xdf32","0x1f27","0x1317","0x1377","0xe4ea","0x9024","0x30fe","0x99f2","0xc22a","0xdfb4","0xc0fc","0x2fdb","0x502","0x10","0x9f3b","0x9405","0x1df3","0xe934","0x1ee6","0x273","0x201f","0x3bff","0x12f","0xd111","0x101","0x0fef","0xe10d","0xc1ff","0xe2ff","0x0df","0x3e0f","0x11","0xe0e2","0x0fe0","0x2202","0x1f1d","0x0ee","0x4bff","0xe2de","0xfd3d","0xe101","0xdff1","0xfdfb","0x110","0xc012","0xffd0","0x2fc0","0x2200","0xc10f","0x30e0","0x1ef","0x102f","0xe2f3","0xf0da","0x1fe1","0x131","0x10e1","0x1200","0xd117","0x15","0x3122","0x312f","0x3","0x132a","0xeeef","0xf420","0x2e0","0xfee0","0xf2f1","0x0b0d","0x32f4","0x201","0x12","0x21e1","0xee2c","0xd1ff","0x110","0x41f2","0xef23","0xf201","0xb011","0x1ff3","0x0f0f","0xf002","0x0efe","0x7226","0xd00a","0x111f","0x0f0","0xabf1","0x32f9","0x1fe1","0xd113","0xf0c1","0x51ef","0x0e12","0xd1fe","0x3000","0xefef","0x2d0c","0xf321","0xe329","0x20ff","0xc123","0x0eef","0x320e","0xe0e7","0x2055","0x1332","0x202f","0x1d3f","0x202c","0xb1f0","0x521","0x111f","0x0e10","0x3d1e","0xb1e3","0x4921","0x1e3a","0xeee0","0x20","0x3003","0x6b50","0x1f4c","0xbce4","0x41e2","0x1d71","0x1d16","0xdfb3","0xc1e1","0x5fee","0x3ccb","0xf22b","0x199c","0x1c4c","0xc992","0xfdf1","0x41e7","0x3e50","0xaa0f","0xbf13","0x20e0","0xcdf0","0x49e2","0x0de5","0xaffe","0x3e92","0x2f2a","0x711a","0xc1d4","0x6fff","0x0c96","0x1202","0x5010","0x2527","0x131","0xf344","0x5031","0x4e2","0xfc02","0x135","0x1e0","0x1ea5","0xffe1","0x14d1","0x3f1","0xf411","0x0fd","0x40ff","0xec00","0x306f","0x11","0xf750","0x121","0x7de2","0x40e4","0xc1e5","0x2fc2","0x1f01","0xd190","0x2bf","0x59e","0xd500","0x1f1","0xf42d","0x0f1f","0x4e60","0xbf20","0x773","0x410f","0x7d00","0x5f9","0xe4f7","0x2b30","0x1e2e","0xf010","0xaffb","0xf1f2","0xcede","0xf012","0x333d","0x0ef2","0x2071","0xdf20","0xd421","0xd330","0x21f1","0x215c","0xf507","0x2ee1","0x22f","0xffff","0x5bed","0x1dec","0xe211","0x1d3d","0xce20","0xf34f","0x102","0x3300","0x2a0","0xfff1","0xbde1","0xe413","0xf0ff","0x1e2d","0x3d1c","0xffb4","0xc03d","0x4fc3","0x6d70","0xf0e9","0x0904","0x1c7","0xc027","0xf403","0x1f05","0x7f0e","0x7d7d","0xe450","0xe216","0xefe3","0xd013","0x5cb5","0xfccd","0x93d7","0x3bb2","0x50d0","0x4339","0xc0eb","0x3ee7","0x4003","0x0f71","0xcc56","0xeceb","0x2fb","0xee21","0xbefe","0x1e01","0xde0f","0xf2f2","0xdf10","0x3021","0x1e12","0x3302","0x0f10","0x2ce0","0x0d9e","0xdebf","0x11dd","0x33e1","0xff00","0x100f","0xff60","0x2fef","0xf92d","0x14ff","0xef2f","0x0e1f","0x0fce","0x2f01","0xfde0","0x3cce","0x0ba2","0x90ce","0xf0d9","0x0f2","0x2ff0","0xffed","0xff5f","0x2e0d","0x23ff","0x4d9","0xf032","0xf312","0xfffd","0x101f","0xde20","0x4fef","0xedd2","0xefc0","0x11fa","0x1301","0xff1f","0xcf0e","0xe140","0x1f0","0xcee1","0x1ece","0x22ff","0xefef","0xe303","0x1b0","0x0c0f","0x0bff","0xde0f","0x210f","0xff30","0xfed0","0xde03","0x120","0x1f12","0x65f1","0xf0fc","0xdfbe","0xf1fd","0xaef1","0x61","0x30c1","0xfa12","0xfafa","0x1e31","0xc2ef","0xd3fe","0x11fe","0x21c0","0xfff0","0x10f4","0xf34b","0xe200","0x41e4","0x4","0x4e1f","0x2d5c","0xf15f","0x1d21","0xe012","0x2","0xd10f","0x40d","0x2101","0x2021","0x0f02","0xff05","0xb25f","0x1e1f","0xf600","0x1f20","0x0e1","0x1210","0x20d2","0xfd3e","0x294f","0x4f92","0xcb2f","0x41","0x1c00","0x102","0xefb4","0x1030","0xffff","0xcb1c","0x72d","0x1f5f","0xde20","0x1df","0x42e2","0x1900","0xfb52","0x3c92","0xaf01","0x3f72","0x3ad0","0xffff","0xf190","0x27e","0x1f0d","0x1fdf","0x122e","0xf131","0xee21","0x10c0","0x2211","0xfc2f","0x0f51","0x0d0","0xef10","0x1261","0x1f1","0x1c2f","0xe0b4","0xe220","0x12f","0x77e5","0xe0ec","0x2fd3","0xdde1","0xfffb","0x701f","0x7f7","0x7351","0xf139","0x5f60","0xc013","0x1471","0x3ff9","0xc107","0x3fdd","0x0e00","0x4b30","0xf337","0xe113","0x73e0","0x2dd0","0xfdff","0x4212","0x5eef","0x09f4","0x2df","0xdf33","0x9a96","0x7102","0x240e","0xbfbb","0x10be","0x2f0","0x5132","0x1d2f","0x10e1","0x0fda","0xff0e","0x0d00","0xdfc3","0x0ed","0x0fe0","0x220f","0xfe11","0xf21f","0xfe11","0x3f00","0xf100","0x1ef","0x1f0e","0x111f","0x1f","0x20e0","0x20","0x1d1d","0xf10f","0x1f01","0xf100","0x21e0","0x3100","0xf011","0x1f01","0x0f00","0x10e","0x1f00","0x512f","0xe30d","0xcfef","0xf1d0","0xcd01","0x2fe","0x0e","0xc114","0x0f0f","0x3000","0x0e01","0xe2f0","0x1ee","0x0dbe","0x1fed","0xf111","0x1a","0x1002","0x0cd2","0x1f0d","0x300d","0xff17","0x227","0x220f","0x2e01","0xfd01","0x411d","0xff1f","0x522","0x42f","0xff03","0x0d10","0xdc2f","0x2010","0x201","0xe01f","0xef1e","0x2c09","0x0ff1","0x1cee","0x1ff2","0x1f0","0xe2b0","0x1ff","0x13e","0xf00f","0x2020","0x0c1f","0xfcf2","0x3ffb","0x1f20","0xf0ff","0xff04","0x10e9","0x10e1","0xffe1","0xfef0","0xe00f","0xfee0","0xc1fd","0xf102","0x100e","0x22fe","0xee20","0x1e1d","0xf00e","0x2f20","0x1f0","0x1ef0","0x2e0f","0xe203","0x21f1","0x1d01","0x20fd","0x10e1","0xef2f","0xef20","0x201","0x2200","0xef01","0x1e11","0x0f1f","0xe1f1","0x2110","0x20f0","0x2e11","0x1e61","0x122","0xeb30","0x3141","0xf011","0x11f0","0x0a1","0x0f3e","0x2011","0xe0f0","0xe00e","0x2f50","0xeec2","0x1101","0x60e1","0x1e34","0x2e71","0x3ff0","0xb020","0x4070","0xd111","0x3f2f","0xf1b1","0x1f","0x3","0x10e0","0x3ff0","0xef30","0xfe01","0x2220","0x110f","0xf00e","0x2f40","0x1000","0xf210","0x2262","0xf002","0x1011","0xdfc2","0x2ee","0xf02e","0xd22c","0x0df0","0x141c","0xb7e3","0xc950","0x103a","0xdf3d","0xef11","0xfee0","0x5f02","0x1fd2","0xa0fd","0xb541","0xf00e","0x2307","0x3d35","0xf109","0x3a30","0xc2fd","0xf39f","0xba7e","0x0e20","0x330a","0xd21d","0xe0e1","0x22fe","0x3f3c","0xac03","0x94f0","0xf3f2","0x1007","0xe177","0xf00f","0xf00b","0x13ca","0x4ffd","0x106e","0xce32","0x1","0x14ff","0x22fe","0x0eef","0x162f","0xe115","0x9510","0xf331","0xefe5","0xcf74","0x120f","0xb4ee","0xf010","0x3013","0xff3f","0x223f","0x0e01","0xfbfe","0x2adf","0xf02e","0xf010","0x2000","0x4e31","0xf1de","0x0f0","0x10d","0xdf0e","0xd6c4","0xf04f","0x431f","0xbfe0","0x4e13","0x4eeb","0xec2e","0x1cbd","0xc2f1","0x41","0x0ede","0x4122","0xd0df","0xe050","0x13ec","0x0cf1","0xe200","0xf021","0xefef","0xef0e","0x22","0x0d0c","0xdf4c","0x2cc1","0xb001","0x105d","0xe09e","0x0f10","0x2d10","0xe022","0x11ef","0x21f0","0x171e","0xfb31","0x1d01","0xf22e","0x40f2","0xf130","0x3960","0x40c3","0x9030","0x4053","0xccfd","0x520f","0xc1a1","0x0f43","0x0f00","0x5e9e","0x170d","0xfc7d","0xcef3","0x12f1","0x4df0","0xf52f","0x3941","0x1dc0","0x902e","0x5073","0xb9c0","0x2d51","0x1f96","0x1473","0x0f51","0x0ef0","0xf1fc","0xee71","0xe1de","0x1e1","0x100","0xc030","0x3f50","0x11dc","0xc12f","0xf23f","0x1001","0x0e63","0x0f3","0x331","0xfd21","0xf021","0x9311","0x0e04","0x4e2f","0xfdee","0x2f1f","0xf1f5","0x10e1","0x0dfe","0x20f1","0xb125","0xa2ef","0x3140","0x1031","0xf1f2","0xb201","0x102e","0xe2f1","0x1efd","0x4060","0xcdff","0xc023","0x2ef9","0xee9d","0xe90f","0x2ff0","0xe2ae","0x2fc2","0x21","0x2c20","0xc013","0x13cd","0x1f1f","0x12e","0xfef0","0x0f40","0xffce","0xdf35","0x1ffa","0xdfeb","0x3f0f","0x2def","0xff9e","0x20cf","0x10","0x1c1f","0xed13","0x3fdd","0x4011","0x91df","0x1ef2","0xf0f0","0x1e10","0x52ee","0xc507","0x4110","0x4409","0x4250","0x9f13","0xa00e","0x6e00","0xbff2","0x1ff1","0xbf04","0x0df0","0x4e17","0xdf0f","0x311f","0x312","0xcfc0","0x1129","0x2fcf","0xfd1e","0xf0f0","0x24ef","0xfe06","0x3e1","0xfd0e","0xff1f","0x1ed0","0x12","0xd012","0x0c","0x20f","0xe120","0xdfdf","0x201d","0xfefc","0xf00f","0x30e1","0xe0e0","0xf0f2","0x0c2","0x0d0e","0x1021","0xf111","0x0e02","0xed11","0x2ff4","0x0f01","0x2001","0x12f2","0x0d01","0x2100","0x3010","0x1011","0xe102","0xf111","0x0fd","0x1011","0x11f","0x0f3","0x0c10","0x7e27","0x10c","0x0f1f","0x1211","0xdde2","0x20fa","0x3ef","0xe112","0x0ff0","0x21e0","0xedf5","0x210","0x0","0xfe00","0x1f0e","0xf000","0xe23e","0x1100","0xdfe0","0x101e","0x12fd","0xf207","0x1024","0xf30f","0x1100","0x1f00","0xf150","0xdff0","0xf211","0x10f","0x122","0xe23e","0xb034","0x6e32","0x3c51","0x0e12","0x2235","0x1b4d","0x3fc3","0x3f00","0xdc00","0xde11","0xe2f4","0x4ff0","0x1ee4","0xff3e","0xffee","0x9c0c","0x7131","0xd5ca","0x24d1","0x2f5","0xae0d","0x193b","0xd20e","0x35f6","0xf400","0x71de","0x430c","0x9ffb","0xa07d","0x3f17","0x21d4","0xe401","0x69d","0xc021","0x0f3d","0xef62","0xd6f3","0xef2e","0x1f0a","0xf2ef","0xee21","0x0def","0x4f0","0x9e10","0x13d2","0x2","0x0e45","0x1020","0x1f31","0xfe01","0x0ef1","0xf020","0x12f0","0xff2b","0xc1ee","0x5d21","0xffd1","0xeeed","0x12e1","0xc0ff","0x230f","0xf32f","0xf0fe","0xcfc0","0x74f1","0x1209","0xa01d","0x5a1","0xfb03","0x22d7","0x217","0xb227","0xaf90","0x60ec","0x2e1f","0x910e","0xf3df","0xf1c1","0x30fb","0xf501","0xcd19","0xa207","0xe2b0","0x2e2d","0x6300","0xf107","0x2367","0x2500","0x416f","0xaa31","0x144c","0x4d5f","0x3723","0x52f0","0xf023","0xdf1f","0x0f4e","0xe303","0x32f0","0x1105","0xd120","0x1e1e","0x0ffe","0x1f10","0x114f","0x20","0x1e","0xfef1","0x2160","0x1d34","0xe002","0xc26c","0x4512","0xff1e","0x1cf0","0x1f62","0xc214","0x4c1a","0x2fe0","0xe2c0","0x2faf","0x2fe2","0xf207","0x9e22","0x1f92","0x1c1","0x2f11","0x1fd2","0x20d","0x2ff9","0xee2f","0xbec0","0x13ef","0x12","0x3203","0x1f50","0xd021","0x220d","0x2ffd","0x921f","0xd260","0xffff","0x1faf","0x5113","0x902e","0x4df1","0x110","0x0dfd","0x6d00","0xf4e7","0x4001","0x2e19","0x4e40","0x9114","0xb04e","0x7ee0","0xe002","0xee0c","0xefe2","0x0920","0x3c17","0x9122","0x4320","0x2ed1","0xdf1f","0x2d1d","0x3d2","0x1901","0xe011","0xfe30","0xfb94","0x1132","0x211f","0xee1e","0xffcf","0x101","0x1321","0x301e","0xe020","0x102e","0xeff0","0xfffb","0xfd0b","0x0fde","0x10c1","0xe12e","0x113","0xe1e0","0xee1f","0x3fe1","0x200","0x0eb1","0x7ef3","0xc40b","0x30fb","0x30df","0x0fb0","0x3b0c","0x39d0","0x3402","0x26e0","0x131f","0xfdff","0x1afe","0xf31c","0x4c0f","0xed4c","0xf117","0x16e1","0xb22b","0x9e3f","0x6c59","0xcf12","0xca19","0xed91","0x323f","0x2011","0x1ed4","0xe1b1","0x9d52","0x70d9","0x5c10","0xd37b","0xc0c4","0xb33a","0x29","0x9073","0x7e29","0x0ff2","0x3e0f","0xdbfd","0x94ed","0x2cce","0xf3a5","0xfbe0","0x9070","0x5404","0xd041","0xf069","0x103","0x9301","0x2005","0x2d1","0x1d12","0x62e2","0xd247","0x7052","0x532c","0x215f","0xe033","0xc401","0x4d32","0xbff2","0x21d2","0xc027","0x0a3d","0x10f7","0xaf2d","0x2efe","0xd31e","0xaef3","0x2ee9","0xfcdc","0xbcbf","0xdeee","0xc4cf","0xade7","0x6121","0x1d1d","0xffd2","0xf11d","0x22e1","0xc03e","0x0fff","0x103f","0xefe1","0x1412","0x2109","0x10df","0x0e0e","0x4eff","0x2ff0","0x21ed","0x0e00","0x291e","0xff22","0x21ff","0x202e","0xf531","0xff11","0x1e02","0x120b","0xf11e","0xf02e","0x4c6f","0x3c92","0x2dff","0xf02f","0x1ede","0x22df","0x0ff5","0xe111","0x12f0","0x0e1f","0xd43e","0x0f32","0xeff2","0x40fa","0x4203","0x2bf0","0xfe73","0x3f93","0xeed0","0xf24c","0x1ec0","0xf2df","0x1ec0","0x124f","0xf40f","0x2301","0x0f2e","0x3030","0x0f2f","0x2e1c","0xf313","0xfe0e","0xe51f","0x101f","0xeed2","0x110e","0x140f","0xf21c","0xfe1e","0xe13e","0x2f0e","0x4e3e","0xe46e","0x0eef","0x3fe0","0x1ea0","0xbef0","0x3117","0x2e10","0xf919","0xa3ef","0xc231","0x9de3","0x3202","0x41ef","0xc03c","0x150e","0xf95e","0xc32f","0x0edd","0x0f0d","0xfcae","0xbbcf","0x22f3","0xfc10","0x0902","0x9f1e","0xb0d2","0x9bfb","0xfeef","0xc413","0xcf0b","0x31c9","0xb30c","0x4eec","0x3002","0x3073","0x0f0f","0x104","0x0f17","0x2f7","0xf114","0xf040","0x0fee","0x410","0x33","0xc703","0x0f0f","0x12de","0xfe30","0xd432","0xed50","0x0c01","0x0e22","0x2223","0x2cfe","0x1191","0xc19f","0x2ac1","0xb10c","0x912f","0x0e0e","0x300e","0x151","0x1ee","0xbb71","0x233e","0xeb7b","0x1c41","0xf0d3","0xfcd1","0x39fa","0xa292","0x4d93","0x30ae","0xb1eb","0x9f3c","0xc006","0xdfe9","0xe222","0x24be","0xcf70","0x4f2d","0xe16b","0x1d51","0x1e6","0x3e21","0x2a33","0xd4f1","0x2fef","0x10b0","0x3eed","0xf52e","0xef16","0x1e1","0xe010","0x21cf","0xc101","0xfee3","0xf0df","0x1111","0x251f","0x40e1","0xec41","0x3c7d","0x2e26","0xc240","0x4235","0xdfa1","0x21f4","0xf0b2","0x3dee","0x0f","0xd391","0x0df","0x0da1","0xf20e","0xf4fe","0x3110","0xfe01","0x3b7c","0xe023","0x9463","0x5f72","0xeca0","0x34ff","0x11a5","0xf253","0x3e","0x0f0f","0xf2eb","0xfec3","0x12ec","0x102d","0xe140","0xedef","0x4f20","0x1d2e","0xd433","0x1244","0x1ed1","0x30","0x23e2","0x6d0","0xf13f","0x1f2d","0xf943","0x0e0f","0x202f","0xddb0","0xd03f","0x0f0c","0xf0d0","0xd92e","0x1e11","0xe0de","0xc1f2","0xdf60","0x214d","0xb1d0","0xefef","0x2f00","0xda2f","0x0ffe","0x1e40","0xbedd","0xf232","0xfe00","0x13","0x0c20","0x2d3f","0xf1bd","0x100","0xf03d","0x3f41","0xbea0","0x0ebb","0x3e1f","0x0e00","0xffee","0x0e41","0xeefc","0xe024","0xeffd","0xc000","0x1011","0x3c00","0x0ed0","0x2ffe","0x1fff","0x3e2f","0x0eb2","0x4cad","0x1003","0x91e1","0x2112","0xf0f0","0x1f10","0x3100","0x37","0x3222","0x2019","0x3240","0xc023","0xc201","0x40ee","0xff20","0x2010","0xdf11","0x1d1e","0x2e13","0x0e1e","0x0f1e","0x120","0xe00f","0x11e9","0x10cc","0xffd2","0xf0ff","0x11ff","0xdce4","0x21e1","0xfdfe","0x1e","0x110e","0x1100","0x1f02","0x0ef","0x1e0f","0x1002","0xfeff","0x121d","0x0fd","0xe1ff","0x11e0","0xf2ee","0x1022","0x1fe1","0xeed0","0x0f00","0x3","0x1eee","0x3ff4","0xe9ef","0x336d","0x9ce4","0x2100","0x11fa","0xbb10","0x3c04","0xe2fe","0x121a","0x10d1","0xeee1","0xed02","0x0ff3","0xc025","0x3eca","0xd1ef","0x43d1","0x2321","0x9cc4","0x12ff","0x2f11","0x2c2a","0x1c23","0x9d0c","0x7009","0x0bd3","0x0f34","0x10b0","0xff12","0x1d27","0x3ddd","0xe400","0xf00f","0xc4d1","0xf1d1","0x2d34","0x0f1e","0x302b","0xe011","0xde0d","0x219","0xf0e1","0x0f00","0xfeb4","0x0f10","0x24"}
},
{{"0x0e0","0x0f00","0x0d","0x3100","0x0ee0","0x0ffe","0xff0f","0xd3ed","0xfe21","0x2000","0x0fff","0x22ee","0xe1df","0x1000","0x0ee","0xf110","0xe11c","0x502f","0x1eec","0x3000","0xf240","0xe11f","0xb01d","0xc1e3","0x11","0x5bb","0x2ef1","0x1ef3","0xeefd","0x441f","0x2fe4","0x13e2","0xff34","0xe720","0x30d","0x0f1f","0x300e","0x61e2","0x31e5","0x2160","0x1efd","0xdd00","0x1b22","0xe3ff","0x31e1","0xd605","0xf1f1","0x4110","0x31ef","0xf60e","0xee03","0x20c3","0x30d","0x4e3d","0xd213","0x12c","0x6f15","0xeb60","0x4152","0xfe41","0x411f","0x2014","0x0e4e","0xe001","0x7edf","0x362d","0xcd6e","0x31d3","0x22fd","0x1f0f","0xc513","0xf21e","0x113","0xc15e","0x5172","0x0a20","0x424d","0xc037","0x135f","0x0f34","0x3fe1","0x312b","0xde42","0x12de","0x10ee","0x2dfd","0xd302","0x1050","0x101f","0x150","0xe152","0x1d11","0x226f","0x0fd7","0xe201","0x0b21","0xff01","0xee01","0xffff","0xff0f","0xf0ef","0xf100","0x2ef","0x10ff","0x1f0e","0xe1ff","0x10","0xeff0","0xff1d","0xfd01","0x0e00","0xeff0","0xe001","0xfef3","0x0eff","0x110","0xf000","0x1f0","0x10ff","0x0ff1","0x1f00","0x110d","0x1ff","0xef1f","0xefe0","0x0d0e","0x0ef0","0xd0e0","0xf1ff","0x0ff2","0x21fe","0xff0f","0x100f","0xff01","0x0f0f","0xffff","0x0f00","0xf1f0","0x100f","0xef1f","0xef0f","0xff00","0xf00f","0x1ff","0x1f11","0x0d21","0xe001","0x1e10","0xf0ef","0x0f1e","0x10e","0xf201","0x3e00","0x1eff","0xe110","0xf010","0x0f0f","0x2c0e","0x2010","0x1010","0xe0f0","0x0c01","0xfffe","0x1f20","0xf100","0xcfff","0xd00f","0xe0e1","0x0f0","0x1ee","0xf101","0x11","0xfe0f","0x0d01","0x0f","0x101","0xd0ff","0x1ef1","0x0ec","0x3001","0x103","0x0ef0","0x1ff0","0xf100","0xf010","0x1fe","0x0","0x1f01","0xfde1","0x0fe1","0xffe1","0xfef1","0xa2f1","0x1f0d","0x2130","0x133f","0xf3f1","0x110","0xe23c","0xdfe4","0xc0f1","0xd1e1","0x0fae","0x0e1c","0xb2f2","0x30ee","0xbeff","0x9ffc","0x4e5","0xefef","0x13","0x14df","0xd213","0x2f01","0xc46e","0xf2fe","0x30e3","0x34f4","0x1fb0","0x0ee3","0xff11","0x2af2","0x9b13","0xc01e","0x0f10","0x30df","0xfcd4","0x1402","0x102f","0x0e0","0x114e","0xd1f1","0x11f1","0xf2e1","0x1a2","0x4e2","0x123","0xe14f","0x2d2f","0xe0f3","0x2100","0x13fc","0x0f01","0x0c2","0x34fe","0x220f","0xf412","0xfe4f","0x34e5","0x51","0x3054","0xff6f","0x30ed","0x0f22","0x1d2d","0xe12f","0x6231","0x14d2","0xd032","0xe1e2","0x4210","0x2dee","0xc414","0x0d52","0x14e1","0x722f","0x4f33","0x0e41","0x402e","0xf227","0x41","0xed43","0x0f10","0xf001","0xfe31","0xd1c0","0x1f1e","0x0bff","0xd2f0","0x2d30","0x0f0c","0x113f","0xd142","0xfef2","0x2f31","0x1ef3","0xf010","0x0b10","0xc12f","0x2472","0xfee2","0x1f30","0x2cd1","0xa1de","0xe3f4","0xe29c","0x120a","0xe1e2","0xf102","0xd163","0xef72","0x222d","0x2fe","0xa003","0x2e0f","0xef44","0x0ef","0x2022","0xdfc2","0xe210","0x250d","0xc39d","0x3f0","0x1d10","0xf2a1","0xef22","0xff4d","0xff3d","0xa2d0","0xcdac","0x3df0","0x0c64","0x0eef","0x1572","0xf1e0","0xd11e","0xe5ff","0xcfdb","0xf7f2","0xfa12","0x119f","0x1031","0xf13e","0xfb0b","0x9f0f","0x0dae","0xe11f","0xfa70","0x0eee","0xd12f","0x2cd2","0xc1f1","0xcffe","0xd1ab","0x141d","0x11ff","0xe2be","0xef50","0xff7f","0x20f","0xe0d3","0xb422","0xc22d","0x3d71","0x2d01","0xd242","0xd02f","0xd130","0xef1e","0xb29c","0x1516","0x0b3e","0xcc91","0xff3f","0xf159","0x2eed","0xb1df","0xbad0","0x1100","0xf054","0xf0fe","0x451","0xfe50","0x5025","0xff15","0xa01d","0x3700","0x0d41","0xecb1","0xf13d","0x33fe","0x5f1","0xcee0","0x0cee","0x31e0","0x0df1","0x24d0","0x2e0d","0xf201","0x3123","0x210d","0x5db3","0x700f","0xfc04","0x2fdf","0xc200","0xd332","0xd90c","0xee32","0x1001","0xd27c","0xfec3","0x9122","0xf2df","0xd642","0x9627","0x1c1d","0x2f95","0x0d07","0x2ca7","0x27b1","0xd011","0xbef3","0x6e29","0x319","0x7ff","0xc0f0","0x23","0xf201","0x2132","0xf271","0x3126","0x0f13","0xee11","0xf0f2","0xf469","0xd0fd","0xfd1f","0x5a4d","0xd671","0x510f","0x0ba1","0x27","0x2b5e","0xc112","0x5e02","0x0ff2","0x0f00","0x3d16","0x21e","0x31e0","0xef12","0x113f","0x0e4e","0xe330","0x0ff0","0xe121","0x7312","0x1146","0xfc22","0x1d06","0x4323","0xc027","0xbe02","0xf010","0xd404","0x50e5","0x372e","0x0f1e","0x2d4e","0xd230","0x70f0","0x1f01","0x4c33","0x2010","0xf2ee","0x6ee1","0x30e7","0xf120","0x1034","0x0c2","0x2f00","0x41f0","0x1f3e","0xfd10","0xe431","0x3322","0x520f","0x4da1","0x0c1f","0x3f14","0xddf0","0x3e01","0xf22b","0x0cfe","0xefd4","0xed1f","0x53cf","0x1fd3","0x2f03","0x119d","0x2e0","0xdd3c","0x1fe","0xcff1","0x62e5","0x0d21","0xedfd","0x0fd","0x121d","0xfce0","0xd1f3","0xaf1f","0xe09f","0xd0ff","0x0ef0","0x2e9e","0x1de0","0xc95b","0x0efb","0x92d0","0x7904","0x0fd","0xf111","0x0f19","0x201a","0x1fe5","0x2ff","0xafe1","0xe4ff","0x211f","0x0e00","0x22e2","0x2ef3","0xfc1f","0xeffd","0xd4e0","0x5af2","0x1e0","0x11e","0x1d2f","0xefee","0x10c4","0x10c2","0xfbe1","0xf30d","0x0e2f","0x110","0x22e2","0x31ef","0x1400","0x20f0","0xdd11","0x4ff0","0x10ee","0x0f22","0x2d4f","0x30fc","0x0dd1","0xc0dc","0x0c20","0x1c3","0xf300","0xf012","0x25ff","0x30ff","0xeefd","0xdbe9","0x9ef0","0x3be3","0x0e01","0xe00a","0x4f29","0x23f2","0x0f5","0x700d","0x3030","0x300e","0x2e1f","0xfe0f","0x0d00","0x411e","0x0eff","0xd00f","0xdefd","0xe930","0x2bc2","0xf3ed","0xbfe1","0xbbe1","0xee1c","0x09ab","0xd0e2","0xf97a","0x3e03","0xe330","0x5040","0x7315","0xf6fa","0xfec3","0x13f1","0xff0a","0x7f9f","0x96ed","0xfc91","0x90ce","0x2fee","0xe9dd","0xcf14","0xd979","0xfe02","0x2c7f","0x3f4e","0x2b67","0x27f9","0x6db7","0x24e4","0x0d0d","0x7fbe","0xccef","0x0f93","0x90de","0xffff","0xfeef","0xcff3","0xff7d","0x0ef2","0x0f7c","0xf011","0x34","0x372c","0x1eb7","0xe212","0x0c1b","0xde01","0x3cfe","0x121f","0x45fe","0x100","0xe0f0","0xf04f","0xbe4d","0x0ff1","0xec41","0x1120","0x4604","0xf60b","0x302e","0x41f0","0x111d","0xc09f","0x2d4c","0x3693","0x4f01","0x0e2","0x3a1f","0xee4e","0xfd7d","0xf030","0xb374","0x1e2e","0x4603","0x240e","0x0f2","0x3e2e","0x451","0xd13e","0x2d4f","0x3190","0x4001","0x2203","0x0e20","0x10fe","0x303f","0x2fd","0xf351","0x1111","0x4","0x232f","0xe0fc","0x402e","0x24","0xf102","0xf101","0x0ef1","0x1f0","0x20","0xc110","0x114","0x11f0","0x2f0f","0xf1f0","0x1010","0x20e0","0x1de1","0xf02f","0x1f1f","0xee0e","0xe10e","0x2d02","0x0fe1","0x1010","0xf130","0xaef0","0xd10d","0xe1e3","0xe005","0x4ee","0x2f01","0x41c3","0xe0d0","0x3011","0x0fc2","0x11d0","0x1f12","0x0b02","0x1210","0x2e1d","0x1fe0","0x4fe0","0x4e2e","0x131e","0xfcff","0xed2f","0x1920","0xd3fc","0x22ff","0xb111","0xf1ff","0x200f","0x122a","0x2301","0xec22","0x12e5","0x0ef","0xa32f","0x1022","0xd22e","0x6e02","0x1fcd","0x1030","0x1c0f","0x5db1","0x1430","0xf1eb","0xe2e0","0x0c94","0xe70d","0x704d","0x5f02","0x212d","0x6edf","0xc191","0xa12c","0xb2e1","0x1229","0x3e3f","0x336e","0x5e1a","0xc7f7","0xddf7","0x0a22","0x5db3","0xf04b","0xeeb5","0x3d1d","0x2dde","0x1cd9","0x20c","0x707c","0x3e1d","0x0f61","0xf94f","0xf3e1","0xc711","0x17d7","0xde1c","0x421","0x23f1","0xb1c1","0xf9a2","0xcefb","0x30ef","0xc0ef","0xd713","0x0fbe","0x2de2","0x1ed0","0xde01","0xccde","0xfd5e","0x0d00","0xb015","0xae31","0xf201","0xf1f3","0xe92f","0x1c1e","0xe0f4","0x9d4f","0x97fe","0xe1c1","0x6ef4","0x23ee","0xb0ff","0x2bde","0xffef","0x30f0","0xcee2","0xcc2f","0x1e02","0x120d","0x0af0","0x3b1f","0x14b7","0xd023","0xf515","0xf2c3","0x6f04","0x3e20","0xf02f","0xddec","0xe0ff","0x32cf","0xed00","0x0ee5","0xdffe","0xfc51","0xffee","0x151","0xed92","0xd000","0xcc0e","0xf0de","0x0e00","0x30ff","0xe0ce","0xeed0","0xf07d","0x21e2","0xb0e2","0xdde0","0x3def","0x4b31","0x0dfc","0x0d51","0xdeed","0xb104","0xfc0d","0x4ff","0xf324","0xec10","0xefb1","0x2dee","0x130","0x1f0f","0xbffd","0x13cd","0x30f3","0x234c","0x21ec","0xf050","0x2e1e","0xff04","0x0df3","0xf330","0x2513","0x0e1c","0x2ef3","0xd13e","0xf2df","0xf41f","0xfeef","0x10ef","0xffef","0x1f0f","0xef1e","0x2f00","0x0fe1","0xf10f","0x0e0f","0x202","0xe100","0x110f","0x201e","0x1edf","0xf0f0","0x3f32","0xfff2","0xcee2","0xd202","0x2ef0","0x0ef0","0x3010","0x1fff","0xe200","0xc001","0x132","0xe20f","0x1fb","0x10e","0x1ed3","0xf1e2","0x13e","0x0dc","0xeed2","0xc102","0x1ee1","0xef1f","0x10ee","0x10ef","0xd2e1","0xee0d","0x13f0","0xe0f1","0xffce","0x10e0","0x1000","0xefe1","0xfd1e","0xedf0","0x10ef","0xe030","0x2f01","0x1e24","0x234f","0x10b0","0x1121","0x1300","0x220e","0x11f1","0x10f0","0x1fd0","0xf22d","0xe00f","0x1f2f","0xef0e","0xb021","0xfe0e","0x21f","0x0bf2","0x2111","0x111","0xfb1f","0xa211","0xf2ff","0x3004","0x14cb","0xf0cf","0xf31f","0xeeee","0x0efb","0xee2f","0xea12","0x0f00","0x0f","0xfff1","0x103e","0xfef1","0x1fe0","0x1211","0xd0cd","0x1111","0xffea","0x0fe0","0x21f","0xec01","0x0fee","0x0dff","0x4ef0","0x301f","0x4c4e","0x1e20","0x11d0","0x2fef","0xd001","0xbf02","0xf12e","0x0e2","0xff62","0x3221","0xc330","0x2c4d","0x1301","0x1022","0xc024","0x210c","0x0c40","0x0d2e","0x1023","0x3fd0","0xfe11","0xbe11","0xe31f","0x26e5","0xf209","0xf11f","0xfe2f","0x2e4e","0x2","0xd020","0xe923","0x1fe0","0x0d31","0xf030","0x0f31","0x2d00","0xde0f","0xc0f1","0xe230","0x7f0","0xf01e","0xff40","0xde1d","0x1112","0x2ef4","0xef2d","0x2b32","0xf00d","0xdd74","0x0dde","0xf05e","0xfcb2","0x90e0","0xcf00","0xb09c","0x11f","0x1ed0","0xd19e","0xfe4f","0xe07d","0x1302","0xa0e5","0xcf01","0xfe1f","0x3b33","0x1ef1","0xef70","0xc0df","0xb112","0x0dee","0xc59f","0x633","0x0cf0","0xff9f","0x0d5e","0xe249","0x3fec","0xb1e2","0xe0bf","0xf0ef","0x2043","0x1fef","0x37f","0x2f2d","0xcf14","0xeeff","0xa2ce","0x1716","0x0c10","0xef93","0x123f","0x50e","0x0e0c","0xbdff","0x1fdd","0x3fe4","0xff70","0xa9f3","0xfe19","0xb1ff","0xfc04","0xee3b","0x3022","0x3902","0x0c45","0xf37c","0x40fd","0xff5d","0xf1c4","0xfd1e","0x911f","0x729d","0xc0f4","0xa9df","0xbf09","0x9d2f","0xfbe6","0xad00","0xfc70","0xfd03","0x7f2f","0x3021","0x4c1d","0xf03d","0x1227","0xc9d2","0x97fd","0x1ce","0xc2d4","0x49ab","0xbe19","0xc127","0x2102","0xa1e3","0xd120","0xeefe","0x5f3d","0xcc63","0x1e41","0x0e0c","0x0f44","0xd9c1","0x25dd","0x1ef","0x0ef0","0xef0f","0x1021","0x20f","0xf10f","0x0f","0x2","0xf001","0xf1f0","0x2f10","0x0ff","0x0e0","0x0e2f","0x0e1c","0xf1e1","0xe310","0x0fd0","0xff01","0x101f","0x3120","0x101","0xa011","0x1f13","0xf00e","0x30ff","0x2f","0xef1f","0x0e1","0xf22e","0x210","0xeef0","0xc111","0x1fe0","0xffff","0x1eff","0x1010","0x101","0xff1f","0x20f0","0xffff","0x0fff","0x110f","0x2f0f","0x1000","0x2f1f","0xf100","0x1ff1","0x7113","0x20ef","0xfdf1","0x1fc1","0x1f21","0x2ef1","0xd002","0x20ff","0x0ee0","0x1f0f","0x2102","0x2c21","0xdc02","0xc0d0","0x12e2","0xced1","0x6023","0x41d0","0xe951","0x102f","0xfff3","0xccc1","0xc71e","0x10e4","0x2cff","0x0f1a","0x2dd1","0x6ee4","0x19fe","0x2fe3","0xad02","0xf9c0","0x5020","0x2fe","0x2050","0xfdd1","0xfe12","0x12f1","0xd7ff","0xf304","0x1df1","0x0d3c","0xeed0","0x6fd0","0xf01f","0x30f5","0xbdf4","0x29d3","0xd10d","0x0b7f","0x1e01","0x203f","0x1ed1","0xcf00","0xdd0f","0xefde","0xf30e","0x3de1","0xefce","0xe102","0x5e","0x112e","0x0ee0","0xdf11","0xe11d","0xfc5f","0x0ff0","0x1e52","0xde11","0xf0f2","0xcdd0","0xe1e1","0x1232","0x2ce1","0x0e90","0xf033","0xf2f0","0x31ff","0xa1e1","0xbfa1","0xc01f","0xfee1","0xe0e0","0x2e30","0x2021","0xf004","0xed00","0xf20e","0x1014","0x1de0","0x1fce","0x1f1e","0xf1df","0x0f0e","0xdfe2","0x12c0","0x3f3f","0x511f","0x3ff2","0xf00e","0x0fe2","0xf101","0x24ff","0x1e11","0x341e","0x21d0","0x0f2","0xef4c","0x42","0xde1f","0x102f","0xa210","0x303d","0x2300","0x0ef2","0xef03","0x0ef","0xe12e","0xc11e","0xeece","0x2424","0x3d0c","0xefe0","0x1f7f","0xee5e","0x4fe0","0xe02e","0xcaf3","0x1122","0x13f2","0x10d","0xe000","0x12f","0x13d","0xc103","0xff42","0xf60e","0x0f1e","0xeff1","0x0f32","0x1c3f","0x400","0xd0f3","0x0c20","0x100","0x1f32","0x0f0","0x420f","0xf1e2","0xe745","0x1e0","0xe5c3","0x121e","0xf9d1","0xd1ef","0xcdfb","0xfaf2","0xef3e","0x1e3f","0xff13","0xe17c","0x4f25","0xec0c","0x7300","0xfe10","0xd722","0xe1ef","0xf5c6","0x1303","0xe7c9","0xe0df","0x0ee1","0xebe2","0x1d7c","0x0900","0xe9f1","0x0f70","0x20f4","0x0d0e","0x7f00","0xf01d","0xf6f0","0xef0e","0x0fa3","0x11f0","0x0fa9","0x1fc0","0xf44e","0x0bd3","0xfe7c","0xeb0e","0x0cf3","0x32f5","0x3e3f","0xfb0d","0x47de","0xf001","0xdf01","0xe011","0x1ec2","0xe12f","0xb211","0x0b1","0x1de0","0xfe42","0x1c0","0x40e","0x70e1","0xf1f0","0x2bfe","0xc209","0x1de1","0xfdeb","0xdf27","0xdc3e","0xe09e","0xf011","0x131f","0x169f","0xcca3","0xcd16","0x09fa","0x140f","0x7aef","0x1001","0x0f21","0x11c9","0x31f0","0xdc0b","0x0c3","0x0ff0","0xf10e","0x3e22","0x253f","0x3ee0","0xd202","0xdf14","0x4311","0xc0ff","0xfa31","0x4f9e","0x36df","0xe021","0xe390","0x130b","0x3a1c","0xd022","0x0c4d","0x61f5","0xb970","0x5141","0x162","0x70fe","0x31e4","0xf01d","0xff1e","0x709f","0xf6db","0xee40","0xaed0","0x32fb","0xf9ed","0x9133","0x0a5d","0xefef","0xb170","0x3f4d","0x0b43","0x4c2a","0xedf7","0x212e","0xec23","0x62df","0xfd1d","0xe212","0x9fed","0x2f0c","0x1eee","0xe412","0x0e7e","0x0f02","0xe140","0xd133","0x0be4","0xf14e","0xeee7","0xf210","0x0c1f","0x4e00","0xeee1","0x1e4","0x1112","0x0f0","0x1312","0x52c3","0x5ff2","0x11fc","0x0c0e","0xf42f","0xe1fd","0x2f04","0xe11f","0x1030","0xcf11","0x10fe","0x0aee","0x11f2","0x2f00","0xf13e","0xbf20","0xcfeb","0xf1d1","0x115","0x309","0x12ed","0x0d06","0xcf0e","0x2deb","0x101f","0x4ee0","0x1001","0x1e11","0xe111","0x100d","0x1102","0x6100","0x212e","0x1e00","0xee0d","0x102","0xe100","0x10ff","0xf1e2","0xffff","0x2101","0x131f","0x2349","0x1c23","0x0c13","0x7041","0x0b23","0x9a26","0xfe6d","0x9494","0x7e04","0x10f","0xddde","0xc92e","0x1bfd","0x210d","0x16e9","0xf20f","0x9f1d","0x0ef4","0xe6ab","0x55e9","0x531","0xc6f4","0x24de","0x90f4","0x1df0","0x2c09","0x4c11","0x56d3","0xc927","0xf00f","0x1cd7","0x6a20","0xed1e","0x0f50","0xd332","0x3012","0x0c04","0x1e13","0x21df","0x1223","0x0e11","0x1022","0x1c3","0x702","0x2604","0xf102","0x2424","0x412f"},
{"0x201","0x0f0","0x1f0d","0x1d20","0x1ee2","0x33d1","0xfe0d","0xd010","0x0ff3","0x20e0","0x0fff","0x2fed","0xcff2","0xff10","0xe000","0x1e1","0x0e2d","0x7345","0x0fb","0x22ff","0x423","0xbfe2","0xcf9b","0xc010","0x0f07","0xddac","0x701b","0x30f4","0x9f00","0x632f","0xeee0","0x54d0","0xf134","0xd72b","0xb2f5","0xfe02","0x33ff","0x73ff","0x5f57","0x2244","0x4243","0xf343","0x6905","0xedec","0x63e1","0xc731","0x20c4","0x1f32","0x1e0","0xfc21","0x12f0","0xe00e","0x1fe1","0xdf30","0x24e1","0xe5cf","0xe01e","0x51c1","0xd0ce","0x141","0xdf1e","0x2e4d","0xf0cf","0xf1e1","0x13c1","0x1b53","0x2f0","0x32f0","0x1f23","0xe111","0x3412","0x5cf","0xf34e","0x71df","0xefb4","0x1541","0x0de2","0xe16f","0x1fbf","0x0fe1","0x0e31","0x3f33","0x30c1","0x11f0","0x21f","0xedf1","0x43ff","0xf0a4","0xe31f","0x3fee","0x2ed0","0xf151","0x1fc2","0x1f","0x2cf2","0x2ef0","0x12f1","0xf3f2","0x20f","0x100","0x11f","0xf000","0xf0f1","0x100e","0x1101","0x1000","0x101","0x1ff0","0x12f0","0xf020","0xf1f0","0xff11","0xf1f0","0xf502","0x11e0","0x1f00","0x3","0xfef0","0xf0f1","0x10","0x202","0x1001","0x2e3","0x2f0f","0x1011","0x2f2","0x1110","0x2e0","0xf00f","0xf000","0xfeef","0xfe1f","0x0f05","0x0e02","0x0f10","0xef0f","0x0f00","0x2f01","0x100","0x120d","0x1f","0xf111","0xf112","0x2e0","0x10f0","0xf112","0x0e10","0xf02f","0x1021","0xf021","0x0e1","0x3100","0xe0ee","0x11df","0x122","0xf10f","0x102f","0x3f10","0x2210","0x2100","0xee0e","0x22","0x10","0x1030","0x21e2","0xfe11","0xf1d0","0xe1f0","0x21ef","0x1df","0x10d","0xf210","0xed21","0xe1e5","0xf210","0x1f3","0xef11","0x101f","0x101f","0x2132","0x21e4","0x311e","0x1f0","0x0fe0","0x11f","0xfeef","0x0fff","0x0f01","0xd011","0x312","0x20f","0x0fd3","0xe2e3","0x124e","0x4030","0x0f0d","0xea0f","0xe101","0xf62b","0xdfc3","0xdbf1","0x2f1","0x309e","0xee0c","0xb002","0x1000","0xa000","0xa100","0x2d6","0x21d1","0xffc0","0x20d1","0x9d21","0xef27","0xd34b","0xf1a3","0x3ae2","0x6de3","0x5fb9","0x2fd1","0xcf12","0x4af2","0x9c10","0xd03d","0xe122","0x100","0x21e3","0x21f1","0xe051","0x1f35","0xf04c","0xd113","0x0fff","0xeeb2","0x1fcc","0x30f","0x20de","0x1140","0xed3f","0xdef2","0xf100","0x0b12","0x13f0","0xf11e","0x11fe","0xd001","0x1301","0xf5df","0xe51e","0x63d2","0xffdf","0xf42c","0xe0ef","0x0f3e","0x10fe","0x2e1","0x1132","0xed55","0x34c1","0x204e","0xf111","0xe0f2","0xc212","0xf5c0","0xd51b","0x70e1","0xffaf","0x145f","0xf5ee","0x34e","0x2edf","0xde11","0xff41","0xff23","0x11ff","0xf23f","0xfff1","0xfee1","0x32ef","0xefd1","0xf31f","0x50ff","0x1fc0","0x20","0x0d2","0x102f","0xfef1","0x2e01","0x0f31","0x51","0xf004","0x6f2d","0xdbc2","0xc123","0xe2f0","0x0b91","0xfcef","0x3f11","0x2c1","0xe202","0xee61","0x131f","0xb2d0","0xa1dd","0x312e","0xdb4f","0xed2b","0x301f","0xcddd","0x2234","0x201c","0x1ec0","0x0b0e","0xed1f","0xf1c0","0xc12f","0xee2f","0x0f2f","0xa30f","0xe0b9","0x3e0f","0xee1f","0xee0e","0x2f5e","0xbfdc","0xe472","0xee20","0x0be","0xf41f","0xeb01","0x1fc0","0x101","0x30","0x5c2e","0xb0fe","0x309c","0xf23f","0x1b61","0x0ffe","0x6e31","0xbbc1","0xe113","0xff09","0x0da0","0xdacf","0x1d01","0x139c","0xd0f1","0xec72","0x202","0xb1f2","0xe3ed","0xf0fd","0x6f64","0xfefd","0x550","0xa10b","0x333","0xbfdc","0xe1f0","0x2ed3","0x0d1e","0xeffb","0xffde","0xbe31","0x4fef","0xb0d0","0xeeb9","0x22ff","0xf13e","0x1120","0x410","0xfdfa","0x4147","0xfdf6","0xc410","0x2612","0x1de1","0x0ccc","0x2d","0x11df","0x14ff","0x1011","0x2ebe","0xa132","0xb920","0xddbf","0xf1ff","0x1e5f","0x4eff","0x11ba","0xfc3e","0x9e10","0x2054","0xf202","0xb013","0x9539","0x3c52","0x1d74","0xfe52","0x092d","0xf915","0xa3d2","0x9f7d","0xebe3","0xb127","0xde79","0x3b5b","0x6b9c","0x13a7","0xd00b","0x90a6","0x97e5","0x29ab","0x54bc","0x17e1","0xf0cd","0x2dc4","0x3259","0xf021","0xe202","0xd1e2","0x19b4","0xc294","0xe213","0x7e93","0x1e4","0x7211","0x595f","0x327f","0x205","0x0fd0","0xb2f5","0xe91b","0x1042","0x22ca","0x0cda","0xf03e","0x5e03","0xe2bf","0x1ea0","0x410","0xbcdf","0xdf4b","0xe3f0","0xbe0a","0x3cf","0x0ff","0x9ee3","0x092f","0x1c2e","0x170a","0x2119","0xc262","0xe9dc","0xc4ce","0x3d92","0x13cc","0xaa9d","0xe54e","0xb2c1","0x6109","0x1fda","0x310a","0x9fe1","0x1d0b","0x3c10","0x20a4","0x63e9","0x17f","0x2913","0xefee","0x10f0","0xf3df","0xca0f","0xb43e","0x32bf","0x2f19","0x3fef","0x3edf","0x3e22","0xdcf3","0x1b1f","0xe35c","0xeac6","0x10f1","0xf0dc","0x0e94","0xe13d","0x2f13","0x1b3","0x2f2","0x9f5b","0xff0c","0xa231","0x33f0","0xbd2e","0x09e0","0x1ce9","0x72a","0xfda0","0xe0b4","0xd919","0xdd90","0xdf01","0xe101","0xe0a4","0x40d2","0x9e5f","0x0e09","0xa5fd","0x7c59","0xe0ef","0x10e","0xfe29","0xf44e","0x11cd","0xe1f3","0x0a01","0x23a1","0x2f","0xff11","0x0eef","0x4f25","0x0d22","0xe02b","0xc10f","0x4d0c","0xe0e0","0x191d","0x1231","0x10f","0xf9d2","0xd12e","0xecfc","0xf0cd","0xe13f","0x2fb0","0xe0de","0xeecf","0xd400","0x30fb","0x9141","0x2e2d","0xef0b","0x4a0d","0x30fc","0x370e","0xdadb","0x9be3","0xfe29","0x093","0x1023","0xc1f0","0x164f","0x21de","0x9e10","0x0ce9","0x9dd2","0xfd10","0xae00","0x1e0d","0x5e39","0x3c1","0xc00a","0x4e95","0x3efd","0x1100","0x4fff","0xe01f","0x0e0","0x1e2e","0xebf3","0xf131","0xfeff","0x3b5e","0x7520","0x2f0","0x2e0d","0xe341","0x2f24","0x0de1","0x9306","0x6504","0x1062","0x9ca1","0x3c7","0x1a51","0xab72","0xad74","0xf02d","0x222f","0x77d2","0xc3e7","0xfe1e","0xaf10","0x146","0x47d5","0x9725","0x5146","0xb37c","0x7a99","0x4b7","0x6940","0x1979","0x3077","0x2931","0x29d4","0x7af0","0x91d7","0x30fc","0xb110","0x4353","0x30b5","0xb72f","0x4ac3","0xfd31","0xfda9","0x0e7","0x3301","0x2b7c","0xe137","0xff10","0x0bdc","0xe6d5","0x5939","0x11ff","0x2def","0xfed3","0xcb2e","0x2ecd","0xf7c0","0xf27f","0x7c2","0xffa3","0xa229","0xdd13","0x9c70","0x10b1","0xd205","0xe793","0x39f4","0xf34d","0x42bb","0x1e31","0xc3ef","0x911d","0xf7bc","0xf772","0x79b9","0xdf05","0xd511","0xbaeb","0x6b79","0x0ec1","0x0e4","0xfa91","0x2ff4","0x3f3a","0x46df","0x0d1f","0xc021","0x530e","0xe09a","0x3d0","0x2be9","0x0dd6","0xfdef","0xddcc","0x0f1","0xd331","0x2df5","0x222","0xb4f0","0xff13","0x0f0f","0xfdf0","0x0f1","0x106","0x1102","0x0f5","0x2df","0x1000","0x1fdf","0x1001","0x232e","0xfee0","0xe1ef","0xfe2f","0x6154","0xc01d","0x122f","0x1131","0x9204","0xc12c","0xe1f4","0xf1f7","0xefe1","0x6f1d","0x2ff3","0x90e2","0x51ff","0x09d","0x44ef","0x1501","0xee2c","0x2127","0x20f2","0x2001","0x421e","0x5152","0xf322","0xc214","0x32f","0x1923","0x0eb","0x531e","0xaf13","0x1fc3","0xef11","0x0cfe","0x3f10","0x4220","0xff1e","0x30c0","0x9321","0x3340","0xf3c1","0x412d","0x14bd","0x2c0e","0x16fc","0x2d03","0x21cc","0x11b0","0x2ff0","0xf7d2","0x57da","0x1f7f","0x7fd3","0x6fe","0xec2e","0xd397","0x15b7","0x5216","0x4ed9","0x70de","0x7e4a","0x1ae3","0x3530","0xdacf","0xf020","0x4900","0x401d","0x9117","0x7095","0x10","0x330b","0xf21a","0xf256","0xb3b1","0xee7b","0xe932","0xdd0a","0x702a","0x1733","0x1aed","0xed13","0x20d1","0xb0ed","0xfa03","0xcceb","0xccbd","0xeff2","0xe534","0x1fc0","0x2b1e","0x52f3","0xa0f3","0xf1de","0x1d40","0x1100","0xb243","0xfd0b","0xd10e","0x3f3","0xfb30","0x321","0x90e2","0x9347","0xa14b","0x3b3","0x1ee0","0x5c0f","0xb23c","0x32fe","0xf1e2","0x5e2f","0xd20f","0x0ef9","0x1f1","0x32ed","0x0aea","0x4d36","0xd1c7","0xe117","0x1f20","0xd1f2","0x40f2","0x3e12","0xfdfe","0xdb0b","0xf2de","0x26df","0xdff2","0x1ed2","0x302d","0x3e00","0xdffc","0x6f4d","0xb0b0","0xef20","0xcc3c","0x0dd0","0x0d21","0x0e1","0xf0b1","0x0fd2","0xbf6f","0x1200","0xbf30","0xc1de","0x3f0c","0x6f1f","0xf1c0","0xf12b","0xbbdc","0x220","0xfc1b","0x1100","0x22f0","0xee10","0x1fd0","0x0bbe","0xf210","0x4d01","0xdd33","0x71a9","0x1303","0x51d","0x31dd","0xff0e","0x310e","0xf035","0x0f05","0x1200","0x27f2","0x1fdb","0x3ec2","0xe20e","0xf1d0","0x1501","0x2e23","0x0cf","0xcfd2","0x1","0x14fd","0x3f2f","0xee02","0xf331","0x5dee","0x15c1","0xd00f","0x14df","0xdfc0","0x3db1","0xc0e0","0x1200","0x22b3","0x5fe0","0xc0d0","0x1ff4","0x3612","0x3000","0xde00","0x241d","0x7cf0","0x27e4","0xf0bc","0xdcd3","0xdfcc","0x24d0","0xd4d1","0x512b","0x10c3","0x77fe","0x212","0x21f2","0x3300","0x3e02","0xc3f3","0x4ef","0x4c2e","0x13ce","0xeef2","0xf0e3","0x32d0","0x160f","0x0bf","0xc11c","0x3232","0x1601","0xe0f1","0x0e02","0xf112","0x3220","0x0fc1","0x1f12","0x20af","0x12ff","0xdfcd","0x37e1","0xe1bf","0x2fd","0xef1f","0xd04e","0xb3f1","0xf1d0","0xed0f","0x2302","0xf330","0x322","0xe2f3","0xed11","0xe090","0xe3d0","0xcd92","0x4f0b","0xa1c9","0x161f","0xfd12","0x1e0e","0xd0a0","0x0ede","0xfb0f","0x2f2","0x232","0x2430","0xfff2","0x1d","0x0ff0","0xc1de","0x12","0x20dd","0xfecf","0xe21f","0xfd11","0xed1e","0xf0ff","0x1df0","0x0","0xfb41","0x0f1e","0x201f","0xddd4","0x9e20","0xffcf","0xd791","0xd11f","0x41f0","0xd0be","0xe421","0xde61","0x122e","0xd1d1","0xc001","0xfc2f","0xbe52","0x1e0d","0x204d","0xeccf","0xb035","0x9c1d","0xe7a2","0x440b","0x5d1a","0xafab","0x2521","0xd03f","0x3f4e","0xe0c0","0xfcb0","0x10ff","0x2f23","0xe1df","0x114f","0xefef","0xaf32","0x0d2f","0xd291","0x1713","0x2e0d","0x1da0","0x2e10","0xe2b0","0x0d","0xcbee","0x3ea0","0x10ed","0x1d40","0xde0d","0x6f21","0xecce","0xb011","0xfe1b","0x1b90","0xfbf0","0xee11","0x129f","0xe0f1","0xbf70","0x2222","0xb3f0","0xc0dd","0x1ffc","0xdd32","0xee4f","0x1031","0xcbdb","0x1253","0xfd0e","0xdda3","0x1c2e","0xee10","0xf0d0","0xeefe","0xe13f","0x4001","0xc201","0x1fca","0x110e","0x500f","0xf1fe","0x0f40","0xeefb","0xc254","0xffef","0xe3c3","0x501","0xfdef","0x1e9e","0xf0ee","0x32f","0x310f","0xed0f","0x30ad","0x3f01","0xa231","0xd940","0x390d","0x9d31","0xc032","0xf2d2","0x3fc1","0x0e0f","0x1d25","0xd349","0x3b3e","0x0d20","0xa3e6","0x0f0f","0xb431","0x5cde","0xf0f3","0xd95d","0x0f1b","0x9a47","0x0dc7","0xa64b","0x2d2e","0xaa0e","0xfad1","0xfffb","0x6931","0xcd1c","0x6116","0x3923","0x76d0","0x12e0","0xacb2","0x3e4e","0xa42a","0x9207","0x40cc","0xa401","0x1cf0","0xdf0f","0x3a1e","0x9c2f","0x2150","0xebdf","0x2c37","0xa91f","0x43ac","0xef11","0x1ff1","0x30d","0x201f","0xf021","0xf213","0x1f0f","0xf5f1","0xe11f","0x12c0","0xfeff","0x1e00","0xe0e0","0x1050","0x21f1","0x2000","0xc432","0xf1f2","0x2300","0x100f","0x121","0x520","0x7ef2","0x1403","0xf2ee","0x7fd0","0xefcd","0x110f","0xe0d0","0x16d","0x21d2","0x13ff","0xcf21","0x0f12","0x10ff","0x2011","0xf002","0x140f","0x1e0e","0x1ee","0xfff1","0x10e1","0x1c0","0x1101","0xffde","0xff2d","0x2010","0x4f1","0x0dd3","0x0ff2","0xfd01","0x3f14","0xf901","0x113","0xf1dd","0x0ece","0xffbc","0x35d2","0xdedb","0x4110","0x2af2","0xd11f","0xe15e","0xefc0","0x3db2","0x41b2","0x1e","0x32d","0xdc0f","0x11e4","0xc03c","0x4ea1","0x5b90","0x3b0f","0xde29","0xf032","0x19f1","0x2c12","0xc17f","0x09ae","0x10e3","0x361d","0xe210","0xdff4","0xf2ff","0xfe05","0xe01f","0x301","0x0fd1","0x2cef","0xddf9","0x4f4f","0xf102","0x3e0f","0xef51","0x0bc0","0xe04f","0x1f40","0x0ff","0x4e40","0xbff1","0xc122","0x2ffd","0x2fd0","0xdaf0","0x10d2","0x2cd","0x11a1","0xdf02","0x1f","0xe1f2","0x31ee","0xe14f","0xe011","0x13f2","0x1f4f","0x900f","0x242f","0x4a00","0x30f4","0xebed","0xeff0","0xf0bf","0xf0ae","0xd0ff","0x4f1b","0xf2e3","0x14bd","0xf01e","0x0ff1","0xf0ef","0x4110","0xc000","0xf434","0xfbf0","0xf2df","0xf003","0xffff","0x1dd","0x0e","0x0fed","0x4efc","0x5110","0x12f0","0xee10","0x1d10","0x0f4","0xe1e0","0x1af1","0xf2f2","0x12c2","0x35e4","0x12fa","0x3000","0xa02f","0xeffd","0x4e10","0xce10","0xe502","0xffff","0x1e2d","0x4cf4","0x42cb","0xfe21","0xcefc","0xc0f2","0xeeaf","0xd4cf","0xfefe","0x4e0a","0xa4fe","0x12e","0xcb20","0x3f00","0xdee1","0xbdb0","0xfe02","0x24f3","0x200b","0xd04e","0xff1e","0x221","0xd2e2","0xef4f","0x1410","0x2edc","0x30d0","0xf131","0xfcf1","0x230f","0xefe0","0x12f","0xdec1","0xf600","0xf21d","0x4cf1","0x0d14","0x2e3a","0x7a2d","0xf5ef","0xfdcf","0x4d1f","0xce0b","0x26b6","0x23ed","0x4253","0xc1bd","0x2cde","0xa9b5","0x62f","0x1470","0x0b21","0x0ed3","0x59ec","0x79e2","0x1531","0x1f9e","0x29b5","0xe1e9","0x27e3","0xf5e5","0x3dc","0x6bf","0x27fc","0x54b4","0x632f","0x53","0x2","0x0bf","0x2df1","0x6c22","0xf30f","0x1f1","0x1eb5","0x33dc","0x09c1","0xf5fe","0x0f9","0x2371","0x17e0","0x1023","0xcb2e","0x3cc0","0x27ed","0x4b27","0xbcf1","0xff1c","0xed94","0xc11b","0xe003","0xe1cf","0x1ef1","0x9e21","0xf20d","0xb260","0x6064","0x9d10","0xd9fb","0xdeb9","0xc709","0x7a19","0xdec5","0xdb79","0x1c9a","0xd2f0","0x402","0xa591","0xeda2","0x9c13","0x4b09","0xc5f2","0x4b32","0x9fef","0x0d3b","0x1f69","0xe73e","0x4d29","0xff22","0x3f4c","0x13cf","0x403f","0xf660","0xece1","0x1f2f","0x1b12","0x6454","0xf120","0x0b61","0x52e4","0xdc1d","0x2ef3","0xfe4e","0x1efe","0xfe42","0xf7a2","0xf7b2","0xd75f","0x67d1","0xdfc3","0xce6d","0xfc5f","0x9d7c","0xffb0","0xe2e2","0x4793","0x2a17","0x0ef1","0x3263","0xef2f","0xce12","0xa7e1","0x7a2","0x77e","0x7edb","0xbfcf","0xd451","0xe93f","0x6274","0x1ebe","0xedd3","0x0941","0x16","0x10bf","0x1632","0x102f","0xfd0f","0x62e0","0x0dc2","0x250","0x500a","0xedbf","0x1f6f","0x2c01","0x2341","0x1cf0","0x11ff","0x2ff1","0x9201","0x0f27","0x1f","0x09ef","0x5d10","0x41c5","0x30b4","0x1fda","0x133d","0x9225","0xf30b","0x3f0c","0xdf21","0xf112","0xb212","0x101e","0x6c06","0x5b","0x211f","0x230","0xad03","0x9e99","0xe2fe","0xd3f7","0xdef9","0x420a","0x2f06","0x9e1c","0x5eee","0x1fcc","0x520d","0x2e10","0x3f10","0x0e2","0xf101","0x1211","0x700e","0x1120","0xfe6d","0xd4f0","0x11f2","0x1f30","0x0fee","0x10f0","0xdd02","0x30e2","0xdf01","0x9c9d","0x9a25","0x7174","0x4e4e","0x0d32","0x9717","0x1e7e","0xcda3","0x7e9f","0x7fa0","0xbcae","0x99ad","0xced7","0x60e9","0xe39b","0xd2a1","0x972f","0x391e","0xe3f9","0x2cfb","0xf7ea","0xcbeb","0x2d99","0x934d","0xf747","0xd069","0x702e","0x7710","0x995d","0x916f","0x5b77","0x2950","0xed1e","0xed4e","0xc0e4","0xc10d","0xf033","0x170f","0xd10f","0x39","0x2e02","0x1f37","0xced0","0xc005","0x790","0x0ec0","0x3134","0x2443"},
{"0x0f0","0x2fe1","0x110f","0x1ff0","0xfff0","0xf1f0","0xfe1b","0xc0d0","0xfe01","0xf0d0","0xfffd","0x1","0xc200","0x21ec","0x101f","0x201f","0xefff","0x5223","0x111c","0x0f1","0xf3e0","0xcbfe","0x401d","0xc023","0xf1f6","0xbfd1","0x50ec","0x3e21","0xa112","0x2fd","0xf1f0","0x5e0f","0x23e1","0xd1e9","0xf127","0xede1","0x1020","0x451e","0xa107","0x3177","0x1510","0x226f","0x3b44","0x124b","0x0d3f","0x403","0x51f2","0xff12","0x0e0d","0x0b1f","0x10f","0xdff0","0xf0f1","0xfe00","0x1eff","0x3e2","0xf02e","0x11e2","0x10","0x10","0x0ef","0x2f1c","0x1fe0","0x10f0","0x211f","0xfdf0","0x3010","0x2e00","0xf001","0x1fe1","0x1c11","0xc310","0x0e01","0x10e1","0x210f","0xf320","0x2e0","0xff0c","0xf1d0","0x0ff0","0x1000","0x3fe1","0xf10f","0x1d00","0x211","0x10e0","0x1000","0xf0f0","0x10f","0x1e2","0x2010","0xf01f","0xe1c1","0xfe0e","0x20c1","0x1ef0","0x1eff","0xef10","0xefef","0x20","0x0ff","0x0ff","0xf00e","0xfff0","0xffde","0x1f11","0xf10f","0xe0d0","0xf10d","0xffff","0xf00f","0xf30f","0xfeff","0x0e0e","0x0f2e","0x0e10","0xefff","0xfd00","0xf0fe","0xe101","0x1fe1","0x0d0","0xe000","0xeeef","0xe0ff","0x0ffe","0xf0e0","0xf1ff","0xf00f","0xffff","0xe0ef","0xf02f","0x0f0","0x0e0f","0x0","0xe01f","0x1011","0xf0e1","0x0f01","0x0fff","0xff0f","0x0ff","0xff00","0xf00f","0x1f00","0x0e11","0xff0f","0x101","0x1f11","0x12f","0xf0f0","0xf3e0","0x200","0x1ef0","0xf000","0xf2f0","0x12f","0x10ef","0x1ff0","0x111f","0xf021","0x1e01","0x3f01","0x201f","0xff01","0x0fff","0x0ff0","0xf211","0xf1e0","0xc0f0","0xf1f1","0xeff0","0xf1f0","0xf00f","0x0f11","0x2212","0xf212","0x2fef","0xf0f2","0x3012","0x101","0x0","0xf110","0xf200","0xe20f","0xe000","0x10e2","0x11f0","0xe00f","0x0","0xfe11","0x12","0xc3f4","0xef22","0x2421","0xe1d0","0xbf00","0xf2fe","0x432c","0xbff6","0xd90d","0xd3d0","0x11cf","0xe1de","0xb2e3","0x1f34","0x91f0","0xf0e2","0x20e2","0x301e","0x30f6","0x1e2","0xb25f","0x22f2","0xf219","0xf1f3","0x19ff","0xc1f3","0x5fbc","0x2ff3","0xf604","0x1ee2","0x934e","0xd232","0xe0f1","0xf020","0x21f4","0x10d3","0xe14f","0xef21","0x101c","0xd0e3","0xfc00","0xe3c1","0x21ad","0xf2e0","0x100","0x1f","0xf261","0xe2f3","0x0f","0x0e11","0x11f","0xff01","0xe1f0","0xf0f0","0x1e0f","0xe3e0","0xff1e","0x1e0","0xdf00","0x1f11","0xe1ff","0xe01c","0x0ff","0xe0ef","0x12d1","0xce00","0xf3ff","0x0f31","0xf210","0x13ee","0xfe02","0xe200","0xfcff","0x21e2","0x10df","0x123f","0xe2ef","0x101e","0xef02","0xf00f","0xf11f","0x201","0x0fff","0x22","0xf0f0","0xf1e1","0x2f0e","0xdf0d","0xed0f","0x10f1","0x2","0xee1f","0x21d0","0x1e1e","0x0f2","0x10ee","0xde3d","0xdb1f","0xd100","0x603f","0xccf1","0x2073","0x11df","0x0fc3","0xf90b","0xe110","0xe310","0xc0b2","0x5f7f","0xe35e","0xc0c1","0xb20f","0xf011","0xd90c","0x1e1f","0x403e","0xcdd1","0x130","0x20b","0x0ed0","0xe9ff","0xf120","0xd1dd","0xe1af","0xd25e","0x27f","0xd2c3","0x1bb","0x3121","0xf0fc","0x0ffe","0x0d4f","0xa0db","0x34f","0x1f0c","0xefcd","0x0edf","0xed1f","0xcfdf","0x0e90","0x111f","0x503f","0xe0e2","0x16ce","0xbf1c","0xfe01","0x10fe","0x6d0d","0xce0d","0x2040","0x1ff9","0xfda2","0x191c","0xe1ff","0xd32b","0x1d3","0x1f71","0x1121","0xd111","0x20c","0xd03f","0x620c","0xe0eb","0x222f","0xd1bc","0xe250","0x1e1c","0xefa1","0x2ae3","0xeff0","0xd0cb","0x3f9c","0xbf33","0x2f4e","0xc0f1","0x32d9","0xf2f0","0xc30d","0x20f1","0xdf2f","0xfddd","0x1167","0x2e26","0xd330","0x2011","0xed04","0xf0eb","0x21ee","0xe21d","0x3231","0x0ee3","0x14fe","0xdd13","0xa0ff","0xddc2","0x22f","0xf32e","0x2ffe","0x0cfd","0x2200","0x94fc","0x1f2","0x0fe4","0x631e","0xae33","0xfb22","0xe1a1","0xf1c0","0x0f99","0x9eb7","0xfecb","0x9e4d","0xf013","0x7f6","0xcef9","0x0dd9","0xd142","0xfe33","0xc01f","0xc3d2","0xd6cf","0xf3b5","0x2074","0x40ff","0x9e5a","0xe544","0x7f09","0xa25e","0x4002","0x0cd3","0x12e5","0xc3df","0x10e2","0xef92","0x45d9","0x1ea7","0x9341","0x4b1","0xe100","0x211e","0xe400","0x1ef1","0x1210","0x4400","0xed31","0x233d","0x3b2c","0xfe1e","0x2eef","0xbf2f","0xff0f","0x30f0","0x2f1","0xf2e1","0x0cf","0x1f","0xd523","0x1115","0xfe11","0x7e0","0xe1f4","0x1010","0x39fb","0xc12c","0xefa3","0xc450","0x2fee","0x1be0","0xf433","0x62cd","0xef1e","0x2239","0xd412","0x2c2d","0x4111","0x1405","0x3332","0x1f61","0x39f2","0xf22f","0x31e","0xe20f","0x2f","0xf10f","0xe1f0","0x6110","0x2000","0xf00e","0x4e12","0xfcb0","0x3e41","0xf22e","0x1bd1","0x2df","0x1ea","0x09d1","0xff0c","0xe011","0xfed1","0xeee2","0x42c","0x1c5d","0x93f3","0x110a","0xdb00","0xe0ec","0x1e29","0xe73b","0x2ed3","0xefa0","0xf9f9","0xe9b1","0x0e0d","0xeff0","0x191","0xfac5","0x9d20","0xf0f9","0x93fc","0xfed9","0x2d0c","0xe0e9","0x1e59","0xe43a","0xf10f","0x2f10","0x09ff","0x13f0","0x41dc","0xfb0f","0x0ed0","0x4cf5","0xadf0","0x122d","0x3df","0xfe0b","0x2d0","0xfd0f","0x2d12","0xf0f0","0x0df3","0x33c","0x20ce","0x2d5c","0x0f3f","0x2c1","0xf01d","0xf1ce","0xf12d","0x41fe","0xb0ff","0x3102","0xef01","0x6f2c","0x4e1b","0x1503","0xfdf5","0xedde","0x30ed","0xfce2","0xf03f","0xc1df","0x42b2","0x12e1","0xc103","0xe229","0x90e3","0x1206","0xce10","0x0f0a","0xfc0b","0xe3e5","0xfefd","0x3fc3","0x1d1f","0x311f","0x2121","0xd400","0x22de","0x2220","0xaef4","0x23","0x1fe0","0x0e13","0xd0c0","0xfa61","0x1f2c","0xf1e1","0xd1ee","0xff12","0x130","0xb693","0xe0fd","0x21b1","0xacee","0x9021","0xd20c","0x1f29","0xbf2f","0x0f1e","0xe17e","0xb931","0x0e79","0xa241","0x30f","0xfd07","0xde0d","0x9593","0x3392","0x3ed6","0xb0a0","0x932f","0xb103","0x269","0x12a1","0x14be","0xdf2f","0x9ef1","0x1f3a","0xc044","0xe2fd","0xdd12","0x1fe0","0xa0b1","0xfedf","0x31f1","0xb0cf","0xee3e","0xe095","0x0e09","0xf200","0x23cc","0x0d2d","0xc133","0xde52","0xfc22","0x0f1","0x1202","0x0f0e","0x5ce0","0x0e9e","0xf9f2","0xd101","0xf01f","0x1cf1","0x2002","0xf14f","0x0fe0","0xaa5d","0x15c","0xfc7d","0x0d33","0x2b2","0xeef3","0x390e","0xefd3","0x3c92","0x9fd0","0x1039","0x0c1e","0xef24","0xe3bc","0xd44d","0x20cf","0xce51","0x3e1e","0xd340","0x2a51","0xf2e4","0x21f1","0x2b31","0xf220","0x1f11","0xffe1","0x3efb","0x52e","0xf041","0xe2d3","0x1001","0x21d1","0xe010","0xe210","0xe011","0x11e0","0xf110","0xe110","0xe024","0x0f0","0x1e00","0xf0f0","0x2000","0xf1ee","0x61f0","0xf2ff","0x0e1e","0xe10e","0x0fe1","0x5012","0xc030","0x1e1","0x2ff","0xaff0","0x2feb","0xe0e4","0x1106","0xd0e1","0x5fed","0x3f11","0xe0f1","0x4f2d","0x20f2","0x2000","0x3402","0xfb0a","0x3204","0x0f22","0x1e1f","0x320d","0xc002","0xff34","0x303","0x1140","0x4c23","0x232a","0x2f1f","0xfdf1","0x1111","0xdef4","0x31ee","0x352f","0x40e","0x0fef","0x1d12","0x0d","0x0ef0","0xeedd","0x2ff5","0xf13f","0x2fe","0xffee","0x41df","0x2ff","0x2eef","0x1f3e","0xed70","0x552b","0x324d","0x112","0x2efd","0xcf10","0x6017","0x12e7","0x10ff","0x21bf","0x1f0f","0xdd11","0xdf21","0xd4fe","0x0fbe","0xedf1","0x41f6","0x4b0d","0x9117","0x3cd1","0xf0ed","0x1f10","0xfd06","0xf157","0x102f","0x102e","0xe337","0x4239","0x7d51","0xf37f","0xe00b","0xe0c1","0x1ec","0xb420","0xea33","0xe9fa","0xced0","0xdfce","0xf0f3","0xe9df","0xdb0d","0x20d5","0xce03","0xceed","0x4ff2","0x410","0xe216","0xf41a","0xf22e","0xfff1","0x191f","0x1cf0","0xa2dd","0xdf12","0x11e","0x0bd3","0x3de3","0xae0f","0x0cd","0x2d1f","0xfff5","0x5142","0xb201","0x15f9","0xff00","0x440d","0x0b0d","0x1e13","0xf2d3","0x0e53","0x30f2","0x11b3","0x40e1","0x1c00","0xefe0","0xfcdb","0xf01e","0x23d0","0xe002","0x0edf","0x0fe","0x14f0","0xee0e","0x6e2e","0xcfd1","0x1f41","0xdd1b","0xfc0f","0xfbf1","0x1000","0xf1ae","0x3dd1","0xdf6c","0x1f3f","0xc1f2","0x1fd","0x1000","0x541e","0xe00f","0x0e01","0xf0ac","0x1f4f","0x0c1c","0xefff","0x2ef3","0x0ff0","0xfeef","0x2ccd","0x2f1f","0x404f","0xc112","0x20dc","0xff11","0xe4fb","0x1112","0x0e00","0x20ca","0x4134","0x0f27","0x1423","0xe212","0xf1d0","0x3010","0x21fe","0xc111","0x2400","0x5012","0x1dd","0x2011","0x17df","0xee1f","0x1f0","0x2410","0x6fdf","0x0d3f","0x196d","0x3ee4","0x9c40","0x5252","0x0dc3","0x43c0","0xffb3","0x2f2f","0x0fef","0x10b1","0x70d","0xef71","0xe1d4","0x231e","0x3f0c","0x42d4","0x395e","0x2ff6","0x9042","0x6075","0x1bc1","0x3010","0xe297","0x1570","0x120","0x0c0","0x13da","0xf041","0xecbf","0x0e01","0x3f2c","0xd1f2","0x415d","0x1ff0","0xb431","0x2240","0xd0e1","0x2e70","0xf2b5","0x2450","0xd521","0xf023","0x1121","0xff21","0x3fff","0xf1e0","0x1031","0xff2f","0x211e","0x0ebf","0xef00","0x0ef","0xf1d2","0x1200","0x1d0e","0xe121","0xe2ff","0x0f10","0x131f","0x2101","0x1000","0xf0d1","0xe11e","0x1d0f","0xe10e","0x0b94","0xc0f1","0x12b9","0x0fcf","0xf0e2","0x0d1c","0xe001","0x1f1d","0x0e00","0x3f2","0x0f14","0x121f","0xee03","0xf110","0xdc10","0xd3e0","0x2112","0xe0d1","0x11ed","0x3df","0xd000","0x1c00","0xf1f4","0x1ff1","0xd01d","0xfd21","0xef1e","0x3e3f","0xe0d3","0xcd40","0xf0ec","0xdfc1","0xdc3d","0x2ecf","0x0ce","0xf103","0x0e40","0x2e30","0xc1f0","0xef0e","0x0e1","0xc04a","0x0cf","0x5e4e","0xbeb2","0xde22","0xecec","0xdec1","0xfd02","0x4def","0xff9c","0x22fe","0xbe1f","0x3e5f","0xb0e2","0x10dd","0x1d30","0x220f","0xf1dc","0x104f","0xdfff","0xe123","0xec0f","0xc101","0x1034","0x3df0","0x0d9f","0x30cd","0xd1ce","0x210d","0xdd01","0x3edd","0xe1fd","0xed2f","0x0eee","0x7c1c","0xadce","0xee63","0xf00a","0x0b91","0xf90d","0x1f00","0xe39c","0xf1b3","0x1e72","0x2131","0xc3e0","0xf2dc","0x1e3f","0xed0e","0x10ee","0x4f4f","0xc0cb","0xd064","0xed0c","0xdd94","0x1b13","0x1e1f","0xd19e","0x3fad","0xdb4f","0x5040","0xc2c2","0x11bc","0x0e00","0x32ef","0x10ed","0xde20","0xffda","0x2066","0xfdf0","0xc2e0","0x2205","0x0df0","0xffbd","0x3fbc","0xf21f","0x214f","0x2ee5","0x3dbd","0x41e9","0xf221","0xf9f2","0x593b","0x916d","0xf060","0xf0f0","0x2bd1","0x2f2e","0xcc2e","0xc149","0x6bf3","0x22","0x23a7","0x3d01","0xfe3c","0x43b9","0x2ee0","0xe9e2","0xaf5c","0x90d0","0x233","0xc14b","0xfc2f","0xdd51","0xaf13","0xe13c","0x4ae0","0x214c","0x37e7","0x0f47","0x32fe","0x21e1","0x9bd6","0x61ef","0x9d0c","0x94e7","0x0ffa","0x1022","0x2d21","0xff2f","0xde00","0x912e","0x1d0b","0xf12c","0x4406","0xc121","0x23ea","0xff21","0x2101","0xff0f","0xf0f2","0x1230","0x11d0","0x0f20","0x2b2f","0x12d4","0xce20","0x2131","0xdee1","0xf2d2","0x1c3","0x1030","0x3e01","0x0c11","0xe311","0x3161","0xd0e2","0x2100","0x40e1","0x2203","0x4c40","0x10d1","0xaf10","0x3163","0xede2","0x1022","0xf2a5","0x241","0x31","0x0ef","0x1fee","0x0f41","0xfee0","0x1e2","0x121f","0xe100","0x422e","0x0e0","0xd11f","0x2320","0xe1f2","0x1040","0x0d3","0x12f","0x220","0x0dfa","0xef0e","0x1d23","0x4f11","0xfaf2","0x3cd1","0x2f0d","0x3a0e","0xd9cf","0xa1ef","0x2eea","0xf132","0x3","0x1e0","0xde12","0xcfe2","0x1a4c","0x41c0","0x0f30","0xe061","0x0dd1","0x0ece","0x0fd2","0x49fd","0xf990","0x9edd","0x1ee9","0xfa6f","0x3122","0x0e10","0xde5e","0x23d2","0x0e1e","0x31ea","0xf212","0xd373","0xf0e3","0x4ee2","0xf104","0xfc2b","0xded4","0xdded","0x2009","0xe142","0x1453","0x2011","0x203e","0x14d1","0x1f0e","0x25ef","0xd012","0x1fe1","0xd120","0x2143","0x222e","0x194f","0x1ba1","0xbf3e","0x4260","0xecc0","0x31f2","0xf1e2","0x1320","0xf01e","0x1e1f","0xc4de","0xe04f","0xfdf3","0x200f","0x4253","0x1e20","0x1a51","0x2da4","0xb1e0","0x4230","0xdfae","0x0f21","0xfff3","0x43f","0x132f","0x0fd1","0x12f0","0xd050","0x0ed","0x20e0","0x3330","0xe00f","0x224e","0x13d4","0xb10f","0x134d","0xd0b0","0xf24f","0x1e11","0x1f2f","0xe311","0xee20","0xe911","0x1f22","0x11f0","0x0e11","0xf041","0x200f","0x21f1","0x1dfd","0x0f20","0xf022","0xf0d1","0x33f","0x134","0xc402","0xf0ee","0xed32","0xd911","0x2101","0x0e2e","0x1eff","0x3222","0x1ffa","0xef2e","0xf9df","0xe00e","0xf30e","0x2090","0x200","0xed30","0xf2cf","0xe10e","0xd00f","0x220","0x10ed","0xc02f","0x0d0","0xd233","0x1f5","0x3e2f","0xec1f","0x1eff","0xf2fe","0xd1b1","0xdfc0","0x1210","0xe0ad","0x142e","0x40df","0x17cf","0x1f1e","0x1ff2","0x133d","0x50ef","0xf3f2","0x697d","0x3f34","0x976e","0x7162","0x1ed0","0x70f3","0xb4b7","0x2da4","0x10","0x709d","0x17be","0xef93","0x1e2","0x11fd","0x601a","0x27e5","0x697c","0xd00f","0x977e","0x7073","0x09f1","0x7f31","0x12d7","0x0f63","0x0e43","0x4d2f","0x40dd","0xd0b5","0xd09d","0x1ffc","0x0f1d","0xf50e","0x7c73","0x20","0xd05f","0x3170","0xee01","0x3c70","0x1f7","0xd23e","0xd141","0x1220","0xaef1","0x4ce3","0x47de","0x3ef4","0xfbc0","0xef0e","0x2afd","0x1ff0","0x11f0","0xe0c0","0xc1e0","0xd2d1","0x120f","0xd230","0x3227","0x9e1c","0x92f9","0x4119","0xd71f","0x7fef","0xdfa2","0x0a2a","0xf99b","0xdee0","0x32d0","0xb0d0","0xc013","0x92df","0x229","0xc3ef","0xb037","0xbf20","0xeeea","0xee0b","0xe7fb","0x4de9","0x2003","0xdef0","0x22f","0x3f13","0x221f","0x0e00","0x10f","0x91fd","0x2301","0xf3c0","0xb035","0xd01d","0x1921","0x101f","0xdfff","0x1e1","0x21","0x1d2d","0xf3d1","0xfd4e","0x1fe0","0x0fe","0x2e1","0xf22f","0x41fd","0xef3f","0xf01f","0xef60","0xea0f","0x401e","0x0f20","0xdff0","0x0ff4","0x0cf1","0xb2d1","0x2bf3","0x32e1","0x121b","0x5fe","0xf3df","0xdefb","0xe101","0x1fd","0x120f","0xef0f","0xf00d","0x0b40","0x1fe","0x3f3","0xfef1","0xd1c1","0x1c10","0x0ec1","0xf100","0x1d0","0xe49f","0x0eed","0x0fc0","0x2def","0x2020","0x9e22","0xff25","0x2011","0xfd20","0x3f11","0x0f10","0x2d01","0x320e","0x3120","0xa225","0xd200","0x7f1f","0xe024","0x0f00","0xe1e1","0xcd0f","0x7f17","0xd0ee","0x124e","0x21fe","0xf100","0x30f9","0xc1ef","0xef15","0xd0cf","0x31dc","0xffe1","0xffe1","0x0f0d","0x122","0x22de","0x3112","0x1ef1","0x21f1","0xe22f","0x2011","0xfff0","0xf30f","0xfffc","0x10f","0x10f0","0x1f0","0xf22f","0xf0d0","0x0e0e","0xfeff","0xe114","0x0a1e","0xbe36","0x703f","0x4020","0x0f03","0xe112","0x190c","0x0ca3","0x3ea6","0xc19f","0xd00d","0xaea2","0xeef7","0x4ffa","0xcf61","0xf2c0","0x91dd","0x3f0a","0xb1dc","0xf11e","0xf212","0xc100","0xdc1f","0x9332","0x2713","0x0f12","0x701f","0x7449","0x9e2d","0xd261","0x2f55","0x10","0x53e","0xc4ef","0xe0f0","0xae4f","0x0f63","0xe503","0xf22f","0x3019","0x1201","0x11","0xedf0","0x1201","0xddee","0x12d1","0x1200","0x1133"}
}
};
const ap_int<13> conv_7_inc_new[2][32]=
{{"0x114","0x0869","0x569","0x169","0x186","0x10d","0x28d","0x2e9","0x3e7","0x179","0x359","0x491","0x7ac","0x17b","0x4c1","0x29d","0x0a05","0x7e5","0x0a2e","0x14c","0x1bf","0x124","0x20c","0x114","0x264","0x753","0x175","0x1a4","0x1bc","0x0ba8","0x5ab","0x19d"},
{"0x38e","0x3e7","0x081c","0x082a","0x2ac","0x097d","0x0bbf","0x799","0x13f","0x1a3","0x238","0x2ee","0x106","0x166","0x7b3","0x164","0x217","0x0c44","0x4ab","0x501","0x721","0x0b77","0x12c","0x0bf7","0x1e4","0x08ba","0x0822","0x16e","0x1a0","0x1c0","0x4d0","0x156"}
};
const ap_int<22> conv_7_bias_new[2][32]=
{{"0x4e9d5","0x3bb09","0x4c6e0","0x6511e","0x419fb","0x36e0f","0x36c58","-0x31eb7","0x3ed49","0x33c97","0x1ff5b","0x08aa0a","-0x22e35","0x34c26","0x0aec88","0x45647","0x0d113d","-0x42507","-0x55db5","0x56e4","0x31eb6","0x2565c","0x221ec","0x2f4e8","0x42be1","0x7e9c9","0x4c5cd","0x360a2","0x2da93","0x0aa4b2","-0x9fc5","0x3c99d"},
{"-0x13a07","-0x1718a","0x34f5b","0x2a695","0x0cd0b","-0x93ced","0x118e86","0x0edd5a","0x2eeca","0x52b88","0x5bff4","0x44098","0x38a6c","0x2528b","-0x6e32a","0x276d2","0x39f89","0x0ab456","-0x1137d","0x50681","0x0c9f8f","0x150ef1","0x6262f","-0x5c5d1","0x37db7","0x092821","0x0cde4f","0x2bd05","0x56793","0x33606","0x4ce44","0x1a3dc"}
};
const ap_uint<32>conv_8_w_new[2][288]=
{{"0x98010701","0x2901f501","0x315ff4c","0x0fe01fc","0xfefd1a95","0x20c00f0","0x9500b922","0xe37d01ff","0x2fefa00","0xf6036701","0xfffaff03","0xf101fefd","0xfcfe0200","0x5ebafcfd","0x8300ff6a","0x3020002","0x1ffff21","0xdf26c400","0x10d12fb","0x1150030","0xe20bf6fb","0xe3eccf04","0xf40d0800","0x0b06fe03","0x320ff","0x5bf2fe00","0xfff10203","0x0cb2f06","0x1082700","0x0af7011c","0x0800dcf4","0xf42301fd","0x828882f6","0xb4fbc582","0x8264cbda","0x81d581f2","0x8f202e88","0xf4a2e38d","0x1bfc4681","0xdaa48481","0x8181f481","0xb7f98182","0x81e0811b","0x883ed5e0","0x818be8ec","0x36df8406","0xeb82d6fa","0x1b8584","0x98010701","0x2901f501","0x315ff4c","0x0fe01fc","0xfefd1a95","0x20c00f0","0x9500b922","0xe37d01ff","0x2fefa00","0xf6036701","0xfffaff03","0xf101fefd","0xfcfe0200","0x5ebafcfd","0x8300ff6a","0x3020002","0x1ffff21","0xde26c400","0x10d13fb","0x1150030","0xe20bf6fb","0xe3eccf04","0xf40d0800","0x0b06fe03","0x320ff","0x5af2fe00","0xfff10203","0x0cb2f07","0x1082700","0x0af7011d","0x0800dcf4","0xf42300fd","0x828883f6","0xb4fbbf82","0x8263cbda","0x81d581f0","0x8f202e88","0xf4a4e38c","0x1bfc4781","0xdba48481","0x8181f481","0xbaf98182","0x81e0811b","0x883ed5e0","0x818be9ec","0x36df8407","0xeb82d6fa","0x1b8584","0x98010701","0x2901f501","0x315ff4c","0x0fe01fc","0xfefd1a95","0x20c00f0","0x9500b922","0xe37d01ff","0x2fefa00","0xf5036701","0xfffaff03","0xf101fefd","0xfcfe0200","0x5ebafcfd","0x8300ff6a","0x3020002","0x1ffff21","0xdf26c400","0x10d12fb","0x1150030","0xe20bf6fb","0xe3eccf04","0xf40d0800","0x0b06fe03","0x320ff","0x5af2fe01","0xfff10203","0x0cb2f06","0x1082700","0x0af7011c","0x08ffdcf4","0xf42300fd","0x828883f6","0xaefbbe82","0x8263cbda","0x81d581f0","0x8f202e88","0xf4a6e38c","0x1bfc4781","0xdba48481","0x8181f481","0xb9f98182","0x81e0811b","0x873ed5e0","0x818be9ec","0x36df8406","0xeb82d6fa","0x1b8584","0x98010701","0x2901f501","0x315ff4c","0x0fe01fc","0xfefd1a95","0x20c00f0","0x9501b922","0xe37d01ff","0x2fefa00","0xf5036701","0xfffaff03","0xf101fefd","0xfcfe0200","0x5ebafcfd","0x8300ff6a","0x3020002","0x1ffff21","0xde26c400","0x10d12fb","0x1150030","0xe20bf6fb","0xe3eccf04","0xf40d0800","0x0b06ff03","0x32000","0x5bf2fe00","0xfff10203","0x0cb2f07","0x1082700","0x0af7011c","0x0800dcf4","0xf42300fd","0x828883f6","0xb7fbbd82","0x8263cbda","0x81d581f2","0x8f202e88","0xf4a3e38c","0x1bfc4781","0xdba48481","0x8181f481","0xb8f98182","0x81e0811b","0x883ed5e0","0x818be8ec","0x36df8406","0xeb82d6fa","0x1b8584","0x98010701","0x2901f501","0x315ff4c","0x0fe01fc","0xfefd1a95","0x20c01f0","0x9500b922","0xe37d01ff","0x2fefb00","0xf6036701","0xfffaff03","0xf101fefd","0xfcfe0200","0x5ebafcfd","0x8300ff6a","0x3020002","0x1ffff21","0xdf26c400","0x10d12fb","0x1150030","0xe20bf6fb","0xe3eccf04","0xf40d0800","0x0b06fe03","0x32000","0x5bf2fe01","0xfff10203","0x0cb2f07","0x1082700","0x0af7011c","0x0800dcf4","0xf42300fd","0x828882f6","0xb2fbbe82","0x8263cbda","0x81d581f1","0x8f202e88","0xf4a5e38c","0x1bfc4781","0xdba48481","0x8181f481","0xb7f98182","0x81e0811b","0x883ed5e0","0x818be9ec","0x36df8406","0xeb82d6fb","0x1b8584","0x98010701","0x2901f501","0x315ff4c","0x0fe01fc","0xfefd1b95","0x20c00f0","0x9500b922","0xe37d01ff","0x2fefa00","0xf5036701","0xfffaff03","0xf101fefd","0xfcfe0200","0x5ebafcfd","0x8300ff6a","0x3020002","0x1ffff21","0xdf26c400","0x10d12fb","0x1150030","0xe20bf6fb","0xe3eccf04","0xf40d0800","0x0b06fe03","0x320ff","0x5af2fe00","0xfff10203","0x0cb2f07","0x1082700","0x0af7011c","0x0800dcf4","0xf42300fd","0x828883f6","0xb3fbbb82","0x8263cbda","0x81d581f1","0x8f202e88","0xf4a6e38c","0x1bfc4781","0xdaa48481","0x8181f481","0xb7f98182","0x81e0811b","0x873ed5e0","0x818be9ec","0x36df8407","0xeb82d6fb","0x1b8584"},
{"0xfff770f9","0x0fffdb1","0x420304","0x4fb0009","0xff88baff","0xf8ff026e","0xfaf5fdff","0x55fcc1fe","0x2c8f3ff","0x6680729","0x0c5ff7d","0x1fcff84","0xfd00fa83","0x3fd05ef","0xfafefd03","0x5e0059a9","0x1fce3","0xfd1c08fd","0x115d300","0x1a0112","0x118ecfe","0xd1cfe809","0xfad20100","0x13020001","0x2032601","0x08dd0101","0xfede010b","0x0e90615","0x1020dfa","0x3fd0429","0x4ffe7fe","0xe7f3fb00","0xfbf10bf9","0xf8fbfcfb","0x100804f2","0x08fb0310","0x0902f411","0x0c07f804","0xfe0ff0f3","0xf2f20a0a","0xf4ff0ef3","0x0d08faff","0xf0090005","0x707f1f9","0x5f8f604","0x6f2f700","0x0efdfcfd","0x0fc06f5","0xfff770f9","0x0fffdb1","0x420304","0x5fb0009","0xff88baff","0xf8ff026e","0xfaf5fd00","0x55fcc1fe","0x2c8f3ff","0x668072a","0xffc5ff7d","0x1fdff84","0xfc00fa83","0x3fd05ef","0xfafefd03","0x5e0059a9","0x1fce3","0xfd1c08fd","0x115d300","0x1a0112","0x118ecfe","0xd1cfe809","0xfad20100","0x13020001","0x2032601","0x08dd0102","0xfede010b","0x1e90615","0x1020dfa","0x4fd0429","0x4ffe7fe","0xe7f3fb00","0xf6f70a0c","0x0afe020f","0x0e020f0f","0x0bf3f5f4","0xf5f60407","0xf60af0f5","0x1f20e0d","0x3040410","0xfafb10f0","0x0807f2f4","0x0e010503","0xf0f50b08","0xf8fa0505","0x0e000bfe","0xfb0d03f7","0xf4fe000f","0xfff771f9","0x0fffdb1","0x420304","0x4fb0009","0xff88baff","0xf8ff026e","0xfaf5fd00","0x55fcc0fe","0x2c8f3ff","0x6680729","0x0c5ff7d","0x1fcff84","0xfd00fa83","0x3fd05ef","0xfafefd03","0x5e0059a9","0x1fce3","0xfd1c08fd","0x15d300","0x1a0112","0x118ecfe","0xd1cfe809","0xfad20100","0x13020001","0x2042601","0x08dd0101","0xfede010b","0x0e90615","0x1020dfa","0x3fd0429","0x4ffe7fe","0xe7f3fb00","0x6f6fb03","0xfefcfa0c","0xef0109f4","0xf70cf3fd","0xf20d0107","0x6f80201","0xf707f30b","0x40ff20f","0xf2f1f7f8","0x10fefcf6","0x0b07f7","0xf5f90f06","0x0cfbef10","0x103100c","0xf100fa0a","0x20af60c","0xfff770f9","0x0fffdb1","0x420304","0x5fb0009","0xff88baff","0xf8ff026e","0xfaf5fdff","0x55fcc1fe","0x2c8f3ff","0x6680729","0xffc5ff7d","0x1fcff84","0xfd00fa83","0x3fd05ef","0xfafefd03","0x5e0059a9","0x1fce3","0xfd1c08fd","0x115d300","0x1a0112","0x118ecfe","0xd1cfe809","0xfad20100","0x13020001","0x2042601","0x08dd0102","0xfede010b","0x0e90615","0x1020dfa","0x3fd0429","0x400e7ff","0xe7f3fb00","0xfbf00104","0xef0a0bfd","0xf9030210","0xf304f306","0x405f2f9","0x60702","0xfc01f9fe","0xf1fe0c06","0xef020bfc","0x09f10c0a","0xf9f6faf6","0x5000ef1","0xf5feff06","0xfb0eeffd","0x110a0e06","0xf8f60c02","0xfff76ff9","0x0fffdb0","0x420303","0x4fb0009","0xff88baff","0xf8ff026c","0xfaf5fd00","0x54fcc1fe","0x2c8f3ff","0x668072a","0xffc5ff7f","0x1fcff84","0xfd00fa83","0x3fd05ee","0xfafefd03","0x5e0058a9","0x1fce3","0xfd1c08fd","0x115d3ff","0x1a0112","0x118ecfe","0xd1cfe809","0xfad20100","0x13020001","0x2042601","0x08dd0101","0xfede010b","0x0e90615","0x1020dfa","0x3fd0429","0x4ffe7fe","0xe7f3fb00","0x4fb0ffd","0xfe0d09f4","0xf40b0906","0xfff2fb05","0x0ef5f005","0xfef90eef","0x40a0cf2","0xf10808f8","0xfa09f9fe","0xef04f100","0xf5f8fd0d","0xf7fffef0","0xf6eff411","0xf8060a01","0x080efa01","0x0ef5ff0e","0xfff771f9","0x0fffdb1","0x420304","0x4fb0009","0xff88baff","0xf8ff026e","0xfaf5fd00","0x55fcc1fe","0x2c8f3ff","0x5680729","0xffc5ff7d","0x1fcff84","0xfd00fa83","0x3fd05ef","0xfafefd03","0x5e0059a9","0x101fce3","0xfd1c08fd","0x115d3ff","0x1a0112","0x118ecfe","0xd1cfe809","0xfbd20100","0x13020001","0x2032601","0x08dd0101","0xfede010b","0x0e90615","0x1020dfa","0x3fd0429","0x4ffe7fe","0xe7f3fb00","0x0df80308","0x7fcfcfc","0xfc04fef7","0xf8fb08fe","0x0ffbfbf0","0x110805f5","0x0efef20d","0x10309f1","0x0fe00f5","0x101f5f8","0xf8ffeffe","0x09faf600","0xf4f4050f","0x0df9f9fa","0xf005f106","0x7f504f9"}
};
const ap_int<13> conv_8_bias_new[2][18]=
{{"0x0dd","-0x462","0x0bbf","0x0de","-0x462","0x0bc3","0x0de","-0x463","0x0bc2","0x0df","-0x463","0x0bc5","0x0de","-0x463","0x0bc5","0x0de","-0x463","0x0bc4"},
{"-0x9a","0x1f2","0x6b","-0x9a","0x1f2","0x09f","-0x9a","0x1f2","0x0a9","-0x9a","0x1f2","0x6c","-0x99","0x1f1","0x0b2","-0x9a","0x1f2","0x37"}
};
# 23 "./src/ultranet.cpp" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 24 "./src/ultranet.cpp" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_video.h" 1
# 48 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_video.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_axi_io.h" 1
# 39 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_axi_io.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_axi_sdata.h" 1
# 86 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_axi_sdata.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 87 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_axi_sdata.h" 2

template<int D,int U,int TI,int TD>
  struct ap_axis{
    ap_int<D> data;
    ap_uint<(D+7)/8> keep;
    ap_uint<(D+7)/8> strb;
    ap_uint<U> user;
    ap_uint<1> last;
    ap_uint<TI> id;
    ap_uint<TD> dest;
  };

template<int D>
  struct ap_axis <D, 0, 0, 0>{
    ap_int<D> data;
    ap_uint<(D+7)/8> keep;
    ap_uint<(D+7)/8> strb;
    ap_uint<1> last;
  };

template<int D,int U,int TI,int TD>
  struct ap_axiu{
    ap_uint<D> data;
    ap_uint<(D+7)/8> keep;
    ap_uint<(D+7)/8> strb;
    ap_uint<U> user;
    ap_uint<1> last;
    ap_uint<TI> id;
    ap_uint<TD> dest;
  };

template<int D>
  struct ap_axiu <D, 0, 0, 0>{
    ap_uint<D> data;
    ap_uint<(D+7)/8> keep;
    ap_uint<(D+7)/8> strb;
    ap_uint<1> last;
  };


template<int D,int U,int TI,int TD> struct qdma_axis;

template<int D>
  struct qdma_axis <D, 0, 0, 0>{

    ap_uint<D> data;
    ap_uint<(D+7)/8> keep;
    ap_uint<1> last;

    ap_uint<D> get_data() const { return data; }
    ap_uint<(D+7)/8> get_keep() const { return keep; }
    ap_uint<1> get_last() const { return last; }

    void set_data(const ap_uint<D> &d) { data = d; }
    void set_keep(const ap_uint<(D+7)/8> &k) { keep = k; }
    void set_last(const ap_uint<1> &l) { last = l; }
    void keep_all() {
       ap_uint<(D+7)/8> k = 0;
       keep = ~k;
     }

    qdma_axis(ap_uint<D> d = ap_uint<D>(), ap_uint<(D+7)/8> k = ap_uint<(D+7)/8>(), ap_uint<1> l = ap_uint<1>()) : data(d), keep(k), last(l) {}
    qdma_axis(const qdma_axis<D, 0, 0, 0> &d) : data(d.data), keep(d.keep), last(d.last) {}
  };
# 40 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_axi_io.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h" 1
# 36 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_half.h" 1
# 3274 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_half.h"
extern half half_nan(const char *tagp);





extern half half_atan(half t);
extern half half_atan2(half y, half x);
extern half half_copysign(half x, half y);

extern half half_fabs(half x);

extern half half_abs(half x);
extern half half_fma(half x, half y, half z);
extern half half_mad(half x, half y, half z);
extern half half_frexp (half x, int* exp);
extern half half_ldexp (half x, int exp);
extern half half_fmax(half x, half y);

extern half half_fmin(half x, half y);

extern half half_asin(half t_in);
extern half half_acos(half t_in);
extern half half_sin(half t_in);
extern half half_cos(half t_in);
extern void half_sincos(half x, half *sin, half *cos);
extern half half_sinh(half t_in);
extern half half_cosh(half t_in);
extern half half_sinpi(half t_in);
extern half half_cospi(half t_in);
extern half half_recip(half x);
extern half half_sqrt(half x);
extern half half_rsqrt(half x);
extern half half_cbrt(half x);
extern half half_hypot(half x, half y);
extern half half_log(half x);
extern half half_log10(half x);
extern half half_log2(half x);
extern half half_logb(half x);
extern half half_log1p(half x);
extern int half_ilogb(half x);
extern half half_exp(half x);
extern half half_exp10(half x);
extern half half_exp2(half x);
extern half half_expm1(half x);
extern half half_pow(half x, half y);
extern half half_powr(half x, half y);
extern half half_pown(half x, int y);
extern half half_rootn(half x, int y);
extern half half_floor(half x);

extern half half_ceil(half x);

extern half half_trunc(half x);

extern half half_round(half x);

extern half half_nearbyint(half x);
extern half half_rint(half x);
extern long int half_lrint(half x);
extern long long int half_llrint(half x);
extern long int half_lround(half x);
extern long long int half_llround(half x);
extern half half_modf(half x, half *intpart);

extern half half_fract(half x, half *intpart);
extern half half_nextafter(half x, half y);
extern half half_fmod(half x, half y);
extern half half_remainder(half x, half y);
extern half half_remquo(half x, half y, int* quo);
extern half half_divide(half x, half y);
# 37 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 1 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
# 147 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 191 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;



    static constexpr bool is_integer = false;





    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;





    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 302 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() throw() { return static_cast<_Tp>(0); }


      static constexpr _Tp
      max() throw() { return static_cast<_Tp>(0); }




      static constexpr _Tp
      lowest() throw() { return static_cast<_Tp>(0); }




      static constexpr _Tp
      epsilon() throw() { return static_cast<_Tp>(0); }


      static constexpr _Tp
      round_error() throw() { return static_cast<_Tp>(0); }


      static constexpr _Tp
      infinity() throw() { return static_cast<_Tp>(0); }



      static constexpr _Tp
      quiet_NaN() throw() { return static_cast<_Tp>(0); }



      static constexpr _Tp
      signaling_NaN() throw() { return static_cast<_Tp>(0); }




      static constexpr _Tp
      denorm_min() throw() { return static_cast<_Tp>(0); }
    };


  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };






  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() throw() { return false; }

      static constexpr bool
      max() throw() { return true; }


      static constexpr bool
      lowest() throw() { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() throw() { return false; }

      static constexpr bool
      round_error() throw() { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() throw() { return false; }

      static constexpr bool
      quiet_NaN() throw() { return false; }

      static constexpr bool
      signaling_NaN() throw() { return false; }

      static constexpr bool
      denorm_min() throw() { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() throw() { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }

      static constexpr char
      max() throw() { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() throw() { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() throw() { return 0; }

      static constexpr char
      round_error() throw() { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() throw() { return char(); }

      static constexpr char
      quiet_NaN() throw() { return char(); }

      static constexpr char
      signaling_NaN() throw() { return char(); }

      static constexpr char
      denorm_min() throw() { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() throw() { return -127 - 1; }

      static constexpr signed char
      max() throw() { return 127; }


      static constexpr signed char
      lowest() throw() { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() throw() { return 0; }

      static constexpr signed char
      round_error() throw() { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() throw() { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() throw() { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() throw() { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() throw() { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() throw() { return 0; }

      static constexpr unsigned char
      max() throw() { return 127 * 2U + 1; }


      static constexpr unsigned char
      lowest() throw() { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() throw() { return 0; }

      static constexpr unsigned char
      round_error() throw() { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() throw() { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() throw() { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() throw() { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() throw() { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() throw() { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }

      static constexpr wchar_t
      max() throw() { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() throw() { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() throw() { return 0; }

      static constexpr wchar_t
      round_error() throw() { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() throw() { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() throw() { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() throw() { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() throw() { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() throw() { return (((char16_t)(-1) < 0) ? (char16_t)1 << (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) : (char16_t)0); }

      static constexpr char16_t
      max() throw() { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }


      static constexpr char16_t
      lowest() throw() { return min(); }


      static constexpr int digits
       = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed
       = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() throw() { return 0; }

      static constexpr char16_t
      round_error() throw() { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() throw() { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() throw() { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() throw() { return char16_t(); }

      static constexpr char16_t
      denorm_min() throw() { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() throw() { return (((char32_t)(-1) < 0) ? (char32_t)1 << (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) : (char32_t)0); }

      static constexpr char32_t
      max() throw() { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }


      static constexpr char32_t
      lowest() throw() { return min(); }


      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed
       = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() throw() { return 0; }

      static constexpr char32_t
      round_error() throw() { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() throw() { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() throw() { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() throw() { return char32_t(); }

      static constexpr char32_t
      denorm_min() throw() { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() throw() { return -32767 - 1; }

      static constexpr short
      max() throw() { return 32767; }


      static constexpr short
      lowest() throw() { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() throw() { return 0; }

      static constexpr short
      round_error() throw() { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() throw() { return short(); }

      static constexpr short
      quiet_NaN() throw() { return short(); }

      static constexpr short
      signaling_NaN() throw() { return short(); }

      static constexpr short
      denorm_min() throw() { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() throw() { return 0; }

      static constexpr unsigned short
      max() throw() { return 32767 * 2U + 1; }


      static constexpr unsigned short
      lowest() throw() { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() throw() { return 0; }

      static constexpr unsigned short
      round_error() throw() { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() throw() { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() throw() { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() throw() { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() throw() { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() throw() { return -2147483647 - 1; }

      static constexpr int
      max() throw() { return 2147483647; }


      static constexpr int
      lowest() throw() { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() throw() { return 0; }

      static constexpr int
      round_error() throw() { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() throw() { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() throw() { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() throw() { return static_cast<int>(0); }

      static constexpr int
      denorm_min() throw() { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() throw() { return 0; }

      static constexpr unsigned int
      max() throw() { return 2147483647 * 2U + 1; }


      static constexpr unsigned int
      lowest() throw() { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() throw() { return 0; }

      static constexpr unsigned int
      round_error() throw() { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() throw() { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() throw() { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() throw() { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() throw() { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() throw() { return -9223372036854775807L - 1; }

      static constexpr long
      max() throw() { return 9223372036854775807L; }


      static constexpr long
      lowest() throw() { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() throw() { return 0; }

      static constexpr long
      round_error() throw() { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() throw() { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() throw() { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() throw() { return static_cast<long>(0); }

      static constexpr long
      denorm_min() throw() { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() throw() { return 0; }

      static constexpr unsigned long
      max() throw() { return 9223372036854775807L * 2UL + 1; }


      static constexpr unsigned long
      lowest() throw() { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() throw() { return 0; }

      static constexpr unsigned long
      round_error() throw() { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() throw() { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() throw() { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() throw() { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() throw() { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() throw() { return -9223372036854775807LL - 1; }

      static constexpr long long
      max() throw() { return 9223372036854775807LL; }


      static constexpr long long
      lowest() throw() { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() throw() { return 0; }

      static constexpr long long
      round_error() throw() { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() throw() { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() throw() { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() throw() { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() throw() { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() throw() { return 0; }

      static constexpr unsigned long long
      max() throw() { return 9223372036854775807LL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() throw() { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() throw() { return 0; }

      static constexpr unsigned long long
      round_error() throw() { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() throw() { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() throw() { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() throw() { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() throw() { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() throw() { return 1.17549435e-38F; }

      static constexpr float
      max() throw() { return 3.40282347e+38F; }


      static constexpr float
      lowest() throw() { return -3.40282347e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() throw() { return 1.19209290e-7F; }

      static constexpr float
      round_error() throw() { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() throw() { return __builtin_huge_valf (); }

      static constexpr float
      quiet_NaN() throw() { return __builtin_nanf (""); }

      static constexpr float
      signaling_NaN() throw() { return __builtin_nansf (""); }

      static constexpr float
      denorm_min() throw() { return 1.40129846e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() throw() { return 2.2250738585072014e-308; }

      static constexpr double
      max() throw() { return 1.7976931348623157e+308; }


      static constexpr double
      lowest() throw() { return -1.7976931348623157e+308; }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() throw() { return 2.2204460492503131e-16; }

      static constexpr double
      round_error() throw() { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() throw() { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() throw() { return __builtin_nan (""); }

      static constexpr double
      signaling_NaN() throw() { return __builtin_nans (""); }

      static constexpr double
      denorm_min() throw() { return 4.9406564584124654e-324; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() throw() { return 3.36210314311209350626e-4932L; }

      static constexpr long double
      max() throw() { return 1.18973149535723176502e+4932L; }


      static constexpr long double
      lowest() throw() { return -1.18973149535723176502e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() throw() { return 1.08420217248550443401e-19L; }

      static constexpr long double
      round_error() throw() { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() throw() { return __builtin_huge_vall (); }

      static constexpr long double
      quiet_NaN() throw() { return __builtin_nanl (""); }

      static constexpr long double
      signaling_NaN() throw() { return __builtin_nansl (""); }

      static constexpr long double
      denorm_min() throw() { return 3.64519953188247460253e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 38 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h" 2
# 68 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h"
namespace hls {

    template<typename T>
    class numeric_limits {
    public:
        static T max() { return std::numeric_limits<T>::max(); }
        static T min() { return std::numeric_limits<T>::min(); }
        static T epsilon() { return std::numeric_limits<T>::epsilon(); }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_fixed<W,I,Q,O> > {
    public:
        static ap_fixed<W,I,Q,O> max() {
            ap_int<W> m = ::hls::numeric_limits<ap_int<W> >::max();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> min() {
            ap_int<W> m = ::hls::numeric_limits<ap_int<W> >::min();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> epsilon() {
          ap_fixed<W,I,Q,O> x = 0;
          x[0] = 1;

          return x;
        }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_ufixed<W,I,Q,O> > {
    public:
        static ap_ufixed<W,I,Q,O> max() {
            ap_uint<W> m = ::hls::numeric_limits<ap_uint<W> >::max();
            ap_ufixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_ufixed<W,I,Q,O> min() { return 0; }
        static ap_ufixed<W,I,Q,O> epsilon() {
          ap_ufixed<W,I,Q,O> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_int<W> > {
    public:
        static ap_int<W> max() { ap_int<W> m = min(); return ~m; }
        static ap_int<W> min() { ap_int<W> m = 0; m[W-1] = 1; return m; }
        static ap_int<W> epsilon() {
          ap_int<W> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_uint<W> > {
    public:
        static ap_uint<W> max() { ap_uint<W> zero = 0; return ~zero; }
        static ap_uint<W> min() { return 0; }
        static ap_uint<W> epsilon() {
          ap_uint<W> x = 0;
          x[0] = 1;
          return x;
        }
    };
}


namespace hlstmp {

    template<typename T>
    class numeric_limits {
    public:
        static T max() { return std::numeric_limits<T>::max(); }
        static T min() { return std::numeric_limits<T>::min(); }
        static T epsilon() { return std::numeric_limits<T>::epsilon(); }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_fixed<W,I,Q,O> > {
    public:
        static ap_fixed<W,I,Q,O> max() {
            ap_int<W> m = ::hlstmp::numeric_limits<ap_int<W> >::max();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> min() {
            ap_int<W> m = ::hlstmp::numeric_limits<ap_int<W> >::min();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> epsilon() {
          ap_fixed<W,I,Q,O> x = 0;
          x[0] = 1;

          return x;
        }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_ufixed<W,I,Q,O> > {
    public:
        static ap_ufixed<W,I,Q,O> max() {
            ap_uint<W> m = ::hlstmp::numeric_limits<ap_uint<W> >::max();
            ap_ufixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_ufixed<W,I,Q,O> min() { return 0; }
        static ap_ufixed<W,I,Q,O> epsilon() {
          ap_ufixed<W,I,Q,O> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_int<W> > {
    public:
        static ap_int<W> max() { ap_int<W> m = min(); return ~m; }
        static ap_int<W> min() { ap_int<W> m = 0; m[W-1] = 1; return m; }
        static ap_int<W> epsilon() {
          ap_int<W> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_uint<W> > {
    public:
        static ap_uint<W> max() { ap_uint<W> zero = 0; return ~zero; }
        static ap_uint<W> min() { return 0; }
        static ap_uint<W> epsilon() {
          ap_uint<W> x = 0;
          x[0] = 1;
          return x;
        }
    };
}


static inline
const
uint32_t pow2(uint32_t e)
{
    switch(e) {
        case 0: return 1; break;
        case 1: return 2; break;
        case 2: return 4; break;
        case 3: return 8; break;
        case 4: return 16; break;
        case 5: return 32; break;
        case 6: return 64; break;
        case 7: return 128; break;
        case 8: return 256; break;
        case 9: return 512; break;
        case 10: return 1024; break;
        case 11: return 2048; break;
        default: return 0;
    }
}

template<class T>
T reg(T in)
{

_ssdm_InlineSelf(2, "");
_ssdm_op_SpecInterface(0, "ap_none", 1, 1, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");

    return in;
}
# 264 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h"
static inline
float to_float(float v)
{
    return v;
}

template<int _W, int _I>
float to_float(ap_fixed<_W, _I> v)
{
    return v.to_float();
}
# 283 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h"
template <typename T>
class fp_struct
{
};

union single_cast {
    float f;
    uint32_t i;
};

template <>
class fp_struct<float>
{
public:
    const static int EXP_INFNAN = 255;
    const static int EXP_BIAS = 127;
    const static int EXP_BITS = 8;
    const static int SIG_BITS = 23;
    const static int BITS = 32;

    fp_struct() {
    }
    fp_struct(float f) {


        union single_cast dc;
        dc.f = f;
        ap_uint<32> data = dc.i;





        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    fp_struct(ap_uint<32> data) {
        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    fp_struct(uint32_t i) {
        ap_uint<32> data = i;
        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    inline ap_uint<32> data() const {
        ap_uint<32> t;
        t[31] = sign[0];
        t(30,23) = exp(7,0);
        t(22,0) = sig(22,0);
        return t;
    }
    inline int expv() const {
        return exp-127;
    }
    inline int32_t to_int() const {
        return data().to_int();
    }
    inline float to_float() const {


        union single_cast ret;
        ret.i = data().to_uint();
        return ret.f;







    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline float to_ieee() const {
        return to_float();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static float infinity() {
        fp_struct<float> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static float minus_infinity() {
        fp_struct<float> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint32_t inttype;
    typedef ap_uint<32> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};
# 413 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h"
static inline
void
castSingle(
    float din,
    fp_struct<float> &dout)
{
    fp_struct<float> t(din);
    dout = t;
}

static inline
float
castSingle(
    fp_struct<float> din)
{
    return din.to_float();
}

static inline
void
dumpSingle(
    float da,
    fp_struct<float> ds)
{
# 447 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h"
}







union double_cast {
    double d;
    uint64_t i;
};

template <>
class fp_struct<double>
{
public:
    const static int EXP_INFNAN = 2047;
    const static int EXP_BIAS = 1023;
    const static int EXP_BITS = 11;
    const static int SIG_BITS = 52;
    const static int BITS = 64;

    fp_struct() {
    }
    fp_struct(double f) {
        union double_cast dc;
        dc.d = f;
        ap_uint<64> data = dc.i;
        sign[0] = data[63];
        exp(10,0) = data(62,52);
        sig(51,0) = data(51,0);
    }
    fp_struct(ap_uint<64> data) {
        sign[0] = data[63];
        exp(10,0) = data(62,52);
        sig(51,0) = data(51,0);
    }
    fp_struct(uint64_t i) {
        ap_uint<64> data = i;
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    inline ap_uint<64> data() const {
        ap_uint<64> t;
        t[EXP_BITS+SIG_BITS+1-1] = sign[0];
        t(EXP_BITS-1+SIG_BITS,SIG_BITS) = exp(EXP_BITS-1,0);
        t(SIG_BITS-1,0) = sig(SIG_BITS-1,0);
        return t;
    }
    inline int64_t to_int() const {
        return data().to_int64();
    }
    inline int expv() const {
        return exp-1023;
    }
    inline ap_uint<20> sig_msb() const {
        return sig(51,32);
    }
    inline ap_uint<32> sig_lsb() const {
        return sig(31,0);
    }
    inline double to_double() const {
        union double_cast ret;
        ret.i = data().to_uint64();
        return ret.d;
    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline double to_ieee() const {
        return to_double();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static double infinity() {
        fp_struct<double> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static double minus_infinity() {
        fp_struct<double> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint64_t inttype;
    typedef ap_uint<64> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};
# 566 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h"
static inline
void
castDouble(
    double din,
    fp_struct<double> &dout)
{
    fp_struct<double> t(din);
    dout = t;
}

static inline
double
castDouble(
    fp_struct<double> din)
{
    return din.to_double();
}

static inline
void
dumpDouble(
    double da,
    fp_struct<double> ds)
{
# 600 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h"
}
# 610 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h"
union half_cast {
    half d;
    uint16_t i;
};


template <>
class fp_struct<half>
{
public:
    const static int EXP_INFNAN = 31;
    const static int EXP_BIAS = 15;
    const static int EXP_BITS = 5;
    const static int SIG_BITS = 10;
    const static int BITS = 16;

    fp_struct() {
    }
    fp_struct(half f) {

        union half_cast dc;
        dc.d = f;
        ap_uint<16> data = dc.i;



        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    fp_struct(ap_uint<16> data) {
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    fp_struct(uint16_t i) {
        ap_uint<16> data = i;
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    inline ap_uint<16> data() const {
        ap_uint<16> t;
        t[EXP_BITS+SIG_BITS+1-1] = sign[0];
        t(EXP_BITS-1+SIG_BITS,SIG_BITS) = exp(EXP_BITS-1,0);
        t(SIG_BITS-1,0) = sig(SIG_BITS-1,0);
        return t;
    }
    inline int expv() const {
        return exp-EXP_BIAS;
    }
    inline int16_t to_int() const {
        return uint16_t(data().to_int());
    }
    inline half to_half() const {

        union half_cast ret;
        ret.i = data().to_uint64();
        return ret.d;





    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline half to_ieee() const {
        return to_half();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static half infinity() {
        fp_struct<half> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static half minus_infinity() {
        fp_struct<half> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint16_t inttype;
    typedef ap_uint<16> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};
# 726 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h"
static inline
void
castHalf(
    half din,
    fp_struct<half> &dout)
{
    fp_struct<half> t(din);
    dout = t;
}

static inline
half
castHalf(
    fp_struct<half> din)
{
    return din.to_half();
}

static inline
void
dumpHalf(
    half da,
    fp_struct<half> ds)
{
# 760 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h"
}
# 775 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h"
template < unsigned int _Base, unsigned int _Num >
class Power
{
public:
    static const unsigned int Value = _Base * Power< _Base, _Num - 1 >::Value;
};

template < unsigned int _Base >
class Power< _Base, 0 >
{
public:
    static const unsigned int Value = 1;
};
# 797 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h"
template < unsigned int _Num, unsigned int _I=_Num/2>
class BitWidth
{
public:
    static const unsigned int Value = 1 + BitWidth<_Num,_I/2>::Value;
};

template <unsigned int _Num>
class BitWidth<_Num, 0>
{
public:
    static const unsigned int Value = 1;
};
# 819 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h"
template < unsigned int _Num, unsigned int _I=_Num/2>
class UnsignedBitWidth
{
public:
    static const unsigned int Value = 1 + UnsignedBitWidth<_Num,_I/2>::Value;
};

template <unsigned int _Num>
class UnsignedBitWidth<_Num, 0>
{
public:
    static const unsigned int Value = 0;
};
# 840 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h"
template < typename T >
class Type_BitWidth
{
public:
    static const unsigned int Value = 8*sizeof(T);
};

template <int W >
class Type_BitWidth< ap_uint<W> >
{
public:
    static const unsigned int Value = W;
};

template < int W >
class Type_BitWidth< ap_int<W> >
{
public:
    static const unsigned int Value = W;
};

template < int W, int I >
class Type_BitWidth< ap_ufixed<W, I> >
{
public:
    static const unsigned int Value = W;
};

template < int W, int I >
class Type_BitWidth< ap_fixed<W, I> >
{
public:
    static const unsigned int Value = W;
};
# 888 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h"
template <typename _T, int _Num, int _I=_Num-1>
class Table : public Table<_T, _Num, _I-1>
{
public:
    typedef typename _T::TableType TableType;
    static const typename _T::TableType dummy;
    static const int size = _Num;

};

template <typename _T, int _Num>
class Table<_T, _Num, 0>
{
public:
    static const typename _T::TableType dummy;
    static typename _T::TableType array[_Num];
};
# 915 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_utils.h"
template <typename _T, int _Num, int _I>
const typename _T::TableType Table<_T, _Num, _I>::dummy
    = Table<_T, _Num, 0>::array[_I] = _T::apply(_I,_Num) + 0*Table<_T, _Num, _I-1>::dummy;

template <typename _T, int _Num>
const typename _T::TableType Table<_T, _Num, 0>::dummy
    = Table<_T, _Num, 0>::array[0] = _T::apply(0,_Num);




template <typename _T, int _Num>
typename _T::TableType Table<_T, _Num, 0>::array[_Num];



template <class T>
struct is_fptype { static const bool value = false; };
template <> struct is_fptype<float> { static const bool value = true; };
template <> struct is_fptype<double> { static const bool value = true; };
template <> struct is_fptype<half> { static const bool value = true; };

template <class T>
struct is_integraltype { static const bool value = false; };
template <> struct is_integraltype<int> { static const bool value = true; };
template <> struct is_integraltype<unsigned int> { static const bool value = true; };
template <> struct is_integraltype<char> { static const bool value = true; };
template <> struct is_integraltype<signed char> { static const bool value = true; };
template <> struct is_integraltype<unsigned char> { static const bool value = true; };
template <> struct is_integraltype<short> { static const bool value = true; };
template <> struct is_integraltype<unsigned short> { static const bool value = true; };
template <> struct is_integraltype<long> { static const bool value = true; };
template <> struct is_integraltype<unsigned long> { static const bool value = true; };
template <> struct is_integraltype<long long> { static const bool value = true; };
template <> struct is_integraltype<unsigned long long> { static const bool value = true; };
template <int W> struct is_integraltype<ap_int<W> > { static const bool value = true; };
template <int W> struct is_integraltype<ap_uint<W> > { static const bool value = true; };

template <class T>
struct is_fixedtype { static const bool value = false; };
template <int W, int I, ap_q_mode Q, ap_o_mode O> struct is_fixedtype<ap_fixed<W,I,Q,O> > { static const bool value = true; };
template <int W, int I, ap_q_mode Q, ap_o_mode O> struct is_fixedtype<ap_ufixed<W,I,Q,O> > { static const bool value = true; };

namespace hls {
    template<bool B, class T = void>
    struct enable_if {};

    template<class T>
    struct enable_if<true, T> { typedef T type; };
    template<typename T, T _v>
    struct integral_constant
    {
        static const T value = _v;
        typedef T value_type;
        typedef integral_constant<T,_v> type;
        operator value_type() { return value; }
    };

    typedef integral_constant<bool, true> true_type;
    typedef integral_constant<bool, false> false_type;

    template<typename T1, typename T2>
    struct is_same;

    template<typename T1, typename T2>
    struct is_same : public false_type { };

    template<typename T1>
    struct is_same<T1,T1> : public true_type { };

    template<typename T>
    struct is_arithmetic : public integral_constant<bool, (is_integraltype<T>::value || is_fptype<T>::value)> { };
}

template<typename T1, typename T2>
struct enable_or { static const bool value = T1::value || T2::value; };

template<typename T1, typename T2>
struct enable_and { static const bool value = T1::value && T2::value; };



template<typename T, bool = is_integraltype<T>::value>
struct __promote { typedef double type; };

template<typename T>
struct __promote<T, false> { };

template<>
struct __promote<double> { typedef double type; };

template<>
struct __promote<float> { typedef float type; };

template<>
struct __promote<half> { typedef half type; };
# 41 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_axi_io.h" 2
# 1 "/usr/include/assert.h" 1 3 4
# 42 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_axi_io.h" 2

namespace hls {

template<int W, typename T>
void AXIGetBitFields(ap_uint<W> pix, int start, int w, T& val) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (start >= 0 && start+w <= W) ? void (0) : __assert_fail ("start >= 0 && start+w <= W", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_axi_io.h", 48, __extension__ __PRETTY_FUNCTION__));
    val = (T)pix(start+w-1, start);
}

template<int W>
void AXIGetBitFields(ap_uint<W> pix, int start, int w, float& val) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (w == 32 && start >= 0 && start+w <= W) ? void (0) : __assert_fail ("w == 32 && start >= 0 && start+w <= W", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_axi_io.h", 55, __extension__ __PRETTY_FUNCTION__));
    fp_struct<float> temp((ap_uint<32>)pix(start+w-1, start));
    val = temp.to_float();
}

template<int W>
void AXIGetBitFields(ap_uint<W> pix, int start, int w, double& val) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (w == 64 && start >= 0 && start+w <= W) ? void (0) : __assert_fail ("w == 64 && start >= 0 && start+w <= W", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_axi_io.h", 63, __extension__ __PRETTY_FUNCTION__));
    fp_struct<double> temp((ap_uint<64>)pix(start+w-1, start));
    val = temp.to_double();
}

template<int W, typename T>
void AXIGetBitFields(ap_axiu<W,1,1,1> axi, int start, int w, T& val) {
_ssdm_InlineSelf(0, "");
    AXIGetBitFields(axi.data, start, w, val);
}

template<int W, typename T>
void AXISetBitFields(ap_uint<W>& pix, int start, int w, T val) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (start >= 0 && start+w <= W) ? void (0) : __assert_fail ("start >= 0 && start+w <= W", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_axi_io.h", 77, __extension__ __PRETTY_FUNCTION__));
    pix(start+w-1, start) = val;
}

template<int W>
void AXISetBitFields(ap_uint<W>& pix, int start, int w, float val) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (w == 32 && start >= 0 && start+w <= W) ? void (0) : __assert_fail ("w == 32 && start >= 0 && start+w <= W", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_axi_io.h", 84, __extension__ __PRETTY_FUNCTION__));
    fp_struct<float> temp(val);
    pix(start+w-1, start) = temp.data();
}

template<int W>
void AXISetBitFields(ap_uint<W>& pix, int start, int w, double val) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (w == 64 && start >= 0 && start+w <= W) ? void (0) : __assert_fail ("w == 64 && start >= 0 && start+w <= W", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_axi_io.h", 92, __extension__ __PRETTY_FUNCTION__));
    fp_struct<double> temp(val);
    pix(start+w-1, start) = temp.data();
}

template<int W, typename T>
void AXISetBitFields(ap_axiu<W,1,1,1>& axi, int start, int w, T val) {
_ssdm_InlineSelf(0, "");
    AXISetBitFields(axi.data, start, w, val);
}

}
# 49 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_video.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 1
# 36 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h"
# 1 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 1 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3
# 41 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3




# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4






extern "C" {






# 1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 152 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/flt-eval-method.h" 1 3 4
# 153 "/usr/include/math.h" 2 3 4
# 163 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 204 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-logb.h" 1 3 4
# 205 "/usr/include/math.h" 2 3 4
# 247 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-fast.h" 1 3 4
# 248 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 312 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbit (double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinf (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnan (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) noexcept (true);


extern int __issignaling (double __value) noexcept (true)
     __attribute__ ((__const__));
# 313 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double acos (double __x) noexcept (true); extern double __acos (double __x) noexcept (true);

extern double asin (double __x) noexcept (true); extern double __asin (double __x) noexcept (true);

extern double atan (double __x) noexcept (true); extern double __atan (double __x) noexcept (true);

extern double atan2 (double __y, double __x) noexcept (true); extern double __atan2 (double __y, double __x) noexcept (true);


extern double cos (double __x) noexcept (true); extern double __cos (double __x) noexcept (true);

extern double sin (double __x) noexcept (true); extern double __sin (double __x) noexcept (true);

extern double tan (double __x) noexcept (true); extern double __tan (double __x) noexcept (true);




extern double cosh (double __x) noexcept (true); extern double __cosh (double __x) noexcept (true);

extern double sinh (double __x) noexcept (true); extern double __sinh (double __x) noexcept (true);

extern double tanh (double __x) noexcept (true); extern double __tanh (double __x) noexcept (true);



extern void sincos (double __x, double *__sinx, double *__cosx) noexcept (true); extern void __sincos (double __x, double *__sinx, double *__cosx) noexcept (true);





extern double acosh (double __x) noexcept (true); extern double __acosh (double __x) noexcept (true);

extern double asinh (double __x) noexcept (true); extern double __asinh (double __x) noexcept (true);

extern double atanh (double __x) noexcept (true); extern double __atanh (double __x) noexcept (true);





extern double exp (double __x) noexcept (true); extern double __exp (double __x) noexcept (true);


extern double frexp (double __x, int *__exponent) noexcept (true); extern double __frexp (double __x, int *__exponent) noexcept (true);


extern double ldexp (double __x, int __exponent) noexcept (true); extern double __ldexp (double __x, int __exponent) noexcept (true);


extern double log (double __x) noexcept (true); extern double __log (double __x) noexcept (true);


extern double log10 (double __x) noexcept (true); extern double __log10 (double __x) noexcept (true);


extern double modf (double __x, double *__iptr) noexcept (true); extern double __modf (double __x, double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern double exp10 (double __x) noexcept (true); extern double __exp10 (double __x) noexcept (true);




extern double expm1 (double __x) noexcept (true); extern double __expm1 (double __x) noexcept (true);


extern double log1p (double __x) noexcept (true); extern double __log1p (double __x) noexcept (true);


extern double logb (double __x) noexcept (true); extern double __logb (double __x) noexcept (true);




extern double exp2 (double __x) noexcept (true); extern double __exp2 (double __x) noexcept (true);


extern double log2 (double __x) noexcept (true); extern double __log2 (double __x) noexcept (true);






extern double pow (double __x, double __y) noexcept (true); extern double __pow (double __x, double __y) noexcept (true);


extern double sqrt (double __x) noexcept (true); extern double __sqrt (double __x) noexcept (true);



extern double hypot (double __x, double __y) noexcept (true); extern double __hypot (double __x, double __y) noexcept (true);




extern double cbrt (double __x) noexcept (true); extern double __cbrt (double __x) noexcept (true);






extern double ceil (double __x) noexcept (true) __attribute__ ((__const__)); extern double __ceil (double __x) noexcept (true) __attribute__ ((__const__));


extern double fabs (double __x) noexcept (true) __attribute__ ((__const__)); extern double __fabs (double __x) noexcept (true) __attribute__ ((__const__));


extern double floor (double __x) noexcept (true) __attribute__ ((__const__)); extern double __floor (double __x) noexcept (true) __attribute__ ((__const__));


extern double fmod (double __x, double __y) noexcept (true); extern double __fmod (double __x, double __y) noexcept (true);
# 183 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern double drem (double __x, double __y) noexcept (true); extern double __drem (double __x, double __y) noexcept (true);



extern double significand (double __x) noexcept (true); extern double __significand (double __x) noexcept (true);






extern double copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double nan (const char *__tagb) noexcept (true); extern double __nan (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double j0 (double) noexcept (true); extern double __j0 (double) noexcept (true);
extern double j1 (double) noexcept (true); extern double __j1 (double) noexcept (true);
extern double jn (int, double) noexcept (true); extern double __jn (int, double) noexcept (true);
extern double y0 (double) noexcept (true); extern double __y0 (double) noexcept (true);
extern double y1 (double) noexcept (true); extern double __y1 (double) noexcept (true);
extern double yn (int, double) noexcept (true); extern double __yn (int, double) noexcept (true);





extern double erf (double) noexcept (true); extern double __erf (double) noexcept (true);
extern double erfc (double) noexcept (true); extern double __erfc (double) noexcept (true);
extern double lgamma (double) noexcept (true); extern double __lgamma (double) noexcept (true);




extern double tgamma (double) noexcept (true); extern double __tgamma (double) noexcept (true);





extern double gamma (double) noexcept (true); extern double __gamma (double) noexcept (true);







extern double lgamma_r (double, int *__signgamp) noexcept (true); extern double __lgamma_r (double, int *__signgamp) noexcept (true);






extern double rint (double __x) noexcept (true); extern double __rint (double __x) noexcept (true);


extern double nextafter (double __x, double __y) noexcept (true); extern double __nextafter (double __x, double __y) noexcept (true);

extern double nexttoward (double __x, long double __y) noexcept (true); extern double __nexttoward (double __x, long double __y) noexcept (true);




extern double nextdown (double __x) noexcept (true); extern double __nextdown (double __x) noexcept (true);

extern double nextup (double __x) noexcept (true); extern double __nextup (double __x) noexcept (true);



extern double remainder (double __x, double __y) noexcept (true); extern double __remainder (double __x, double __y) noexcept (true);



extern double scalbn (double __x, int __n) noexcept (true); extern double __scalbn (double __x, int __n) noexcept (true);



extern int ilogb (double __x) noexcept (true); extern int __ilogb (double __x) noexcept (true);




extern long int llogb (double __x) noexcept (true); extern long int __llogb (double __x) noexcept (true);




extern double scalbln (double __x, long int __n) noexcept (true); extern double __scalbln (double __x, long int __n) noexcept (true);



extern double nearbyint (double __x) noexcept (true); extern double __nearbyint (double __x) noexcept (true);



extern double round (double __x) noexcept (true) __attribute__ ((__const__)); extern double __round (double __x) noexcept (true) __attribute__ ((__const__));



extern double trunc (double __x) noexcept (true) __attribute__ ((__const__)); extern double __trunc (double __x) noexcept (true) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) noexcept (true); extern double __remquo (double __x, double __y, int *__quo) noexcept (true);






extern long int lrint (double __x) noexcept (true); extern long int __lrint (double __x) noexcept (true);
__extension__
extern long long int llrint (double __x) noexcept (true); extern long long int __llrint (double __x) noexcept (true);



extern long int lround (double __x) noexcept (true); extern long int __lround (double __x) noexcept (true);
__extension__
extern long long int llround (double __x) noexcept (true); extern long long int __llround (double __x) noexcept (true);



extern double fdim (double __x, double __y) noexcept (true); extern double __fdim (double __x, double __y) noexcept (true);



extern double fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) noexcept (true); extern double __fma (double __x, double __y, double __z) noexcept (true);




extern double roundeven (double __x) noexcept (true) __attribute__ ((__const__)); extern double __roundeven (double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalize (double *__cx, const double *__x) noexcept (true);






extern double fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double fmaximum (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern int totalorder (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermag (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern double getpayload (const double *__x) noexcept (true); extern double __getpayload (const double *__x) noexcept (true);


extern int setpayload (double *__x, double __payload) noexcept (true);


extern int setpayloadsig (double *__x, double __payload) noexcept (true);







extern double scalb (double __x, double __n) noexcept (true); extern double __scalb (double __x, double __n) noexcept (true);
# 314 "/usr/include/math.h" 2 3 4
# 329 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitf (float __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinff (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) noexcept (true);


extern int __issignalingf (float __value) noexcept (true)
     __attribute__ ((__const__));
# 330 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float acosf (float __x) noexcept (true); extern float __acosf (float __x) noexcept (true);

extern float asinf (float __x) noexcept (true); extern float __asinf (float __x) noexcept (true);

extern float atanf (float __x) noexcept (true); extern float __atanf (float __x) noexcept (true);

extern float atan2f (float __y, float __x) noexcept (true); extern float __atan2f (float __y, float __x) noexcept (true);


extern float cosf (float __x) noexcept (true); extern float __cosf (float __x) noexcept (true);

extern float sinf (float __x) noexcept (true); extern float __sinf (float __x) noexcept (true);

extern float tanf (float __x) noexcept (true); extern float __tanf (float __x) noexcept (true);




extern float coshf (float __x) noexcept (true); extern float __coshf (float __x) noexcept (true);

extern float sinhf (float __x) noexcept (true); extern float __sinhf (float __x) noexcept (true);

extern float tanhf (float __x) noexcept (true); extern float __tanhf (float __x) noexcept (true);



extern void sincosf (float __x, float *__sinx, float *__cosx) noexcept (true); extern void __sincosf (float __x, float *__sinx, float *__cosx) noexcept (true);





extern float acoshf (float __x) noexcept (true); extern float __acoshf (float __x) noexcept (true);

extern float asinhf (float __x) noexcept (true); extern float __asinhf (float __x) noexcept (true);

extern float atanhf (float __x) noexcept (true); extern float __atanhf (float __x) noexcept (true);





extern float expf (float __x) noexcept (true); extern float __expf (float __x) noexcept (true);


extern float frexpf (float __x, int *__exponent) noexcept (true); extern float __frexpf (float __x, int *__exponent) noexcept (true);


extern float ldexpf (float __x, int __exponent) noexcept (true); extern float __ldexpf (float __x, int __exponent) noexcept (true);


extern float logf (float __x) noexcept (true); extern float __logf (float __x) noexcept (true);


extern float log10f (float __x) noexcept (true); extern float __log10f (float __x) noexcept (true);


extern float modff (float __x, float *__iptr) noexcept (true); extern float __modff (float __x, float *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern float exp10f (float __x) noexcept (true); extern float __exp10f (float __x) noexcept (true);




extern float expm1f (float __x) noexcept (true); extern float __expm1f (float __x) noexcept (true);


extern float log1pf (float __x) noexcept (true); extern float __log1pf (float __x) noexcept (true);


extern float logbf (float __x) noexcept (true); extern float __logbf (float __x) noexcept (true);




extern float exp2f (float __x) noexcept (true); extern float __exp2f (float __x) noexcept (true);


extern float log2f (float __x) noexcept (true); extern float __log2f (float __x) noexcept (true);






extern float powf (float __x, float __y) noexcept (true); extern float __powf (float __x, float __y) noexcept (true);


extern float sqrtf (float __x) noexcept (true); extern float __sqrtf (float __x) noexcept (true);



extern float hypotf (float __x, float __y) noexcept (true); extern float __hypotf (float __x, float __y) noexcept (true);




extern float cbrtf (float __x) noexcept (true); extern float __cbrtf (float __x) noexcept (true);






extern float ceilf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __ceilf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fabsf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __fabsf (float __x) noexcept (true) __attribute__ ((__const__));


extern float floorf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __floorf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) noexcept (true); extern float __fmodf (float __x, float __y) noexcept (true);
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinff (float __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern float dremf (float __x, float __y) noexcept (true); extern float __dremf (float __x, float __y) noexcept (true);



extern float significandf (float __x) noexcept (true); extern float __significandf (float __x) noexcept (true);






extern float copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float nanf (const char *__tagb) noexcept (true); extern float __nanf (const char *__tagb) noexcept (true);
# 213 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));





extern float j0f (float) noexcept (true); extern float __j0f (float) noexcept (true);
extern float j1f (float) noexcept (true); extern float __j1f (float) noexcept (true);
extern float jnf (int, float) noexcept (true); extern float __jnf (int, float) noexcept (true);
extern float y0f (float) noexcept (true); extern float __y0f (float) noexcept (true);
extern float y1f (float) noexcept (true); extern float __y1f (float) noexcept (true);
extern float ynf (int, float) noexcept (true); extern float __ynf (int, float) noexcept (true);





extern float erff (float) noexcept (true); extern float __erff (float) noexcept (true);
extern float erfcf (float) noexcept (true); extern float __erfcf (float) noexcept (true);
extern float lgammaf (float) noexcept (true); extern float __lgammaf (float) noexcept (true);




extern float tgammaf (float) noexcept (true); extern float __tgammaf (float) noexcept (true);





extern float gammaf (float) noexcept (true); extern float __gammaf (float) noexcept (true);







extern float lgammaf_r (float, int *__signgamp) noexcept (true); extern float __lgammaf_r (float, int *__signgamp) noexcept (true);






extern float rintf (float __x) noexcept (true); extern float __rintf (float __x) noexcept (true);


extern float nextafterf (float __x, float __y) noexcept (true); extern float __nextafterf (float __x, float __y) noexcept (true);

extern float nexttowardf (float __x, long double __y) noexcept (true); extern float __nexttowardf (float __x, long double __y) noexcept (true);




extern float nextdownf (float __x) noexcept (true); extern float __nextdownf (float __x) noexcept (true);

extern float nextupf (float __x) noexcept (true); extern float __nextupf (float __x) noexcept (true);



extern float remainderf (float __x, float __y) noexcept (true); extern float __remainderf (float __x, float __y) noexcept (true);



extern float scalbnf (float __x, int __n) noexcept (true); extern float __scalbnf (float __x, int __n) noexcept (true);



extern int ilogbf (float __x) noexcept (true); extern int __ilogbf (float __x) noexcept (true);




extern long int llogbf (float __x) noexcept (true); extern long int __llogbf (float __x) noexcept (true);




extern float scalblnf (float __x, long int __n) noexcept (true); extern float __scalblnf (float __x, long int __n) noexcept (true);



extern float nearbyintf (float __x) noexcept (true); extern float __nearbyintf (float __x) noexcept (true);



extern float roundf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __roundf (float __x) noexcept (true) __attribute__ ((__const__));



extern float truncf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __truncf (float __x) noexcept (true) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) noexcept (true); extern float __remquof (float __x, float __y, int *__quo) noexcept (true);






extern long int lrintf (float __x) noexcept (true); extern long int __lrintf (float __x) noexcept (true);
__extension__
extern long long int llrintf (float __x) noexcept (true); extern long long int __llrintf (float __x) noexcept (true);



extern long int lroundf (float __x) noexcept (true); extern long int __lroundf (float __x) noexcept (true);
__extension__
extern long long int llroundf (float __x) noexcept (true); extern long long int __llroundf (float __x) noexcept (true);



extern float fdimf (float __x, float __y) noexcept (true); extern float __fdimf (float __x, float __y) noexcept (true);



extern float fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) noexcept (true); extern float __fmaf (float __x, float __y, float __z) noexcept (true);




extern float roundevenf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __roundevenf (float __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalizef (float *__cx, const float *__x) noexcept (true);






extern float fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float fmaximumf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximumf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimumf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimumf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern float getpayloadf (const float *__x) noexcept (true); extern float __getpayloadf (const float *__x) noexcept (true);


extern int setpayloadf (float *__x, float __payload) noexcept (true);


extern int setpayloadsigf (float *__x, float __payload) noexcept (true);







extern float scalbf (float __x, float __n) noexcept (true); extern float __scalbf (float __x, float __n) noexcept (true);
# 331 "/usr/include/math.h" 2 3 4
# 398 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitl (long double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) noexcept (true);


extern int __issignalingl (long double __value) noexcept (true)
     __attribute__ ((__const__));
# 399 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double acosl (long double __x) noexcept (true); extern long double __acosl (long double __x) noexcept (true);

extern long double asinl (long double __x) noexcept (true); extern long double __asinl (long double __x) noexcept (true);

extern long double atanl (long double __x) noexcept (true); extern long double __atanl (long double __x) noexcept (true);

extern long double atan2l (long double __y, long double __x) noexcept (true); extern long double __atan2l (long double __y, long double __x) noexcept (true);


extern long double cosl (long double __x) noexcept (true); extern long double __cosl (long double __x) noexcept (true);

extern long double sinl (long double __x) noexcept (true); extern long double __sinl (long double __x) noexcept (true);

extern long double tanl (long double __x) noexcept (true); extern long double __tanl (long double __x) noexcept (true);




extern long double coshl (long double __x) noexcept (true); extern long double __coshl (long double __x) noexcept (true);

extern long double sinhl (long double __x) noexcept (true); extern long double __sinhl (long double __x) noexcept (true);

extern long double tanhl (long double __x) noexcept (true); extern long double __tanhl (long double __x) noexcept (true);



extern void sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true);





extern long double acoshl (long double __x) noexcept (true); extern long double __acoshl (long double __x) noexcept (true);

extern long double asinhl (long double __x) noexcept (true); extern long double __asinhl (long double __x) noexcept (true);

extern long double atanhl (long double __x) noexcept (true); extern long double __atanhl (long double __x) noexcept (true);





extern long double expl (long double __x) noexcept (true); extern long double __expl (long double __x) noexcept (true);


extern long double frexpl (long double __x, int *__exponent) noexcept (true); extern long double __frexpl (long double __x, int *__exponent) noexcept (true);


extern long double ldexpl (long double __x, int __exponent) noexcept (true); extern long double __ldexpl (long double __x, int __exponent) noexcept (true);


extern long double logl (long double __x) noexcept (true); extern long double __logl (long double __x) noexcept (true);


extern long double log10l (long double __x) noexcept (true); extern long double __log10l (long double __x) noexcept (true);


extern long double modfl (long double __x, long double *__iptr) noexcept (true); extern long double __modfl (long double __x, long double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern long double exp10l (long double __x) noexcept (true); extern long double __exp10l (long double __x) noexcept (true);




extern long double expm1l (long double __x) noexcept (true); extern long double __expm1l (long double __x) noexcept (true);


extern long double log1pl (long double __x) noexcept (true); extern long double __log1pl (long double __x) noexcept (true);


extern long double logbl (long double __x) noexcept (true); extern long double __logbl (long double __x) noexcept (true);




extern long double exp2l (long double __x) noexcept (true); extern long double __exp2l (long double __x) noexcept (true);


extern long double log2l (long double __x) noexcept (true); extern long double __log2l (long double __x) noexcept (true);






extern long double powl (long double __x, long double __y) noexcept (true); extern long double __powl (long double __x, long double __y) noexcept (true);


extern long double sqrtl (long double __x) noexcept (true); extern long double __sqrtl (long double __x) noexcept (true);



extern long double hypotl (long double __x, long double __y) noexcept (true); extern long double __hypotl (long double __x, long double __y) noexcept (true);




extern long double cbrtl (long double __x) noexcept (true); extern long double __cbrtl (long double __x) noexcept (true);






extern long double ceill (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __ceill (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fabsl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __fabsl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double floorl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __floorl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) noexcept (true); extern long double __fmodl (long double __x, long double __y) noexcept (true);
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) noexcept (true); extern long double __dreml (long double __x, long double __y) noexcept (true);



extern long double significandl (long double __x) noexcept (true); extern long double __significandl (long double __x) noexcept (true);






extern long double copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double nanl (const char *__tagb) noexcept (true); extern long double __nanl (const char *__tagb) noexcept (true);
# 213 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));





extern long double j0l (long double) noexcept (true); extern long double __j0l (long double) noexcept (true);
extern long double j1l (long double) noexcept (true); extern long double __j1l (long double) noexcept (true);
extern long double jnl (int, long double) noexcept (true); extern long double __jnl (int, long double) noexcept (true);
extern long double y0l (long double) noexcept (true); extern long double __y0l (long double) noexcept (true);
extern long double y1l (long double) noexcept (true); extern long double __y1l (long double) noexcept (true);
extern long double ynl (int, long double) noexcept (true); extern long double __ynl (int, long double) noexcept (true);





extern long double erfl (long double) noexcept (true); extern long double __erfl (long double) noexcept (true);
extern long double erfcl (long double) noexcept (true); extern long double __erfcl (long double) noexcept (true);
extern long double lgammal (long double) noexcept (true); extern long double __lgammal (long double) noexcept (true);




extern long double tgammal (long double) noexcept (true); extern long double __tgammal (long double) noexcept (true);





extern long double gammal (long double) noexcept (true); extern long double __gammal (long double) noexcept (true);







extern long double lgammal_r (long double, int *__signgamp) noexcept (true); extern long double __lgammal_r (long double, int *__signgamp) noexcept (true);






extern long double rintl (long double __x) noexcept (true); extern long double __rintl (long double __x) noexcept (true);


extern long double nextafterl (long double __x, long double __y) noexcept (true); extern long double __nextafterl (long double __x, long double __y) noexcept (true);

extern long double nexttowardl (long double __x, long double __y) noexcept (true); extern long double __nexttowardl (long double __x, long double __y) noexcept (true);




extern long double nextdownl (long double __x) noexcept (true); extern long double __nextdownl (long double __x) noexcept (true);

extern long double nextupl (long double __x) noexcept (true); extern long double __nextupl (long double __x) noexcept (true);



extern long double remainderl (long double __x, long double __y) noexcept (true); extern long double __remainderl (long double __x, long double __y) noexcept (true);



extern long double scalbnl (long double __x, int __n) noexcept (true); extern long double __scalbnl (long double __x, int __n) noexcept (true);



extern int ilogbl (long double __x) noexcept (true); extern int __ilogbl (long double __x) noexcept (true);




extern long int llogbl (long double __x) noexcept (true); extern long int __llogbl (long double __x) noexcept (true);




extern long double scalblnl (long double __x, long int __n) noexcept (true); extern long double __scalblnl (long double __x, long int __n) noexcept (true);



extern long double nearbyintl (long double __x) noexcept (true); extern long double __nearbyintl (long double __x) noexcept (true);



extern long double roundl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __roundl (long double __x) noexcept (true) __attribute__ ((__const__));



extern long double truncl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __truncl (long double __x) noexcept (true) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) noexcept (true); extern long double __remquol (long double __x, long double __y, int *__quo) noexcept (true);






extern long int lrintl (long double __x) noexcept (true); extern long int __lrintl (long double __x) noexcept (true);
__extension__
extern long long int llrintl (long double __x) noexcept (true); extern long long int __llrintl (long double __x) noexcept (true);



extern long int lroundl (long double __x) noexcept (true); extern long int __lroundl (long double __x) noexcept (true);
__extension__
extern long long int llroundl (long double __x) noexcept (true); extern long long int __llroundl (long double __x) noexcept (true);



extern long double fdiml (long double __x, long double __y) noexcept (true); extern long double __fdiml (long double __x, long double __y) noexcept (true);



extern long double fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) noexcept (true); extern long double __fmal (long double __x, long double __y, long double __z) noexcept (true);




extern long double roundevenl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __roundevenl (long double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalizel (long double *__cx, const long double *__x) noexcept (true);






extern long double fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double fmaximuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern long double getpayloadl (const long double *__x) noexcept (true); extern long double __getpayloadl (const long double *__x) noexcept (true);


extern int setpayloadl (long double *__x, long double __payload) noexcept (true);


extern int setpayloadsigl (long double *__x, long double __payload) noexcept (true);







extern long double scalbl (long double __x, long double __n) noexcept (true); extern long double __scalbl (long double __x, long double __n) noexcept (true);
# 400 "/usr/include/math.h" 2 3 4
# 450 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 acosf32 (_Float32 __x) noexcept (true); extern _Float32 __acosf32 (_Float32 __x) noexcept (true);

extern _Float32 asinf32 (_Float32 __x) noexcept (true); extern _Float32 __asinf32 (_Float32 __x) noexcept (true);

extern _Float32 atanf32 (_Float32 __x) noexcept (true); extern _Float32 __atanf32 (_Float32 __x) noexcept (true);

extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) noexcept (true); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) noexcept (true);


extern _Float32 cosf32 (_Float32 __x) noexcept (true); extern _Float32 __cosf32 (_Float32 __x) noexcept (true);

extern _Float32 sinf32 (_Float32 __x) noexcept (true); extern _Float32 __sinf32 (_Float32 __x) noexcept (true);

extern _Float32 tanf32 (_Float32 __x) noexcept (true); extern _Float32 __tanf32 (_Float32 __x) noexcept (true);




extern _Float32 coshf32 (_Float32 __x) noexcept (true); extern _Float32 __coshf32 (_Float32 __x) noexcept (true);

extern _Float32 sinhf32 (_Float32 __x) noexcept (true); extern _Float32 __sinhf32 (_Float32 __x) noexcept (true);

extern _Float32 tanhf32 (_Float32 __x) noexcept (true); extern _Float32 __tanhf32 (_Float32 __x) noexcept (true);



extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true);





extern _Float32 acoshf32 (_Float32 __x) noexcept (true); extern _Float32 __acoshf32 (_Float32 __x) noexcept (true);

extern _Float32 asinhf32 (_Float32 __x) noexcept (true); extern _Float32 __asinhf32 (_Float32 __x) noexcept (true);

extern _Float32 atanhf32 (_Float32 __x) noexcept (true); extern _Float32 __atanhf32 (_Float32 __x) noexcept (true);





extern _Float32 expf32 (_Float32 __x) noexcept (true); extern _Float32 __expf32 (_Float32 __x) noexcept (true);


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) noexcept (true); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) noexcept (true);


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) noexcept (true); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) noexcept (true);


extern _Float32 logf32 (_Float32 __x) noexcept (true); extern _Float32 __logf32 (_Float32 __x) noexcept (true);


extern _Float32 log10f32 (_Float32 __x) noexcept (true); extern _Float32 __log10f32 (_Float32 __x) noexcept (true);


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern _Float32 exp10f32 (_Float32 __x) noexcept (true); extern _Float32 __exp10f32 (_Float32 __x) noexcept (true);




extern _Float32 expm1f32 (_Float32 __x) noexcept (true); extern _Float32 __expm1f32 (_Float32 __x) noexcept (true);


extern _Float32 log1pf32 (_Float32 __x) noexcept (true); extern _Float32 __log1pf32 (_Float32 __x) noexcept (true);


extern _Float32 logbf32 (_Float32 __x) noexcept (true); extern _Float32 __logbf32 (_Float32 __x) noexcept (true);




extern _Float32 exp2f32 (_Float32 __x) noexcept (true); extern _Float32 __exp2f32 (_Float32 __x) noexcept (true);


extern _Float32 log2f32 (_Float32 __x) noexcept (true); extern _Float32 __log2f32 (_Float32 __x) noexcept (true);






extern _Float32 powf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) noexcept (true);


extern _Float32 sqrtf32 (_Float32 __x) noexcept (true); extern _Float32 __sqrtf32 (_Float32 __x) noexcept (true);



extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) noexcept (true);




extern _Float32 cbrtf32 (_Float32 __x) noexcept (true); extern _Float32 __cbrtf32 (_Float32 __x) noexcept (true);






extern _Float32 ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) noexcept (true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) noexcept (true); extern _Float32 __nanf32 (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) noexcept (true); extern _Float32 __j0f32 (_Float32) noexcept (true);
extern _Float32 j1f32 (_Float32) noexcept (true); extern _Float32 __j1f32 (_Float32) noexcept (true);
extern _Float32 jnf32 (int, _Float32) noexcept (true); extern _Float32 __jnf32 (int, _Float32) noexcept (true);
extern _Float32 y0f32 (_Float32) noexcept (true); extern _Float32 __y0f32 (_Float32) noexcept (true);
extern _Float32 y1f32 (_Float32) noexcept (true); extern _Float32 __y1f32 (_Float32) noexcept (true);
extern _Float32 ynf32 (int, _Float32) noexcept (true); extern _Float32 __ynf32 (int, _Float32) noexcept (true);





extern _Float32 erff32 (_Float32) noexcept (true); extern _Float32 __erff32 (_Float32) noexcept (true);
extern _Float32 erfcf32 (_Float32) noexcept (true); extern _Float32 __erfcf32 (_Float32) noexcept (true);
extern _Float32 lgammaf32 (_Float32) noexcept (true); extern _Float32 __lgammaf32 (_Float32) noexcept (true);




extern _Float32 tgammaf32 (_Float32) noexcept (true); extern _Float32 __tgammaf32 (_Float32) noexcept (true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) noexcept (true); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) noexcept (true);






extern _Float32 rintf32 (_Float32 __x) noexcept (true); extern _Float32 __rintf32 (_Float32 __x) noexcept (true);


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true);






extern _Float32 nextdownf32 (_Float32 __x) noexcept (true); extern _Float32 __nextdownf32 (_Float32 __x) noexcept (true);

extern _Float32 nextupf32 (_Float32 __x) noexcept (true); extern _Float32 __nextupf32 (_Float32 __x) noexcept (true);



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 scalbnf32 (_Float32 __x, int __n) noexcept (true); extern _Float32 __scalbnf32 (_Float32 __x, int __n) noexcept (true);



extern int ilogbf32 (_Float32 __x) noexcept (true); extern int __ilogbf32 (_Float32 __x) noexcept (true);




extern long int llogbf32 (_Float32 __x) noexcept (true); extern long int __llogbf32 (_Float32 __x) noexcept (true);




extern _Float32 scalblnf32 (_Float32 __x, long int __n) noexcept (true); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) noexcept (true);



extern _Float32 nearbyintf32 (_Float32 __x) noexcept (true); extern _Float32 __nearbyintf32 (_Float32 __x) noexcept (true);



extern _Float32 roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true);






extern long int lrintf32 (_Float32 __x) noexcept (true); extern long int __lrintf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llrintf32 (_Float32 __x) noexcept (true); extern long long int __llrintf32 (_Float32 __x) noexcept (true);



extern long int lroundf32 (_Float32 __x) noexcept (true); extern long int __lroundf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llroundf32 (_Float32 __x) noexcept (true); extern long long int __llroundf32 (_Float32 __x) noexcept (true);



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));



extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true);




extern _Float32 roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) noexcept (true);






extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 fmaximumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32 getpayloadf32 (const _Float32 *__x) noexcept (true); extern _Float32 __getpayloadf32 (const _Float32 *__x) noexcept (true);


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) noexcept (true);


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) noexcept (true);
# 451 "/usr/include/math.h" 2 3 4
# 467 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 acosf64 (_Float64 __x) noexcept (true); extern _Float64 __acosf64 (_Float64 __x) noexcept (true);

extern _Float64 asinf64 (_Float64 __x) noexcept (true); extern _Float64 __asinf64 (_Float64 __x) noexcept (true);

extern _Float64 atanf64 (_Float64 __x) noexcept (true); extern _Float64 __atanf64 (_Float64 __x) noexcept (true);

extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) noexcept (true); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) noexcept (true);


extern _Float64 cosf64 (_Float64 __x) noexcept (true); extern _Float64 __cosf64 (_Float64 __x) noexcept (true);

extern _Float64 sinf64 (_Float64 __x) noexcept (true); extern _Float64 __sinf64 (_Float64 __x) noexcept (true);

extern _Float64 tanf64 (_Float64 __x) noexcept (true); extern _Float64 __tanf64 (_Float64 __x) noexcept (true);




extern _Float64 coshf64 (_Float64 __x) noexcept (true); extern _Float64 __coshf64 (_Float64 __x) noexcept (true);

extern _Float64 sinhf64 (_Float64 __x) noexcept (true); extern _Float64 __sinhf64 (_Float64 __x) noexcept (true);

extern _Float64 tanhf64 (_Float64 __x) noexcept (true); extern _Float64 __tanhf64 (_Float64 __x) noexcept (true);



extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true);





extern _Float64 acoshf64 (_Float64 __x) noexcept (true); extern _Float64 __acoshf64 (_Float64 __x) noexcept (true);

extern _Float64 asinhf64 (_Float64 __x) noexcept (true); extern _Float64 __asinhf64 (_Float64 __x) noexcept (true);

extern _Float64 atanhf64 (_Float64 __x) noexcept (true); extern _Float64 __atanhf64 (_Float64 __x) noexcept (true);





extern _Float64 expf64 (_Float64 __x) noexcept (true); extern _Float64 __expf64 (_Float64 __x) noexcept (true);


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) noexcept (true); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) noexcept (true);


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) noexcept (true); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) noexcept (true);


extern _Float64 logf64 (_Float64 __x) noexcept (true); extern _Float64 __logf64 (_Float64 __x) noexcept (true);


extern _Float64 log10f64 (_Float64 __x) noexcept (true); extern _Float64 __log10f64 (_Float64 __x) noexcept (true);


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern _Float64 exp10f64 (_Float64 __x) noexcept (true); extern _Float64 __exp10f64 (_Float64 __x) noexcept (true);




extern _Float64 expm1f64 (_Float64 __x) noexcept (true); extern _Float64 __expm1f64 (_Float64 __x) noexcept (true);


extern _Float64 log1pf64 (_Float64 __x) noexcept (true); extern _Float64 __log1pf64 (_Float64 __x) noexcept (true);


extern _Float64 logbf64 (_Float64 __x) noexcept (true); extern _Float64 __logbf64 (_Float64 __x) noexcept (true);




extern _Float64 exp2f64 (_Float64 __x) noexcept (true); extern _Float64 __exp2f64 (_Float64 __x) noexcept (true);


extern _Float64 log2f64 (_Float64 __x) noexcept (true); extern _Float64 __log2f64 (_Float64 __x) noexcept (true);






extern _Float64 powf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float64 sqrtf64 (_Float64 __x) noexcept (true); extern _Float64 __sqrtf64 (_Float64 __x) noexcept (true);



extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) noexcept (true);




extern _Float64 cbrtf64 (_Float64 __x) noexcept (true); extern _Float64 __cbrtf64 (_Float64 __x) noexcept (true);






extern _Float64 ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) noexcept (true); extern _Float64 __nanf64 (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) noexcept (true); extern _Float64 __j0f64 (_Float64) noexcept (true);
extern _Float64 j1f64 (_Float64) noexcept (true); extern _Float64 __j1f64 (_Float64) noexcept (true);
extern _Float64 jnf64 (int, _Float64) noexcept (true); extern _Float64 __jnf64 (int, _Float64) noexcept (true);
extern _Float64 y0f64 (_Float64) noexcept (true); extern _Float64 __y0f64 (_Float64) noexcept (true);
extern _Float64 y1f64 (_Float64) noexcept (true); extern _Float64 __y1f64 (_Float64) noexcept (true);
extern _Float64 ynf64 (int, _Float64) noexcept (true); extern _Float64 __ynf64 (int, _Float64) noexcept (true);





extern _Float64 erff64 (_Float64) noexcept (true); extern _Float64 __erff64 (_Float64) noexcept (true);
extern _Float64 erfcf64 (_Float64) noexcept (true); extern _Float64 __erfcf64 (_Float64) noexcept (true);
extern _Float64 lgammaf64 (_Float64) noexcept (true); extern _Float64 __lgammaf64 (_Float64) noexcept (true);




extern _Float64 tgammaf64 (_Float64) noexcept (true); extern _Float64 __tgammaf64 (_Float64) noexcept (true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) noexcept (true); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) noexcept (true);






extern _Float64 rintf64 (_Float64 __x) noexcept (true); extern _Float64 __rintf64 (_Float64 __x) noexcept (true);


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true);






extern _Float64 nextdownf64 (_Float64 __x) noexcept (true); extern _Float64 __nextdownf64 (_Float64 __x) noexcept (true);

extern _Float64 nextupf64 (_Float64 __x) noexcept (true); extern _Float64 __nextupf64 (_Float64 __x) noexcept (true);



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 scalbnf64 (_Float64 __x, int __n) noexcept (true); extern _Float64 __scalbnf64 (_Float64 __x, int __n) noexcept (true);



extern int ilogbf64 (_Float64 __x) noexcept (true); extern int __ilogbf64 (_Float64 __x) noexcept (true);




extern long int llogbf64 (_Float64 __x) noexcept (true); extern long int __llogbf64 (_Float64 __x) noexcept (true);




extern _Float64 scalblnf64 (_Float64 __x, long int __n) noexcept (true); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) noexcept (true);



extern _Float64 nearbyintf64 (_Float64 __x) noexcept (true); extern _Float64 __nearbyintf64 (_Float64 __x) noexcept (true);



extern _Float64 roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true);






extern long int lrintf64 (_Float64 __x) noexcept (true); extern long int __lrintf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llrintf64 (_Float64 __x) noexcept (true); extern long long int __llrintf64 (_Float64 __x) noexcept (true);



extern long int lroundf64 (_Float64 __x) noexcept (true); extern long int __lroundf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llroundf64 (_Float64 __x) noexcept (true); extern long long int __llroundf64 (_Float64 __x) noexcept (true);



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));



extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);




extern _Float64 roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) noexcept (true);






extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 fmaximumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64 getpayloadf64 (const _Float64 *__x) noexcept (true); extern _Float64 __getpayloadf64 (const _Float64 *__x) noexcept (true);


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) noexcept (true);


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) noexcept (true);
# 468 "/usr/include/math.h" 2 3 4
# 501 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x acosf32x (_Float32x __x) noexcept (true); extern _Float32x __acosf32x (_Float32x __x) noexcept (true);

extern _Float32x asinf32x (_Float32x __x) noexcept (true); extern _Float32x __asinf32x (_Float32x __x) noexcept (true);

extern _Float32x atanf32x (_Float32x __x) noexcept (true); extern _Float32x __atanf32x (_Float32x __x) noexcept (true);

extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) noexcept (true); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) noexcept (true);


extern _Float32x cosf32x (_Float32x __x) noexcept (true); extern _Float32x __cosf32x (_Float32x __x) noexcept (true);

extern _Float32x sinf32x (_Float32x __x) noexcept (true); extern _Float32x __sinf32x (_Float32x __x) noexcept (true);

extern _Float32x tanf32x (_Float32x __x) noexcept (true); extern _Float32x __tanf32x (_Float32x __x) noexcept (true);




extern _Float32x coshf32x (_Float32x __x) noexcept (true); extern _Float32x __coshf32x (_Float32x __x) noexcept (true);

extern _Float32x sinhf32x (_Float32x __x) noexcept (true); extern _Float32x __sinhf32x (_Float32x __x) noexcept (true);

extern _Float32x tanhf32x (_Float32x __x) noexcept (true); extern _Float32x __tanhf32x (_Float32x __x) noexcept (true);



extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true);





extern _Float32x acoshf32x (_Float32x __x) noexcept (true); extern _Float32x __acoshf32x (_Float32x __x) noexcept (true);

extern _Float32x asinhf32x (_Float32x __x) noexcept (true); extern _Float32x __asinhf32x (_Float32x __x) noexcept (true);

extern _Float32x atanhf32x (_Float32x __x) noexcept (true); extern _Float32x __atanhf32x (_Float32x __x) noexcept (true);





extern _Float32x expf32x (_Float32x __x) noexcept (true); extern _Float32x __expf32x (_Float32x __x) noexcept (true);


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) noexcept (true); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) noexcept (true);


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) noexcept (true); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) noexcept (true);


extern _Float32x logf32x (_Float32x __x) noexcept (true); extern _Float32x __logf32x (_Float32x __x) noexcept (true);


extern _Float32x log10f32x (_Float32x __x) noexcept (true); extern _Float32x __log10f32x (_Float32x __x) noexcept (true);


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern _Float32x exp10f32x (_Float32x __x) noexcept (true); extern _Float32x __exp10f32x (_Float32x __x) noexcept (true);




extern _Float32x expm1f32x (_Float32x __x) noexcept (true); extern _Float32x __expm1f32x (_Float32x __x) noexcept (true);


extern _Float32x log1pf32x (_Float32x __x) noexcept (true); extern _Float32x __log1pf32x (_Float32x __x) noexcept (true);


extern _Float32x logbf32x (_Float32x __x) noexcept (true); extern _Float32x __logbf32x (_Float32x __x) noexcept (true);




extern _Float32x exp2f32x (_Float32x __x) noexcept (true); extern _Float32x __exp2f32x (_Float32x __x) noexcept (true);


extern _Float32x log2f32x (_Float32x __x) noexcept (true); extern _Float32x __log2f32x (_Float32x __x) noexcept (true);






extern _Float32x powf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32x sqrtf32x (_Float32x __x) noexcept (true); extern _Float32x __sqrtf32x (_Float32x __x) noexcept (true);



extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) noexcept (true);




extern _Float32x cbrtf32x (_Float32x __x) noexcept (true); extern _Float32x __cbrtf32x (_Float32x __x) noexcept (true);






extern _Float32x ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) noexcept (true); extern _Float32x __nanf32x (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) noexcept (true); extern _Float32x __j0f32x (_Float32x) noexcept (true);
extern _Float32x j1f32x (_Float32x) noexcept (true); extern _Float32x __j1f32x (_Float32x) noexcept (true);
extern _Float32x jnf32x (int, _Float32x) noexcept (true); extern _Float32x __jnf32x (int, _Float32x) noexcept (true);
extern _Float32x y0f32x (_Float32x) noexcept (true); extern _Float32x __y0f32x (_Float32x) noexcept (true);
extern _Float32x y1f32x (_Float32x) noexcept (true); extern _Float32x __y1f32x (_Float32x) noexcept (true);
extern _Float32x ynf32x (int, _Float32x) noexcept (true); extern _Float32x __ynf32x (int, _Float32x) noexcept (true);





extern _Float32x erff32x (_Float32x) noexcept (true); extern _Float32x __erff32x (_Float32x) noexcept (true);
extern _Float32x erfcf32x (_Float32x) noexcept (true); extern _Float32x __erfcf32x (_Float32x) noexcept (true);
extern _Float32x lgammaf32x (_Float32x) noexcept (true); extern _Float32x __lgammaf32x (_Float32x) noexcept (true);




extern _Float32x tgammaf32x (_Float32x) noexcept (true); extern _Float32x __tgammaf32x (_Float32x) noexcept (true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true);






extern _Float32x rintf32x (_Float32x __x) noexcept (true); extern _Float32x __rintf32x (_Float32x __x) noexcept (true);


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true);






extern _Float32x nextdownf32x (_Float32x __x) noexcept (true); extern _Float32x __nextdownf32x (_Float32x __x) noexcept (true);

extern _Float32x nextupf32x (_Float32x __x) noexcept (true); extern _Float32x __nextupf32x (_Float32x __x) noexcept (true);



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x scalbnf32x (_Float32x __x, int __n) noexcept (true); extern _Float32x __scalbnf32x (_Float32x __x, int __n) noexcept (true);



extern int ilogbf32x (_Float32x __x) noexcept (true); extern int __ilogbf32x (_Float32x __x) noexcept (true);




extern long int llogbf32x (_Float32x __x) noexcept (true); extern long int __llogbf32x (_Float32x __x) noexcept (true);




extern _Float32x scalblnf32x (_Float32x __x, long int __n) noexcept (true); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) noexcept (true);



extern _Float32x nearbyintf32x (_Float32x __x) noexcept (true); extern _Float32x __nearbyintf32x (_Float32x __x) noexcept (true);



extern _Float32x roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true);






extern long int lrintf32x (_Float32x __x) noexcept (true); extern long int __lrintf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llrintf32x (_Float32x __x) noexcept (true); extern long long int __llrintf32x (_Float32x __x) noexcept (true);



extern long int lroundf32x (_Float32x __x) noexcept (true); extern long int __lroundf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llroundf32x (_Float32x __x) noexcept (true); extern long long int __llroundf32x (_Float32x __x) noexcept (true);



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));



extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);




extern _Float32x roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) noexcept (true);






extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x fmaximumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32x getpayloadf32x (const _Float32x *__x) noexcept (true); extern _Float32x __getpayloadf32x (const _Float32x *__x) noexcept (true);


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) noexcept (true);


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) noexcept (true);
# 502 "/usr/include/math.h" 2 3 4
# 518 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x acosf64x (_Float64x __x) noexcept (true); extern _Float64x __acosf64x (_Float64x __x) noexcept (true);

extern _Float64x asinf64x (_Float64x __x) noexcept (true); extern _Float64x __asinf64x (_Float64x __x) noexcept (true);

extern _Float64x atanf64x (_Float64x __x) noexcept (true); extern _Float64x __atanf64x (_Float64x __x) noexcept (true);

extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) noexcept (true); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) noexcept (true);


extern _Float64x cosf64x (_Float64x __x) noexcept (true); extern _Float64x __cosf64x (_Float64x __x) noexcept (true);

extern _Float64x sinf64x (_Float64x __x) noexcept (true); extern _Float64x __sinf64x (_Float64x __x) noexcept (true);

extern _Float64x tanf64x (_Float64x __x) noexcept (true); extern _Float64x __tanf64x (_Float64x __x) noexcept (true);




extern _Float64x coshf64x (_Float64x __x) noexcept (true); extern _Float64x __coshf64x (_Float64x __x) noexcept (true);

extern _Float64x sinhf64x (_Float64x __x) noexcept (true); extern _Float64x __sinhf64x (_Float64x __x) noexcept (true);

extern _Float64x tanhf64x (_Float64x __x) noexcept (true); extern _Float64x __tanhf64x (_Float64x __x) noexcept (true);



extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true);





extern _Float64x acoshf64x (_Float64x __x) noexcept (true); extern _Float64x __acoshf64x (_Float64x __x) noexcept (true);

extern _Float64x asinhf64x (_Float64x __x) noexcept (true); extern _Float64x __asinhf64x (_Float64x __x) noexcept (true);

extern _Float64x atanhf64x (_Float64x __x) noexcept (true); extern _Float64x __atanhf64x (_Float64x __x) noexcept (true);





extern _Float64x expf64x (_Float64x __x) noexcept (true); extern _Float64x __expf64x (_Float64x __x) noexcept (true);


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) noexcept (true); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) noexcept (true);


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) noexcept (true); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) noexcept (true);


extern _Float64x logf64x (_Float64x __x) noexcept (true); extern _Float64x __logf64x (_Float64x __x) noexcept (true);


extern _Float64x log10f64x (_Float64x __x) noexcept (true); extern _Float64x __log10f64x (_Float64x __x) noexcept (true);


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern _Float64x exp10f64x (_Float64x __x) noexcept (true); extern _Float64x __exp10f64x (_Float64x __x) noexcept (true);




extern _Float64x expm1f64x (_Float64x __x) noexcept (true); extern _Float64x __expm1f64x (_Float64x __x) noexcept (true);


extern _Float64x log1pf64x (_Float64x __x) noexcept (true); extern _Float64x __log1pf64x (_Float64x __x) noexcept (true);


extern _Float64x logbf64x (_Float64x __x) noexcept (true); extern _Float64x __logbf64x (_Float64x __x) noexcept (true);




extern _Float64x exp2f64x (_Float64x __x) noexcept (true); extern _Float64x __exp2f64x (_Float64x __x) noexcept (true);


extern _Float64x log2f64x (_Float64x __x) noexcept (true); extern _Float64x __log2f64x (_Float64x __x) noexcept (true);






extern _Float64x powf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64x sqrtf64x (_Float64x __x) noexcept (true); extern _Float64x __sqrtf64x (_Float64x __x) noexcept (true);



extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) noexcept (true);




extern _Float64x cbrtf64x (_Float64x __x) noexcept (true); extern _Float64x __cbrtf64x (_Float64x __x) noexcept (true);






extern _Float64x ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) noexcept (true); extern _Float64x __nanf64x (const char *__tagb) noexcept (true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) noexcept (true); extern _Float64x __j0f64x (_Float64x) noexcept (true);
extern _Float64x j1f64x (_Float64x) noexcept (true); extern _Float64x __j1f64x (_Float64x) noexcept (true);
extern _Float64x jnf64x (int, _Float64x) noexcept (true); extern _Float64x __jnf64x (int, _Float64x) noexcept (true);
extern _Float64x y0f64x (_Float64x) noexcept (true); extern _Float64x __y0f64x (_Float64x) noexcept (true);
extern _Float64x y1f64x (_Float64x) noexcept (true); extern _Float64x __y1f64x (_Float64x) noexcept (true);
extern _Float64x ynf64x (int, _Float64x) noexcept (true); extern _Float64x __ynf64x (int, _Float64x) noexcept (true);





extern _Float64x erff64x (_Float64x) noexcept (true); extern _Float64x __erff64x (_Float64x) noexcept (true);
extern _Float64x erfcf64x (_Float64x) noexcept (true); extern _Float64x __erfcf64x (_Float64x) noexcept (true);
extern _Float64x lgammaf64x (_Float64x) noexcept (true); extern _Float64x __lgammaf64x (_Float64x) noexcept (true);




extern _Float64x tgammaf64x (_Float64x) noexcept (true); extern _Float64x __tgammaf64x (_Float64x) noexcept (true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true);






extern _Float64x rintf64x (_Float64x __x) noexcept (true); extern _Float64x __rintf64x (_Float64x __x) noexcept (true);


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true);






extern _Float64x nextdownf64x (_Float64x __x) noexcept (true); extern _Float64x __nextdownf64x (_Float64x __x) noexcept (true);

extern _Float64x nextupf64x (_Float64x __x) noexcept (true); extern _Float64x __nextupf64x (_Float64x __x) noexcept (true);



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x scalbnf64x (_Float64x __x, int __n) noexcept (true); extern _Float64x __scalbnf64x (_Float64x __x, int __n) noexcept (true);



extern int ilogbf64x (_Float64x __x) noexcept (true); extern int __ilogbf64x (_Float64x __x) noexcept (true);




extern long int llogbf64x (_Float64x __x) noexcept (true); extern long int __llogbf64x (_Float64x __x) noexcept (true);




extern _Float64x scalblnf64x (_Float64x __x, long int __n) noexcept (true); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) noexcept (true);



extern _Float64x nearbyintf64x (_Float64x __x) noexcept (true); extern _Float64x __nearbyintf64x (_Float64x __x) noexcept (true);



extern _Float64x roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true);






extern long int lrintf64x (_Float64x __x) noexcept (true); extern long int __lrintf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llrintf64x (_Float64x __x) noexcept (true); extern long long int __llrintf64x (_Float64x __x) noexcept (true);



extern long int lroundf64x (_Float64x __x) noexcept (true); extern long int __lroundf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llroundf64x (_Float64x __x) noexcept (true); extern long long int __llroundf64x (_Float64x __x) noexcept (true);



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));



extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);




extern _Float64x roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true);




extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true);





extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true);





extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true);



extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) noexcept (true);






extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x fmaximumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64x getpayloadf64x (const _Float64x *__x) noexcept (true); extern _Float64x __getpayloadf64x (const _Float64x *__x) noexcept (true);


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) noexcept (true);


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) noexcept (true);
# 519 "/usr/include/math.h" 2 3 4
# 566 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float fadd (double __x, double __y) noexcept (true);


extern float fdiv (double __x, double __y) noexcept (true);


extern float ffma (double __x, double __y, double __z) noexcept (true);


extern float fmul (double __x, double __y) noexcept (true);


extern float fsqrt (double __x) noexcept (true);


extern float fsub (double __x, double __y) noexcept (true);
# 567 "/usr/include/math.h" 2 3 4
# 587 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float faddl (long double __x, long double __y) noexcept (true);


extern float fdivl (long double __x, long double __y) noexcept (true);


extern float ffmal (long double __x, long double __y, long double __z) noexcept (true);


extern float fmull (long double __x, long double __y) noexcept (true);


extern float fsqrtl (long double __x) noexcept (true);


extern float fsubl (long double __x, long double __y) noexcept (true);
# 588 "/usr/include/math.h" 2 3 4
# 616 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern double daddl (long double __x, long double __y) noexcept (true);


extern double ddivl (long double __x, long double __y) noexcept (true);


extern double dfmal (long double __x, long double __y, long double __z) noexcept (true);


extern double dmull (long double __x, long double __y) noexcept (true);


extern double dsqrtl (long double __x) noexcept (true);


extern double dsubl (long double __x, long double __y) noexcept (true);
# 617 "/usr/include/math.h" 2 3 4
# 697 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32divf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);


extern _Float32 f32mulf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32sqrtf32x (_Float32x __x) noexcept (true);


extern _Float32 f32subf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 698 "/usr/include/math.h" 2 3 4
# 707 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32divf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);


extern _Float32 f32mulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32sqrtf64 (_Float64 __x) noexcept (true);


extern _Float32 f32subf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 708 "/usr/include/math.h" 2 3 4
# 717 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float32 f32mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32sqrtf64x (_Float64x __x) noexcept (true);


extern _Float32 f32subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 718 "/usr/include/math.h" 2 3 4
# 747 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xdivf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xfmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);


extern _Float32x f32xmulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xsqrtf64 (_Float64 __x) noexcept (true);


extern _Float32x f32xsubf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 748 "/usr/include/math.h" 2 3 4
# 757 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xdivf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xfmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float32x f32xmulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xsqrtf64x (_Float64x __x) noexcept (true);


extern _Float32x f32xsubf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 758 "/usr/include/math.h" 2 3 4
# 787 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float64 f64mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64sqrtf64x (_Float64x __x) noexcept (true);


extern _Float64 f64subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 788 "/usr/include/math.h" 2 3 4
# 854 "/usr/include/math.h" 3 4
extern int signgam;
# 934 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 1054 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     noexcept (true) __attribute__ ((__const__));
# 46 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern "C++" {
inline int iscanonical (float __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (double __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (long double __val) { return __iscanonicall (__val); }



}
# 1055 "/usr/include/math.h" 2 3 4
# 1066 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling (float __val) { return __issignalingf (__val); }
inline int issignaling (double __val) { return __issignaling (__val); }
inline int
issignaling (long double __val)
{



  return __issignalingl (__val);

}





}
# 1097 "/usr/include/math.h" 3 4
extern "C++" {
# 1128 "/usr/include/math.h" 3 4
template <class __T> inline bool
iszero (__T __val)
{
  return __val == 0;
}

}
# 1363 "/usr/include/math.h" 3 4
extern "C++" {
template<typename> struct __iseqsig_type;

template<> struct __iseqsig_type<float>
{
  static int __call (float __x, float __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};

template<> struct __iseqsig_type<double>
{
  static int __call (double __x, double __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};

template<> struct __iseqsig_type<long double>
{
  static int __call (long double __x, long double __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};
# 1406 "/usr/include/math.h" 3 4
template<typename _T1, typename _T2>
inline int
iseqsig (_T1 __x, _T2 __y) throw ()
{

  typedef decltype (((__x) + (__y) + 0.0f)) _T3;



  return __iseqsig_type<_T3>::__call (__x, __y);
}

}




}
# 46 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 2 3
# 76 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;

  inline float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline long double
  acos(long double __x)
  { return __builtin_acosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;

  inline float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline long double
  asin(long double __x)
  { return __builtin_asinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;

  inline float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline long double
  atan(long double __x)
  { return __builtin_atanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;

  inline float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }

  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;

  inline float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;

  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;

  inline float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;

  inline float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline long double
  exp(long double __x)
  { return __builtin_expl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;

  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;

  inline float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline long double
  floor(long double __x)
  { return __builtin_floorl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;

  inline float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }

  using ::frexp;

  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;

  inline float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
  ldexp(_Tp __x, int __exp)
  { return __builtin_ldexp(__x, __exp); }

  using ::log;

  inline float
  log(float __x)
  { return __builtin_logf(__x); }

  inline long double
  log(long double __x)
  { return __builtin_logl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;

  inline float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline long double
  log10(long double __x)
  { return __builtin_log10l(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;

  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }

  using ::pow;

  inline float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 371 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3
  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;

  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;

  inline float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;

  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;

  inline float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline long double
  tan(long double __x)
  { return __builtin_tanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;

  inline float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
# 480 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  inline int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  inline int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  inline int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }

  inline bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  inline bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  inline bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        bool>::__type
    isfinite(_Tp __x)
    { return true; }

  inline bool
  isinf(float __x)
  { return __builtin_isinf(__x); }

  inline bool
  isinf(double __x)
  { return __builtin_isinf(__x); }

  inline bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        bool>::__type
    isinf(_Tp __x)
    { return false; }

  inline bool
  isnan(float __x)
  { return __builtin_isnan(__x); }

  inline bool
  isnan(double __x)
  { return __builtin_isnan(__x); }

  inline bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        bool>::__type
    isnan(_Tp __x)
    { return false; }

  inline bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  inline bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  inline bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }

  inline bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  inline bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  inline bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }

  inline bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  inline bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  inline bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }

  inline bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  inline bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  inline bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }

  inline bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  inline bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  inline bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }

  inline bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  inline bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  inline bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }

  inline bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  inline bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  inline bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }

  inline bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  inline bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  inline bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 842 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3
}
# 957 "/tools/Xilinx/Vivado/2019.2/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;

  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;

  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;


  inline float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  inline long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    acosh(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return acosh(__type(__x));
    }

  inline float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  inline long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    asinh(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return asinh(__type(__x));
    }

  inline float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  inline long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    atanh(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return atanh(__type(__x));
    }

  inline float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  inline long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    cbrt(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return cbrt(__type(__x));
    }

  inline float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  inline long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }

  inline float
  erf(float __x)
  { return __builtin_erff(__x); }

  inline long double
  erf(long double __x)
  { return __builtin_erfl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    erf(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return erf(__type(__x));
    }

  inline float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  inline long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    erfc(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return erfc(__type(__x));
    }

  inline float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  inline long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    exp2(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return exp2(__type(__x));
    }

  inline float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  inline long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    expm1(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return expm1(__type(__x));
    }

  inline float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  inline long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }

  inline float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  inline long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }

  template<typename _Tp, typename _Up, typename _Vp>
    inline typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }

  inline float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  inline long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }

  inline float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  inline long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }

  inline float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  inline long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }

  inline int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  inline int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }

  template<typename _Tp>
    inline int
    ilogb(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return ilogb(__type(__x));
    }

  inline float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  inline long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    lgamma(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return lgamma(__type(__x));
    }

  inline long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  inline long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }

  template<typename _Tp>
    inline long long
    llrint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return llrint(__type(__x));
    }

  inline long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  inline long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }

  template<typename _Tp>
    inline long long
    llround(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return llround(__type(__x));
    }

  inline float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  inline long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    log1p(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return log1p(__type(__x));
    }


  inline float
  log2(float __x)
  { return __builtin_log2f(__x); }

  inline long double
  log2(long double __x)
  { return __builtin_log2l(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    log2(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return log2(__type(__x));
    }

  inline float
  logb(float __x)
  { return __builtin_logbf(__x); }

  inline long double
  logb(long double __x)
  { return __builtin_logbl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    logb(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return logb(__type(__x));
    }

  inline long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  inline long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }

  template<typename _Tp>
    inline long
    lrint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return lrint(__type(__x));
    }

  inline long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  inline long
  lround(long double __x)
  { return __builtin_lroundl(__x); }

  template<typename _Tp>
    inline long
    lround(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return lround(__type(__x));
    }

  inline float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  inline long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    nearbyint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return nearbyint(__type(__x));
    }

  inline float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  inline long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }

  inline float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  inline long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    nexttoward(_Tp __x, long double __y)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return nexttoward(__type(__x), __y);
    }

  inline float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  inline long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }

  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }

  inline float
  rint(float __x)
  { return __builtin_rintf(__x); }

  inline long double
  rint(long double __x)
  { return __builtin_rintl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    rint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return rint(__type(__x));
    }

  inline float
  round(float __x)
  { return __builtin_roundf(__x); }

  inline long double
  round(long double __x)
  { return __builtin_roundl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    round(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return round(__type(__x));
    }

  inline float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  inline long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    scalbln(_Tp __x, long __ex)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return scalbln(__type(__x), __ex);
    }

  inline float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  inline long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    scalbn(_Tp __x, int __ex)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return scalbn(__type(__x), __ex);
    }

  inline float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  inline long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    tgamma(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return tgamma(__type(__x));
    }

  inline float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  inline long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    trunc(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return trunc(__type(__x));
    }


}
# 37 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2

# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_fpo.h" 1
# 62 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_fpo.h"
# 1 "/usr/include/assert.h" 1 3 4
# 63 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_fpo.h" 2
# 39 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2


namespace hls {


  int signbit(double);
  int signbit(float);
  int signbit(half);
  int signbitf(float);
  int half_signbit(half);


  double nan(const char*);
  float nanf(const char*);
  half half_nan(const char *);


  int isfinite(double);
  int isfinite(float);
  int isfinite(half);
  int isfinitef(float);
  int half_isfinite(half);


  int __isfinite(double);
  int __isfinite(float);
  int __isfinite(half);
  int __isfinitef(float);


  int isinf(double);
  int isinf(float);
  int isinf(half);
  int isinff(float);
  int half_isinf(half);


  int __isinf(double);
  int __isinf(float);
  int __isinf(half);
  int __isinff(float);


  int isnan(double);
  int isnan(float);
  int isnan(half);
  int isnanf(float);
  int half_isnan(half);


  int __isnan(double);
  int __isnan(float);
  int __isnan(half);
  int __isnanf(float);


  int isnormal(double);
  int isnormal(float);
  int isnormal(half);
  int isnormalf(float);
  int half_isnormal(half);


  int __isnormal(double);
  int __isnormal(float);
  int __isnormal(half);
  int __isnormalf(float);


  int fpclassify(double);
  int fpclassify(float);
  int fpclassify(half);
  int fpclassifyf(float);
  int half_fpclassify(half);


  int __fpclassify(double);
  int __fpclassify(float);
  int __fpclassify(half);
  int __fpclassifyf(float);


  double copysign(double, double);
  float copysign(float, float);
  half copysign(half, half);
  float copysignf(float, float);
  half half_copysign(half, half);
  int8_t copysign(int8_t, int8_t);
  uint8_t copysign(uint8_t, uint8_t);
  int16_t copysign(int16_t, int16_t);
  uint16_t copysign(uint16_t, uint16_t);
  int32_t copysign(int32_t, int32_t);
  uint32_t copysign(uint32_t, uint32_t);


  double fabs(double);
  float fabs(float);
  half fabs(half);
  float fabsf(float);
  half half_fabs(half);
  int8_t fabs(int8_t);
  uint8_t fabs(uint8_t);
  int16_t fabs(int16_t);
  uint16_t fabs(uint16_t);
  int32_t fabs(int32_t);
  uint32_t fabs(uint32_t);


  double abs(double);
  float abs(float);
  half abs(half);
  float absf(float);
  half half_abs(half);
  int8_t abs(int8_t);
  uint8_t abs(uint8_t);
  int16_t abs(int16_t);
  uint16_t abs(uint16_t);
  int32_t abs(int32_t);
  uint32_t abs(uint32_t);


  double fma(double, double, double);
  float fma(float, float, float);
  half fma(half, half, half);
  float fmaf(float, float, float);
  half half_fma(half, half, half);


  double mad(double, double, double);
  float mad(float, float, float);
  half mad(half, half, half);
  float madf(float, float, float);
  half half_mad(half, half, half);


  int isequal(double, double);
  int isequal(float, float);
  int isequal(half, half);
  int isequalf(float, float);
  int half_isequal(half, half);


  int isgreater(double, double);
  int isgreater(float, float);
  int isgreater(half, half);
  int isgreaterf(float, float);
  int half_isgreater(half, half);


  int isgreaterequal(double, double);
  int isgreaterequal(float, float);
  int isgreaterequal(half, half);
  int isgreaterequalf(float, float);
  int half_isgreaterequal(half, half);


  int isless(double, double);
  int isless(float, float);
  int isless(half, half);
  int islessf(float, float);
  int half_isless(half, half);


  int islessequal(double, double);
  int islessequal(float, float);
  int islessequal(half, half);
  int islessequalf(float, float);
  int half_islessequal(half, half);


  int islessgreater(double, double);
  int islessgreater(float, float);
  int islessgreater(half, half);
  int islessgreaterf(float, float);
  int half_islessgreater(half, half);


  int isnotequal(double, double);
  int isnotequal(float, float);
  int isnotequal(half, half);
  int isnotequalf(float, float);
  int half_isnotequal(half, half);


  double fmax(double, double);
  float fmax(float, float);
  half fmax(half, half);
  float fmaxf(float, float);
  half half_fmax(half, half);
  int8_t fmax(int8_t,int8_t);
  uint8_t fmax(uint8_t, uint8_t);
  int16_t fmax(int16_t, int16_t);
  uint16_t fmax(uint16_t, uint16_t);
  int32_t fmax(int32_t, int32_t);
  uint32_t fmax(uint32_t, uint32_t);


  double fmin(double, double);
  float fmin(float, float);
  half fmin(half, half);
  float fminf(float, float);
  half half_fmin(half, half);
  int8_t fmin(int8_t,int8_t);
  uint8_t fmin(uint8_t, uint8_t);
  int16_t fmin(int16_t, int16_t);
  uint16_t fmin(uint16_t, uint16_t);
  int32_t fmin(int32_t, int32_t);
  uint32_t fmin(uint32_t, uint32_t);


  template <class T>
  T max(T x, T y){
 return (x > y) ? x : y;
  }


  template <class T>
  T min(T x, T y){
 return (x < y) ? x : y;
  }


  double fdim(double, double);
  float fdim(float, float);
  half fdim(half, half);
  float fdimf(float, float);
  half half_fdim(half, half);
  int8_t fdim(int8_t,int8_t);
  uint8_t fdim(uint8_t, uint8_t);
  int16_t fdim(int16_t, int16_t);
  uint16_t fdim(uint16_t, uint16_t);
  int32_t fdim(int32_t, int32_t);
  uint32_t fdim(uint32_t, uint32_t);


  double maxmag(double, double);
  float maxmag(float, float);
  half maxmag(half, half);
  float maxmagf(float, float);
  half half_maxmag(half, half);
  int8_t maxmag(int8_t,int8_t);
  uint8_t maxmag(uint8_t, uint8_t);
  int16_t maxmag(int16_t, int16_t);
  uint16_t maxmag(uint16_t, uint16_t);
  int32_t maxmag(int32_t, int32_t);
  uint32_t maxmag(uint32_t, uint32_t);


  double minmag(double, double);
  float minmag(float, float);
  half minmag(half, half);
  float minmagf(float, float);
  half half_minmag(half, half);
  int8_t minmag(int8_t,int8_t);
  uint8_t minmag(uint8_t, uint8_t);
  int16_t minmag(int16_t, int16_t);
  uint16_t minmag(uint16_t, uint16_t);
  int32_t minmag(int32_t, int32_t);
  uint32_t minmag(uint32_t, uint32_t);



  double frexp(double, int*);
  float frexp(float, int*);
  half frexp(half, int*);
  float frexpf(float, int*);
  half half_frexp(half, int*);


  double ldexp(double, int);
  float ldexp(float, int);
  half ldexp(half, int);
  float ldexpf(float, int);
  half half_ldexp(half, int);


  int ilogb(double);
  int ilogb(float);
  int ilogb(half);
  int ilogbf(float);
  int half_ilogb(half);


  double scalbn(double, int);
  float scalbn(float, int);
  half scalbn(half, int);
  float scalbnf(float, int);
  half half_scalbn(half, int);


  double scalbln(double, long int);
  float scalbln(float, long int);
  half scalbln(half, long int);
  float scalblnf(float, long int);
  half half_scalbln(half, long int);


  double ceil(double);
  float ceil(float);
  half ceil(half);
  float ceilf(float);
  half half_ceil(half);


  double floor(double);
  float floor(float);
  half floor(half);
  float floorf(float);
  half half_floor(half);


  double trunc(double);
  float trunc(float);
  half trunc(half);
  float truncf(float);
  half half_trunc(half);


  double round(double);
  float round(float);
  half round(half);
  float roundf(float);
  half half_round(half);


  double rint(double);
  float rint(float);
  half rint(half);
  float rintf(float);
  half half_rint(half);


  long int lround(double);
  long int lround(float);
  long int lround(half);
  long int lroundf(float);
  long int half_lround(half);


  long long int llround(double);
  long long int llround(float);
  long long int llround(half);
  long long int llroundf(float);
  long long int half_llround(half);


  long int lrint(double);
  long int lrint(float);
  long int lrint(half);
  long int lrintf(float);
  long int half_lrint(half);


  long long int llrint(double);
  long long int llrint(float);
  long long int llrint(half);
  long long int llrintf(float);
  long long int half_llrint(half);


  template<class T>
  T cast_IEEE754(double, bool);
  template<class T>
  T cast_IEEE754(float, bool);
  template<class T>
  T cast_IEEE754(half, bool);

  template<class T>
  T cast_IEEE754(double);
  template<class T>
  T cast_IEEE754(float);
  template<class T>
  T cast_IEEE754(half);



  template<>
  char cast_IEEE754<char>(double, bool);
  template<>
  char cast_IEEE754<char>(float, bool);
  template<>
  char cast_IEEE754<char>(half, bool);
  template<>
  char cast_IEEE754<char>(double);
  template<>
  char cast_IEEE754<char>(float);
  template<>
  char cast_IEEE754<char>(half);


  template<>
  int8_t cast_IEEE754<int8_t>(double, bool);
  template<>
  int8_t cast_IEEE754<int8_t>(float, bool);
  template<>
  int8_t cast_IEEE754<int8_t>(half, bool);
  template<>
  int8_t cast_IEEE754<int8_t>(double);
  template<>
  int8_t cast_IEEE754<int8_t>(float);
  template<>
  int8_t cast_IEEE754<int8_t>(half);


  template<>
  uint8_t cast_IEEE754<uint8_t>(double, bool);
  template<>
  uint8_t cast_IEEE754<uint8_t>(float, bool);
  template<>
  uint8_t cast_IEEE754<uint8_t>(half, bool);
  template<>
  uint8_t cast_IEEE754<uint8_t>(double);
  template<>
  uint8_t cast_IEEE754<uint8_t>(float);
  template<>
  uint8_t cast_IEEE754<uint8_t>(half);


  template<>
  int16_t cast_IEEE754<int16_t>(double, bool);
  template<>
  int16_t cast_IEEE754<int16_t>(float, bool);
  template<>
  int16_t cast_IEEE754<int16_t>(half, bool);
  template<>
  int16_t cast_IEEE754<int16_t>(double);
  template<>
  int16_t cast_IEEE754<int16_t>(float);
  template<>
  int16_t cast_IEEE754<int16_t>(half);


  template<>
  uint16_t cast_IEEE754<uint16_t>(double, bool);
  template<>
  uint16_t cast_IEEE754<uint16_t>(float, bool);
  template<>
  uint16_t cast_IEEE754<uint16_t>(half, bool);
  template<>
  uint16_t cast_IEEE754<uint16_t>(double);
  template<>
  uint16_t cast_IEEE754<uint16_t>(float);
  template<>
  uint16_t cast_IEEE754<uint16_t>(half);


  template<>
  int32_t cast_IEEE754<int32_t>(double, bool);
  template<>
  int32_t cast_IEEE754<int32_t>(float, bool);
  template<>
  int32_t cast_IEEE754<int32_t>(half, bool);
  template<>
  int32_t cast_IEEE754<int32_t>(double);
  template<>
  int32_t cast_IEEE754<int32_t>(float);
  template<>
  int32_t cast_IEEE754<int32_t>(half);


  template<>
  uint32_t cast_IEEE754<uint32_t>(double, bool);
  template<>
  uint32_t cast_IEEE754<uint32_t>(float, bool);
  template<>
  uint32_t cast_IEEE754<uint32_t>(half, bool);
  template<>
  uint32_t cast_IEEE754<uint32_t>(double);
  template<>
  uint32_t cast_IEEE754<uint32_t>(float);
  template<>
  uint32_t cast_IEEE754<uint32_t>(half);


  template<>
  int64_t cast_IEEE754<int64_t>(double, bool);
  template<>
  int64_t cast_IEEE754<int64_t>(float, bool);
  template<>
  int64_t cast_IEEE754<int64_t>(half, bool);
  template<>
  int64_t cast_IEEE754<int64_t>(double);
  template<>
  int64_t cast_IEEE754<int64_t>(float);
  template<>
  int64_t cast_IEEE754<int64_t>(half);


  template<>
  uint64_t cast_IEEE754<uint64_t>(double, bool);
  template<>
  uint64_t cast_IEEE754<uint64_t>(float, bool);
  template<>
  uint64_t cast_IEEE754<uint64_t>(half, bool);
  template<>
  uint64_t cast_IEEE754<uint64_t>(double);
  template<>
  uint64_t cast_IEEE754<uint64_t>(float);
  template<>
  uint64_t cast_IEEE754<uint64_t>(half);



  double nearbyint(double);
  float nearbyint(float);
  half nearbyint(half);
  float nearbyintf(float);
  half half_nearbyint(half);


  double modf(double, double*);
  float modf(float, float*);
  half modf(half, half*);
  float modff(float, float*);
  half half_modf(half, half*);


  double fract(double, double*);
  float fract(float, float*);
  half fract(half, half*);
  float fractf(float, float*);
  half half_fract(half, half*);


  int isordered(double, double);
  int isordered(float, float);
  int isordered(half, half);
  int isorderedf(float, float);
  int half_isordered(half, half);


  int isunordered(double, double);
  int isunordered(float, float);
  int isunordered(half, half);
  int isunorderedf(float, float);
  int half_isunordered(half, half);


  double bitselect(double, double, double);
  float bitselect(float, float, float);
  int bitselect(int, int, int);
  uint32_t bitselect(uint32_t, uint32_t, uint32_t);
  half bitselect(half, half, half);
  float bitselectf(float, float, float);
  half half_bitselect(half, half, half);


  namespace hotbm {
 double sin(double);
 float sin(float);
 half sin(half);
 float sinf(float);
 half half_sin(half);

 double cos(double);
 float cos(float);
 half cos(half);
 float cosf(float);
 half half_cos(half);

 void sincos(double, double*, double*);
 void sincos(float, float*, float*);
 void sincos(half, half*, half*);
 void sincosf(float, float*, float*);
 void half_sincos(half, half*, half*);
  }


  namespace cordic {
 double sin(double);
 float sin(float);
 half sin(half);
 float sinf(float);
 half half_sin(half);

 double cos(double);
 float cos(float);
 half cos(half);
 float cosf(float);
 half half_cos(half);

 void sincos(double, double*, double*);
 void sincos(float, float*, float*);
 void sincos(half, half*, half*);
 void sincosf(float, float*, float*);
 void half_sincos(half, half*, half*);
  }


  double sin(double);
  float sin(float);
  half sin(half);
  float sinf(float);
  half half_sin(half);

  double cos(double);
  float cos(float);
  half cos(half);
  float cosf(float);
  half half_cos(half);


  void sincos(double, double*, double*);
  void sincos(float, float*, float*);
  void sincos(half, half*, half*);
  void sincosf(float, float*, float*);
  void half_sincos(half, half*, half*);


  double sinpi(double);
  float sinpi(float);
  half sinpi(half);
  float sinpif(float);
  half half_sinpi(half);


  double cospi(double);
  float cospi(float);
  half cospi(half);
  float cospif(float);
  half half_cospi(half);


  double tanpi(double);
  float tanpi(float);
  half tanpi(half);
  float tanpif(float);
  half half_tanpi(half);


  double atan(double);
  float atan(float);
  half atan(half);
  float atanf(float);
  half half_atan(half);


  double atan2(double, double);
  float atan2(float, float);
  half atan2(half, half);
  float atan2f(float, float);
  half half_atan2(half, half);


  double tan(double);
  float tan(float);
  half tan(half);
  float tanf(float);
  half half_tan(half);


  double sinh(double);
  float sinh(float);
  half sinh(half);
  float sinhf(float);
  half half_sinh(half);


  double cosh(double);
  float cosh(float);
  half cosh(half);
  float coshf(float);
  half half_cosh(half);


  double exp(double);
  float exp(float);
  half exp(half);
  float expf(float);
  half half_exp(half);
  int8_t exp(int8_t);
  uint8_t exp(uint8_t);
  int16_t exp(int16_t);
  uint16_t exp(uint16_t);
  int32_t exp(int32_t);
  uint32_t exp(uint32_t);


  double exp2(double);
  float exp2(float);
  half exp2(half);
  float exp2f(float);
  half half_exp2(half);


  double exp10(double);
  float exp10(float);
  half exp10(half);
  float exp10f(float);
  half half_exp10(half);


  double expm1(double);
  float expm1(float);
  half expm1(half);
  float expm1f(float);
  half half_expm1(half);


  double log(double);
  float log(float);
  half log(half);
  float logf(float);
  half half_log(half);
  int8_t log(int8_t);
  uint8_t log(uint8_t);
  int16_t log(int16_t);
  uint16_t log(uint16_t);
  int32_t log(int32_t);
  uint32_t log(uint32_t);


  double log2(double);
  float log2(float);
  half log2(half);
  float log2f(float);
  half half_log2(half);


  double log10(double);
  float log10(float);
  half log10(half);
  float log10f(float);
  half half_log10(half);
  int8_t log10(int8_t);
  uint8_t log10(uint8_t);
  int16_t log10(int16_t);
  uint16_t log10(uint16_t);
  int32_t log10(int32_t);
  uint32_t log10(uint32_t);


  double logb(double);
  float logb(float);
  half logb(half);
  float logbf(float);
  half half_logb(half);

  double log1p(double);
  float log1p(float);
  half log1p(half);
  float log1pf(float);
  half half_log1p(half);


  half pow(half, half);
  float pow(float, float);
  double pow(double, double);
  float powf(float, float);
  half half_pow(half, half);
  int8_t pow(int8_t, int8_t);
  uint8_t pow(uint8_t, uint8_t);
  int16_t pow(int16_t, int16_t);
  uint16_t pow(uint16_t, uint16_t);
  int32_t pow(int32_t, int32_t);
  uint32_t pow(uint32_t, uint32_t);
  int8_t powr(int8_t, int8_t);
  uint8_t powr(uint8_t, uint8_t);
  int16_t powr(int16_t, int16_t);
  uint16_t powr(uint16_t, uint16_t);
  int32_t powr(int32_t, int32_t);
  uint32_t powr(uint32_t, uint32_t);


  half powr(half, half);
  float powr(float, float);
  double powr(double, double);
  float powrf(float, float);
  half half_powr(half, half);


  half pown(half, int);
  float pown(float, int);
  double pown(double, int);
  float pownf(float, int);
  half half_pown(half, int);


  half rootn(half, int);
  float rootn(float, int);
  double rootn(double, int);
  float rootnf(float, int);
  half half_rootn(half, int);


  double sqrt(double);
  float sqrt(float);
  half sqrt(half);
  float sqrtf(float);
  half half_sqrt(half);
  int8_t sqrt(int8_t);
  uint8_t sqrt(uint8_t);
  int16_t sqrt(int16_t);
  uint16_t sqrt(uint16_t);
  int32_t sqrt(int32_t);
  uint32_t sqrt(uint32_t);
# 854 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h"
  double recip(double);
  float recip(float);
  half recip(half);
  float recipf(float);
  half half_recip(half);
  int8_t recip(int8_t);
  uint8_t recip(uint8_t);
  int16_t recip(int16_t);
  uint16_t recip(uint16_t);
  int32_t recip(int32_t);
  uint32_t recip(uint32_t);


  double rsqrt(double);
  float rsqrt(float);
  half rsqrt(half);
  float rsqrtf(float);
  half half_rsqrt(half);
  int8_t rsqrt(int8_t);
  uint8_t rsqrt(uint8_t);
  int16_t rsqrt(int16_t);
  uint16_t rsqrt(uint16_t);
  int32_t rsqrt(int32_t);
  uint32_t rsqrt(uint32_t);


  double cbrt(double);
  float cbrt(float);
  half cbrt(half);
  float cbrtf(float);
  half half_cbrt(half);


  double hypot(double, double);
  float hypot(float, float);
  half hypot(half, half);
  float hypotf(float, float);
  half half_hypot(half, half);


  double erf(double);
  float erf(float);
  half erf(half);
  float erff(float);
  half half_erf(half);
  int8_t erf(int8_t);
  uint8_t erf(uint8_t);
  int16_t erf(int16_t);
  uint16_t erf(uint16_t);
  int32_t erf(int32_t);
  uint32_t erf(uint32_t);


  double erfc(double);
  float erfc(float);
  half erfc(half);
  float erfcf(float);
  half half_erfc(half);
  int8_t erfc(int8_t);
  uint8_t erfc(uint8_t);
  int16_t erfc(int16_t);
  uint16_t erfc(uint16_t);
  int32_t erfc(int32_t);
  uint32_t erfc(uint32_t);


  double fmod(double, double);
  float fmod(float, float);
  half fmod(half, half);
  float fmodf(float, float);
  half half_fmod(half, half);


  double remainder(double, double);
  float remainder(float, float);
  half remainder(half, half);
  float remainderf(float, float);
  half half_remainder(half, half);


  double remquo(double, double, int*);
  float remquo(float, float, int*);
  half remquo(half, half, int*);
  float remquof(float, float, int*);
  half half_remquo(half, half, int*);


  double divide(double, double);
  float divide(float, float);
  half divide(half, half);
  float dividef(float, float);
  half half_divide(half, half);


  double nextafter(double, double);
  float nextafter(float, float);
  half nextafter(half, half);
  float nextafterf(float, float);
  half half_nextafter(half, half);


  double tanh(double);
  float tanh(float);
  half tanh(half);
  float tanhf(float);
  half half_tanh(half);


  double atanh(double);
  float atanh(float);
  half atanh(half);
  float atanhf(float);
  half half_atanh(half);


  double asinh(double);
  float asinh(float);
  half asinh(half);
  float asinhf(float);
  half half_asinh(half);


  double acosh(double);
  float acosh(float);
  half acosh(half);
  float acoshf(float);
  half half_acosh(half);


  double asin(double);
  float asin(float);
  half asin(half);
  float asinf(float);
  half half_asin(half);


  double acos(double);
  float acos(float);
  half acos(half);
  float acosf(float);
  half half_acos(half);


  double asinpi(double);
  float asinpi(float);
  half asinpi(half);
  float asinpif(float);
  half half_asinpi(half);


  double acospi(double);
  float acospi(float);
  half acospi(half);
  float acospif(float);
  half half_acospi(half);


  double atanpi(double);
  float atanpi(float);
  half atanpi(half);
  float atanpif(float);
  half half_atanpi(half);
}


# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hotbm_apfixed.h" 1
# 43 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hotbm_apfixed.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 44 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hotbm_apfixed.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_defines.h" 1
# 39 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_defines.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 40 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_defines.h" 2
# 107 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_defines.h"
template<int M, int E>
struct float_struct {
    ap_uint<M> mant;
    ap_uint<E> exp;
    ap_uint<1> sign;
};




template<int M, int E>
struct float_struct2 {
    ap_int<M> mant;
    ap_uint<E> exp;
};
# 45 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hotbm_apfixed.h" 2







namespace hotbm_apfixed
{

  namespace first_order_fixed_16{
 extern const ap_fixed<19,2> sin_cos_K0[256];
 extern const ap_fixed<11,2> sin_cos_K1[256];
  };

  namespace second_order_float{
 extern const ap_fixed<29,0> cos_K0[128];
 extern const ap_fixed<23,1> cos_K1[128];
 extern const ap_fixed<15,0> cos_K2[128];
 extern const ap_fixed<30,1> sin_K0[128];
 extern const ap_fixed<21,-1> sin_K1[128];
 extern const ap_fixed<13,-2> sin_K2[128];
 extern const ap_ufixed<30,1> sin_cos_K0[256];
 extern const ap_fixed<23,1> sin_cos_K1[256];
 extern const ap_fixed<15,0> sin_cos_K2[256];
  };

  namespace fourth_order_double{
 extern const ap_fixed<59,0> cos_K0[128];
 extern const ap_fixed<53,1> cos_K1[128];
 extern const ap_fixed<45,0> cos_K2[128];
 extern const ap_fixed<35,-3> cos_K3[128];
 extern const ap_fixed<27,-4> cos_K4[128];
 extern const ap_fixed<60,1> sin_K0[128];
 extern const ap_fixed<51,-1> sin_K1[128];
 extern const ap_fixed<43,-2> sin_K2[128];
 extern const ap_fixed<33,-5> sin_K3[128];
 extern const ap_fixed<24,-7> sin_K4[128];
 extern const ap_fixed<59,1> sin_cos_K0[256];
 extern const ap_fixed<52,1> sin_cos_K1[256];
 extern const ap_fixed<44,0> sin_cos_K2[256];
 extern const ap_fixed<34,-3> sin_cos_K3[256];
 extern const ap_fixed<26,-4> sin_cos_K4[256];
  };

  template<class T>
  struct value_list{
  };

  template<>
  struct value_list<double>{
    typedef double T;
 static const int g = 10;
 static const int p1 = 61;
 static const int alpha = 7;

 static const int beta1 = 0;

 static const int beta2 = alpha;

    static const int W_dout = fp_struct<T>::SIG_BITS+1+g;
    static const int W_Mx = fp_struct<T>::SIG_BITS+1+g;

    template <int Wx, int Wr>
    static ap_ufixed<Wx, 1> sin_or_cos_approximation(bool do_cos,
              ap_uint<3> &k,
              ap_ufixed<Wx, 0> &x,
              ap_ufixed<Wr, 0> &Mx,
              ap_int<fp_struct<double>::EXP_BITS> &Ex){

   const bool swap_table[8] = {0,1,1,0,0,1,1,0};
_ssdm_SpecConstant(swap_table);
# 115 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hotbm_apfixed.h"

#pragma HLS array_partition variable=&swap_table complete
#pragma HLS RESOURCE variable=&fourth_order_double::sin_cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&fourth_order_double::sin_cos_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&fourth_order_double::sin_cos_K2 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&fourth_order_double::sin_cos_K3 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&fourth_order_double::sin_cos_K4 core=ROM_1P_LUTRAM

 ap_uint<alpha+1> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;
   ap_ufixed<Wx-3*alpha, -3*alpha> B_third_power = B_trunc*B_squared;
   ap_ufixed<Wx-4*alpha, -4*alpha> B_fourth_power = B_squared*B_squared;

   bool sin_basis = do_cos? swap_table[k]:!swap_table[k];
   A[alpha] = sin_basis;

   ap_fixed<Wx, 1> t1 = fourth_order_double::sin_cos_K0[A];
   ap_fixed<Wx, 1> t2 = B*fourth_order_double::sin_cos_K1[A];
   ap_fixed<Wx, 1> t3 = B_squared*fourth_order_double::sin_cos_K2[A];
   ap_fixed<Wx, 1> t4 = B_third_power*fourth_order_double::sin_cos_K3[A];
   ap_fixed<Wx, 1> t5 = B_fourth_power*fourth_order_double::sin_cos_K4[A];
   ap_ufixed<Wx, 1> result = Mx*(t1+t2+t3+t4+t5);
   return result;
    }

    template <int Wx, int Wr>
    static void sincos_approximation(ap_uint<3> &k,
          ap_ufixed<Wx, 0> &x,
          ap_ufixed<Wr, 0> Mx,
          ap_int<fp_struct<double>::EXP_BITS> Ex,
          ap_ufixed<Wr, 1> &sin_result,
          ap_ufixed<Wr, 1> &cos_result
          ) {
#pragma HLS RESOURCE variable=&fourth_order_double::cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&fourth_order_double::cos_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&fourth_order_double::cos_K2 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&fourth_order_double::cos_K3 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&fourth_order_double::cos_K4 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&fourth_order_double::sin_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&fourth_order_double::sin_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&fourth_order_double::sin_K2 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&fourth_order_double::sin_K3 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&fourth_order_double::sin_K4 core=ROM_1P_LUTRAM

 ap_uint<alpha> A = x(x.wl()-x.iwl()-1,
         x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;
   ap_ufixed<Wx-3*alpha, -3*alpha> B_third_power = B_trunc*B_squared;
   ap_ufixed<Wx-4*alpha, -4*alpha> B_fourth_power = B_squared*B_squared;

   ap_fixed<Wx, 1> cos_t1 = fourth_order_double::cos_K0[A];
   ap_fixed<Wx, 1> cos_t2 = B*fourth_order_double::cos_K1[A];
   ap_fixed<Wx, 1> cos_t3 = B_squared*fourth_order_double::cos_K2[A];
   ap_fixed<Wx, 1> cos_t4 = B_third_power*fourth_order_double::cos_K3[A];
   ap_fixed<Wx, 1> cos_t5 = B_fourth_power*fourth_order_double::cos_K4[A];
   cos_result = 1 - (cos_t1 + cos_t2 + cos_t3 + cos_t4 + cos_t5);

   ap_fixed<Wx, 1> sin_t1 = fourth_order_double::sin_K0[A];
   ap_fixed<Wx, 1> sin_t2 = B*fourth_order_double::sin_K1[A];
   ap_fixed<Wx, 1> sin_t3 = B_squared*fourth_order_double::sin_K2[A];
   ap_fixed<Wx, 1> sin_t4 = B_third_power*fourth_order_double::sin_K3[A];
   ap_fixed<Wx, 1> sin_t5 = B_fourth_power*fourth_order_double::sin_K4[A];
   sin_result = Mx * (sin_t1 + sin_t2 + sin_t3 + sin_t4 + sin_t5);
    }
  };

  template<>
  struct value_list<float> {
 typedef float T;
 static const int g = 5;
 static const int p1 = 29;
 static const int alpha = 7;
 static const int beta1 = 0;
 static const int beta2 = 7;

 static const int W_dout = fp_struct<T>::SIG_BITS+1+g;
 static const int W_Mx = fp_struct<T>::SIG_BITS+1+g;

 template <int Wx, int Wr>
 static ap_ufixed<Wx, 1> sin_or_cos_approximation(bool do_cos,
              ap_uint<3> &k,
              ap_ufixed<Wx, 0> &x,
              ap_ufixed<Wr, 0> &Mx,
              ap_int<fp_struct<float>::EXP_BITS> &Ex){

   const bool swap_table[8] = {0,1,1,0,0,1,1,0};
_ssdm_SpecConstant(swap_table);
# 204 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hotbm_apfixed.h"


#pragma HLS array_partition variable=&swap_table complete
#pragma HLS RESOURCE variable=&second_order_float::sin_cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&second_order_float::sin_cos_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&second_order_float::sin_cos_K2 core=ROM_1P_LUTRAM

 ap_uint<alpha+1> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;

   bool sin_basis = do_cos? swap_table[k]:!swap_table[k];
   A[alpha] = sin_basis;

   ap_fixed<Wx, 1> t1 = second_order_float::sin_cos_K0[A];
   ap_fixed<Wx, 1> t2 = B*second_order_float::sin_cos_K1[A];
   ap_fixed<Wx, 1> t3 = B_squared*second_order_float::sin_cos_K2[A];
   ap_ufixed<Wx, 1> result = (t1+t2+t3) * Mx;

   return result;
 }

 template <int Wx, int Wr>
 static void sincos_approximation(ap_uint<3> &k,
          ap_ufixed<Wx, 0> &x,
          ap_ufixed<Wr, 0> &Mx,
          ap_int<fp_struct<float>::EXP_BITS> &Ex,
          ap_ufixed<Wr, 1> &sin_result,
          ap_ufixed<Wr, 1> &cos_result
          ) {
#pragma HLS RESOURCE variable=&second_order_float::cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&second_order_float::cos_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&second_order_float::cos_K2 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&second_order_float::sin_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&second_order_float::sin_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&second_order_float::sin_K2 core=ROM_1P_LUTRAM

 ap_uint<alpha> A = x(x.wl()-x.iwl()-1,
         x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;


   ap_ufixed<Wx, 1> cos_t1 = second_order_float::cos_K0[A];
   ap_ufixed<Wx, 1> cos_t2 = B*second_order_float::cos_K1[A];
   ap_ufixed<Wx, 1> cos_t3 = B_squared*second_order_float::cos_K2[A];
   cos_result = 1 - (cos_t1 + cos_t2 + cos_t3);

   ap_fixed<Wx, 1> sin_t1 = second_order_float::sin_K0[A];
   ap_fixed<Wx, 1> sin_t2 = B*second_order_float::sin_K1[A];
   ap_fixed<Wx, 1> sin_t3 = B_squared*second_order_float::sin_K2[A];
   sin_result = Mx * (sin_t1 + sin_t2 + sin_t3);
 }
  };

  struct sin_cos_fixed_16 {

 typedef half T;
 static const int g = 3;
 static const int p1 = 12;
 static const int alpha = 8;
 static const int beta1 = 4;

 template <int W_dout>
 static ap_ufixed<W_dout, 1> sin_or_cos_approximation(bool do_cos,
               ap_uint<2> &k,
               ap_ufixed<W_dout, 0> &x){

#pragma HLS RESOURCE variable=&first_order_fixed_16::sin_cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=&first_order_fixed_16::sin_cos_K1 core=ROM_1P_LUTRAM

 ap_uint<alpha> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);

   const int BW = (W_dout-alpha-beta1)>1 ? W_dout-alpha-beta1 : 2;
   ap_ufixed<BW, -alpha> B = x;

   ap_fixed<W_dout, 1> t1 = first_order_fixed_16::sin_cos_K0[A];
   ap_fixed<W_dout, 1> t2 = B*first_order_fixed_16::sin_cos_K1[A];
   ap_ufixed<W_dout, 1> result = (t1+t2);

   return result;
 };
  };

  template<int W, int I>
  ap_fixed<W,2>
  sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi,
      typename hls::enable_if<(W > 16) && (W <= 32), bool>::type dummy = true)
  {
 const int WO = W;
 const int g = 3;

 const bool swap_table[8] = {0,1,1,0,0,1,1,0};
_ssdm_SpecConstant(swap_table);
# 298 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hotbm_apfixed.h"

 const bool neg_sin_table[16] = {0,0,1,0,1,1,0,1, 1,0,1,1,0,1,0,0};
_ssdm_SpecConstant(neg_sin_table);
# 299 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hotbm_apfixed.h"

 const bool neg_cos_table[16] = {0,0,0,1,1,1,1,0, 0,1,1,1,1,0,0,0};
_ssdm_SpecConstant(neg_cos_table);
# 300 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hotbm_apfixed.h"


#pragma HLS array_partition variable=&swap_table complete
#pragma HLS array_partition variable=&neg_sin_table complete
#pragma HLS array_partition variable=&neg_cos_table complete

 ap_uint<3> k;
 ap_ufixed<WO+1+g, 0> x;
 ap_ufixed<WO+1+g, 0> Mx;
 ap_int<fp_struct<float>::EXP_BITS> Ex = 0;

 int exactly_pi_over_4 = 0;
 bool is_negative = t_in[t_in.wl()-1];
 ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

 if(do_pi) {
   k = din*4;
   x = din*4;
   ap_ufixed<W, 1> Mx_bits_extended = din*4;



   exactly_pi_over_4 = (Mx_bits_extended == 1);
 } else {
   ap_ufixed<WO+1+g+3, 3> Wx = din * ap_ufixed<W+1+g,2>(4/3.14159265358979323846);
   k = Wx;
   x = Wx;
 }




 if(k[0] == 1) {
   x = 1-x;
 }
 Mx = x;

 bool cos_basis = do_cos?!swap_table[k]: swap_table[k];
 if(cos_basis) {


   Mx = ap_ufixed<value_list<float>::W_dout, 0, AP_RND, AP_SAT>(1);
   Ex = 0;
 }

 ap_ufixed<WO+1+g, 1> result = value_list<float>::sin_or_cos_approximation(do_cos,k,x,Mx,Ex);

 if(exactly_pi_over_4) {
   result = 0.7071067811865475244008443;
 }

 ap_uint<4> index = k;
 index[3] = is_negative;

 if(cos_basis ? neg_cos_table[index] : neg_sin_table[index]) {
   return -result;
 } else {
   return result;
 }
  }


  template<int W, int I>
  ap_fixed<W,2>
  sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi,
      typename hls::enable_if<(W > 32) && (W <= 64), bool>::type dummy = true)
  {
 const int WO = W;
 const int g = 3;

 const bool swap_table[8] = {0,1,1,0,0,1,1,0};
_ssdm_SpecConstant(swap_table);
# 370 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hotbm_apfixed.h"

 const bool neg_sin_table[16] = {0,0,1,0,1,1,0,1, 1,0,1,1,0,1,0,0};
_ssdm_SpecConstant(neg_sin_table);
# 371 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hotbm_apfixed.h"

 const bool neg_cos_table[16] = {0,0,0,1,1,1,1,0, 0,1,1,1,1,0,0,0};
_ssdm_SpecConstant(neg_cos_table);
# 372 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hotbm_apfixed.h"

#pragma HLS array_partition variable=&swap_table complete
#pragma HLS array_partition variable=&neg_sin_table complete
#pragma HLS array_partition variable=&neg_cos_table complete

 ap_uint<3> k;
 ap_ufixed<WO+1+g, 0> x;
 ap_ufixed<WO+1+g, 0> Mx;
 ap_int<fp_struct<double>::EXP_BITS> Ex = 0;

 int exactly_pi_over_4 = 0;
 bool is_negative = t_in[t_in.wl()-1];
 ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

 if(do_pi) {
   k = din*4;
   x = din*4;
   ap_ufixed<W, 1> Mx_bits_extended = din*4;



   exactly_pi_over_4 = (Mx_bits_extended == 1);
 } else {
   ap_ufixed<WO+1+g+3, 3> Wx = din * ap_ufixed<W+1+g,2>(4/3.14159265358979323846);
   k = Wx;
   x = Wx;
 }




 if(k[0] == 1) {
   x = 1-x;
 }
 Mx = x;

 bool cos_basis = do_cos?!swap_table[k]: swap_table[k];
 if(cos_basis) {


   Mx = ap_ufixed<value_list<double>::W_dout, 0, AP_RND, AP_SAT>(1);
   Ex = 0;
 }

 ap_ufixed<WO+1+g, 1> result = value_list<double>::sin_or_cos_approximation(do_cos,k,x,Mx,Ex);

 if(exactly_pi_over_4) {
   result = 0.7071067811865475244008443;
 }

 ap_uint<4> index = k;
 index[3] = is_negative;

 if(cos_basis ? neg_cos_table[index] : neg_sin_table[index]) {
   return -result;
 } else {
   return result;
 }
  };


  template<int W, int I>
  ap_fixed<W,2>
  sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi,
      typename hls::enable_if<W <= 16, bool>::type dummy = true)
  {
 const int WO = W;
 const int g = 4;

 const bool neg_sin_table[8] = {0,0,1,1, 1,1,0,0};
_ssdm_SpecConstant(neg_sin_table);
# 441 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hotbm_apfixed.h"

 const bool neg_cos_table[8] = {0,1,1,0, 0,1,1,0};
_ssdm_SpecConstant(neg_cos_table);
# 442 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hotbm_apfixed.h"

#pragma HLS array_partition variable=&neg_sin_table complete
#pragma HLS array_partition variable=&neg_cos_table complete

 ap_uint<2> k;
 ap_ufixed<WO+1+g, 0> x;

 bool is_negative = t_in[t_in.wl()-1];
 ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

 if(do_pi) {
   k = din*2;
   x = din*2;
   ap_ufixed<W, 1> Mx_bits_extended = din*2;
 }
 else {
   ap_ufixed<WO+1+g+2, 2> Wx = din * ap_ufixed<W+1+g,2>(2/3.14159265358979323846);
   k = Wx;
   x = Wx;
 }

 bool is_special_case = false;

 if((k[0] == 1) ^ !do_cos) {
   ap_ufixed<WO+1+g+1, 1> Wx = 1-x;
   x = Wx;
   is_special_case = (Wx[Wx.wl()-1] == 1);
 }

 ap_ufixed<WO+1+g, 1> result = sin_cos_fixed_16::sin_or_cos_approximation(do_cos,k,x);

 if(is_special_case) {
   ap_uint<3> index = k;
   index[2] = do_cos;
   const bool special_case_table[8] = {0,1,0,1,1,0,1,0};
_ssdm_SpecConstant(special_case_table);
# 476 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hotbm_apfixed.h"

   result(result.wl()-2,0) = 0;
   result[result.wl()-1] = special_case_table[index];
 }

 {
   ap_uint<3> index = k;
   index[2] = is_negative;

   if(do_cos ? neg_cos_table[index] : neg_sin_table[index]) {
  return -result;
   } else {
  return result;
   }
 }
  };

};
# 1019 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h" 1
# 41 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 42 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h" 2





namespace cordic_apfixed {

  extern const ap_ufixed<128,2> circ_table_arctan_128[128];
  extern const int hyperb_table_tau_128[128];
  extern const ap_ufixed<128,4> hyperb_table_arctanh_128[128];





  template<int W, int I, int Wo>
  void circ_range_redux( ap_ufixed<W,I> x,
                         ap_uint<2> &k,
                         ap_ufixed<Wo,1> &r) {

    ap_ufixed<(Wo+I),0> inv_pi2("0x0.A2F9836E4E43FC715BBF");
    ap_ufixed<Wo+1,1> pi2("1.5707963267948966192313216916397514420985846996876");
    ap_ufixed<Wo+I,I> prod = x * inv_pi2;
    ap_uint<I> kint = prod;

    k = kint;
    r = x - kint * pi2;
  };






  template<int W, int I, int MODE>
  void cordic_circ_apfixed( ap_fixed<W,I> &x,
                            ap_fixed<W,I> &y,
                            ap_fixed<W,I> &z) {

    const int Nmax = W;

    ap_fixed<W,I> tx, ty, tz;
    ap_fixed<W,I> x_s, y_s, z_s;
    ap_uint<1> d;

    for (int n=0; n<Nmax; n++){
#pragma HLS pipeline

 if(MODE == 1) {
        d = ~y[W-1];
      }
      else {
        d = z[W-1];
      }

      x_s = x >> n;
      y_s = y >> n;
      z_s = circ_table_arctan_128[n];

      if(d){
        tx = x + y_s;
        ty = y - x_s;
        tz = z + z_s;
      }
      else{
        tx = x - y_s;
        ty = y + x_s;
        tz = z - z_s;
      }

      x = tx;
      y = ty;
      z = tz;
# 126 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h"
    }
  };







  template<int W, int I, int MODE, int INTYPE>
  void doublecordic_apfixed( ap_fixed<W,I> &x,
                             ap_fixed<W,I> &y,
                             ap_fixed<W,I> &z,
                             ap_fixed<W,I> &t) {

    const int Nmax = W - I + 1;

    for (int n=0; n<Nmax; n++){

      if(INTYPE==64){
#pragma HLS pipeline II=5
 }
      else if(INTYPE==32){
#pragma HLS pipeline II=3
 }
      else if(INTYPE==16){
#pragma HLS pipeline II=1
 }
      else{
#pragma HLS pipeline II=4
 }

      ap_uint<1> d;
      if(MODE == 0) {
        if(y<=t){
          d = x[W-1];
        }
        else{
          d = ~x[W-1];
        }
      }
      else {
        if(x>=t){
          d = y[W-1];
        }
        else{
          d = ~y[W-1];
        }
      }

      ap_fixed<W,I> x_s = x >> (n-1);
      ap_fixed<W,I> y_s = y >> (n-1);
      ap_fixed<W,I> x_s2 = x_s >> (n+1);
      ap_fixed<W,I> y_s2 = y_s >> (n+1);

      x = x - x_s2;
      y = y - y_s2;
      if(d){
        x = x + y_s;
        y = y - x_s;
      }
      else{
        x = x - y_s;
        y = y + x_s;
      }


      ap_fixed<W,I> t_s;
      int n2 = (n << 1);
      if(n2<W){
        t_s = (t >> n2);
        t = t + t_s;
      }


      ap_fixed<W,I> ca = circ_table_arctan_128[n];
      ap_fixed<W,I> z_s = (ca << 1);
      ap_fixed<W,I> tz;
      if(d){
        tz = z - z_s;
      }
      else{
        tz = z + z_s;
      }
      z = tz;
# 221 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h"
    }
  };



  template<int W, int I>
  void generic_sincos(ap_fixed<W,I> in,
                      ap_fixed<W-I+2,2> & outsin, ap_fixed<W-I+2,2> & outcos){

    ap_uint<1> sign0 = (in > 0) ? 1: 0;


    ap_ufixed<W,I> inabs;
    if(sign0)
      inabs = in;
    else
      inabs = -in;


    const int Fr = (W - I) + I + 1;
    ap_uint<2> k;
    ap_ufixed<Fr,1> r;
    circ_range_redux(inabs, k, r);

    ap_fixed<W+2,3> x, y, z;

    const ap_fixed<W+2,3> K1("0x0.9B74EDA8435E47F277F7");
    x = K1;
    y = 0;

    if(k==1 or k==3){
      ap_ufixed<Fr,1> pi2("0x1.921FB54442D1846");

      z = pi2 - r;
    }
    else{
      z = r;
    }







    cordic_circ_apfixed<W+2,3,0>(x,y,z);







    if(k==0){
      outsin = y;
      outcos = x;
    }
    else if(k==1){
      outsin = y;
      outcos = -x;
    }
    else if(k==2){
      outsin = -y;
      outcos = -x;
    }
    else{
      outsin = -y;
      outcos = x;
    }

    if(sign0==0)
      outsin = -outsin;
  };


  template<int W, int I>
  ap_fixed<W,I> generic_tan(ap_fixed<W,I> x){

    const int Ix = I;
    const int Fx = (((W-I)>(I-1)) ? (W-I): (I-1)) + I;
    const int Wx = I + Fx;

    ap_fixed<Wx,Ix> xs = x;

    ap_fixed<Wx-Ix+2,2> outsin;
    ap_fixed<Wx-Ix+2,2> outcos;
    generic_sincos(xs, outsin, outcos);

    ap_fixed<W,I> out = outsin / outcos;


    if(I==1){
      if(out[W-1]==1){
        out[W-1] = 0;
        for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
 out[i] = 1;
        }
      }
    }

    return out;
  };


  template<int W, int I>
  ap_ufixed<W,I> generic_tan(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,I+1> fout = generic_tan(fin);
    ap_ufixed<W,I> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<I> generic_tan(ap_int<I> in) {
    ap_fixed<I,I> fin = in;
    ap_fixed<I,I> fout = generic_tan(fin);
    ap_int<I> out = fout;
    return out;
  };


  template<int I>
  ap_uint<I> generic_tan(ap_uint<I> in) {
    ap_fixed<I+1,I+1> fin = in;
    ap_fixed<I+1,I+1> fout = generic_tan(fin);
    ap_uint<I> out = 0;
    if(fout[I]==0){
        out = fout;
    }
    return out;
  };
# 366 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h"
  template<int W, int I, int Wo>
  void circ_range_redux_pi( ap_ufixed<W,I> x,
                             ap_uint<2> &k,
                             ap_ufixed<Wo,1> &r) {

    ap_ufixed<Wo+1,1> pi2("1.5707963267948966192313216916397514420985846996876");
    ap_ufixed<W+1,I+1> prod = x << 1;
    ap_uint<I+1> kint = prod;

    k = kint;
    r = (prod - kint) * pi2;
  };

  template<int W, int I>
  void generic_sincospi(ap_fixed<W,I> in,
                      ap_fixed<W-I+2,2> & outsin, ap_fixed<W-I+2,2> & outcos){

    ap_uint<1> sign0 = (in > 0) ? 1: 0;


    ap_ufixed<W,I> inabs;
    if(sign0)
      inabs = in;
    else
      inabs = -in;


    const int Fr = (W - I) + I + 1;
    ap_uint<2> k;
    ap_ufixed<Fr,1> r;
    circ_range_redux_pi(inabs, k, r);

    ap_fixed<W+2,3> x, y, z;

    const ap_fixed<W+2,3> K1("0x0.9B74EDA8435E47F277F7");
    x = K1;
    y = 0;

    if(k==1 or k==3){
      ap_ufixed<Fr,1> pi2("0x1.921FB54442D1846");
      z = pi2 - r;
    }
    else{
      z = r;
    }







    cordic_circ_apfixed<W+2,3,0>(x,y,z);







    if(k==0){
      outsin = y;
      outcos = x;
    }
    else if(k==1){
      outsin = y;
      outcos = -x;
    }
    else if(k==2){
      outsin = -y;
      outcos = -x;
    }
    else{
      outsin = -y;
      outcos = x;
    }

    if(sign0==0)
      outsin = -outsin;
  };


  template<int W, int I>
  ap_fixed<W,I> generic_tanpi(ap_fixed<W,I> x){

    const int Ix = I;
    const int Fx = (((W-I)>(I-1)) ? (W-I): (I-1)) + I;
    const int Wx = I + Fx;

    ap_fixed<Wx,Ix> xs = x;

    ap_fixed<Wx-Ix+2,2> outsin;
    ap_fixed<Wx-Ix+2,2> outcos;
    generic_sincospi(xs, outsin, outcos);

    ap_fixed<W,I> out;
    ap_int<1> bpoint=0;
    if(!outcos){
        bpoint = 1;
    }else{
        out = outsin / outcos;
    }




    if(I==1||bpoint){
      if( out[W-1]==1 ){
        out[W-1] = 0;
        for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
 out[i] = 1;
        }
      }
    }

    return out;
  };


  template<int W, int I>
  ap_ufixed<W,I> generic_tanpi(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,I+1> fout = generic_tanpi(fin);
    ap_ufixed<W,I> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<I> generic_tanpi(ap_int<I> in) {
    return ap_int<I>(0);
  };


  template<int I>
  ap_uint<I> generic_tanpi(ap_uint<I> in) {
    return ap_uint<I>(0);
  };


  template<int W, int I>
  ap_fixed<W,2> generic_atan(ap_fixed<W,I> in){

    ap_uint<1> sign0 = (in > 0) ? 1: 0;


    ap_fixed<W+1,I+1> inabs;
    if(sign0)
      inabs = in;
    else
      inabs = -in;


    ap_uint<1> sign1 = (inabs > 1) ? 1: 0;

    ap_fixed<W+2,3> x, y, z;
    if(sign1){
      x = 1;

      y = 1.0 / inabs.to_double();
      z = 0;
    }
    else{
      x = 1;
      y = inabs;
      z = 0;
    }
    cordic_circ_apfixed<W+2,3,1>(x,y,z);

    ap_fixed<W,2> out;
    if(sign1){
      const ap_fixed<W,2> pi2("0x1.921FB54442D1846");
      out = pi2 - z;
    }
    else{
      out = z;
    }


    if(sign0){
      return out;
    }
    else{
      return -out;
    }
  };


  template<int W, int I>
  ap_ufixed<W,2> generic_atan(ap_ufixed<W,I> in){
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,2> fout = generic_atan(fin);
    ap_ufixed<W,2> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<2> generic_atan(ap_int<I> in){
    if(in<-1)
      return ap_int<2>(-1);
    else if(in>1)
      return ap_int<2>(1);
    else
      return ap_int<2>(0);
  };


  template<int I>
  ap_uint<1> generic_atan(ap_uint<I> in){
    if(in>1)
      return ap_uint<1>(1);
    else
      return ap_uint<1>(0);
  };


  template<int W, int I>
  ap_fixed<W,3> generic_atan2(ap_fixed<W,I> in1,
                              ap_fixed<W,I> in2){

    const ap_fixed<W+1,3> pi("0x3.243F6A8885A308D3");
    const ap_fixed<W+2,3> pi2("0x1.921FB54442D1846");
    const ap_fixed<W+1,3> pi4("0x0.C90FDAA22168C23");
    const ap_fixed<W+1,3> pi3_("-0x2.5B2F8FE6643A469");

    ap_uint<2> signin1 = (in1 > 0) ? 2: (in1==0) ? 1: 0;
    ap_uint<2> signin2 = (in2 > 0) ? 2: (in2==0) ? 1: 0;

    ap_fixed<W,3> out;



    if(signin1==1 and signin2==2){
      out = 0;
      return out;
    }
    else if(signin1==1 and signin2==0){
      out = pi;
      return out;
    }
    else if(signin1==2 and signin2==1){
      out = pi2;
      return out;
    }
    else if(signin1==0 and signin2==1){
      out = -pi2;
      return out;
    }
    else if(in1==in2){
      if(signin1==2){
        out = pi4;
        return out;
      }
      else if(signin1==1){
        out = 0;
        return out;
      }
      else{
        out = pi3_;
        return out;
      }
    }



    ap_fixed<W+1,I+1> in1abs;
    if(signin1==0)
      in1abs = -in1;
    else
      in1abs = in1;

    ap_fixed<W+1,I+1> in2abs;
    if(signin2==0)
      in2abs = -in2;
    else
      in2abs = in2;

    ap_fixed<W+1,2> in1abs_sft;
    ap_fixed<W+1,2> in2abs_sft;
    for(int i=0;i<W+1;i++){
#pragma HLS UNROLL
 in1abs_sft[i] = in1abs[i];
    }
    for(int i=0;i<W+1;i++){
#pragma HLS UNROLL
 in2abs_sft[i] = in2abs[i];
    }

    ap_fixed<W+7,3> x, y, z;
    if(in1abs > in2abs){
      x = in1abs_sft;
      y = in2abs_sft;
      z = 0;
    }
    else{
      x = in2abs_sft;
      y = in1abs_sft;
      z = 0;
    }
    cordic_circ_apfixed<W+7,3,1>(x,y,z);

    if(in1abs > in2abs){
      z = pi2 - z;
    }

    if(signin2==0 and signin1==2){
      out = pi - z;
    }
    else if(signin2==0 and signin1==0){
      out = z - pi;
    }
    else if(signin2==2 and signin1==0){
      out = -z;
    }
    else{
      out = z;
    }

    return out;
  };


  template<int W, int I>
  ap_ufixed<W,3> generic_atan2(ap_ufixed<W,I> in1,
                               ap_ufixed<W,I> in2){
    ap_fixed<W+1,I+1> fin1 = in1;
    ap_fixed<W+1,I+1> fin2 = in2;
    ap_fixed<W+1,3> fout = generic_atan2(fin1, fin2);
    ap_ufixed<W,3> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  }


  template<int I>
  ap_int<3> generic_atan2(ap_int<I> in1,
                          ap_int<I> in2){
    ap_fixed<I+1,I+1> fin1 = in1;
    ap_fixed<I+1,I+1> fin2 = in2;
    ap_fixed<I+1,3> fout = generic_atan2(fin1, fin2);
    ap_int<3> out = fout;
    return out;
  }


  template<int I>
  ap_uint<2> generic_atan2(ap_uint<I> in1,
                           ap_uint<I> in2){
    ap_fixed<I+1,I+1> fin1 = in1;
    ap_fixed<I+1,I+1> fin2 = in2;
    ap_fixed<I+1,3> fout = generic_atan2(fin1, fin2);
    ap_uint<2> out = 0;
    if(fout[I]==0){
        out = fout;
    }
    return out;
  }





  template<int W, int I, int Wo>
  void hyperb_range_redux( ap_ufixed<W,I> x,
                           ap_uint<I+1> &k,
                           ap_ufixed<Wo,0> &r) {

    ap_ufixed<(Wo+I)+1,1> inv_ln2("0x1.71547652b82fe1777d0ffda0d23a7d11d6aef551cp0");
    ap_ufixed<Wo,0> ln2("0xb.17217f7d1cf79abc9e3b39803f2f6af40f343267p-4");
    ap_ufixed<Wo+(I+1),I+1> prod = x * inv_ln2;
    ap_ufixed<Wo,0> prod_dec = prod;
    k = prod;
    r = prod_dec * ln2;
  };






  template<int W, int I, int MODE>
  void cordic_hyperb_apfixed( ap_fixed<W,I> &x,
                              ap_fixed<W,I> &y,
                              ap_fixed<W,I> &z) {

    const int Nmax = W + 1;

    ap_fixed<W,I> tx, ty, tz;
    ap_fixed<W,I> x_s, y_s, z_s;
    ap_uint<1> d;

    for (int n=0; n<Nmax; n++){

      int k = hyperb_table_tau_128[n];

      if(MODE == 1) {
        d = ~y[W-1];
      }
      else {
        d = z[W-1];
      }

      x_s = x >> k;
      y_s = y >> k;
      z_s = hyperb_table_arctanh_128[k-1];

      if(d){
        tx = x - y_s;
        ty = y - x_s;
        tz = z + z_s;
      }
      else{
        tx = x + y_s;
        ty = y + x_s;
        tz = z - z_s;
      }

      x = tx;
      y = ty;
      z = tz;
# 804 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h"
    }
  }


  template <int W, int I>
  void sinh_cosh_range_redux_cordic( ap_fixed<W,I> in,
                                     ap_fixed<W,I> &s_out,
                                     ap_fixed<W,I> &c_out){

    ap_uint<1> sign0 = in[W-1];

    ap_ufixed<W,I> inabs;
    if(sign0 == 0)
      inabs = in;
    else
      inabs = -in;

    const int Fr = (W - I) + I;

    if(in==0){
      s_out = 0;
      c_out = 1;
      return;
    }


    ap_uint<I+1> k;
    ap_ufixed<Fr,0> r;
    hyperb_range_redux(inabs, k, r);

    ap_fixed<Fr+2,2> x("1.20749706776307212887772");
    ap_fixed<Fr+2,2> y(0);
    ap_fixed<Fr+2,2> z(r);




    cordic_hyperb_apfixed<Fr+2,2,0>(x,y,z);



    ap_fixed<Fr+(I+2),I+2> er, e_r;
    er = x + y;
    e_r = x - y;



    er <<= (k-1);
    e_r >>= (k+1);



    ap_fixed<W+1,I+1> s_out_tmp = er - e_r;
    ap_fixed<W+1,I+1> c_out_tmp = er + e_r;




    if(s_out_tmp[W-1]==1){
      s_out_tmp[W-1] = 0;
      for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
 s_out_tmp[i] = 1;
      }
    }


    if(sign0 == 0){
      s_out = s_out_tmp;
    }
    else{
      s_out = -s_out_tmp;
    }




    if(c_out_tmp[W-1]==1){
      c_out[W-1] = 0;
      for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
 c_out[i] = 1;
      }
    }
    else{
      c_out = c_out_tmp;
    }
  };

    template<int W, int I>
    void tanh_range_redux_cordic(ap_fixed<W,I> in, ap_fixed<W,I> &tan_out) {

        ap_uint<1> sign0 = in[W-1];

        ap_ufixed<W,I> inabs;
        if(sign0 == 0)
            inabs = in;
        else
            inabs = -in;

        const int Fr = (W - I) + I;

        if(in==0){
            tan_out = 0;
            return;
        }

        ap_uint<I+1> k;
        ap_ufixed<Fr,0> r;
        hyperb_range_redux(inabs, k, r);

        ap_fixed<Fr+2,2> x("1.20749706776307212887772");
        ap_fixed<Fr+2,2> y(0);
        ap_fixed<Fr+2,2> z(r);

        cordic_hyperb_apfixed<Fr+2,2,0>(x,y,z);
        ap_fixed<Fr+(I+2),I+2> er, e_r;
        er = x + y;
        e_r = x - y;
        er <<= k;
        e_r >>= k;
        tan_out = (er/(er+e_r))*2 - 1;
    }

    template<int W, int I>
    ap_fixed<W,I> generic_tanh(ap_fixed<W,I> in) {
        ap_fixed<W,I> tan_out;
        tanh_range_redux_cordic(in, tan_out);
        return tan_out;
    }

    template<int W, int I>
    ap_ufixed<W,I> generic_tanh(ap_ufixed<W,I> in) {
        ap_fixed<W+1,I+1> fin = in;
        ap_fixed<W+1,I+1> fout = generic_tanh(fin);
        ap_ufixed<W,I> tan_out = fout;
        return tan_out;
    }

    template<int I>
    ap_int<I> generic_tanh(ap_int<I> in) {
        ap_fixed<I,I> fin = in;
        ap_fixed<I,I> fout = generic_tanh(fin);
        ap_int<I> tan_out = fout;
        return tan_out;
    }

    template<int I>
    ap_uint<I> generic_tanh(ap_uint<I> in) {
        ap_fixed<I+1,I+1> fin = in;
        ap_fixed<I+1,I+1> fout = generic_tanh(fin);
        ap_uint<I> tan_out = fout;
        return tan_out;
    }

  template<int W, int I>
  ap_fixed<W,I> generic_sinh(ap_fixed<W,I> in) {
    ap_fixed<W,I> s_out, c_out;
    sinh_cosh_range_redux_cordic(in,s_out,c_out);
    return s_out;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_sinh(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,I+1> fout = generic_sinh(fin);
    ap_ufixed<W,I> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<I> generic_sinh(ap_int<I> in) {
    ap_fixed<I,I> fin = in;
    ap_fixed<I,I> fout = generic_sinh(fin);
    ap_int<I> out = fout;
    return out;
  };


  template<int I>
  ap_uint<I> generic_sinh(ap_uint<I> in) {
    ap_fixed<I+1,I+1> fin = in;
    ap_fixed<I+1,I+1> fout = generic_sinh(fin);
    ap_uint<I> out = 0;
    if(fout[I]==0){
        out = fout;
    }
    return out;
  };


  template<int W, int I>
  ap_fixed<W, I> generic_cosh(ap_fixed<W,I> in) {
    ap_fixed<W,I> s_out, c_out;
    sinh_cosh_range_redux_cordic(in,s_out,c_out);
    return c_out;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_cosh(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,I+1> fout = generic_cosh(fin);
    ap_ufixed<W,I> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<I> generic_cosh(ap_int<I> in) {
    ap_fixed<I,I> fin = in;
    ap_fixed<I,I> fout = generic_cosh(fin);
    ap_int<I> out = fout;
    return out;
  };


  template<int I>
  ap_uint<I> generic_cosh(ap_uint<I> in) {
    ap_fixed<I+1,I+1> fin = in;
    ap_fixed<I+1,I+1> fout = generic_cosh(fin);
    ap_uint<I> out = 0;
    if(fout[I]==0){
        out = fout;
    }
    return out;
  };



  template<int W, int I>
  ap_fixed<W-I+3,3> generic_asin(ap_fixed<W,I> in){

    const int I0 = 3;
    const int W0 = W - I + I0 + 6;

    const ap_fixed<W+1,I+1> cst1("0x1");
    const ap_fixed<W,I> cst0("0x0");
    const ap_fixed<W,I> cst_1("-0x1");
# 1062 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h"
    ap_fixed<W-I+3,3> out;


    if(in==cst1){
      out = ap_fixed<W-I+3,3>("0x1.921FB54442D1846");
      return out;
    }
    else if(in==cst_1){
      out = ap_fixed<W-I+3,3>("-0x1.921FB54442D1846");
      return out;
    }
    else if(in==cst0){
      out = ap_fixed<W-I+3,3>("0x0");
      return out;
    }


    ap_uint<1> sign0 = (in >= 0) ? 1: 0;


    ap_fixed<W,I> inabs;
    if(sign0)
      inabs = in;
    else
      inabs = -in;

    ap_fixed<W,I> absout;


    if(inabs[W-I-1]==0){
      ap_fixed<W0,I0> x("0x1");
      ap_fixed<W0,I0> y("0x0");
      ap_fixed<W0,I0> z("0x0");
      ap_fixed<W0,I0> t = inabs;
      doublecordic_apfixed<W0,I0,0,0>(x,y,z,t);
      absout = z;
    }
    else{
      const int F1 = W - I;
      const int W1 = F1 + F1 + I;
      ap_fixed<W1,I> one("0x1");
      ap_fixed<W1,I> onex = one - inabs * inabs;
      ap_fixed<W1,I> sqrtonex = ::__builtin_sqrt(onex.to_double());
      ap_fixed<W1,I> xsqrtonex = inabs / (one + sqrtonex);
      absout = generic_atan(xsqrtonex) << 1;
    }


    if(sign0)
      out = absout;
    else
      out = -absout;

    return out;
  }



  template<int W, int I>
  ap_fixed<W-I+3,3> generic_acos(ap_fixed<W,I> in){

    const int I0 = 3;
    const int W0 = W - I + I0;
# 1140 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h"
    const ap_fixed<W0,I0> pi2("0x1.921FB54442D1846");
    ap_fixed<W0,I0> out = pi2 - generic_asin(in);

    if(out[W0-1]==1){
      out = -out;
    }

    return out;
  }

  template<int W, int I>
  void cordic_semi_recovery_asinh(ap_fixed<W,I> in_top, ap_fixed<W,I>& out) {

    if(in_top == 0) {
      out = 0;
      return;
    }

    ap_fixed<W,I> in;
    if(in_top >= 0) {
      in = in_top;
    }
    else {
      in = -in_top;
    }

    int m = in.countLeadingZeros();
    int k = I-m;

    if(W-I-2 >= k) {

      ap_fixed<W,I> boundk = 1.0;
      ap_fixed<W,I> bound_k_2 = 1.0;
      boundk <<= k;
      bound_k_2 >>= k;
      bound_k_2 >>= 2;

      if(in >= (boundk - bound_k_2)) {
        k+=1;
      }

    }

    if(k < 0) {
      k = 0;
    }

    const int Nmax = W - I + 1;
    int tau;
    ap_fixed<W,I> x_r(1);
    ap_fixed<W,I> y_r(0);
    ap_fixed<W,I> z_r(0);
    ap_fixed<W,I> x1_tau, x_2tau, y1_tau, y_2tau, z_s;
    ap_fixed<W,I> xk, x_k, yk, y_k;
    ap_fixed<W,I> y_semi_recovery;
    ap_fixed<W,I> in_s;

    for(int i=0; i<Nmax; i++) {

      xk = x_r << k;
      x_k = x_r >> k;
      yk = y_r << k;
      y_k = y_r >> k;

      y_semi_recovery = (xk - x_k + yk + y_k) >> 1;

      tau = hyperb_table_tau_128[i+1];
      z_s = hyperb_table_arctanh_128[tau-1] << 1;

      x1_tau = ((x_r >> tau) << 1);
      x_2tau = (x_r >> (tau << 1));
      y1_tau = ((y_r >> tau) << 1);
      y_2tau = (y_r >> (tau << 1));

      if(y_semi_recovery <= in) {
        x_r += x_2tau + y1_tau;
        y_r += y_2tau + x1_tau;
        z_r += z_s;
      }
      else {
        x_r += x_2tau - y1_tau;
        y_r += y_2tau - x1_tau;
        z_r -= z_s;
      }

      in_s = in >> (tau << 1);
      in -= in_s;
    }

    ap_ufixed<W,0> ln2("0xb.17217f7d1cf79abc9e3b39803f2f6af40f343267p-4");
    if(in_top >= 0) {
      out = z_r + k*ln2;
    }
    else {
      out = -z_r - k*ln2;
    }
  }

  template<int W, int I>
  void cordic_semi_recovery_acosh(ap_fixed<W,I> in, ap_fixed<W,I>& out) {






    if(in == 1) {
      out = 0;
      return;
    }

    int m = in.countLeadingZeros();
    int k = I-m;


    ap_fixed<W,I> boundk = 1.0;
    ap_fixed<W,I> bound_k_1 = 1.0;
    boundk <<= k;
    boundk >>= 1;
    bound_k_1 >>= k;
    bound_k_1 >>= 1;

      if(in < (boundk - bound_k_1)) {
        k-=1;
      }

    if(k < 0) {
      k = 0;
    }

    const int Nmax = W - I + 1;
    int tau;
    ap_fixed<W,I> x_r(1);
    ap_fixed<W,I> y_r(0);
    ap_fixed<W,I> z_r(0);
    ap_fixed<W,I> x1_tau, x_2tau, y1_tau, y_2tau, z_s;
    ap_fixed<W,I> xk, x_k, yk, y_k;
    ap_fixed<W,I> x_semi_recovery;
    ap_fixed<W,I> in_s;

    for(int i=0; i<Nmax; i++) {

      xk = x_r << k;
      x_k = x_r >> k;
      yk = y_r << k;
      y_k = y_r >> k;

      x_semi_recovery = (xk + x_k + yk - y_k) >> 1;

      tau = hyperb_table_tau_128[i+1];
      z_s = hyperb_table_arctanh_128[tau-1] << 1;

      x1_tau = ((x_r >> tau) << 1);
      x_2tau = (x_r >> (tau << 1));
      y1_tau = ((y_r >> tau) << 1);
      y_2tau = (y_r >> (tau << 1));

      if(x_semi_recovery <= in) {
        x_r += x_2tau + y1_tau;
        y_r += y_2tau + x1_tau;
        z_r += z_s;
      }
      else {
        x_r += x_2tau - y1_tau;
        y_r += y_2tau - x1_tau;
        z_r -= z_s;
      }

      in_s = in >> (tau << 1);
      in -= in_s;
    }

    ap_ufixed<W,0> ln2("0xb.17217f7d1cf79abc9e3b39803f2f6af40f343267p-4");
    out = z_r + k*ln2;
  }


  template<int W, int I>
  ap_fixed<W,I> generic_asinh(ap_fixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output; input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_asinh(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  };


  template<int I>
  ap_int<I> generic_asinh(ap_int<I> in) {
    ap_fixed<I+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  };


  template<int I>
  ap_uint<I> generic_asinh(ap_uint<I> in) {
    ap_fixed<I+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  };


  template<int W, int I>
  ap_fixed<W,I> generic_acosh(ap_fixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_acosh(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  };


  template<int I>
  ap_int<I> generic_acosh(ap_int<I> in) {
    ap_fixed<I,I> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  };


  template<int I>
  ap_uint<I> generic_acosh(ap_uint<I> in) {
    ap_fixed<I+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  };


  template<int W, int I>
  ap_fixed<W,I> generic_asinpi(ap_fixed<W,I> x) {
      const static int we = I < 3? 3: I;
_ssdm_SpecConstant(&we);
# 1390 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h"

      ap_fixed<W-I+we, we> xi = x;
      ap_fixed<W-I+3,3> asin_x = generic_asin(xi);






      static const int F = W - I;
_ssdm_SpecConstant(&F);
# 1399 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h"






      static const int wf = F < 1? 0: F - 1;
_ssdm_SpecConstant(&wf);
# 1405 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h"

      ap_ufixed<2+wf,2> pi = 3.14159265358979323846;





      ap_fixed<W,I> r = asin_x/pi;





      return r;
  }
  template<int W, int I>
  ap_ufixed<W,I> generic_asinpi(ap_ufixed<W,I> x) {
      ap_fixed<W+1,I+1> xi = x;
      return generic_asinpi(xi);
  }
  template<int I>
  ap_int<I> generic_asinpi(ap_int<I> x) {

      if(x==-1){

        return -1;
      }else if(x==0){
        return 0;
      }else if(x==1){

        return 1;
      }else{




        return 0;
      };
  }
  template<int I>
  ap_uint<I> generic_asinpi(ap_uint<I> x) {

      if(x==0){
        return 0;

      } else if(x==1){
        return 1;
      } else{




        return 0;
      };
  }

  template<int W, int I>
  ap_fixed<W,I> generic_acospi(ap_fixed<W,I> x) {





      const static int we = I < 3? 3 : I;
_ssdm_SpecConstant(&we);
# 1468 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h"

      ap_fixed<W-I+we,we> xi = x;
      ap_fixed<W-I+3,3> acos_x = generic_acos(xi);





      static const int F = W - I;
_ssdm_SpecConstant(&F);
# 1476 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h"






      static const int wf = F;
_ssdm_SpecConstant(&wf);
# 1482 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h"

      ap_ufixed<2+wf,2> pi = 3.14159265358979323846;





      ap_fixed<W,I> r = acos_x/pi;





      return r;
  }
  template<int W, int I>
  ap_ufixed<W,I> generic_acospi(ap_ufixed<W,I> x) {
      ap_fixed<W+1,I+1> xi = x;
      return generic_acospi(xi);
  }
  template<int I>
  ap_int<I> generic_acospi(ap_int<I> x) {

      if(x==-1){
        return 1;

      } else if(x==0){
        return 1;
      } else if(x==1){
        return 0;
      } else{




        return 0;
      };
  }
  template<int I>
  ap_uint<I> generic_acospi(ap_uint<I> x) {

      if(x==0){
        return 1;
      } else if(x==1){
        return 0;
      } else{




        return 0;
      };
  }

  template<int W, int I>
  ap_fixed<W,I> generic_atanpi(ap_fixed<W,I> x) {
      ap_fixed<W-I+3,3> atan_x = generic_atan(x);





      static const int F = W - I;
_ssdm_SpecConstant(&F);
# 1544 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h"






      static const int wf = F < 1? 0: F - 1;
_ssdm_SpecConstant(&wf);
# 1550 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h"

      ap_ufixed<2+wf,2> pi = 3.14159265358979323846;
      ap_fixed<W,I> r = atan_x/pi;






      return r;
  }
  template<int W, int I>
  ap_ufixed<W,I> generic_atanpi(ap_ufixed<W,I> x) {
      ap_fixed<W+1,I+1> xi = x;
      return generic_atanpi(xi);
  }
  template<int I>
  ap_int<I> generic_atanpi(ap_int<I> x) {

      return 0;
  }
  template<int I>
  ap_uint<I> generic_atanpi(ap_uint<I> x) {

      return 0;
  }

  template<int W, int I>
  ap_fixed<W,I> generic_atan2pi(ap_fixed<W,I> y, ap_fixed<W, I> x) {
      ap_fixed<W-I+3,3> atan2_x = generic_atan2(y, x);
      static const int F = W - I;
_ssdm_SpecConstant(&F);
# 1580 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h"






      static const int wf = F;
_ssdm_SpecConstant(&wf);
# 1586 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cordic_apfixed.h"

      ap_ufixed<2+wf,2> pi = 3.14159265358979323846;
      ap_fixed<W,I> r = atan2_x/pi;
      return r;
  }
  template<int W, int I>
  ap_ufixed<W,I> generic_atan2pi(ap_ufixed<W,I> y, ap_ufixed<W,I> x) {
      ap_fixed<W+1,I+1> xi = x;
      ap_fixed<W+1,I+1> yi = y;
      return generic_atan2pi(yi, xi);
  }
  template<int I>
  ap_int<I> generic_atan2pi(ap_int<I> y, ap_int<I> x) {

      bool x_sig = x[I-1];
      bool y_sig = y[I-1];
      if(y==0 && x==0) return 0;


      else if(y_sig && x==0) return -1;

      else if(!y_sig && x==0) return 1;

      else if(!y_sig && x_sig) return 1;

      else if(y_sig && x_sig) return -1;
      else return 0;
  }
  template<int I>
  ap_uint<I> generic_atan2pi(ap_uint<I> y, ap_uint<I> x) {


      if(y!=0 && x==0) return 1;
      else return 0;
  }

}
# 1020 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h" 1
# 36 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"
namespace exp_reduce {

template<int W_, int I_>
ap_fixed<W_,I_> exp(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline

 int F_ = W_ - I_;
    if (I_>33) return 0;
    else if (F_>32) return 0;




    int I_s_;
    int M_ = (I_-1>F_) ? (I_-1) : F_;
    if (M_==1) I_s_ = 1;
    else if (M_==2) I_s_ = 2;
    else if (M_<6) I_s_ = 3;
    else if (M_<12) I_s_ = 4;
    else if (M_<24) I_s_ = 5;
    else I_s_ = 6;

    ap_fixed<W_,I_> r;
    if (I_s_==1) {
        ap_fixed<3,2> x_l = x;
        ap_ufixed<2,1> y = 0;
        if (x_l[2]!=x_l[1]) {
            if (!x_l[2]) y = "0x1.8p0";
        } else {
            if (!x_l[2]) y[1] = 1;
            if (x_l[2]|x_l[0]) y[0] = 1;
        }
        if (I_<2) {
            if (y[1]) {
                y[1] = 0;
                y[0] = 1;
            }
        }
        r = y;
    } else if (I_s_==2) {
        ap_fixed<5,3> x_l = x;
        ap_ufixed<4,2> y = 0;
        ap_fixed<2,2> x_l_int;
        x_l_int(1,0) = x_l(3,2);
        ap_ufixed<2,0> x_l_fract;
        x_l_fract(1,0) = x_l(1,0);

        if ((x_l[4]!=x_l[3])||((x_l_int==1)&&(x_l_fract>=ap_ufixed<2,0>("0x0.8p0")))) {
            if (!x_l[4]) y = "0x3.cp0";
        } else {
            if (!x_l[4]&((x_l[1]&x_l[0])|x_l[2])) y[3] = 1;
            if (!x_l[4]&((!x_l[2]&!x_l[0])|(!x_l[1]&x_l[0]))) y[2] = 1;
            if ((!x_l[4]&x_l[1]&!x_l[0])|(!x_l[4]&x_l[2])|(x_l[2]&x_l[0])|(x_l[2]&x_l[1])) y[1] = 1;
            if ((!x_l[2]&!x_l[1]&x_l[0])|(!x_l[2]&x_l[1]&!x_l[0])|(x_l[2]&!x_l[1]&!x_l[0])|(x_l[2]&x_l[1]&x_l[0])|(x_l[4]&!x_l[3])) y[0] = 1;
        }
        if (I_<3) {
            bool overf = 0;
#pragma unroll
 for (int j = 3; j >= I_+1; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
 for (int j = 3; j >= I_+1; j--)
                    y[j] = 0;
#pragma unroll
 for (int j = I_; j >= 0; j--)
                    y[j] = 1;
            }
        }
        r = y;
    } else if (I_s_==3) {
        ap_fixed<11,6> x_l = x;
        ap_ufixed<10,5> y = 0;
        ap_fixed<3,3> x_l_int;
        x_l_int(2,0) = x_l(7,5);
        ap_ufixed<5,0> x_l_fract;
        x_l_fract(4,0) = x_l(4,0);

        if ((x_l[10]!=x_l[9])||(x_l[10]!=x_l[8])||(x_l[10]!=x_l[7])||((x_l_int==3)&&(x_l_fract>ap_fixed<5,0>("0x0.7p0")))) {
            if (!x_l[10]) y = "0x1f.f8p0";
        } else {





            ap_uint<4> x_msb_ind;
            x_msb_ind[3] = x_l[10];
            x_msb_ind(2,0) = x_l(6,4);
            ap_uint<4> x_lsb_ind;
            x_lsb_ind(3,0) = x_l(3,0);
            ap_ufixed<4,-1> x_lsb = x_l;
# 151 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"
            const static ap_ufixed<12,0> exp_x_lsb_m_1_table[16] = {
                "0x0.0p0", "0x0.082p0", "0x0.108p0", "0x0.193p0", "0x0.221p0", "0x0.2b5p0", "0x0.34dp0", "0x0.3eap0",
                "0x0.48bp0", "0x0.532p0", "0x0.5dfp0", "0x0.69p0", "0x0.748p0", "0x0.805p0", "0x0.8c8p0", "0x0.991p0",
            };
_ssdm_SpecConstant(exp_x_lsb_m_1_table);
# 151 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<12, 0> exp_x_lsb_m_1 = exp_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<12,5> exp_x_msb_table[16] = {
                "0x1.0p0", "0x1.a6p0", "0x2.b8p0", "0x4.7cp0", "0x7.64p0", "0xc.2ep0", "0x14.16p0", "0x21.1ep0",
                "0x0.04p0", "0x0.08p0", "0x0.0cp0", "0x0.16p0", "0x0.22p0", "0x0.3ap0", "0x0.5ep0", "0x0.9cp0",
            };
_ssdm_SpecConstant(exp_x_msb_table);
# 157 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<12,5> exp_x_msb = exp_x_msb_table[x_msb_ind];
            ap_ufixed<24,5> y_lo = exp_x_msb * exp_x_lsb_m_1;
            ap_ufixed<12,5> y_lo_s = y_lo;
            ap_ufixed<12,5> y_l = y_lo_s + exp_x_msb;
            y = y_l;
        }
        if (I_<6) {
            bool overf = 0;
#pragma unroll
 for (int j = 9; j >= I_+4; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
 for (int j = 9; j >= I_+4; j--)
                    y[j] = 0;
#pragma unroll
 for (int j = I_+3; j >= 0; j--)
                    y[j] = 1;
            }
        }
        r = y;
    } else if (I_s_==4) {
        ap_fixed<23,12> x_l = x;
        ap_ufixed<22,11> y = 0;
        ap_fixed<4,4> x_l_int;
        x_l_int(3,0) = x_l(14,11);
        ap_ufixed<11,0> x_l_fract;
        x_l_fract(10,0) = x_l(10,0);
        bool overf = 0;
#pragma unroll
 for (int j = 14; j < 22; j++)
            if (x_l[22]!=x_l[j])
                overf = 1;

        if (overf||((x_l_int==7)&&(x_l_fract>ap_ufixed<11,0>("0x0.ap0")))) {
            if (!x_l[22]) {
#pragma unroll
 for (int j = 0; j < 22; j++) y[j] = 1;
            }
        } else {
            ap_uint<5> x_msb_ind_1;
            x_msb_ind_1[4] = x_l[22];
            x_msb_ind_1(3,0) = x_l(13,10);
            ap_uint<5> x_msb_ind_2;
            x_msb_ind_2(4,0) = x_l(9,5);
            ap_ufixed<5,-1> x_msb_2 = x_l;
            ap_uint<5> x_lsb_ind;
            x_lsb_ind(4,0) = x_l(4,0);


            const static ap_ufixed<11,-13> f_x_lsb_table[32] = {
                "0x0.0p0", "0x0.000002p0", "0x0.000008p0", "0x0.000012p0",
                "0x0.00002p0", "0x0.000032p0", "0x0.000048p0", "0x0.000062p0",
                "0x0.00008p0", "0x0.0000a2p0", "0x0.0000c9p0", "0x0.0000f3p0",
                "0x0.000121p0", "0x0.000153p0", "0x0.000189p0", "0x0.0001c3p0",
                "0x0.000202p0", "0x0.000244p0", "0x0.00028ap0", "0x0.0002d4p0",
                "0x0.000323p0", "0x0.000375p0", "0x0.0003ccp0", "0x0.000426p0",
                "0x0.000485p0", "0x0.0004e7p0", "0x0.00054ep0", "0x0.0005b9p0",
                "0x0.000627p0", "0x0.00069ap0", "0x0.000711p0", "0x0.00078cp0",
            };
_ssdm_SpecConstant(f_x_lsb_table);
# 213 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<11,-13> f_x_lsb = f_x_lsb_table[x_lsb_ind];
            ap_ufixed<18, -6> exp_x_lsb_m_1 = 0;
            exp_x_lsb_m_1(17,13) = x_lsb_ind(4,0);
            exp_x_lsb_m_1(10,0) = f_x_lsb(10,0);

            const static ap_ufixed<25,0> exp_x_msb_2_m_1_table[32] = {
                "0x0.0000000p0", "0x0.04080a8p0", "0x0.0820560p0", "0x0.0c49238p0",
                "0x0.1082b58p0", "0x0.14cd500p0", "0x0.1929370p0", "0x0.1d96b10p0",
                "0x0.2216048p0", "0x0.26a7790p0", "0x0.2b4b588p0", "0x0.3001ed0p0",
                "0x0.34cb818p0", "0x0.39a8628p0", "0x0.3e98de8p0", "0x0.439d440p0",
                "0x0.48b5e40p0", "0x0.4de30f0p0", "0x0.5325180p0", "0x0.587c540p0",
                "0x0.5de9178p0", "0x0.636bb98p0", "0x0.6904930p0", "0x0.6eb3fc8p0",
                "0x0.747a510p0", "0x0.7a57ee0p0", "0x0.804d300p0", "0x0.865a778p0",
                "0x0.8c80248p0", "0x0.92be998p0", "0x0.99163b0p0", "0x0.9f876e8p0",
            };
_ssdm_SpecConstant(exp_x_msb_2_m_1_table);
# 228 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<25, 0> exp_x_msb_2_m_1 = exp_x_msb_2_m_1_table[x_msb_ind_2];

            ap_ufixed<43,-6> f_x_msb_2_lsb = exp_x_msb_2_m_1 * exp_x_lsb_m_1;
            ap_ufixed<19,-6> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<25, 0> exp_x_msb_2_lsb_m_1 = f_x_msb_2_lsb_s + exp_x_lsb_m_1 + exp_x_msb_2_m_1;

            const static ap_ufixed<25,11> exp_x_msb_1_table[32] = {
                "0x1.0000p0", "0x1.a614p0", "0x2.b7e0p0", "0x4.7b50p0",
                "0x7.6398p0", "0xc.2eb8p0", "0x14.15e4p0", "0x21.1d90p0",
                "0x36.9920p0", "0x5a.0464p0", "0x94.69c4p0", "0xf4.b124p0",
                "0x193.6dc4p0", "0x299.2444p0", "0x448.a218p0", "0x710.0adcp0",
                "0x0.0014p0", "0x0.0024p0", "0x0.003cp0", "0x0.0064p0",
                "0x0.00a4p0", "0x0.010cp0", "0x0.01b8p0", "0x0.02d8p0",
                "0x0.04b0p0", "0x0.07bcp0", "0x0.0cc0p0", "0x0.1504p0",
                "0x0.22a4p0", "0x0.3920p0", "0x0.5e2cp0", "0x0.9b44p0",
            };
_ssdm_SpecConstant(exp_x_msb_1_table);
# 244 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<25,11> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<50,11> y_lo = exp_x_msb_1 * exp_x_msb_2_lsb_m_1;
            ap_ufixed<25,11> y_lo_s = y_lo;
            ap_ufixed<25,11> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        if (I_<12) {
            bool overf = 0;
#pragma unroll
 for (int j = 21; j >= I_+10; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
 for (int j = 21; j >= I_+10; j--)
                    y[j] = 0;
#pragma unroll
 for (int j = I_+9; j >= 0; j--)
                    y[j] = 1;
            }
        }
        r = y;
    } else if (I_s_==5) {
        ap_fixed<47,24> x_l = x;
        ap_ufixed<46,23> y = 0;
        ap_fixed<5,5> x_l_int;
        x_l_int(4,0) = x_l(27,23);
        ap_ufixed<23,0> x_l_fract;
        x_l_fract(22,0) = x_l(22,0);
        bool overf = 0;
#pragma unroll
 for (int j = 27; j < 46; j++)
            if (x_l[46]!=x_l[j])
                overf = 1;

        if (overf||((x_l_int==15)&&(x_l_fract>=ap_ufixed<23,0>("0x0.f14028p0")))) {
            if (!x_l[46]) {
#pragma unroll
 for (int j = 0; j < 46; j++) y[j] = 1;
            }
        } else {
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[46];
            x_msb_ind_1(6,0) = x_l(26,20);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(19,12);
            ap_uint<5> x_msb_ind_3;
            x_msb_ind_3(4,0) = x_l(11,7);
            ap_uint<3> x_msb_ind_4;
            x_msb_ind_4(2,0) = x_l(6,4);
            ap_uint<4> x_lsb_ind;
            x_lsb_ind(3,0) = x_l(3,0);

            ap_ufixed<8, -3> x_msb_2 = x_l;
            ap_ufixed<5,-11> x_msb_3 = x_l;
            ap_ufixed<3,-16> x_msb_4 = x_l;
            ap_ufixed<4,-19> x_lsb = x_l;

            const static ap_ufixed< 6,-33> f_x_msb_4_h_table[8] = {
"0x0.0000000000p0", "0x0.0000000002p0", "0x0.0000000008p0", "0x0.0000000012p0",
"0x0.0000000020p0", "0x0.0000000032p0", "0x0.0000000048p0", "0x0.0000000062p0",
            };
_ssdm_SpecConstant(f_x_msb_4_h_table);
# 313 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            const static ap_ufixed< 7,-51> f_x_msb_4_l_table[8] = {
"0x0.000000000000000p0", "0x0.000000000000000p0", "0x0.00000000000000cp0", "0x0.000000000000024p0",
"0x0.000000000000054p0", "0x0.0000000000000a8p0", "0x0.000000000000120p0", "0x0.0000000000001c8p0",
            };
_ssdm_SpecConstant(f_x_msb_4_l_table);
# 317 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed< 6,-33> f_x_msb_4_h = f_x_msb_4_h_table[x_msb_ind_4];
            ap_ufixed< 7,-51> f_x_msb_4_l = f_x_msb_4_l_table[x_msb_ind_4];

            const static ap_ufixed< 8,-39> f_x_lsb_table[16] = {
"0x0.000000000000p0", "0x0.000000000002p0", "0x0.000000000008p0", "0x0.000000000012p0",
"0x0.000000000020p0", "0x0.000000000032p0", "0x0.000000000048p0", "0x0.000000000062p0",
"0x0.000000000080p0", "0x0.0000000000a2p0", "0x0.0000000000c8p0", "0x0.0000000000f2p0",
"0x0.000000000120p0", "0x0.000000000152p0", "0x0.000000000188p0", "0x0.0000000001c2p0",
            };
_ssdm_SpecConstant(f_x_lsb_table);
# 324 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed< 8,-39> f_x_lsb = f_x_lsb_table[x_lsb_ind];

            ap_ufixed< 7,-35> f_x_msb_4_lsb = x_msb_4 * x_lsb;

            ap_ufixed<10,-32> exp_x_msb_4_lsb_m_1_m = 0;
            exp_x_msb_4_lsb_m_1_m(8,3) = f_x_msb_4_h(5,0);
            exp_x_msb_4_lsb_m_1_m(2,0) = f_x_lsb(7,5);
            exp_x_msb_4_lsb_m_1_m = exp_x_msb_4_lsb_m_1_m + f_x_msb_4_lsb;

            ap_ufixed<42,-16> exp_x_msb_4_lsb_m_1 = 0;
            exp_x_msb_4_lsb_m_1(41,35) = x_l(6,0);
            exp_x_msb_4_lsb_m_1(25,16) = exp_x_msb_4_lsb_m_1_m(9,0);
            exp_x_msb_4_lsb_m_1(15,11) = f_x_lsb(4,0);
            exp_x_msb_4_lsb_m_1( 6, 0) = f_x_msb_4_l(6,0);


            const static ap_ufixed<32,-23> f_x_msb_3_table[32] = {
"0x0.00000000000000p0", "0x0.0000000080002ap0", "0x0.00000002000156p0", "0x0.00000004800480p0",
"0x0.00000008000aaap0", "0x0.0000000c8014d6p0", "0x0.00000012002400p0", "0x0.0000001880392cp0",
"0x0.00000020005556p0", "0x0.00000028807982p0", "0x0.0000003200a6acp0", "0x0.0000003c80ddd8p0",
"0x0.00000048012004p0", "0x0.00000054816e30p0", "0x0.0000006201c95cp0", "0x0.00000070823288p0",
"0x0.0000008002aab6p0", "0x0.000000908332e2p0", "0x0.000000a203cc12p0", "0x0.000000b4847740p0",
"0x0.000000c8053570p0", "0x0.000000dc8607a0p0", "0x0.000000f206eed0p0", "0x0.0000010887ec02p0",
"0x0.00000120090036p0", "0x0.000001388a2c6ap0", "0x0.000001520b71a0p0", "0x0.0000016c8cd0d6p0",
"0x0.000001880e4b0ep0", "0x0.000001a48fe148p0", "0x0.000001c2119484p0", "0x0.000001e09365c0p0",
            };
_ssdm_SpecConstant(f_x_msb_3_table);
# 346 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"


            ap_ufixed<32,-23> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<44,-11> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(43,39) = x_msb_3(4,0);
            exp_x_msb_3_m_1(31, 0) = f_x_msb_3(31,0);

            ap_ufixed<86,-27> f_x_msb_3_4_lsb = exp_x_msb_3_m_1 * exp_x_msb_4_lsb_m_1;
            ap_ufixed<31,-27> f_x_msb_3_4_lsb_s = f_x_msb_3_4_lsb;
            ap_ufixed<48,-10> exp_x_msb_3_4_lsb_m_1 = f_x_msb_3_4_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_lsb_m_1;


            const static ap_ufixed<46,-6> f_x_msb_2_table[256] = {
"0x0", "0x0.0000020015560p0", "0x0.00000800AAB55p0", "0x0.0000120240360p0",
"0x0.0000200556001p0", "0x0.0000320A6C4B8p0", "0x0.0000481203608p0", "0x0.0000621C9B971p0",
"0x0.0000802AB5577p0", "0x0.0000A23CD119Dp0", "0x0.0000C8536F668p0", "0x0.0000F26F10D5Dp0",
"0x0.0001209036103p0", "0x0.000152B75FCE3p0", "0x0.000188E50ED86p0", "0x0.0001C319C4077p0",
"0x0.0002015600445p0", "0x0.0002439A4487Ep0", "0x0.000289E711DB3p0", "0x0.0002D43CE9577p0",
"0x0.0003229C4C260p0", "0x0.00037505BB805p0", "0x0.0003CB79B8B01p0", "0x0.000425F8C50F2p0",
"0x0.0004848362076p0", "0x0.0004E71A11131p0", "0x0.00054DBD53BC8p0", "0x0.0005B86DAB9E3p0",
"0x0.0006272B9A630p0", "0x0.000699F7A1C5Dp0", "0x0.000710D24391Ep0", "0x0.00078BBC01A29p0",
"0x0.00080AB55DE39p0", "0x0.00088DBEDA50Bp0", "0x0.000914D8F8F63p0", "0x0.0009A0043BF07p0",
"0x0.000A2F41256C2p0", "0x0.000AC29037A63p0", "0x0.000B59F1F4EBDp0", "0x0.000BF566DF9AAp0",
"0x0.000C94EF7A206p0", "0x0.000D388C46FB4p0", "0x0.000DE03DC8B9Bp0", "0x0.000E8C0481FA7p0",
"0x0.000F3BE0F56CAp0", "0x0.000FEFD3A5CFAp0", "0x0.0010A7DD15F36p0", "0x0.001163FDC8B7Fp0",
"0x0.00122436410DDp0", "0x0.0012E88701F5Ep0", "0x0.0013B0F08E817p0", "0x0.00147D7369D22p0",
"0x0.00154E101719Fp0", "0x0.001622C7199B7p0", "0x0.0016FB98F4A96p0", "0x0.0017D8862BA72p0",
"0x0.0018B98F42084p0", "0x0.00199EB4BB511p0", "0x0.001A87F71B161p0", "0x0.001B7556E4FC4p0",
"0x0.001C66D49CB93p0", "0x0.001D5C70C612Dp0", "0x0.001E562BE4DFAp0", "0x0.001F54067D067p0",
"0x0.00205601127ECp0", "0x0.00215C1C29507p0", "0x0.0022665845940p0", "0x0.002374B5EB724p0",
"0x0.002487359F24Cp0", "0x0.00259DD7E4F57p0", "0x0.0026B89D413EFp0", "0x0.0027D786386C4p0",
"0x0.0028FA934EF90p0", "0x0.002A21C509717p0", "0x0.002B4D1BEC726p0", "0x0.002C7C987CA92p0",
"0x0.002DB03B3ED3Ap0", "0x0.002EE804B7C07p0", "0x0.003023F56C4ECp0", "0x0.0031640DE16E3p0",
"0x0.0032A84E9C1F5p0", "0x0.0033F0B821730p0", "0x0.00353D4AF68B0p0", "0x0.00368E07A0999p0",
"0x0.0037E2EEA4E19p0", "0x0.00393C0088B6Cp0", "0x0.003A993DD17D5p0", "0x0.003BFAA704AA3p0",
"0x0.003D603CA7C32p0", "0x0.003EC9FF405E6p0", "0x0.004037EF54230p0", "0x0.0041AA0D68C8Cp0",
"0x0.0043205A04182p0", "0x0.00449AD5ABEA5p0", "0x0.00461980E6294p0", "0x0.00479C5C38CF9p0",
"0x0.0049236829E8Bp0", "0x0.004AAEA53F90Ep0", "0x0.004C3E13FFF51p0", "0x0.004DD1B4F152Fp0",
"0x0.004F698899F90p0", "0x0.0051058F8046Ap0", "0x0.0052A5CA2AABFp0", "0x0.00544A391FA9Cp0",
"0x0.0055F2DCE5D1Ep0", "0x0.00579FB603C6Ep0", "0x0.005950C5003C2p0", "0x0.005B060A61F5Dp0",
"0x0.005CBF86AFC91p0", "0x0.005E7D3A709BEp0", "0x0.00603F262B650p0", "0x0.0062054A672C2p0",
"0x0.0063CFA7AB09Dp0", "0x0.00659E3E7E278p0", "0x0.0067710F67BFAp0", "0x0.0069481AEF1D5p0",
"0x0.006B23619B9CFp0", "0x0.006D02E3F4AB7p0", "0x0.006EE6A281C6Fp0", "0x0.0070CE9DCA7E6p0",
"0x0.0072BAD65671Bp0", "0x0.0074AB4CAD51Cp0", "0x0.0076A00156E07p0", "0x0.007898F4DAF09p0",
"0x0.007A9627C165Fp0", "0x0.007C979A92356p0", "0x0.007E9D4DD564Ap0", "0x0.0080A742130A8p0",
"0x0.0082B577D34EDp0", "0x0.0084C7EF9E6A7p0", "0x0.0086DEA9FCA73p0", "0x0.0088F9A776601p0",
"0x0.008B18E894010p0", "0x0.008D3C6DDE06Fp0", "0x0.008F6437DD000p0", "0x0.00919047198B6p0",
"0x0.0093C09C1C595p0", "0x0.0095F5376E2B2p0", "0x0.00982E1997D33p0", "0x0.009A6B4322352p0",
"0x0.009CACB496458p0", "0x0.009EF26E7D0A2p0", "0x0.00A13C715F99Ep0", "0x0.00A38ABDC71CEp0",
"0x0.00A5DD543CCC4p0", "0x0.00A8343549F26p0", "0x0.00AA8F6177EADp0", "0x0.00ACEED950222p0",
"0x0.00AF529D5C165p0", "0x0.00B1BAAE25566p0", "0x0.00B4270C3582Ap0", "0x0.00B697B8164C7p0",
"0x0.00B90CB25176Ap0", "0x0.00BB85FB70D50p0", "0x0.00BE0393FE4CCp0", "0x0.00C0857C83D44p0",
"0x0.00C30BB58B732p0", "0x0.00C5963F9F424p0", "0x0.00C8251B496BEp0", "0x0.00CAB849142B5p0",
"0x0.00CD4FC989CD6p0", "0x0.00CFEB9D34B00p0", "0x0.00D28BC49F428p0", "0x0.00D5304054059p0",
"0x0.00D7D910DD8B1p0", "0x0.00DA8636C6764p0", "0x0.00DD37B2997BCp0", "0x0.00DFED84E1618p0",
"0x0.00E2A7AE28FECp0", "0x0.00E5662EFB3C3p0", "0x0.00E82907E313Dp0", "0x0.00EAF0396B910p0",
"0x0.00EDBBC41FD08p0", "0x0.00F08BA88B009p0", "0x0.00F35FE73860Bp0", "0x0.00F63880B341Ep0",
"0x0.00F9157587069p0", "0x0.00FBF6C63F228p0", "0x0.00FEDC73671B0p0", "0x0.0101C67D8A86Cp0",
"0x0.0104B4E5350DFp0", "0x0.0107A7AAF26A2p0", "0x0.010A9ECF4E667p0", "0x0.010D9A52D4DF8p0",
"0x0.01109A3611C34p0", "0x0.01139E7991116p0", "0x0.0116A71DDEDADp0", "0x0.0119B42387423p0",
"0x0.011CC58B167B9p0", "0x0.011FDB5518CCAp0", "0x0.0122F5821A8C7p0", "0x0.01261412A823Cp0",
"0x0.012937074E0CDp0", "0x0.012C5E6098D37p0", "0x0.012F8A1F15151p0", "0x0.0132BA434F80Ap0",
"0x0.0135EECDD4D6Cp0", "0x0.013927BF31E98p0", "0x0.013C6517F39CCp0", "0x0.013FA6D8A6E5Dp0",
"0x0.0142ED01D8CBCp0", "0x0.0146379416673p0", "0x0.0149868FECE26p0", "0x0.014CD9F5E9795p0",
"0x0.015031C699799p0", "0x0.01538E028A426p0", "0x0.0156EEAA4944Bp0", "0x0.015A53BE64033p0",
"0x0.015DBD3F68122p0", "0x0.01612B2DE3178p0", "0x0.01649D8A62CB1p0", "0x0.0168145574F65p0",
"0x0.016B8F8FA7745p0", "0x0.016F0F3988321p0", "0x0.01729353A52E4p0", "0x0.01761BDE8C792p0",
"0x0.0179A8DACC350p0", "0x0.017D3A48F295Dp0", "0x0.0180D0298DE13p0", "0x0.01846A7D2C6ECp0",
"0x0.018809445CA7Bp0", "0x0.018BAC7FAD074p0", "0x0.018F542FAC1A4p0", "0x0.01930054E87F8p0",
"0x0.0196B0EFF0E79p0", "0x0.019A66015414Dp0", "0x0.019E1F89A0DBAp0", "0x0.01A1DD8966221p0",
"0x0.01A5A00132E02p0", "0x0.01A966F1961FCp0", "0x0.01AD325B1EFC9p0", "0x0.01B1023E5CA45p0",
"0x0.01B4D69BDE569p0", "0x0.01B8AF743364Cp0", "0x0.01BC8CC7EB323p0", "0x0.01C06E9795345p0",
"0x0.01C454E3C0F24p0", "0x0.01C83FACFE054p0", "0x0.01CC2EF3DC187p0", "0x0.01D022B8EAE8Fp0",
"0x0.01D41AFCBA45Ep0", "0x0.01D817BFDA104p0", "0x0.01DC1902DA3B1p0", "0x0.01E01EC64ACB7p0",
"0x0.01E4290ABBD87p0", "0x0.01E837D0BD8B2p0", "0x0.01EC4B18E01E9p0", "0x0.01F062E3B3DFEp0",
"0x0.01F47F31C92E4p0", "0x0.01F8A003B07AFp0", "0x0.01FCC559FA492p0", "0x0.0200EF35372E4p0",
"0x0.02051D95F7D1Cp0", "0x0.0209507CCCED1p0", "0x0.020D87EA474BEp0", "0x0.0211C3DEF7CBDp0",
            };
_ssdm_SpecConstant(f_x_msb_2_table);
# 367 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<46,-6> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 5,-6> f_x_msb_2_h;
            f_x_msb_2_h(4,0) = f_x_msb_2(45,41);
            ap_ufixed< 9,-2> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<50,-2> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(49,41) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(40, 0) = f_x_msb_2(40,0);

            ap_ufixed<98,-12> f_x_msb_2_3_4_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_lsb_m_1;
            ap_ufixed<46,-12> f_x_msb_2_3_4_lsb_s = f_x_msb_2_3_4_lsb;
            ap_ufixed<50,-2> exp_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_3_4_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<50,23> exp_x_msb_1_table[256] = {
"0x1.0000000p0", "0x1.2216045p0", "0x1.48B5E3Cp0", "0x1.747A513p0",
"0x1.A61298Ep0", "0x1.DE455DFp0", "0x2.1DF3B68p0", "0x2.661CB0Fp0",
"0x2.B7E1516p0", "0x3.1489176p0", "0x3.7D871DBp0", "0x3.F47FE87p0",
"0x4.7B4FF99p0", "0x5.1413452p0", "0x5.C12DA41p0", "0x6.855466Ep0",
"0x7.63992E3p0", "0x8.5F7635Bp0", "0x9.7CDC417p0", "0xA.C042667p0",
"0xC.2EB7EC9p0", "0xD.CDF892Ep0", "0xF.A48385Ep0", "0x11.B9B5652p0",
"0x14.15E5BF6p0", "0x16.C2887C1p0", "0x19.CA53B78p0", "0x1D.396AA97p0",
"0x21.1D8E427p0", "0x25.865441Cp0", "0x2A.8565A14p0", "0x30.2EC550Bp0",
"0x36.99205C4p0", "0x3D.DE28BF3p0", "0x46.1AFC4DBp0", "0x4F.7099532p0",
"0x5A.0462B78p0", "0x66.00B5BC9p0", "0x73.9593ABBp0", "0x82.F9621ADp0",
"0x94.69C4CB8p0", "0xA8.2C948C1p0", "0xBE.90F6F83p0", "0xD7.F09B78Cp0",
"0xF4.B122790p0", "0x115.45B4704p0", "0x13A.30CF1CCp0", "0x164.0650296p0",
"0x193.6DC5690p0", "0x1C9.250BEDCp0", "0x206.03487A3p0", "0x24A.FC4533Cp0",
"0x299.2442102p0", "0x2F1.B447462p0", "0x356.0F0B0F9p0", "0x3C7.C67E5BEp0",
"0x448.A216ABBp0", "0x4DA.A5EE46Ap0", "0x580.1AD754Fp0", "0x63B.9782341p0",
"0x710.0ADBAC7p0", "0x800.C7CC8E3p0", "0x911.9289C39p0", "0xA46.AFAA2ADp0",
"0xBA4.F53EA38p0", "0xD31.DE30C52p0", "0xEF3.A035D57p0", "0x10F1.44ADE60p0",
"0x1332.C4D2B7Cp0", "0x15C1.29A744Cp0", "0x18A6.B027DA0p0", "0x1BEE.F24BB12p0",
"0x1FA7.157C470p0", "0x23DD.FF3C8BAp0", "0x28A4.90D2CCEp0", "0x2E0D.EAE454Bp0",
"0x342F.BA11823p0", "0x3B22.8DC5359p0", "0x4302.3A933EEp0", "0x4BEE.49AFCDCp0",
"0x560A.773E541p0", "0x617F.4171BF9p0", "0x6E7A.8ABB4A8p0", "0x7D30.5191764p0",
"0x8DDB.80AF426p0", "0xA0BE.DB0DB10p0", "0xB626.0748BAEp0", "0xCE66.BE9EAADp0",
"0xE9E2.2447727p0", "0x10906.4A831F8p0", "0x12C4F.EB75B2Ap0", "0x1544C.5CB6133p0",
"0x1819B.C560F61p0", "0x1B4F3.9F8AF64p0", "0x1EF21.8F1B001p0", "0x2310E.996C40Fp0",
"0x27BC2.CA9A6F9p0", "0x2D069.571279Ap0", "0x33055.49F35D9p0", "0x39D06.D2FEF17p0",
"0x41831.49596E9p0", "0x4A3C1.FB2AC39p0", "0x541E7.E56949Dp0", "0x5F51C.72B7532p0",
"0x6C02D.645AB25p0", "0x7A648.0CFF534p0", "0x8AB06.0A3EE9Fp0", "0x9D27B.AFE4CF1p0",
"0xB2148.5EAE56Cp0", "0xC9CA9.07F86EFp0", "0xE4A8D.2881EDBp0", "0x1031AE.8E4996Cp0",
"0x1259AC.48BF05Dp0", "0x14CB29.2F2B31Fp0", "0x178FEE.7792E44p0", "0x1AB312.E89CD0Dp0",
"0x1E4127.437732Bp0", "0x224868.979FC2Ep0", "0x26D8F9.4A204BEp0", "0x2C0521.B4A8E0Bp0",
"0x31E199.5F5A550p0", "0x3885D9.FA89D00p0", "0x400C7D.64D3386p0", "0x4893A8.361032Dp0",
"0x523D82.79EDAEFp0", "0x5D30C0.7DAB686p0", "0x69993D.D4F2D95p0", "0x77A8AD.02A7C71p0",
"0x0.000001Ep0", "0x0.0000022p0", "0x0.0000026p0", "0x0.000002Bp0",
"0x0.0000031p0", "0x0.0000038p0", "0x0.000003Fp0", "0x0.0000048p0",
"0x0.0000052p0", "0x0.000005Dp0", "0x0.0000069p0", "0x0.0000077p0",
"0x0.0000087p0", "0x0.0000099p0", "0x0.00000ADp0", "0x0.00000C4p0",
"0x0.00000DFp0", "0x0.00000FCp0", "0x0.000011Ep0", "0x0.0000144p0",
"0x0.0000170p0", "0x0.00001A1p0", "0x0.00001D8p0", "0x0.0000217p0",
"0x0.000025Ep0", "0x0.00002AFp0", "0x0.000030Bp0", "0x0.0000372p0",
"0x0.00003E8p0", "0x0.000046Dp0", "0x0.0000504p0", "0x0.00005AFp0",
"0x0.0000671p0", "0x0.000074Cp0", "0x0.0000845p0", "0x0.000095Fp0",
"0x0.0000A9Fp0", "0x0.0000C09p0", "0x0.0000DA3p0", "0x0.0000F74p0",
"0x0.0001183p0", "0x0.00013D8p0", "0x0.000167Cp0", "0x0.000197Bp0",
"0x0.0001CDFp0", "0x0.00020B7p0", "0x0.0002513p0", "0x0.0002A02p0",
"0x0.0002F9Ap0", "0x0.00035F1p0", "0x0.0003D20p0", "0x0.0004543p0",
"0x0.0004E7Cp0", "0x0.00058F0p0", "0x0.00064C7p0", "0x0.0007232p0",
"0x0.0008167p0", "0x0.00092A2p0", "0x0.000A628p0", "0x0.000BC48p0",
"0x0.000D55Ap0", "0x0.000F1C2p0", "0x0.00111F3p0", "0x0.001366Cp0",
"0x0.0015FC2p0", "0x0.0018E98p0", "0x0.001C3AAp0", "0x0.001FFCEp0",
"0x0.00243F3p0", "0x0.002912Bp0", "0x0.002E8ABp0", "0x0.0034BD2p0",
"0x0.003BC2Dp0", "0x0.0043B7Dp0", "0x0.004CBC1p0", "0x0.0056F3Ap0",
"0x0.0062878p0", "0x0.006FA5Fp0", "0x0.007E83Ap0", "0x0.008F5C0p0",
"0x0.00A2728p0", "0x0.00B813Bp0", "0x0.00D0963p0", "0x0.00EC5C1p0",
"0x0.010BD4Ap0", "0x0.012F7DEp0", "0x0.0157E6Bp0", "0x0.0185B0Fp0",
"0x0.01B993Fp0", "0x0.01F45F9p0", "0x0.0236FF5p0", "0x0.02827E0p0",
"0x0.02D80A0p0", "0x0.0338F9Fp0", "0x0.03A6D22p0", "0x0.04234A7p0",
"0x0.04B0556p0", "0x0.0550280p0", "0x0.0605424p0", "0x0.06D279Ap0",
"0x0.07BB040p0", "0x0.08C284Cp0", "0x0.09ED1B4p0", "0x0.0B3F736p0",
"0x0.0CBED86p0", "0x0.0E7149Cp0", "0x0.105D938p0", "0x0.128B697p0",
"0x0.150385Cp0", "0x0.17CFCC2p0", "0x0.1AFB718p0", "0x0.1E9328Bp0",
"0x0.22A5554p0", "0x0.2742456p0", "0x0.2C7C72Fp0", "0x0.3268CDBp0",
"0x0.391F0EEp0", "0x0.40BA188p0", "0x0.495860Dp0", "0x0.531C6C9p0",
"0x0.5E2D58Dp0", "0x0.6AB7782p0", "0x0.78ED03Ap0", "0x0.8906E49p0",
"0x0.9B4597Ep0", "0x0.AFF230Ap0", "0x0.C75F7CFp0", "0x0.E1EB512p0",
            };
_ssdm_SpecConstant(exp_x_msb_1_table);
# 445 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<50,23> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<100,21> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<48,21> y_lo_s = y_lo;
            ap_ufixed<50,23> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        if (I_<24) {
            bool overf = 0;
#pragma unroll
 for (int j = 45; j >= I_+22; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
 for (int j = 45; j >= I_+22; j--)
                    y[j] = 0;
#pragma unroll
 for (int j = I_+21; j >= 0; j--)
                    y[j] = 1;
            }
        }
        r = y;
    } else {

        ap_fixed<65,33> x_l = 0;
#pragma unroll
 for (int j = 32-F_; j < 32+I_; j++)
            x_l[j] = x[j-(32-F_)];
#pragma unroll
 for (int j = 32+I_; j <= 64; j++)
            x_l[j] = x[W_-1];
        ap_ufixed<64,32> y = 0;
        ap_fixed<6,6> x_l_int;
        x_l_int(5,0) = x_l(37,32);
        ap_ufixed<32,0> x_l_fract;
        x_l_fract(31,0) = x_l(31,0);
        bool overf = 0;
#pragma unroll
 for (int j = 37; j < 64; j++)
            if (x_l[64]!=x_l[j])
                overf = 1;

        if (overf||(x_l_int>22)||((x_l_int==22)&&(x_l_fract>=ap_ufixed<32,0>("0x0.2e42fefap0")))) {
            if (!x_l[64]) {
#pragma unroll
 for (int j = 0; j < 64; j++) y[j] = 1;
            }
        } else {
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[64];
            x_msb_ind_1(6,0) = x_l(36,30);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(29,22);
            ap_uint<8> x_msb_ind_3;
            x_msb_ind_3(7,0) = x_l(21,14);
            ap_uint<8> x_msb_ind_4;
            x_msb_ind_4(7,0) = x_l(13,6);
            ap_uint<6> x_lsb_ind;
            x_lsb_ind(5,0) = x_l(5,0);

            ap_ufixed<8, -2> x_msb_2 = x_l;
            ap_ufixed<8,-10> x_msb_3 = x_l;
            ap_ufixed<8,-18> x_msb_4 = x_l;
            ap_ufixed<6,-26> x_lsb = x_l;

            const static ap_ufixed<31,-37> f_x_msb_4_table[256] = {
"0x0.000000000000000000p0", "0x0.000000000000080000p0", "0x0.000000000000200000p0", "0x0.000000000000480000p0",
"0x0.000000000000800000p0", "0x0.000000000000C80000p0", "0x0.000000000001200000p0", "0x0.000000000001880000p0",
"0x0.000000000002000001p0", "0x0.000000000002880001p0", "0x0.000000000003200002p0", "0x0.000000000003C80003p0",
"0x0.000000000004800004p0", "0x0.000000000005480005p0", "0x0.000000000006200007p0", "0x0.000000000007080008p0",
"0x0.00000000000800000Ap0", "0x0.00000000000908000Cp0", "0x0.00000000000A20000Fp0", "0x0.00000000000B480011p0",
"0x0.00000000000C800014p0", "0x0.00000000000DC80018p0", "0x0.00000000000F20001Bp0", "0x0.00000000001088001Fp0",
"0x0.000000000012000024p0", "0x0.000000000013880028p0", "0x0.00000000001520002Dp0", "0x0.000000000016C80033p0",
"0x0.000000000018800039p0", "0x0.00000000001A48003Fp0", "0x0.00000000001C200046p0", "0x0.00000000001E08004Dp0",
"0x0.000000000020000055p0", "0x0.00000000002208005Dp0", "0x0.000000000024200066p0", "0x0.00000000002648006Fp0",
"0x0.000000000028800079p0", "0x0.00000000002AC80083p0", "0x0.00000000002D20008Ep0", "0x0.00000000002F88009Ap0",
"0x0.0000000000320000A6p0", "0x0.0000000000348800B3p0", "0x0.0000000000372000C0p0", "0x0.000000000039C800CFp0",
"0x0.00000000003C8000DDp0", "0x0.00000000003F4800EDp0", "0x0.0000000000422000FDp0", "0x0.00000000004508010Ep0",
"0x0.000000000048000120p0", "0x0.00000000004B080132p0", "0x0.00000000004E200145p0", "0x0.000000000051480159p0",
"0x0.00000000005480016Ep0", "0x0.000000000057C80183p0", "0x0.00000000005B20019Ap0", "0x0.00000000005E8801B1p0",
"0x0.0000000000620001C9p0", "0x0.0000000000658801E2p0", "0x0.0000000000692001FCp0", "0x0.00000000006CC80216p0",
"0x0.000000000070800232p0", "0x0.00000000007448024Fp0", "0x0.00000000007820026Cp0", "0x0.00000000007C08028Bp0",
"0x0.0000000000800002AAp0", "0x0.0000000000840802CBp0", "0x0.0000000000882002ECp0", "0x0.00000000008C48030Fp0",
"0x0.000000000090800332p0", "0x0.000000000094C80357p0", "0x0.00000000009920037Dp0", "0x0.00000000009D8803A4p0",
"0x0.0000000000A20003CCp0", "0x0.0000000000A68803F5p0", "0x0.0000000000AB20041Fp0", "0x0.0000000000AFC8044Ap0",
"0x0.0000000000B4800477p0", "0x0.0000000000B94804A4p0", "0x0.0000000000BE2004D3p0", "0x0.0000000000C3080503p0",
"0x0.0000000000C8000535p0", "0x0.0000000000CD080567p0", "0x0.0000000000D220059Bp0", "0x0.0000000000D74805D1p0",
"0x0.0000000000DC800607p0", "0x0.0000000000E1C8063Fp0", "0x0.0000000000E7200678p0", "0x0.0000000000EC8806B2p0",
"0x0.0000000000F20006EEp0", "0x0.0000000000F788072Bp0", "0x0.0000000000FD20076Ap0", "0x0.000000000102C807AAp0",
"0x0.0000000001088007EBp0", "0x0.00000000010E48082Ep0", "0x0.000000000114200872p0", "0x0.00000000011A0808B8p0",
"0x0.000000000120000900p0", "0x0.000000000126080948p0", "0x0.00000000012C200993p0", "0x0.0000000001324809DEp0",
"0x0.000000000138800A2Cp0", "0x0.00000000013EC80A7Bp0", "0x0.000000000145200ACBp0", "0x0.00000000014B880B1Dp0",
"0x0.000000000152000B71p0", "0x0.000000000158880BC6p0", "0x0.00000000015F200C1Dp0", "0x0.000000000165C80C76p0",
"0x0.00000000016C800CD0p0", "0x0.000000000173480D2Cp0", "0x0.00000000017A200D8Ap0", "0x0.000000000181080DE9p0",
"0x0.000000000188000E4Ap0", "0x0.00000000018F080EADp0", "0x0.000000000196200F12p0", "0x0.00000000019D480F78p0",
"0x0.0000000001A4800FE0p0", "0x0.0000000001ABC8104Ap0", "0x0.0000000001B32010B6p0", "0x0.0000000001BA881124p0",
"0x0.0000000001C2001194p0", "0x0.0000000001C9881205p0", "0x0.0000000001D1201278p0", "0x0.0000000001D8C812EEp0",
"0x0.0000000001E0801365p0", "0x0.0000000001E84813DEp0", "0x0.0000000001F0201459p0", "0x0.0000000001F80814D6p0",
"0x0.000000000200001555p0", "0x0.0000000002080815D6p0", "0x0.000000000210201659p0", "0x0.0000000002184816DEp0",
"0x0.000000000220801765p0", "0x0.000000000228C817EEp0", "0x0.000000000231201879p0", "0x0.000000000239881907p0",
"0x0.000000000242001996p0", "0x0.00000000024A881A28p0", "0x0.000000000253201ABBp0", "0x0.00000000025BC81B51p0",
"0x0.000000000264801BE9p0", "0x0.00000000026D481C84p0", "0x0.000000000276201D20p0", "0x0.00000000027F081DBFp0",
"0x0.000000000288001E60p0", "0x0.000000000291081F03p0", "0x0.00000000029A201FA8p0", "0x0.0000000002A3482050p0",
"0x0.0000000002AC8020FAp0", "0x0.0000000002B5C821A6p0", "0x0.0000000002BF202255p0", "0x0.0000000002C8882306p0",
"0x0.0000000002D20023B9p0", "0x0.0000000002DB88246Fp0", "0x0.0000000002E5202527p0", "0x0.0000000002EEC825E1p0",
"0x0.0000000002F880269Ep0", "0x0.00000000030248275Dp0", "0x0.00000000030C20281Fp0", "0x0.0000000003160828E3p0",
"0x0.0000000003200029AAp0", "0x0.00000000032A082A73p0", "0x0.000000000334202B3Fp0", "0x0.00000000033E482C0Dp0",
"0x0.000000000348802CDEp0", "0x0.000000000352C82DB2p0", "0x0.00000000035D202E88p0", "0x0.000000000367882F60p0",
"0x0.00000000037200303Cp0", "0x0.00000000037C883119p0", "0x0.0000000003872031FAp0", "0x0.000000000391C832DDp0",
"0x0.00000000039C8033C3p0", "0x0.0000000003A74834ABp0", "0x0.0000000003B2203596p0", "0x0.0000000003BD083684p0",
"0x0.0000000003C8003775p0", "0x0.0000000003D3083868p0", "0x0.0000000003DE20395Ep0", "0x0.0000000003E9483A57p0",
"0x0.0000000003F4803B53p0", "0x0.0000000003FFC83C52p0", "0x0.00000000040B203D53p0", "0x0.000000000416883E57p0",
"0x0.000000000422003F5Ep0", "0x0.00000000042D884068p0", "0x0.000000000439204175p0", "0x0.000000000444C84285p0",
"0x0.000000000450804397p0", "0x0.00000000045C4844ADp0", "0x0.0000000004682045C5p0", "0x0.0000000004740846E1p0",
"0x0.000000000480004800p0", "0x0.00000000048C084921p0", "0x0.000000000498204A46p0", "0x0.0000000004A4484B6Dp0",
"0x0.0000000004B0804C98p0", "0x0.0000000004BCC84DC5p0", "0x0.0000000004C9204EF6p0", "0x0.0000000004D588502Ap0",
"0x0.0000000004E2005161p0", "0x0.0000000004EE88529Bp0", "0x0.0000000004FB2053D8p0", "0x0.000000000507C85518p0",
"0x0.00000000051480565Cp0", "0x0.0000000005214857A3p0", "0x0.00000000052E2058EDp0", "0x0.00000000053B085A3Ap0",
"0x0.000000000548005B8Ap0", "0x0.000000000555085CDEp0", "0x0.000000000562205E35p0", "0x0.00000000056F485F8Fp0",
"0x0.00000000057C8060ECp0", "0x0.000000000589C8624Dp0", "0x0.0000000005972063B1p0", "0x0.0000000005A4886519p0",
"0x0.0000000005B2006684p0", "0x0.0000000005BF8867F2p0", "0x0.0000000005CD206963p0", "0x0.0000000005DAC86AD8p0",
"0x0.0000000005E8806C51p0", "0x0.0000000005F6486DCDp0", "0x0.000000000604206F4Cp0", "0x0.0000000006120870CFp0",
"0x0.000000000620007255p0", "0x0.00000000062E0873DFp0", "0x0.00000000063C20756Cp0", "0x0.00000000064A4876FDp0",
"0x0.000000000658807891p0", "0x0.000000000666C87A29p0", "0x0.000000000675207BC4p0", "0x0.000000000683887D64p0",
"0x0.000000000692007F06p0", "0x0.0000000006A08880ADp0", "0x0.0000000006AF208256p0", "0x0.0000000006BDC88404p0",
"0x0.0000000006CC8085B5p0", "0x0.0000000006DB48876Ap0", "0x0.0000000006EA208923p0", "0x0.0000000006F9088ADFp0",
"0x0.000000000708008CA0p0", "0x0.000000000717088E63p0", "0x0.00000000072620902Bp0", "0x0.0000000007354891F6p0",
"0x0.0000000007448093C6p0", "0x0.000000000753C89599p0", "0x0.000000000763209770p0", "0x0.00000000077288994Ap0",
"0x0.000000000782009B29p0", "0x0.000000000791889D0Bp0", "0x0.0000000007A1209EF2p0", "0x0.0000000007B0C8A0DCp0",
"0x0.0000000007C080A2CAp0", "0x0.0000000007D048A4BCp0", "0x0.0000000007E020A6B2p0", "0x0.0000000007F008A8ACp0",
            };
_ssdm_SpecConstant(f_x_msb_4_table);
# 577 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<31,-37> f_x_msb_4 = f_x_msb_4_table[x_msb_ind_4];

            const static ap_ufixed<12,-53> f_x_lsb_table[64] = {
"0x0.00000000000000000p0", "0x0.00000000000000008p0", "0x0.00000000000000020p0", "0x0.00000000000000048p0",
"0x0.00000000000000080p0", "0x0.000000000000000c8p0", "0x0.00000000000000120p0", "0x0.00000000000000188p0",
"0x0.00000000000000200p0", "0x0.00000000000000288p0", "0x0.00000000000000320p0", "0x0.000000000000003c8p0",
"0x0.00000000000000480p0", "0x0.00000000000000548p0", "0x0.00000000000000620p0", "0x0.00000000000000708p0",
"0x0.00000000000000800p0", "0x0.00000000000000908p0", "0x0.00000000000000a20p0", "0x0.00000000000000b48p0",
"0x0.00000000000000c80p0", "0x0.00000000000000dc8p0", "0x0.00000000000000f20p0", "0x0.00000000000001088p0",
"0x0.00000000000001200p0", "0x0.00000000000001388p0", "0x0.00000000000001520p0", "0x0.000000000000016c8p0",
"0x0.00000000000001880p0", "0x0.00000000000001a48p0", "0x0.00000000000001c20p0", "0x0.00000000000001e08p0",
"0x0.00000000000002000p0", "0x0.00000000000002208p0", "0x0.00000000000002420p0", "0x0.00000000000002648p0",
"0x0.00000000000002880p0", "0x0.00000000000002ac8p0", "0x0.00000000000002d20p0", "0x0.00000000000002f88p0",
"0x0.00000000000003200p0", "0x0.00000000000003488p0", "0x0.00000000000003720p0", "0x0.000000000000039c8p0",
"0x0.00000000000003c80p0", "0x0.00000000000003f48p0", "0x0.00000000000004220p0", "0x0.00000000000004508p0",
"0x0.00000000000004800p0", "0x0.00000000000004b08p0", "0x0.00000000000004e20p0", "0x0.00000000000005148p0",
"0x0.00000000000005480p0", "0x0.000000000000057c8p0", "0x0.00000000000005b20p0", "0x0.00000000000005e88p0",
"0x0.00000000000006200p0", "0x0.00000000000006588p0", "0x0.00000000000006920p0", "0x0.00000000000006cc8p0",
"0x0.00000000000007080p0", "0x0.00000000000007448p0", "0x0.00000000000007820p0", "0x0.00000000000007c08p0",
            };
_ssdm_SpecConstant(f_x_lsb_table);
# 645 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<12,-53> f_x_lsb = f_x_lsb_table[x_lsb_ind];

            ap_ufixed<14,-44> f_x_msb_4_lsb = x_msb_4 * x_lsb;

            ap_ufixed<15,-43> exp_x_msb_4_lsb_m_1_m1 = 0;
            exp_x_msb_4_lsb_m_1_m1(4,0) = f_x_lsb(11,7);
            exp_x_msb_4_lsb_m_1_m1 = exp_x_msb_4_lsb_m_1_m1 + f_x_msb_4_lsb;

            ap_ufixed<22,-43> exp_x_msb_4_lsb_m_1_m2 = exp_x_msb_4_lsb_m_1_m1;
            exp_x_msb_4_lsb_m_1_m2(6,0) = f_x_lsb(6,0);

            ap_ufixed<29,-36> exp_x_msb_4_lsb_m_1_m3 = 0;
            exp_x_msb_4_lsb_m_1_m3(27,0) = f_x_msb_4(30,3);
            exp_x_msb_4_lsb_m_1_m3 = exp_x_msb_4_lsb_m_1_m3 + exp_x_msb_4_lsb_m_1_m2;

            ap_ufixed<32,-36> exp_x_msb_4_lsb_m_1_m = exp_x_msb_4_lsb_m_1_m3;
            exp_x_msb_4_lsb_m_1_m(2,0) = f_x_msb_4(2,0);

            ap_ufixed<50,-18> exp_x_msb_4_lsb_m_1 = 0;
            exp_x_msb_4_lsb_m_1(49,36) = x_l(13,0);
            exp_x_msb_4_lsb_m_1(31, 0) = exp_x_msb_4_lsb_m_1_m(31,0);


            const static ap_ufixed<51,-21> f_x_msb_3_table[256] = {
"0x0", "0x0.00000000080000AAAAp0", "0x0.000000002000055556p0", "0x0.000000004800120003p0",
"0x0.0000000080002AAAB5p0", "0x0.00000000C80053556Fp0", "0x0.000000012000900036p0", "0x0.000000018800E4AB0Ep0",
"0x0.000000020001555600p0", "0x0.000000028801E60111p0", "0x0.0000000320029AAC4Bp0", "0x0.00000003C8037757B7p0",
"0x0.000000048004800360p0", "0x0.000000054805B8AF50p0", "0x0.000000062007255B96p0", "0x0.000000070808CA083Dp0",
"0x0.00000008000AAAB555p0", "0x0.00000009080CCB62EDp0", "0x0.0000000A200F301116p0", "0x0.0000000B4811DCBFE0p0",
"0x0.0000000C8014D56F60p0", "0x0.0000000DC8181E1FA7p0", "0x0.0000000F201BBAD0CBp0", "0x0.00000010881FAF82E1p0",
"0x0.000000120024003600p0", "0x0.000000138828B0EA3Fp0", "0x0.00000015202DC59FB6p0", "0x0.00000016C83342567Fp0",
"0x0.0000001880392B0EB5p0", "0x0.0000001A483F83C874p0", "0x0.0000001C20465083D6p0", "0x0.0000001E084D9540FBp0",
"0x0.000000200055560001p0", "0x0.00000022085D96C106p0", "0x0.0000002420665B842Cp0", "0x0.00000026486FA84995p0",
"0x0.000000288079811161p0", "0x0.0000002AC883E9DBB6p0", "0x0.0000002D208EE6A8B8p0", "0x0.0000002F889A7B788Cp0",
"0x0.0000003200A6AC4B58p0", "0x0.0000003488B37D2145p0", "0x0.0000003720C0F1FA7Ap0", "0x0.00000039C8CF0ED721p0",
"0x0.0000003C80DDD7B765p0", "0x0.0000003F48ED509B71p0", "0x0.0000004220FD7D8371p0", "0x0.00000045090E626F94p0",
"0x0.000000480120036008p0", "0x0.0000004B09326454FBp0", "0x0.0000004E2145894E9Fp0", "0x0.000000514959764D26p0",
"0x0.00000054816E2F50C1p0", "0x0.00000057C983B859A4p0", "0x0.0000005B219A156804p0", "0x0.0000005E89B14A7C16p0",
"0x0.0000006201C95B9611p0", "0x0.0000006589E24CB62Cp0", "0x0.0000006921FC21DCA0p0", "0x0.0000006CCA16DF09A6p0",
"0x0.000000708232883D78p0", "0x0.000000744A4F217853p0", "0x0.00000078226CAEBA73p0", "0x0.0000007C0A8B340414p0",
"0x0.0000008002AAB55577p0", "0x0.000000840ACB36AEDAp0", "0x0.0000008822ECBC107Dp0", "0x0.0000008C4B0F497AA3p0",
"0x0.000000908332E2ED8Ep0", "0x0.00000094CB578C6981p0", "0x0.00000099237D49EEC0p0", "0x0.0000009D8BA41F7D92p0",
"0x0.000000A203CC11163Dp0", "0x0.000000A68BF522B908p0", "0x0.000000AB241F58663Cp0", "0x0.000000AFCC4AB61E22p0",
"0x0.000000B484773FE105p0", "0x0.000000B94CA4F9AF31p0", "0x0.000000BE24D3E788F1p0", "0x0.000000C30D040D6E94p0",
"0x0.000000C805356F6068p0", "0x0.000000CD0D68115EBCp0", "0x0.000000D2259BF769E1p0", "0x0.000000D74DD1258228p0",
"0x0.000000DC86079FA7E4p0", "0x0.000000E1CE3F69DB69p0", "0x0.000000E72678881D0Bp0", "0x0.000000EC8EB2FE6D1Fp0",
"0x0.000000F206EED0CBFDp0", "0x0.000000F78F2C0339FAp0", "0x0.000000FD276A99B771p0", "0x0.00000102CFAA9844BBp0",
"0x0.0000010887EC02E231p0", "0x0.0000010E502EDD9030p0", "0x0.0000011428732C4F14p0", "0x0.0000011A10B8F31F3Bp0",
"0x0.000001200900360103p0", "0x0.000001261148F8F4CBp0", "0x0.0000012C29933FFAF5p0", "0x0.0000013251DF0F13E1p0",
"0x0.000001388A2C6A3FF3p0", "0x0.0000013ED27B557F8Dp0", "0x0.000001452ACBD4D315p0", "0x0.0000014B931DEC3AEFp0",
"0x0.000001520B719FB782p0", "0x0.0000015893C6F34937p0", "0x0.0000015F2C1DEAF074p0", "0x0.00000165D4768AADA5p0",
"0x0.0000016C8CD0D68133p0", "0x0.00000173552CD26B89p0", "0x0.0000017A2D8A826D16p0", "0x0.0000018115E9EA8645p0",
"0x0.000001880E4B0EB785p0", "0x0.0000018F16ADF30147p0", "0x0.000001962F129B63FAp0", "0x0.0000019D57790BE010p0",
"0x0.000001A48FE14875FBp0", "0x0.000001ABD84B552630p0", "0x0.000001B330B735F122p0", "0x0.000001BA9924EED748p0",
"0x0.000001C2119483D917p0", "0x0.000001C99A05F8F707p0", "0x0.000001D13279523191p0", "0x0.000001D8DAEE93892Ep0",
"0x0.000001E09365C0FE59p0", "0x0.000001E85BDEDE918Dp0", "0x0.000001F03459F04347p0", "0x0.000001F81CD6FA1405p0",
"0x0.000002001556000444p0", "0x0.000002081DD7061485p0", "0x0.00000210365A104547p0", "0x0.000002185EDF22970Dp0",
"0x0.000002209766410A5Ap0", "0x0.00000228DFEF6F9FAFp0", "0x0.00000231387AB25793p0", "0x0.00000239A1080D328Ap0",
"0x0.00000242199784311Cp0", "0x0.0000024AA2291B53CFp0", "0x0.000002533ABCD69B2Dp0", "0x0.0000025BE352BA07BEp0",
"0x0.000002649BEAC99A0Dp0", "0x0.0000026D64850952A7p0", "0x0.000002763D217D3216p0", "0x0.0000027F25C02938EAp0",
"0x0.000002881E611167B0p0", "0x0.00000291270439BEF8p0", "0x0.0000029A3FA9A63F53p0", "0x0.000002A368515AE951p0",
"0x0.000002ACA0FB5BBD86p0", "0x0.000002B5E9A7ACBC86p0", "0x0.000002BF425651E6E4p0", "0x0.000002C8AB074F3D36p0",
"0x0.000002D223BAA8C013p0", "0x0.000002DBAC70627012p0", "0x0.000002E54528804DCDp0", "0x0.000002EEEDE30659DBp0",
"0x0.000002F8A69FF894D9p0", "0x0.000003026F5F5AFF61p0", "0x0.0000030C4821319A10p0", "0x0.0000031630E5806584p0",
"0x0.0000032029AC4B625Bp0", "0x0.0000032A3275969134p0", "0x0.000003344B4165F2B1p0", "0x0.0000033E740FBD8772p0",
"0x0.00000348ACE0A1501Bp0", "0x0.00000352F5B4154D4Fp0", "0x0.0000035D4E8A1D7FB2p0", "0x0.00000367B762BDE7EAp0",
"0x0.00000372303DFA869Ep0", "0x0.0000037CB91BD75C75p0", "0x0.0000038751FC586A18p0", "0x0.00000391FADF81B02Fp0",
"0x0.0000039CB3C5572F67p0", "0x0.000003A77CADDCE86Ap0", "0x0.000003B2559916DBE4p0", "0x0.000003BD3E87090A84p0",
"0x0.000003C83777B774F8p0", "0x0.000003D3406B261BF0p0", "0x0.000003DE596159001Cp0", "0x0.000003E9825A54222Dp0",
"0x0.000003F4BB561B82D7p0", "0x0.000004000454B322CCp0", "0x0.0000040B5D561F02C2p0", "0x0.00000416C65A63236Ep0",
"0x0.000004223F61838586p0", "0x0.0000042DC86B8429C2p0", "0x0.0000043961786910DBp0", "0x0.000004450A88363B8Ap0",
"0x0.00000450C39AEFAA8Ap0", "0x0.0000045C8CB0995E96p0", "0x0.0000046865C937586Bp0", "0x0.000004744EE4CD98C6p0",
"0x0.000004804803602067p0", "0x0.0000048C5124F2F00Cp0", "0x0.000004986A498A0876p0", "0x0.000004A49371296A67p0",
"0x0.000004B0CC9BD516A1p0", "0x0.000004BD15C9910DE8p0", "0x0.000004C96EFA615101p0", "0x0.000004D5D82E49E0B0p0",
"0x0.000004E251654EBDBDp0", "0x0.000004EEDA9F73E8F0p0", "0x0.000004FB73DCBD6310p0", "0x0.000005081D1D2F2CE7p0",
"0x0.00000514D660CD4740p0", "0x0.000005219FA79BB2E7p0", "0x0.0000052E78F19E70A8p0", "0x0.0000053B623ED98150p0",
"0x0.000005485B8F50E5AFp0", "0x0.0000055564E3089E93p0", "0x0.000005627E3A04ACCEp0", "0x0.0000056FA794491131p0",
"0x0.0000057CE0F1D9CC8Ep0", "0x0.0000058A2A52BADFBAp0", "0x0.0000059783B6F04B88p0", "0x0.000005A4ED1E7E10CFp0",
"0x0.000005B26689683064p0", "0x0.000005BFEFF7B2AB20p0", "0x0.000005CD89696181DBp0", "0x0.000005DB32DE78B56Fp0",
"0x0.000005E8EC56FC46B6p0", "0x0.000005F6B5D2F0368Cp0", "0x0.000006048F525885CDp0", "0x0.0000061278D5393558p0",
"0x0.00000620725B96460Ap0", "0x0.0000062E7BE573B8C3p0", "0x0.0000063C9572D58E64p0", "0x0.0000064ABF03BFC7CEp0",
"0x0.00000658F8983665E5p0", "0x0.0000066742303D698Bp0", "0x0.000006759BCBD8D3A5p0", "0x0.00000684056B0CA519p0",
"0x0.000006927F0DDCDECEp0", "0x0.000006A108B44D81AAp0", "0x0.000006AFA25E628E98p0", "0x0.000006BE4C0C20067Fp0",
"0x0.000006CD05BD89EA4Bp0", "0x0.000006DBCF72A43AE8p0", "0x0.000006EAA92B72F942p0", "0x0.000006F992E7FA2646p0",
"0x0.000007088CA83DC2E4p0", "0x0.00000717966C41D00Ap0", "0x0.00000726B0340A4EAAp0", "0x0.00000735D9FF9B3FB6p0",
"0x0.0000074513CEF8A41Ep0", "0x0.000007545DA2267CD9p0", "0x0.00000763B77928CAD9p0", "0x0.000007732154038F14p0",
"0x0.000007829B32BACA82p0", "0x0.000007922515527E1Ap0", "0x0.000007A1BEFBCEAAD4p0", "0x0.000007B168E63351AAp0",
"0x0.000007C122D4847397p0", "0x0.000007D0ECC6C61195p0", "0x0.000007E0C6BCFC2CA3p0", "0x0.000007F0B0B72AC5BEp0",
            };
_ssdm_SpecConstant(f_x_msb_3_table);
# 686 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<51,-21> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<62,-10> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(61,54) = x_msb_3(7,0);
            exp_x_msb_3_m_1(50, 0) = f_x_msb_3(50,0);

            ap_ufixed<50,-10> exp_x_msb_3_m_1_s = exp_x_msb_3_m_1;
            ap_ufixed<100,-28> f_x_msb_3_4_lsb = exp_x_msb_3_m_1_s * exp_x_msb_4_lsb_m_1;
            ap_ufixed<44,-28> f_x_msb_3_4_lsb_s = f_x_msb_3_4_lsb;
            ap_ufixed<63, -9> exp_x_msb_3_4_lsb_m_1 = f_x_msb_3_4_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_lsb_m_1;


            const static ap_ufixed<64,-4> f_x_msb_2_table[256] = {
"0x0.0p0", "0x0.00000800AAB555DDEp0", "0x0.00002005560011127p0", "0x0.00004812036081A9Cp0",
"0x0.0000802AB55777D28p0", "0x0.0000C8536F6684062p0", "0x0.0001209036103740Dp0", "0x0.000188E50ED8634A0p0",
"0x0.0002015600445B0C3p0", "0x0.000289E711DB32FD7p0", "0x0.0003229C4C260197Ep0", "0x0.0003CB79B8B01FE26p0",
"0x0.0004848362076A08Dp0", "0x0.00054DBD53BC80058p0", "0x0.0006272B9A630659Dp0", "0x0.000710D24391E6D7Ap0",
"0x0.00080AB55DE3917ABp0", "0x0.000914D8F8F63D524p0", "0x0.000A2F41256C297AFp0", "0x0.000B59F1F4EBDE291p0",
"0x0.000C94EF7A206DC2Dp0", "0x0.000DE03DC8B9B60B1p0", "0x0.000F3BE0F56CA15C4p0", "0x0.0010A7DD15F367F40p0",
"0x0.00122436410DD14E5p0", "0x0.0013B0F08E817591Ep0", "0x0.00154E101719FF0C5p0", "0x0.0016FB98F4A96BBEFp0",
"0x0.0018B98F42084EFBDp0", "0x0.001A87F71B1613137p0", "0x0.001C66D49CB93B127p0", "0x0.001E562BE4DFA4904p0",
"0x0.00205601127EC98E0p0", "0x0.00226658459402659p0", "0x0.002487359F24C7C99p0", "0x0.0026B89D413EF4D5Ep0",
"0x0.0028FA934EF909304p0", "0x0.002B4D1BEC726B39Cp0", "0x0.002DB03B3ED3AA50Ep0", "0x0.003023F56C4EC123Fp0",
"0x0.0032A84E9C1F58145p0", "0x0.00353D4AF68B07AA1p0", "0x0.0037E2EEA4E19B185p0", "0x0.003A993DD17D52D25p0",
"0x0.003D603CA7C32730Fp0", "0x0.004037EF54230B293p0", "0x0.0043205A04182F12Fp0", "0x0.00461980E62943810p0",
"0x0.0049236829E8BC292p0", "0x0.004C3E13FFF512DD8p0", "0x0.004F698899F90A966p0", "0x0.0052A5CA2AABF28D0p0",
"0x0.0055F2DCE5D1E966Ep0", "0x0.005950C5003C20723p0", "0x0.005CBF86AFC91EF2Bp0", "0x0.00603F262B65057FCp0",
"0x0.0063CFA7AB09D1732p0", "0x0.0067710F67BFA0687p0", "0x0.006B23619B9CF3CDEp0", "0x0.006EE6A281C6F4857p0",
"0x0.0072BAD65671B6977p0", "0x0.0076A00156E07CF57p0", "0x0.007A9627C165FD4EDp0", "0x0.007E9D4DD564A3F5Ep0",
"0x0.0082B577D34ED7D5Bp0", "0x0.0086DEA9FCA73E799p0", "0x0.008B18E8940100253p0", "0x0.008F6437DD000BFDAp0",
"0x0.0093C09C1C595C43Ep0", "0x0.00982E1997D33A9FCp0", "0x0.009CACB49645847CCp0", "0x0.00A13C715F99EF773p0",
"0x0.00A5DD543CCC4DDAFp0", "0x0.00AA8F6177EAD3336p0", "0x0.00AF529D5C1658EBCp0", "0x0.00B4270C3582A301Dp0",
"0x0.00B90CB25176A4C8Bp0", "0x0.00BE0393FE4CC5BD7p0", "0x0.00C30BB58B73266CAp0", "0x0.00C8251B496BE5696p0",
"0x0.00CD4FC989CD64555p0", "0x0.00D28BC49F428CFA3p0", "0x0.00D7D910DD8B16743p0", "0x0.00DD37B2997BCA6E6p0",
"0x0.00E2A7AE28FECA6FBp0", "0x0.00E82907E313D5399p0", "0x0.00EDBBC41FD08C383p0", "0x0.00F35FE73860B9038p0",
"0x0.00F91575870692F24p0", "0x0.00FEDC73671B04BDFp0", "0x0.0104B4E5350DF2386p0", "0x0.010A9ECF4E667E12Dp0",
"0x0.01109A3611C34FB64p0", "0x0.0116A71DDEDAD92D8p0", "0x0.011CC58B167B9D206p0", "0x0.0122F5821A8C74E0Dp0",
"0x0.012937074E0CD6893p0", "0x0.012F8A1F15151B2C6p0", "0x0.0135EECDD4D6C5172p0", "0x0.013C6517F39CC6233p0",
"0x0.0142ED01D8CBC61C4p0", "0x0.0149868FECE26935Dp0", "0x0.015031C6997996937p0", "0x0.0156EEAA4944BEE23p0",
"0x0.015DBD3F68122303Ep0", "0x0.01649D8A62CB1ACBEp0", "0x0.016B8F8FA7745BCDBp0", "0x0.01729353A52E403D8p0",
"0x0.0179A8DACC350DE1Dp0", "0x0.0180D0298DE13D179p0", "0x0.018809445CA7BFE78p0", "0x0.018F542FAC1A492D6p0",
"0x0.0196B0EFF0E793D15p0", "0x0.019E1F89A0DBAA128p0", "0x0.01A5A00132E02CE42p0", "0x0.01AD325B1EFC9B5BCp0",
"0x0.01B4D69BDE569A322p0", "0x0.01BC8CC7EB323B553p0", "0x0.01C454E3C0F2458C8p0", "0x0.01CC2EF3DC187C2F6p0",
"0x0.01D41AFCBA45E6ED2p0", "0x0.01DC1902DA3B19A6Dp0", "0x0.01E4290ABBD87C5BCp0", "0x0.01EC4B18E01E9326Fp0",
"0x0.01F47F31C92E464FCp0", "0x0.01FCC559FA492A6B6p0", "0x0.02051D95F7D1C8917p0", "0x0.020D87EA474BE6A1Cp0",
"0x0.0216045B6F5CCF9CEp0", "0x0.021E92EDF7CB9C0E4p0", "0x0.022733A669817A88Ap0", "0x0.022FE6894E89F834Cp0",
"0x0.0238AB9B321349722p0", "0x0.024182E0A06E9289Bp0", "0x0.024A6C5E271030733p0", "0x0.02536818549001AC1p0",
"0x0.025C7613B8A9AF215p0", "0x0.02659654E43CF52B1p0", "0x0.026EC8E0694DEC9A9p0", "0x0.02780DBADB0553DA6p0",
"0x0.028164E8CDB0D8211p0", "0x0.028ACE6ED6C35EB5Fp0", "0x0.02944A518CD54E484p0", "0x0.029DD89587A4D858Dp0",
"0x0.02A7793F601642B5Dp0", "0x0.02B12C53B03431090p0", "0x0.02BAF1D7132FEE788p0", "0x0.02C4C9CE2561B759Fp0",
"0x0.02CEB43D844902F7Ap0", "0x0.02D8B129CE8CCD68Fp0", "0x0.02E2C097A3FBE17C9p0", "0x0.02ECE28BA58D22B56p0",
"0x0.02F7170A755FD759Ep0", "0x0.03015E18B6BBF2966p0", "0x0.030BB7BB0E125EB13p0", "0x0.031623F620FD4751Ep0",
"0x0.0320A2CE964063DACp0", "0x0.032B344915C941D54p0", "0x0.0335D86A48AF8F70Cp0", "0x0.03408F36D93566140p0",
"0x0.034B58B372C795013p0", "0x0.035634E4C1FDEC0D0p0", "0x0.036123CF749B8667Cp0", "0x0.036C2578398F157A0p0",
"0x0.037739E3C0F32BD30p0", "0x0.03826116BC0E882ACp0", "0x0.038D9B15DD5460763p0", "0x0.0398E7E5D864AD0E9p0",
"0x0.03A4478B620C73EB5p0", "0x0.03AFBA0B304613EEDp0", "0x0.03BB3F69FA3990464p0", "0x0.03C6D7AC783CDBDBFp0",
"0x0.03D282D763D424DCDp0", "0x0.03DE40EF77B220509p0", "0x0.03EA11F96FB855C4Fp0", "0x0.03F5F5FA08F76B0BBp0",
"0x0.0401ECF601AF700BDp0", "0x0.040DF6F219502AA55p0", "0x0.041A13F3107962A88p0", "0x0.042643FDA8FB2DDFBp0",
"0x0.04328716A5D63C2C4p0", "0x0.043EDD42CB3C23B6Dp0", "0x0.044B4686DE8FAD325p0", "0x0.0457C2E7A66520322p0",
"0x0.04645269EA828F932p0", "0x0.0470F51273E025F89p0", "0x0.047DAAE60CA8725B3p0", "0x0.048A73E98038B4ABFp0",
"0x0.049750219B212A8A0p0", "0x0.04A43F932B255C0B7p0", "0x0.04B14242FF3C689A0p0", "0x0.04BE5835E79153E1Dp0",
"0x0.04CB8170B58352D4Ep0", "0x0.04D8BDF83BA618C04p0", "0x0.04E60DD14DC22475Ep0", "0x0.04F37100C0D50D88Ep0",
"0x0.0500E78B6B11D19D6p0", "0x0.050E717623E121CBAp0", "0x0.051C0EC5C3E1B016Cp0", "0x0.0529BF7F24E87CF6Ap0",
"0x0.053783A7220124F51p0", "0x0.05455B42976E2E5EAp0", "0x0.0553465662A95706Bp0", "0x0.056144E76263E21F4p0",
"0x0.056F56FA7686E623Ep0", "0x0.057D7C9480339AD83p0", "0x0.058BB5BA61C3A75A3p0", "0x0.059A0270FEC97047Ap0",
"0x0.05A862BD3C1065F74p0", "0x0.05B6D6A3FF9D52C58p0", "0x0.05C55E2A30AEA974Ep0", "0x0.05D3F954B7BCD3A1Bp0",
"0x0.05E2A8287E7A8049Ep0", "0x0.05F16AAA6FD4F267Bp0", "0x0.060040DF77F44FA13p0", "0x0.060F2ACC843BEF0A0p0",
"0x0.061E2876834AA7FA4p0", "0x0.062D39E264FB20F7Ep0", "0x0.063C5F151A641EB4Cp0", "0x0.064B981395D8D31FEp0",
"0x0.065AE4E2CAE92C8AAp0", "0x0.066A4587AE6224E1Cp0", "0x0.0679BA07364E10FA3p0", "0x0.0689426659F4EFF1Bp0",
"0x0.0698DEAA11DCBAA37p0", "0x0.06A88ED757C9B3304p0", "0x0.06B852F326BEB49B0p0", "0x0.06C82B027AFD8278Ap0",
"0x0.06D8170A520718B46p0", "0x0.06E8170FAA9BFB67Ep0", "0x0.06F82B1784BC86C72p0", "0x0.07085326E1A93F207p0",
"0x0.07188F42C3E320F0Bp0", "0x0.0728DF702F2BF10B2p0", "0x0.073943B428868CD5Ap0", "0x0.0749BC13B6373A98Fp0",
"0x0.075A4893DFC3F9E4Cp0", "0x0.076AE939ADF4D4083p0", "0x0.077B9E0A2AD42C9E8p0", "0x0.078C670A61AF122F4p0",
"0x0.079D443F5F158EE3Ap0", "0x0.07AE35AE30DAF94F1p0", "0x0.07BF3B5BE616454CBp0", "0x0.07D0554D8F2254F0Cp0",
"0x0.07E183883D9E498E2p0", "0x0.07F2C611046DD4D06p0", "0x0.08041CECF7B989EA2p0", "0x0.081588212CEF2ED73p0",
"0x0.082707B2BAC20DB40p0", "0x0.08389BA6B92B46284p0", "0x0.084A4402416A1EE6Fp0", "0x0.085C00CA6E045741Fp0",
"0x0.086DD2045AC678D2Bp0", "0x0.087FB7B524C42936Cp0", "0x0.0891B1E1EA587BE12p0", "0x0.08A3C08FCB2643FFEp0",
            };
_ssdm_SpecConstant(f_x_msb_2_table);
# 763 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<64,-4> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 6,-4> f_x_msb_2_h;
            f_x_msb_2_h(5,0) = f_x_msb_2(63,58);
            ap_ufixed< 9,-1> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<67,-1> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(66,58) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(57, 0) = f_x_msb_2(57,0);

            ap_ufixed<130,-10> f_x_msb_2_3_4_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_lsb_m_1;
            ap_ufixed<62,-10> f_x_msb_2_3_4_lsb_s = f_x_msb_2_3_4_lsb;
            ap_ufixed<72,0> exp_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_3_4_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<68,32> exp_x_msb_1_table[256] = {
"0x1.000000000p0", "0x1.48B5E3C3Ep0", "0x1.A61298E1Ep0", "0x2.1DF3B68CFp0",
"0x2.B7E151628p0", "0x3.7D871DB61p0", "0x4.7B4FF993Fp0", "0x5.C12DA416Ep0",
"0x7.63992E353p0", "0x9.7CDC417A3p0", "0xC.2EB7EC98Fp0", "0xF.A48385EDFp0",
"0x14.15E5BF6FBp0", "0x19.CA53B7811p0", "0x21.1D8E4272Dp0", "0x2A.8565A144Cp0",
"0x36.99205C4E7p0", "0x46.1AFC4DB59p0", "0x5A.0462B7877p0", "0x73.9593ABB7Dp0",
"0x94.69C4CB819p0", "0xBE.90F6F83E9p0", "0xF4.B122790DDp0", "0x13A.30CF1CCBBp0",
"0x193.6DC5690C0p0", "0x206.03487A3B1p0", "0x299.2442102D9p0", "0x356.0F0B0F980p0",
"0x448.A216ABB76p0", "0x580.1AD754FA3p0", "0x710.0ADBAC7DAp0", "0x911.9289C3923p0",
"0xBA4.F53EA3863p0", "0xEF3.A035D5798p0", "0x1332.C4D2B7C4Ap0", "0x18A6.B027DA0A7p0",
"0x1FA7.157C470F8p0", "0x28A4.90D2CCEF1p0", "0x342F.BA11823B8p0", "0x4302.3A933EE5Cp0",
"0x560A.773E54157p0", "0x6E7A.8ABB4A83Cp0", "0x8DDB.80AF4269Dp0", "0xB626.0748BAEC7p0",
"0xE9E2.2447727BFp0", "0x12C4F.EB75B2AB0p0", "0x1819B.C560F6113p0", "0x1EF21.8F1B001A4p0",
"0x27BC2.CA9A6F934p0", "0x33055.49F35D91Fp0", "0x41831.49596E996p0", "0x541E7.E56949D58p0",
"0x6C02D.645AB2554p0", "0x8AB06.0A3EE9FB1p0", "0xB2148.5EAE56C5Bp0", "0xE4A8D.2881EDBE8p0",
"0x1259AC.48BF05D6Ep0", "0x178FEE.7792E44B3p0", "0x1E4127.437732B71p0", "0x26D8F9.4A204BEA5p0",
"0x31E199.5F5A550DDp0", "0x400C7D.64D3386CBp0", "0x523D82.79EDAEF9Cp0", "0x69993D.D4F2D9524p0",
"0x87975E.854001024p0", "0xAE1A47.C38A42CD0p0", "0xDF8D5F.6DCFE5CEAp0", "0x11F0BF8.1E99FDEB6p0",
"0x1709348.C0EA4F8CEp0", "0x1D94295.464477ACCp0", "0x25FAD90.65C78E342p0", "0x30C4623.616ED2BE2p0",
"0x3E9E441.232817A61p0", "0x506744D.3B342FC94p0", "0x673D70B.C00F1F76Dp0", "0x849012B.C127FC962p0",
"0xAA36C7C.F69370B94p0", "0xDA8F202.DD9ACE661p0", "0x118A2AAE.0AA05236Bp0", "0x16857CFA.1AA8A5555p0",
"0x1CEB088B.68E804021p0", "0x2521AEDA.32CD52BE5p0", "0x2FAD89E1.79BAB8EADp0", "0x3D3838C6.BE0F13F06p0",
"0x4E9B87F6.7BB3F5597p0", "0x64EF201B.01109A4A5p0", "0x819A1801.9394C0D96p0", "0xA6698403.CF5D9E663p0",
"0xD5AD6DCE.21AFFC0DDp0", "0x1125E066B.0B19418CCp0", "0x1604B68CF.05F65FAA9p0", "0x1C45AED0A.D0C934CDCp0",
"0x244D5E676.3FB814AF0p0", "0x2E9CEBF49.9C21839C7p0", "0x3BDA2CBD0.9F5AC2146p0", "0x4CDA0FD41.989F004E7p0",
"0x62ADFED51.D7EDCCDE6p0", "0x7EB50B520.76F91D6E8p0", "0xA2B1FD3D9.A57B6C33Cp0", "0xD0E7A50F4.EF0D7447Fp0",
"0x10C3D39209.62C88AAFBp0", "0x1586D0722B.3EEB27301p0", "0x1BA4068AAC.2B6E3EE34p0", "0x237DCBF1E5.709A9F9C1p0",
"0x2D9264D2D4.D6B94153Bp0", "0x3A83F23B18.FE5BD524Ap0", "0x4B22A1B5C3.27A2FD85Ap0", "0x6079C1866C.71A93951Dp0",
"0x7BE08BDFD9.CC72249ABp0", "0x9F0FB7309C.B446D3919p0", "0xCC3D265776.C3D25779Ep0", "0x1063F7612B0.C0831CA6Cp0",
"0x150BBA37963.79A4FB6ADp0", "0x1B05FA9B62E.737D935B8p0", "0x22B2DC5C41D.AD89559EBp0", "0x2C8DD1AB28B.404414BE7p0",
"0x39355C8C638.0AC5631B1p0", "0x49750434675.301B8D0E7p0", "0x5E521E7A16E.51F9CD3C2p0", "0x791C3B06F8B.EA2DEC48Cp0",
"0x9B823857614.764F43E20p0", "0xC7AD559D438.E7C270C30p0", "0x10063F4E687B.A1A43A35Bp0", "0x149363C905BA.3641D0164p0",
"0x1A6B765D8CDF.6CDBF1C63p0", "0x21EC75240E66.E2891CE63p0", "0x2B8F1073A6AF.BA219DB61p0", "0x37EE3FFC0063.E360F931Fp0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000001p0", "0x0.000000001p0", "0x0.000000002p0",
"0x0.000000002p0", "0x0.000000003p0", "0x0.000000004p0", "0x0.000000005p0",
"0x0.000000007p0", "0x0.000000009p0", "0x0.00000000Bp0", "0x0.00000000Ep0",
"0x0.000000013p0", "0x0.000000018p0", "0x0.00000001Fp0", "0x0.000000028p0",
"0x0.000000034p0", "0x0.000000042p0", "0x0.000000055p0", "0x0.00000006Ep0",
"0x0.00000008Dp0", "0x0.0000000B5p0", "0x0.0000000E9p0", "0x0.00000012Bp0",
"0x0.000000181p0", "0x0.0000001EEp0", "0x0.00000027Ap0", "0x0.00000032Fp0",
"0x0.000000416p0", "0x0.00000053Fp0", "0x0.0000006BDp0", "0x0.0000008A7p0",
"0x0.000000B1Cp0", "0x0.000000E44p0", "0x0.000001252p0", "0x0.000001786p0",
"0x0.000001E35p0", "0x0.0000026C9p0", "0x0.0000031CEp0", "0x0.000003FF3p0",
"0x0.00000521Dp0", "0x0.000006970p0", "0x0.000008762p0", "0x0.00000ADD6p0",
"0x0.00000DF36p0", "0x0.000011E9Cp0", "0x0.000017003p0", "0x0.00001D88Ap0",
"0x0.000025EC0p0", "0x0.000030B15p0", "0x0.00003E85Dp0", "0x0.00005047Ep0",
"0x0.000067153p0", "0x0.0000845C6p0", "0x0.0000A9F46p0", "0x0.0000DA39Ep0",
"0x0.000118354p0", "0x0.000167CB5p0", "0x0.0001CDFC2p0", "0x0.000251334p0",
"0x0.0002F9AF3p0", "0x0.0003D205Ap0", "0x0.0004E7CE2p0", "0x0.00064C7C6p0",
"0x0.000816791p0", "0x0.000A628A3p0", "0x0.000D55A1Fp0", "0x0.00111F30Fp0",
"0x0.0015FC210p0", "0x0.001C3AA91p0", "0x0.00243F374p0", "0x0.002E8ABFCp0",
"0x0.003BC2D73p0", "0x0.004CBC19Ap0", "0x0.006287862p0", "0x0.007E83A56p0",
"0x0.00A2728F8p0", "0x0.00D096336p0", "0x0.010BD4A5Ap0", "0x0.0157E6BFEp0",
"0x0.01B993FE0p0", "0x0.0236FF5BFp0", "0x0.02D80A08Dp0", "0x0.03A6D2222p0",
"0x0.04B0556E0p0", "0x0.0605424D5p0", "0x0.07BB04063p0", "0x0.09ED1B429p0",
"0x0.0CBED8666p0", "0x0.105D93892p0", "0x0.150385C09p0", "0x0.1AFB718E8p0",
"0x0.22A555477p0", "0x0.2C7C72FC0p0", "0x0.391F0EE49p0", "0x0.495860DCAp0",
"0x0.5E2D58D8Bp0", "0x0.78ED03AFBp0", "0x0.9B4597E37p0", "0x0.C75F7CF56p0",
            };
_ssdm_SpecConstant(exp_x_msb_1_table);
# 841 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<68,32> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<140,32> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<68,32> y_lo_s = y_lo;
            ap_ufixed<68,32> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        if (I_<33) {
            bool overf = 0;
#pragma unroll
 for (int j = 63; j >= I_+31; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
 for (int j = 63; j >= I_+31; j--)
                    y[j] = 0;
#pragma unroll
 for (int j = I_+30; j >= 0; j--)
                    y[j] = 1;
            }
        }
        r = y;
    }
    return r;
}


template<int WO_, int I_, int WI_>
ap_fixed<WO_,I_> exp_core(ap_fixed<WI_,I_> x)
{
#pragma HLS pipeline

 const static int FO_ = WO_ - I_;
_ssdm_SpecConstant(&FO_);
# 940 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

    const static int FI_ = WI_ - I_;
_ssdm_SpecConstant(&FI_);
# 941 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"



    if (I_>33) return 0;
    else if (FO_>32) return 0;
    else if (FI_>100) return 0;




    int I_s_;
    int M_ = (I_-1>FO_) ? (I_-1) : FO_;
    if (M_==1) I_s_ = 1;
    else if (M_==2) I_s_ = 2;
    else if (M_<6) I_s_ = 3;
    else if (M_<12) I_s_ = 4;
    else if (M_<24) I_s_ = 5;
    else I_s_ = 6;

    ap_fixed<WO_,I_> r = 0;

    ap_ufixed<1,-FO_> delta = 0;
    delta[0] = 1;

    if (I_s_==1) {






        const static int w = 7;
_ssdm_SpecConstant(&w);
# 972 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

        const static int we = 2;
_ssdm_SpecConstant(&we);
# 973 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

        const static int wf = 5;
_ssdm_SpecConstant(&wf);
# 974 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"


        ap_fixed<w,we> x_l = x;
        ap_ufixed<3,2> y = 0;
        ap_ufixed<5,0> x_l_fract=0;
        x_l_fract(4,0) = x_l(4,0);


        if (x_l[6]!=x_l[5]) {
            if (!x_l[6]) y = "0x1.8p0";
        } else {
            if (!x_l[6]) y[1] = 1;

            if (!x_l[6]&(x_l[4]|(x_l[2]&x_l[3]))) y[0]=1;
            if (!x_l[6]&x_l[2]&x_l[3]) y[0]=1;
            if (x_l[6]&((x_l[4]&x_l[3])|x_l[5])) y[0] = 1;
            if (x_l[6]&x_l[5]&!x_l[4]&x_l[3]&!x_l[2]&x_l[1]) y[0] = 1;
        }
        y += delta;

            if (y[1]|y[2]) {
                y[2] = 0;
                y[1] = 0;
                y[0] = 1;
            }

        r = y;

    } else if (I_s_==2) {
        const static int w = 10;
_ssdm_SpecConstant(&w);
# 1003 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

        const static int we = 3;
_ssdm_SpecConstant(&we);
# 1004 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

        const static int wf = 7;
_ssdm_SpecConstant(&wf);
# 1005 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"



        ap_fixed<w,we> x_l = x;
        ap_ufixed<5,3> y = 0;
        ap_fixed<2,2> x_l_int;
        x_l_int(1,0) = x_l(wf+1,wf);
        ap_ufixed<7,0> x_l_fract;
        x_l_fract(6,0) = x_l(6,0);

        ap_uint<5> x_msb_ind;
        x_msb_ind[3] = x_l[w-1];
        x_msb_ind(2,0) = x_l(wf,wf-3);
        ap_ufixed<4,-3> x_lsb = x_l;


        if ((x_l[w-1]!=x_l[w-2])||((x_l_int==1)&&(x_l_fract>=ap_ufixed<wf,0>("0x0.54p0")))) {
            if (!x_l[w-1]) y = "0x3.cp0";
        } else {
            ap_ufixed<5,2> exp_x_msb_table[32] = {
               "0x1.00p0", "0x1.48p0", "0x1.A6p0", "0x2.1Dp0", "0x2.B7p0", "0x3.7Dp0", "0x4.7Bp0", "0x5.C1p0",
               "0x0.22p0", "0x0.2Cp0", "0x0.39p0", "0x0.49p0", "0x0.5Ep0", "0x0.78p0", "0x0.9Bp0", "0x0.C7p0",
            };
            ap_ufixed<5,2> exp_x_msb = exp_x_msb_table[x_msb_ind];


            ap_ufixed<5,0> y_lo = x_lsb * exp_x_msb;

            ap_ufixed<5,2> y_l = y_lo + exp_x_msb;

            y = y_l;
        }
        y += delta;
            bool overf = 0;
#pragma unroll
 for (int j = 4; j >= I_+1; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
 for (int j = 4; j >= I_+1; j--)
                    y[j] = 0;
#pragma unroll
 for (int j = I_; j >= 0; j--)
                    y[j] = 1;
            }
        r = y;
    } else if (I_s_==3) {

        const static int w = 19;
_ssdm_SpecConstant(&w);
# 1055 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

        const static int we = 6;
_ssdm_SpecConstant(&we);
# 1056 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

        const static int wf = 13;
_ssdm_SpecConstant(&wf);
# 1057 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"


        ap_fixed<w,we> x_l = x;
        ap_ufixed<11,6> y = 0;
        ap_fixed<3,3> x_l_int;
        x_l_int(2,0) = x_l(wf+2,wf);
        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);




        if ((x_l[w-1]!=x_l[w-2])||(x_l[w-1]!=x_l[w-3])||(x_l[w-1]!=x_l[w-4])||((x_l_int==3)&&(x_l_fract>ap_ufixed<wf,0>("0x0.76FAp0")))) {
            if (!x_l[18]) y = "0x1f.f8p0";
        } else {
            const static int g = 2;
_ssdm_SpecConstant(&g);
# 1072 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            const static int Maxprecision = FO_+we+g;
_ssdm_SpecConstant(&Maxprecision);
# 1073 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_uint<4> x_msb_ind_1;
            x_msb_ind_1[3] = x_l[w-1];

            x_msb_ind_1(2,0) = x_l(wf+1,wf-1);

            ap_uint<6> x_msb_ind_2;
            x_msb_ind_2(5,0) = x_l(wf-2,wf-7);
            ap_ufixed<6,-1> x_msb_2 = x_l;

            ap_ufixed<wf-7,-7> x_lsb = x_l;

            const static ap_ufixed<Maxprecision,0> exp_x_msb_2_m_1_table[64] = {
                "0x0.0p0", "0x0.0202p0", "0x0.0408p0", "0x0.0612p0",
                "0x0.0820p0", "0x0.0A32p0", "0x0.0C49p0", "0x0.0E63p0",
                "0x0.1082p0", "0x0.12A5p0", "0x0.14CDp0", "0x0.16F9p0",
                "0x0.1929p0", "0x0.1B5Dp0", "0x0.1D96p0", "0x0.1FD4p0",
                "0x0.2216p0", "0x0.245Cp0", "0x0.26A7p0", "0x0.28F7p0",
                "0x0.2B4Bp0", "0x0.2DA4p0", "0x0.3001p0", "0x0.3264p0",
                "0x0.34CBp0", "0x0.3737p0", "0x0.39A8p0", "0x0.3C1Ep0",
                "0x0.3E98p0", "0x0.4118p0", "0x0.439Dp0", "0x0.4627p0",
                "0x0.48B5p0", "0x0.4B49p0", "0x0.4DE3p0", "0x0.5081p0",
                "0x0.5325p0", "0x0.55CEp0", "0x0.587Cp0", "0x0.5B2Fp0",
                "0x0.5DE9p0", "0x0.60A7p0", "0x0.636Bp0", "0x0.6635p0",
                "0x0.6904p0", "0x0.6BD9p0", "0x0.6EB3p0", "0x0.7194p0",
                "0x0.747Ap0", "0x0.7766p0", "0x0.7A57p0", "0x0.7D4Fp0",
                "0x0.804Dp0", "0x0.8350p0", "0x0.865Ap0", "0x0.896Ap0",
                "0x0.8C80p0", "0x0.8F9Cp0", "0x0.92BEp0", "0x0.95E7p0",
                "0x0.9916p0", "0x0.9C4Bp0", "0x0.9F87p0", "0x0.A2C9p0",
            };
_ssdm_SpecConstant(exp_x_msb_2_m_1_table);
# 1085 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"


            ap_ufixed<5,-8> f_x_msb_2_lsb = x_msb_2 * x_lsb;


            ap_ufixed<7,-6> f_x_msb_2_lsb_m_1_m=0;
            f_x_msb_2_lsb_m_1_m(5,0) = x_lsb(5,0);
            f_x_msb_2_lsb_m_1_m = f_x_msb_2_lsb_m_1_m + f_x_msb_2_lsb;


            ap_ufixed<Maxprecision+1,1> exp_x_msb_2_m_1 = exp_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<Maxprecision,1> exp_x_msb_2_lsb_m_1 = f_x_msb_2_lsb_m_1_m + exp_x_msb_2_m_1;


            const static ap_ufixed<Maxprecision,5> exp_x_msb_1_table[16] = {
                "0x1.0000p0", "0x1.A612p0", "0x2.B7E1p0", "0x4.7B4Fp0",
                "0x7.6399p0", "0xC.2EB7p0", "0x14.15E5p0", "0x21.1D8Ep0",
                "0x0.04B0p0", "0x0.07BBp0", "0x0.0CBEp0", "0x0.1503p0",
                "0x0.22A5p0", "0x0.391Fp0", "0x0.5E2Dp0", "0x0.9B45p0",

            };
_ssdm_SpecConstant(exp_x_msb_1_table);
# 1116 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<Maxprecision,5> exp_x_msb = exp_x_msb_1_table[x_msb_ind_1];

            ap_ufixed<2*Maxprecision+1,6> y_lo = exp_x_msb * exp_x_msb_2_lsb_m_1;
            ap_ufixed<Maxprecision,5> y_lo_s = y_lo;
            ap_ufixed<Maxprecision,5> y_l = y_lo_s + exp_x_msb;
            y = y_l;

        }
        y += delta;

            bool overf = 0;
#pragma unroll
 for (int j = 10; j >= I_+4; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
 for (int j = 10; j >= I_+4; j--)
                    y[j] = 0;
#pragma unroll
 for (int j = I_+3; j >= 0; j--)
                    y[j] = 1;
            }

        r = y;
    } else if (I_s_==4) {

        const static int wf = 25;
_ssdm_SpecConstant(&wf);
# 1151 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

        const static int we = 12;
_ssdm_SpecConstant(&we);
# 1152 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

        const static int w = 37;
_ssdm_SpecConstant(&w);
# 1153 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

        ap_fixed<w,we> x_l = x;
        ap_ufixed<23,12> y = 0;
        ap_fixed<4,4> x_l_int;
        x_l_int(3,0) = x_l(wf+3,wf);
        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);
        bool overf = 0;
#pragma unroll
 for (int j = wf+3; j < w-1; j++)
            if (x_l[w-1]!=x_l[j])
                overf = 1;
        if (overf||((x_l_int==7)&&(x_l_fract>ap_ufixed<wf,0>("0x0.9fe7038p0")))) {
            if (!x_l[w-1]) {
#pragma unroll
 for (int j = 0; j < 22; j++) y[j] = 1;
            }
        } else {
            const static int g = 2;
_ssdm_SpecConstant(&g);
# 1171 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            const static int Maxprecision = 25;
_ssdm_SpecConstant(&Maxprecision);
# 1172 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_uint<5> x_msb_ind_1;
            x_msb_ind_1[4] = x_l[w-1];
            x_msb_ind_1(3,0) = x_l(wf+2,wf-1);

            ap_uint<5> x_msb_ind_2;
            x_msb_ind_2(4,0) = x_l(wf-2,wf-6);
            ap_ufixed<5,-1> x_msb_2 = x_l;

            ap_uint<7> x_msb_ind_3;
            x_msb_ind_3(6,0) = x_l(wf-7,wf-13);
            ap_ufixed<7,-6> x_msb_3 = x_l;

            ap_ufixed<7,-13> x_lsb = x_l;

            const static ap_ufixed<12,-13> f_x_msb_3_m_1_table[128] = {
"0x0.0p0", "0x0.0000002p0", "0x0.0000008p0", "0x0.0000012p0",
"0x0.0000020p0", "0x0.0000032p0", "0x0.0000048p0", "0x0.0000062p0",
"0x0.0000080p0", "0x0.00000A2p0", "0x0.00000C8p0", "0x0.00000F2p0",
"0x0.0000120p0", "0x0.0000152p0", "0x0.0000188p0", "0x0.00001C2p0",
"0x0.0000200p0", "0x0.0000242p0", "0x0.0000288p0", "0x0.00002D2p0",
"0x0.0000320p0", "0x0.0000372p0", "0x0.00003C8p0", "0x0.0000422p0",
"0x0.0000481p0", "0x0.00004E3p0", "0x0.0000549p0", "0x0.00005B3p0",
"0x0.0000621p0", "0x0.0000693p0", "0x0.000070Ap0", "0x0.0000784p0",
"0x0.0000802p0", "0x0.0000884p0", "0x0.000090Bp0", "0x0.0000995p0",
"0x0.0000A23p0", "0x0.0000AB6p0", "0x0.0000B4Cp0", "0x0.0000BE6p0",
"0x0.0000C85p0", "0x0.0000D27p0", "0x0.0000DCEp0", "0x0.0000E78p0",
"0x0.0000F26p0", "0x0.0000FD9p0", "0x0.000108Fp0", "0x0.000114Ap0",
"0x0.0001209p0", "0x0.00012CBp0", "0x0.0001392p0", "0x0.000145Cp0",
"0x0.000152Bp0", "0x0.00015FEp0", "0x0.00016D4p0", "0x0.00017AFp0",
"0x0.000188Ep0", "0x0.0001971p0", "0x0.0001A57p0", "0x0.0001B42p0",
"0x0.0001C31p0", "0x0.0001D24p0", "0x0.0001E1Bp0", "0x0.0001F16p0",
"0x0.0002015p0", "0x0.0002118p0", "0x0.000221Fp0", "0x0.000232Ap0",
"0x0.0002439p0", "0x0.000254Cp0", "0x0.0002663p0", "0x0.000277Fp0",
"0x0.000289Ep0", "0x0.00029C1p0", "0x0.0002AE9p0", "0x0.0002C14p0",
"0x0.0002D43p0", "0x0.0002E77p0", "0x0.0002FAEp0", "0x0.00030EAp0",
"0x0.0003229p0", "0x0.000336Dp0", "0x0.00034B4p0", "0x0.0003600p0",
"0x0.0003750p0", "0x0.00038A4p0", "0x0.00039FBp0", "0x0.0003B57p0",
"0x0.0003CB7p0", "0x0.0003E1Bp0", "0x0.0003F83p0", "0x0.00040EFp0",
"0x0.000425Fp0", "0x0.00043D3p0", "0x0.000454Bp0", "0x0.00046C7p0",
"0x0.0004848p0", "0x0.00049CCp0", "0x0.0004B54p0", "0x0.0004CE1p0",
"0x0.0004E71p0", "0x0.0005006p0", "0x0.000519Ep0", "0x0.000533Bp0",
"0x0.00054DBp0", "0x0.0005680p0", "0x0.0005829p0", "0x0.00059D6p0",
"0x0.0005B86p0", "0x0.0005D3Bp0", "0x0.0005EF4p0", "0x0.00060B1p0",
"0x0.0006272p0", "0x0.0006437p0", "0x0.0006600p0", "0x0.00067CEp0",
"0x0.000699Fp0", "0x0.0006B74p0", "0x0.0006D4Ep0", "0x0.0006F2Bp0",
"0x0.000710Dp0", "0x0.00072F2p0", "0x0.00074DCp0", "0x0.00076CAp0",
"0x0.00078BBp0", "0x0.0007AB1p0", "0x0.0007CABp0", "0x0.0007EA9p0",
            };
_ssdm_SpecConstant(f_x_msb_3_m_1_table);
# 1187 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"


            ap_ufixed<6,-19> f_x_msb_3_lsb = x_msb_3 * x_lsb;


            ap_ufixed<12,-13> f_x_msb_3 = f_x_msb_3_m_1_table[x_msb_ind_3];

            ap_ufixed<13,-12> exp_x_msb_3_lsb_m_1_m = 0;
            exp_x_msb_3_lsb_m_1_m(11,0) = f_x_msb_3(11,0);
            exp_x_msb_3_lsb_m_1_m = exp_x_msb_3_lsb_m_1_m + f_x_msb_3_lsb;


            ap_ufixed<19,-6> x_msb_3_lsb = x_l;

            ap_ufixed<20,-5> exp_x_msb_3_lsb_m_1 = 0;
            exp_x_msb_3_lsb_m_1(18,0) = x_msb_3_lsb(18,0);
            exp_x_msb_3_lsb_m_1 = exp_x_msb_3_lsb_m_1+ exp_x_msb_3_lsb_m_1_m;


            const static ap_ufixed<25,0> exp_x_msb_2_m_1_table[32] = {
                "0x0.0000000p0", "0x0.04080a8p0", "0x0.0820560p0", "0x0.0c49238p0",
                "0x0.1082b58p0", "0x0.14cd500p0", "0x0.1929370p0", "0x0.1d96b10p0",
                "0x0.2216048p0", "0x0.26a7790p0", "0x0.2b4b588p0", "0x0.3001ed0p0",
                "0x0.34cb818p0", "0x0.39a8628p0", "0x0.3e98de8p0", "0x0.439d440p0",
                "0x0.48b5e40p0", "0x0.4de30f0p0", "0x0.5325180p0", "0x0.587c540p0",
                "0x0.5de9178p0", "0x0.636bb98p0", "0x0.6904930p0", "0x0.6eb3fc8p0",
                "0x0.747a510p0", "0x0.7a57ee0p0", "0x0.804d300p0", "0x0.865a778p0",
                "0x0.8c80248p0", "0x0.92be998p0", "0x0.99163b0p0", "0x0.9f876e8p0",
            };
_ssdm_SpecConstant(exp_x_msb_2_m_1_table);
# 1239 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<25, 0> exp_x_msb_2_m_1 = exp_x_msb_2_m_1_table[x_msb_ind_2];

            ap_ufixed<50,-5> f_x_msb_2_3_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_lsb_m_1;
            ap_ufixed<20,-5> f_x_msb_2_3_lsb_s = f_x_msb_2_3_lsb;
            ap_ufixed<25, 0> exp_x_msb_2_3_lsb_m_1 = f_x_msb_2_3_lsb_s + exp_x_msb_3_lsb_m_1 + exp_x_msb_2_m_1;


            const static ap_ufixed<25,11> exp_x_msb_1_table[32] = {
                "0x1.0000p0", "0x1.a614p0", "0x2.b7e0p0", "0x4.7b50p0",
                "0x7.6398p0", "0xc.2eb8p0", "0x14.15e4p0", "0x21.1d90p0",
                "0x36.9920p0", "0x5a.0464p0", "0x94.69c4p0", "0xf4.b124p0",
                "0x193.6dc4p0", "0x299.2444p0", "0x448.a218p0", "0x710.0adcp0",
                "0x0.0014p0", "0x0.0024p0", "0x0.003cp0", "0x0.0064p0",
                "0x0.00a4p0", "0x0.010cp0", "0x0.01b8p0", "0x0.02d8p0",
                "0x0.04b0p0", "0x0.07bcp0", "0x0.0cc0p0", "0x0.1504p0",
                "0x0.22a4p0", "0x0.3920p0", "0x0.5e2cp0", "0x0.9b44p0",
            };
_ssdm_SpecConstant(exp_x_msb_1_table);
# 1256 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<25,11> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];


            ap_ufixed<50,11> y_lo = exp_x_msb_1 * exp_x_msb_2_3_lsb_m_1;

            ap_ufixed<25,11> y_lo_s = y_lo;

            ap_ufixed<25,11> y_l = y_lo_s + exp_x_msb_1;

            y = y_l;

        }
        y += delta;

            overf = 0;
#pragma unroll
 for (int j = 22; j >= I_+10; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
 for (int j = 22; j >= I_+10; j--)
                    y[j] = 0;
#pragma unroll
 for (int j = I_+9; j >= 0; j--)
                    y[j] = 1;
            }

        r = y;
    } else if (I_s_==5) {

        if(WI_>73) return 0;
        const static int we = 24;
_ssdm_SpecConstant(&we);
# 1299 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

        const static int wf = 49;
_ssdm_SpecConstant(&wf);
# 1300 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

        const static int w = 73;
_ssdm_SpecConstant(&w);
# 1301 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

        ap_fixed<w,we> x_l = x;
        ap_ufixed<47,24> y = 0;
        ap_fixed<5,5> x_l_int;
        x_l_int(4,0) = x_l(wf+4,wf);
        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);
        bool overf = 0;
#pragma unroll
 for (int j = wf+4; j < w-1; j++)
            if (x_l[w-1]!=x_l[j])
                overf = 1;

        if (overf||((x_l_int==15)&&(x_l_fract>=ap_ufixed<wf,0>("0x0.F1402743D99F8p0")))) {
            if (!x_l[w-1]) {
#pragma unroll
 for (int j = 0; j < 46; j++) y[j] = 1;
            }
        } else {
            const static int g=4;
_ssdm_SpecConstant(&g);
# 1320 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            const static int Maxprecision = 51;
_ssdm_SpecConstant(&Maxprecision);
# 1321 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[w-1];
            x_msb_ind_1(6,0) = x_l(wf+3,wf-3);

            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(wf-4,wf-11);
            ap_uint<5> x_msb_ind_3;
            x_msb_ind_3(4,0) = x_l(wf-12,wf-16);
            ap_uint<3> x_msb_ind_4;
            x_msb_ind_4(2,0) = x_l(wf-17,wf-19);

            ap_uint<6> x_msb_ind_5;
            x_msb_ind_5(5,0) = x_l(wf-20,wf-25);

            ap_ufixed<8, -3> x_msb_2 = x_l;
            ap_ufixed<5,-11> x_msb_3 = x_l;
            ap_ufixed<3,-16> x_msb_4 = x_l;
            ap_ufixed<6,-19> x_msb_5 = x_l;

            ap_ufixed<7,-25> x_lsb = x_l;

            const static ap_ufixed<12,-39> f_x_msb_5_table[64] = {
"0x0.0000000000000p0", "0x0.0000000000002p0", "0x0.0000000000008p0", "0x0.0000000000012p0",
"0x0.0000000000020p0", "0x0.0000000000032p0", "0x0.0000000000048p0", "0x0.0000000000062p0",
"0x0.0000000000080p0", "0x0.00000000000A2p0", "0x0.00000000000C8p0", "0x0.00000000000F2p0",
"0x0.0000000000120p0", "0x0.0000000000152p0", "0x0.0000000000188p0", "0x0.00000000001C2p0",
"0x0.0000000000200p0", "0x0.0000000000242p0", "0x0.0000000000288p0", "0x0.00000000002D2p0",
"0x0.0000000000320p0", "0x0.0000000000372p0", "0x0.00000000003C8p0", "0x0.0000000000422p0",
"0x0.0000000000480p0", "0x0.00000000004E2p0", "0x0.0000000000548p0", "0x0.00000000005B2p0",
"0x0.0000000000620p0", "0x0.0000000000692p0", "0x0.0000000000708p0", "0x0.0000000000782p0",
"0x0.0000000000800p0", "0x0.0000000000882p0", "0x0.0000000000908p0", "0x0.0000000000992p0",
"0x0.0000000000A20p0", "0x0.0000000000AB2p0", "0x0.0000000000B48p0", "0x0.0000000000BE2p0",
"0x0.0000000000C80p0", "0x0.0000000000D22p0", "0x0.0000000000DC8p0", "0x0.0000000000E72p0",
"0x0.0000000000F20p0", "0x0.0000000000FD2p0", "0x0.0000000001088p0", "0x0.0000000001142p0",
"0x0.0000000001200p0", "0x0.00000000012C2p0", "0x0.0000000001388p0", "0x0.0000000001452p0",
"0x0.0000000001520p0", "0x0.00000000015F2p0", "0x0.00000000016C8p0", "0x0.00000000017A2p0",
"0x0.0000000001880p0", "0x0.0000000001962p0", "0x0.0000000001A48p0", "0x0.0000000001B32p0",
"0x0.0000000001C20p0", "0x0.0000000001D12p0", "0x0.0000000001E08p0", "0x0.0000000001F02p0",

            };
_ssdm_SpecConstant(f_x_msb_5_table);
# 1343 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<12,-39> f_x_msb_5 = f_x_msb_5_table[x_msb_ind_5];

            const static ap_ufixed<7,-33> f_x_msb_4_table[8] = {
"0x0.0000000000p0", "0x0.0000000002p0", "0x0.0000000008p0", "0x0.0000000012p0",
"0x0.0000000020p0", "0x0.0000000032p0", "0x0.0000000048p0", "0x0.0000000062p0",
            };
_ssdm_SpecConstant(f_x_msb_4_table);
# 1364 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<7,-33> f_x_msb_4 = f_x_msb_4_table[x_msb_ind_4];

            ap_ufixed<7,-44> f_x_msb_5_lsb = x_msb_5 * x_lsb;

            ap_ufixed<16,-19> x_msb_5_lsb = x_l;

            ap_ufixed<19,-35> f_x_msb_4_5_lsb = x_msb_5_lsb * x_msb_4;
            ap_ufixed<16,-35> f_x_msb_4_5_lsb_s = f_x_msb_4_5_lsb;

            ap_ufixed<13,-38> exp_x_msb_4_5_lsb_m_1_m3 = 0;
            exp_x_msb_4_5_lsb_m_1_m3(11,0)=f_x_msb_5(11,0);
            exp_x_msb_4_5_lsb_m_1_m3 = exp_x_msb_4_5_lsb_m_1_m3+f_x_msb_5_lsb;

            ap_ufixed<17,-34> exp_x_msb_4_5_lsb_m_1_m4 = 0;
            exp_x_msb_4_5_lsb_m_1_m4(15,0)=f_x_msb_4_5_lsb_s(15,0);
            exp_x_msb_4_5_lsb_m_1_m4 = exp_x_msb_4_5_lsb_m_1_m4 + f_x_msb_4_5_lsb_s;

            ap_ufixed<8,-32> exp_x_msb_4_5_lsb_m_1_m5_s = 0;
            exp_x_msb_4_5_lsb_m_1_m5_s(5,0)=exp_x_msb_4_5_lsb_m_1_m4(16,11);
            exp_x_msb_4_5_lsb_m_1_m5_s = f_x_msb_4+exp_x_msb_4_5_lsb_m_1_m5_s;

            ap_ufixed<19,-32> exp_x_msb_4_5_lsb_m_1_m5 = exp_x_msb_4_5_lsb_m_1_m5_s;
            exp_x_msb_4_5_lsb_m_1_m5(10,0)=exp_x_msb_4_5_lsb_m_1_m4(10,0);

            ap_ufixed<32,-15> exp_x_msb_4_5_lsb_m_1_m6 = 0;
            ap_ufixed<wf-16,-16> x_msb_4_5_lsb = x_l;
            exp_x_msb_4_5_lsb_m_1_m6(14,0) = exp_x_msb_4_5_lsb_m_1_m5(18,4);
            exp_x_msb_4_5_lsb_m_1_m6 = exp_x_msb_4_5_lsb_m_1_m6 + x_msb_4_5_lsb;
            ap_ufixed<36,-15> exp_x_msb_4_5_lsb_m_1 = exp_x_msb_4_5_lsb_m_1_m6;
            exp_x_msb_4_5_lsb_m_1(3,0) = exp_x_msb_4_5_lsb_m_1_m5(3,0);


            const static ap_ufixed<32,-23> f_x_msb_3_table[32] = {
"0x0.00000000000000p0", "0x0.0000000080002ap0", "0x0.00000002000156p0", "0x0.00000004800480p0",
"0x0.00000008000aaap0", "0x0.0000000c8014d6p0", "0x0.00000012002400p0", "0x0.0000001880392cp0",
"0x0.00000020005556p0", "0x0.00000028807982p0", "0x0.0000003200a6acp0", "0x0.0000003c80ddd8p0",
"0x0.00000048012004p0", "0x0.00000054816e30p0", "0x0.0000006201c95cp0", "0x0.00000070823288p0",
"0x0.0000008002aab6p0", "0x0.000000908332e2p0", "0x0.000000a203cc12p0", "0x0.000000b4847740p0",
"0x0.000000c8053570p0", "0x0.000000dc8607a0p0", "0x0.000000f206eed0p0", "0x0.0000010887ec02p0",
"0x0.00000120090036p0", "0x0.000001388a2c6ap0", "0x0.000001520b71a0p0", "0x0.0000016c8cd0d6p0",
"0x0.000001880e4b0ep0", "0x0.000001a48fe148p0", "0x0.000001c2119484p0", "0x0.000001e09365c0p0",
            };
_ssdm_SpecConstant(f_x_msb_3_table);
# 1400 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"


            ap_ufixed<32,-23> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<44,-11> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(43,39) = x_msb_3(4,0);
            exp_x_msb_3_m_1(31, 0) = f_x_msb_3(31,0);


            ap_ufixed<80,-26> f_x_msb_3_4_lsb = exp_x_msb_3_m_1 * exp_x_msb_4_5_lsb_m_1;
            ap_ufixed<31,-26> f_x_msb_3_4_lsb_s = f_x_msb_3_4_lsb;
            ap_ufixed<48,-10> exp_x_msb_3_4_lsb_m_1 = f_x_msb_3_4_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_5_lsb_m_1;


            const static ap_ufixed<46,-6> f_x_msb_2_table[256] = {
"0x0.0p0", "0x0.0000020015560p0", "0x0.00000800AAB55p0", "0x0.0000120240360p0",
"0x0.0000200556001p0", "0x0.0000320A6C4B8p0", "0x0.0000481203608p0", "0x0.0000621C9B971p0",
"0x0.0000802AB5577p0", "0x0.0000A23CD119Dp0", "0x0.0000C8536F668p0", "0x0.0000F26F10D5Dp0",
"0x0.0001209036103p0", "0x0.000152B75FCE3p0", "0x0.000188E50ED86p0", "0x0.0001C319C4077p0",
"0x0.0002015600445p0", "0x0.0002439A4487Ep0", "0x0.000289E711DB3p0", "0x0.0002D43CE9577p0",
"0x0.0003229C4C260p0", "0x0.00037505BB805p0", "0x0.0003CB79B8B01p0", "0x0.000425F8C50F2p0",
"0x0.0004848362076p0", "0x0.0004E71A11131p0", "0x0.00054DBD53BC8p0", "0x0.0005B86DAB9E3p0",
"0x0.0006272B9A630p0", "0x0.000699F7A1C5Dp0", "0x0.000710D24391Ep0", "0x0.00078BBC01A29p0",
"0x0.00080AB55DE39p0", "0x0.00088DBEDA50Bp0", "0x0.000914D8F8F63p0", "0x0.0009A0043BF07p0",
"0x0.000A2F41256C2p0", "0x0.000AC29037A63p0", "0x0.000B59F1F4EBDp0", "0x0.000BF566DF9AAp0",
"0x0.000C94EF7A206p0", "0x0.000D388C46FB4p0", "0x0.000DE03DC8B9Bp0", "0x0.000E8C0481FA7p0",
"0x0.000F3BE0F56CAp0", "0x0.000FEFD3A5CFAp0", "0x0.0010A7DD15F36p0", "0x0.001163FDC8B7Fp0",
"0x0.00122436410DDp0", "0x0.0012E88701F5Ep0", "0x0.0013B0F08E817p0", "0x0.00147D7369D22p0",
"0x0.00154E101719Fp0", "0x0.001622C7199B7p0", "0x0.0016FB98F4A96p0", "0x0.0017D8862BA72p0",
"0x0.0018B98F42084p0", "0x0.00199EB4BB511p0", "0x0.001A87F71B161p0", "0x0.001B7556E4FC4p0",
"0x0.001C66D49CB93p0", "0x0.001D5C70C612Dp0", "0x0.001E562BE4DFAp0", "0x0.001F54067D067p0",
"0x0.00205601127ECp0", "0x0.00215C1C29507p0", "0x0.0022665845940p0", "0x0.002374B5EB724p0",
"0x0.002487359F24Cp0", "0x0.00259DD7E4F57p0", "0x0.0026B89D413EFp0", "0x0.0027D786386C4p0",
"0x0.0028FA934EF90p0", "0x0.002A21C509717p0", "0x0.002B4D1BEC726p0", "0x0.002C7C987CA92p0",
"0x0.002DB03B3ED3Ap0", "0x0.002EE804B7C07p0", "0x0.003023F56C4ECp0", "0x0.0031640DE16E3p0",
"0x0.0032A84E9C1F5p0", "0x0.0033F0B821730p0", "0x0.00353D4AF68B0p0", "0x0.00368E07A0999p0",
"0x0.0037E2EEA4E19p0", "0x0.00393C0088B6Cp0", "0x0.003A993DD17D5p0", "0x0.003BFAA704AA3p0",
"0x0.003D603CA7C32p0", "0x0.003EC9FF405E6p0", "0x0.004037EF54230p0", "0x0.0041AA0D68C8Cp0",
"0x0.0043205A04182p0", "0x0.00449AD5ABEA5p0", "0x0.00461980E6294p0", "0x0.00479C5C38CF9p0",
"0x0.0049236829E8Bp0", "0x0.004AAEA53F90Ep0", "0x0.004C3E13FFF51p0", "0x0.004DD1B4F152Fp0",
"0x0.004F698899F90p0", "0x0.0051058F8046Ap0", "0x0.0052A5CA2AABFp0", "0x0.00544A391FA9Cp0",
"0x0.0055F2DCE5D1Ep0", "0x0.00579FB603C6Ep0", "0x0.005950C5003C2p0", "0x0.005B060A61F5Dp0",
"0x0.005CBF86AFC91p0", "0x0.005E7D3A709BEp0", "0x0.00603F262B650p0", "0x0.0062054A672C2p0",
"0x0.0063CFA7AB09Dp0", "0x0.00659E3E7E278p0", "0x0.0067710F67BFAp0", "0x0.0069481AEF1D5p0",
"0x0.006B23619B9CFp0", "0x0.006D02E3F4AB7p0", "0x0.006EE6A281C6Fp0", "0x0.0070CE9DCA7E6p0",
"0x0.0072BAD65671Bp0", "0x0.0074AB4CAD51Cp0", "0x0.0076A00156E07p0", "0x0.007898F4DAF09p0",
"0x0.007A9627C165Fp0", "0x0.007C979A92356p0", "0x0.007E9D4DD564Ap0", "0x0.0080A742130A8p0",
"0x0.0082B577D34EDp0", "0x0.0084C7EF9E6A7p0", "0x0.0086DEA9FCA73p0", "0x0.0088F9A776601p0",
"0x0.008B18E894010p0", "0x0.008D3C6DDE06Fp0", "0x0.008F6437DD000p0", "0x0.00919047198B6p0",
"0x0.0093C09C1C595p0", "0x0.0095F5376E2B2p0", "0x0.00982E1997D33p0", "0x0.009A6B4322352p0",
"0x0.009CACB496458p0", "0x0.009EF26E7D0A2p0", "0x0.00A13C715F99Ep0", "0x0.00A38ABDC71CEp0",
"0x0.00A5DD543CCC4p0", "0x0.00A8343549F26p0", "0x0.00AA8F6177EADp0", "0x0.00ACEED950222p0",
"0x0.00AF529D5C165p0", "0x0.00B1BAAE25566p0", "0x0.00B4270C3582Ap0", "0x0.00B697B8164C7p0",
"0x0.00B90CB25176Ap0", "0x0.00BB85FB70D50p0", "0x0.00BE0393FE4CCp0", "0x0.00C0857C83D44p0",
"0x0.00C30BB58B732p0", "0x0.00C5963F9F424p0", "0x0.00C8251B496BEp0", "0x0.00CAB849142B5p0",
"0x0.00CD4FC989CD6p0", "0x0.00CFEB9D34B00p0", "0x0.00D28BC49F428p0", "0x0.00D5304054059p0",
"0x0.00D7D910DD8B1p0", "0x0.00DA8636C6764p0", "0x0.00DD37B2997BCp0", "0x0.00DFED84E1618p0",
"0x0.00E2A7AE28FECp0", "0x0.00E5662EFB3C3p0", "0x0.00E82907E313Dp0", "0x0.00EAF0396B910p0",
"0x0.00EDBBC41FD08p0", "0x0.00F08BA88B009p0", "0x0.00F35FE73860Bp0", "0x0.00F63880B341Ep0",
"0x0.00F9157587069p0", "0x0.00FBF6C63F228p0", "0x0.00FEDC73671B0p0", "0x0.0101C67D8A86Cp0",
"0x0.0104B4E5350DFp0", "0x0.0107A7AAF26A2p0", "0x0.010A9ECF4E667p0", "0x0.010D9A52D4DF8p0",
"0x0.01109A3611C34p0", "0x0.01139E7991116p0", "0x0.0116A71DDEDADp0", "0x0.0119B42387423p0",
"0x0.011CC58B167B9p0", "0x0.011FDB5518CCAp0", "0x0.0122F5821A8C7p0", "0x0.01261412A823Cp0",
"0x0.012937074E0CDp0", "0x0.012C5E6098D37p0", "0x0.012F8A1F15151p0", "0x0.0132BA434F80Ap0",
"0x0.0135EECDD4D6Cp0", "0x0.013927BF31E98p0", "0x0.013C6517F39CCp0", "0x0.013FA6D8A6E5Dp0",
"0x0.0142ED01D8CBCp0", "0x0.0146379416673p0", "0x0.0149868FECE26p0", "0x0.014CD9F5E9795p0",
"0x0.015031C699799p0", "0x0.01538E028A426p0", "0x0.0156EEAA4944Bp0", "0x0.015A53BE64033p0",
"0x0.015DBD3F68122p0", "0x0.01612B2DE3178p0", "0x0.01649D8A62CB1p0", "0x0.0168145574F65p0",
"0x0.016B8F8FA7745p0", "0x0.016F0F3988321p0", "0x0.01729353A52E4p0", "0x0.01761BDE8C792p0",
"0x0.0179A8DACC350p0", "0x0.017D3A48F295Dp0", "0x0.0180D0298DE13p0", "0x0.01846A7D2C6ECp0",
"0x0.018809445CA7Bp0", "0x0.018BAC7FAD074p0", "0x0.018F542FAC1A4p0", "0x0.01930054E87F8p0",
"0x0.0196B0EFF0E79p0", "0x0.019A66015414Dp0", "0x0.019E1F89A0DBAp0", "0x0.01A1DD8966221p0",
"0x0.01A5A00132E02p0", "0x0.01A966F1961FCp0", "0x0.01AD325B1EFC9p0", "0x0.01B1023E5CA45p0",
"0x0.01B4D69BDE569p0", "0x0.01B8AF743364Cp0", "0x0.01BC8CC7EB323p0", "0x0.01C06E9795345p0",
"0x0.01C454E3C0F24p0", "0x0.01C83FACFE054p0", "0x0.01CC2EF3DC187p0", "0x0.01D022B8EAE8Fp0",
"0x0.01D41AFCBA45Ep0", "0x0.01D817BFDA104p0", "0x0.01DC1902DA3B1p0", "0x0.01E01EC64ACB7p0",
"0x0.01E4290ABBD87p0", "0x0.01E837D0BD8B2p0", "0x0.01EC4B18E01E9p0", "0x0.01F062E3B3DFEp0",
"0x0.01F47F31C92E4p0", "0x0.01F8A003B07AFp0", "0x0.01FCC559FA492p0", "0x0.0200EF35372E4p0",
"0x0.02051D95F7D1Cp0", "0x0.0209507CCCED1p0", "0x0.020D87EA474BEp0", "0x0.0211C3DEF7CBDp0",
            };
_ssdm_SpecConstant(f_x_msb_2_table);
# 1422 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<46,-6> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 5,-6> f_x_msb_2_h;
            f_x_msb_2_h(4,0) = f_x_msb_2(45,41);
            ap_ufixed< 9,-2> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<50,-2> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(49,41) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(40, 0) = f_x_msb_2(40,0);

            ap_ufixed<98,-12> f_x_msb_2_3_4_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_lsb_m_1;
            ap_ufixed<46,-12> f_x_msb_2_3_4_lsb_s = f_x_msb_2_3_4_lsb;
            ap_ufixed<50,-2> exp_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_3_4_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<50,23> exp_x_msb_1_table[256] = {
"0x1.0000000p0", "0x1.2216045p0", "0x1.48B5E3Cp0", "0x1.747A513p0",
"0x1.A61298Ep0", "0x1.DE455DFp0", "0x2.1DF3B68p0", "0x2.661CB0Fp0",
"0x2.B7E1516p0", "0x3.1489176p0", "0x3.7D871DBp0", "0x3.F47FE87p0",
"0x4.7B4FF99p0", "0x5.1413452p0", "0x5.C12DA41p0", "0x6.855466Ep0",
"0x7.63992E3p0", "0x8.5F7635Bp0", "0x9.7CDC417p0", "0xA.C042667p0",
"0xC.2EB7EC9p0", "0xD.CDF892Ep0", "0xF.A48385Ep0", "0x11.B9B5652p0",
"0x14.15E5BF6p0", "0x16.C2887C1p0", "0x19.CA53B78p0", "0x1D.396AA97p0",
"0x21.1D8E427p0", "0x25.865441Cp0", "0x2A.8565A14p0", "0x30.2EC550Bp0",
"0x36.99205C4p0", "0x3D.DE28BF3p0", "0x46.1AFC4DBp0", "0x4F.7099532p0",
"0x5A.0462B78p0", "0x66.00B5BC9p0", "0x73.9593ABBp0", "0x82.F9621ADp0",
"0x94.69C4CB8p0", "0xA8.2C948C1p0", "0xBE.90F6F83p0", "0xD7.F09B78Cp0",
"0xF4.B122790p0", "0x115.45B4704p0", "0x13A.30CF1CCp0", "0x164.0650296p0",
"0x193.6DC5690p0", "0x1C9.250BEDCp0", "0x206.03487A3p0", "0x24A.FC4533Cp0",
"0x299.2442102p0", "0x2F1.B447462p0", "0x356.0F0B0F9p0", "0x3C7.C67E5BEp0",
"0x448.A216ABBp0", "0x4DA.A5EE46Ap0", "0x580.1AD754Fp0", "0x63B.9782341p0",
"0x710.0ADBAC7p0", "0x800.C7CC8E3p0", "0x911.9289C39p0", "0xA46.AFAA2ADp0",
"0xBA4.F53EA38p0", "0xD31.DE30C52p0", "0xEF3.A035D57p0", "0x10F1.44ADE60p0",
"0x1332.C4D2B7Cp0", "0x15C1.29A744Cp0", "0x18A6.B027DA0p0", "0x1BEE.F24BB12p0",
"0x1FA7.157C470p0", "0x23DD.FF3C8BAp0", "0x28A4.90D2CCEp0", "0x2E0D.EAE454Bp0",
"0x342F.BA11823p0", "0x3B22.8DC5359p0", "0x4302.3A933EEp0", "0x4BEE.49AFCDCp0",
"0x560A.773E541p0", "0x617F.4171BF9p0", "0x6E7A.8ABB4A8p0", "0x7D30.5191764p0",
"0x8DDB.80AF426p0", "0xA0BE.DB0DB10p0", "0xB626.0748BAEp0", "0xCE66.BE9EAADp0",
"0xE9E2.2447727p0", "0x10906.4A831F8p0", "0x12C4F.EB75B2Ap0", "0x1544C.5CB6133p0",
"0x1819B.C560F61p0", "0x1B4F3.9F8AF64p0", "0x1EF21.8F1B001p0", "0x2310E.996C40Fp0",
"0x27BC2.CA9A6F9p0", "0x2D069.571279Ap0", "0x33055.49F35D9p0", "0x39D06.D2FEF17p0",
"0x41831.49596E9p0", "0x4A3C1.FB2AC39p0", "0x541E7.E56949Dp0", "0x5F51C.72B7532p0",
"0x6C02D.645AB25p0", "0x7A648.0CFF534p0", "0x8AB06.0A3EE9Fp0", "0x9D27B.AFE4CF1p0",
"0xB2148.5EAE56Cp0", "0xC9CA9.07F86EFp0", "0xE4A8D.2881EDBp0", "0x1031AE.8E4996Cp0",
"0x1259AC.48BF05Dp0", "0x14CB29.2F2B31Fp0", "0x178FEE.7792E44p0", "0x1AB312.E89CD0Dp0",
"0x1E4127.437732Bp0", "0x224868.979FC2Ep0", "0x26D8F9.4A204BEp0", "0x2C0521.B4A8E0Bp0",
"0x31E199.5F5A550p0", "0x3885D9.FA89D00p0", "0x400C7D.64D3386p0", "0x4893A8.361032Dp0",
"0x523D82.79EDAEFp0", "0x5D30C0.7DAB686p0", "0x69993D.D4F2D95p0", "0x77A8AD.02A7C71p0",
"0x0.000001Ep0", "0x0.0000022p0", "0x0.0000026p0", "0x0.000002Bp0",
"0x0.0000031p0", "0x0.0000038p0", "0x0.000003Fp0", "0x0.0000048p0",
"0x0.0000052p0", "0x0.000005Dp0", "0x0.0000069p0", "0x0.0000077p0",
"0x0.0000087p0", "0x0.0000099p0", "0x0.00000ADp0", "0x0.00000C4p0",
"0x0.00000DFp0", "0x0.00000FCp0", "0x0.000011Ep0", "0x0.0000144p0",
"0x0.0000170p0", "0x0.00001A1p0", "0x0.00001D8p0", "0x0.0000217p0",
"0x0.000025Ep0", "0x0.00002AFp0", "0x0.000030Bp0", "0x0.0000372p0",
"0x0.00003E8p0", "0x0.000046Dp0", "0x0.0000504p0", "0x0.00005AFp0",
"0x0.0000671p0", "0x0.000074Cp0", "0x0.0000845p0", "0x0.000095Fp0",
"0x0.0000A9Fp0", "0x0.0000C09p0", "0x0.0000DA3p0", "0x0.0000F74p0",
"0x0.0001183p0", "0x0.00013D8p0", "0x0.000167Cp0", "0x0.000197Bp0",
"0x0.0001CDFp0", "0x0.00020B7p0", "0x0.0002513p0", "0x0.0002A02p0",
"0x0.0002F9Ap0", "0x0.00035F1p0", "0x0.0003D20p0", "0x0.0004543p0",
"0x0.0004E7Cp0", "0x0.00058F0p0", "0x0.00064C7p0", "0x0.0007232p0",
"0x0.0008167p0", "0x0.00092A2p0", "0x0.000A628p0", "0x0.000BC48p0",
"0x0.000D55Ap0", "0x0.000F1C2p0", "0x0.00111F3p0", "0x0.001366Cp0",
"0x0.0015FC2p0", "0x0.0018E98p0", "0x0.001C3AAp0", "0x0.001FFCEp0",
"0x0.00243F3p0", "0x0.002912Bp0", "0x0.002E8ABp0", "0x0.0034BD2p0",
"0x0.003BC2Dp0", "0x0.0043B7Dp0", "0x0.004CBC1p0", "0x0.0056F3Ap0",
"0x0.0062878p0", "0x0.006FA5Fp0", "0x0.007E83Ap0", "0x0.008F5C0p0",
"0x0.00A2728p0", "0x0.00B813Bp0", "0x0.00D0963p0", "0x0.00EC5C1p0",
"0x0.010BD4Ap0", "0x0.012F7DEp0", "0x0.0157E6Bp0", "0x0.0185B0Fp0",
"0x0.01B993Fp0", "0x0.01F45F9p0", "0x0.0236FF5p0", "0x0.02827E0p0",
"0x0.02D80A0p0", "0x0.0338F9Fp0", "0x0.03A6D22p0", "0x0.04234A7p0",
"0x0.04B0556p0", "0x0.0550280p0", "0x0.0605424p0", "0x0.06D279Ap0",
"0x0.07BB040p0", "0x0.08C284Cp0", "0x0.09ED1B4p0", "0x0.0B3F736p0",
"0x0.0CBED86p0", "0x0.0E7149Cp0", "0x0.105D938p0", "0x0.128B697p0",
"0x0.150385Cp0", "0x0.17CFCC2p0", "0x0.1AFB718p0", "0x0.1E9328Bp0",
"0x0.22A5554p0", "0x0.2742456p0", "0x0.2C7C72Fp0", "0x0.3268CDBp0",
"0x0.391F0EEp0", "0x0.40BA188p0", "0x0.495860Dp0", "0x0.531C6C9p0",
"0x0.5E2D58Dp0", "0x0.6AB7782p0", "0x0.78ED03Ap0", "0x0.8906E49p0",
"0x0.9B4597Ep0", "0x0.AFF230Ap0", "0x0.C75F7CFp0", "0x0.E1EB512p0",
            };
_ssdm_SpecConstant(exp_x_msb_1_table);
# 1500 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<50,23> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];

            ap_ufixed<100,21> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<48,21> y_lo_s = y_lo;
            ap_ufixed<50,23> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        y += delta;

            overf = 0;
#pragma unroll
 for (int j = 46; j >= I_+22; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
 for (int j = 46; j >= I_+22; j--)
                    y[j] = 0;
#pragma unroll
 for (int j = I_+21; j >= 0; j--)
                    y[j] = 1;
            }

        r = y;
    } else {
        const static int wf = 67;
_ssdm_SpecConstant(&wf);
# 1592 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

        const static int we = 33;
_ssdm_SpecConstant(&we);
# 1593 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

        const static int w = 100;
_ssdm_SpecConstant(&w);
# 1594 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

        ap_fixed<w,we> x_l = x;


        ap_ufixed<65,33> y = 0;

        ap_fixed<6,6> x_l_int;
        x_l_int(5,0) = x_l(wf+5,wf);


        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);

        bool overf = 0;
#pragma unroll
 for (int j = wf+5; j < w-1; j++)
            if (x_l[w-1]!=x_l[j])
                overf = 1;
        if (overf||(x_l_int>22)||((x_l_int==22)&&(x_l_fract>=ap_ufixed<wf,0>("0x0.2E42FEFA39EF35783p0")))) {
            if (!x_l[w-1]) {
#pragma unroll
 for (int j = 0; j < 64; j++) y[j] = 1;
            }
        } else {
            const static int g=4;
_ssdm_SpecConstant(&g);
# 1618 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            const static int Maxprecision=69;
_ssdm_SpecConstant(&Maxprecision);
# 1619 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[w-1];

            x_msb_ind_1(6,0) = x_l(wf+4,wf-2);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(wf-3,wf-10);
            ap_uint<8> x_msb_ind_3;
            x_msb_ind_3(7,0) = x_l(wf-11,wf-18);
            ap_uint<8> x_msb_ind_4;
            x_msb_ind_4(7,0) = x_l(wf-19,wf-26);

            ap_uint<8> x_msb_ind_5;
            x_msb_ind_5(7,0) = x_l(wf-27,wf-34);

            ap_ufixed<8, -2> x_msb_2 = x_l;
            ap_ufixed<8,-10> x_msb_3 = x_l;
            ap_ufixed<8,-18> x_msb_4 = x_l;
            ap_ufixed<8,-26> x_msb_5 = x_l;
            ap_ufixed<9,-34> x_lsb = x_l;

            const static ap_ufixed<32,-37> f_x_msb_4_table[256] = {
"0x0.000000000000000000p0", "0x0.000000000000080000p0", "0x0.000000000000200000p0", "0x0.000000000000480000p0",
"0x0.000000000000800000p0", "0x0.000000000000C80000p0", "0x0.000000000001200000p0", "0x0.000000000001880000p0",
"0x0.000000000002000001p0", "0x0.000000000002880001p0", "0x0.000000000003200002p0", "0x0.000000000003C80003p0",
"0x0.000000000004800004p0", "0x0.000000000005480005p0", "0x0.000000000006200007p0", "0x0.000000000007080008p0",
"0x0.00000000000800000Ap0", "0x0.00000000000908000Cp0", "0x0.00000000000A20000Fp0", "0x0.00000000000B480011p0",
"0x0.00000000000C800014p0", "0x0.00000000000DC80018p0", "0x0.00000000000F20001Bp0", "0x0.00000000001088001Fp0",
"0x0.000000000012000024p0", "0x0.000000000013880028p0", "0x0.00000000001520002Dp0", "0x0.000000000016C80033p0",
"0x0.000000000018800039p0", "0x0.00000000001A48003Fp0", "0x0.00000000001C200046p0", "0x0.00000000001E08004Dp0",
"0x0.000000000020000055p0", "0x0.00000000002208005Dp0", "0x0.000000000024200066p0", "0x0.00000000002648006Fp0",
"0x0.000000000028800079p0", "0x0.00000000002AC80083p0", "0x0.00000000002D20008Ep0", "0x0.00000000002F88009Ap0",
"0x0.0000000000320000A6p0", "0x0.0000000000348800B3p0", "0x0.0000000000372000C0p0", "0x0.000000000039C800CFp0",
"0x0.00000000003C8000DDp0", "0x0.00000000003F4800EDp0", "0x0.0000000000422000FDp0", "0x0.00000000004508010Ep0",
"0x0.000000000048000120p0", "0x0.00000000004B080132p0", "0x0.00000000004E200145p0", "0x0.000000000051480159p0",
"0x0.00000000005480016Ep0", "0x0.000000000057C80183p0", "0x0.00000000005B20019Ap0", "0x0.00000000005E8801B1p0",
"0x0.0000000000620001C9p0", "0x0.0000000000658801E2p0", "0x0.0000000000692001FCp0", "0x0.00000000006CC80216p0",
"0x0.000000000070800232p0", "0x0.00000000007448024Fp0", "0x0.00000000007820026Cp0", "0x0.00000000007C08028Bp0",
"0x0.0000000000800002AAp0", "0x0.0000000000840802CBp0", "0x0.0000000000882002ECp0", "0x0.00000000008C48030Fp0",
"0x0.000000000090800332p0", "0x0.000000000094C80357p0", "0x0.00000000009920037Dp0", "0x0.00000000009D8803A4p0",
"0x0.0000000000A20003CCp0", "0x0.0000000000A68803F5p0", "0x0.0000000000AB20041Fp0", "0x0.0000000000AFC8044Ap0",
"0x0.0000000000B4800477p0", "0x0.0000000000B94804A4p0", "0x0.0000000000BE2004D3p0", "0x0.0000000000C3080503p0",
"0x0.0000000000C8000535p0", "0x0.0000000000CD080567p0", "0x0.0000000000D220059Bp0", "0x0.0000000000D74805D1p0",
"0x0.0000000000DC800607p0", "0x0.0000000000E1C8063Fp0", "0x0.0000000000E7200678p0", "0x0.0000000000EC8806B2p0",
"0x0.0000000000F20006EEp0", "0x0.0000000000F788072Bp0", "0x0.0000000000FD20076Ap0", "0x0.000000000102C807AAp0",
"0x0.0000000001088007EBp0", "0x0.00000000010E48082Ep0", "0x0.000000000114200872p0", "0x0.00000000011A0808B8p0",
"0x0.000000000120000900p0", "0x0.000000000126080948p0", "0x0.00000000012C200993p0", "0x0.0000000001324809DEp0",
"0x0.000000000138800A2Cp0", "0x0.00000000013EC80A7Bp0", "0x0.000000000145200ACBp0", "0x0.00000000014B880B1Dp0",
"0x0.000000000152000B71p0", "0x0.000000000158880BC6p0", "0x0.00000000015F200C1Dp0", "0x0.000000000165C80C76p0",
"0x0.00000000016C800CD0p0", "0x0.000000000173480D2Cp0", "0x0.00000000017A200D8Ap0", "0x0.000000000181080DE9p0",
"0x0.000000000188000E4Ap0", "0x0.00000000018F080EADp0", "0x0.000000000196200F12p0", "0x0.00000000019D480F78p0",
"0x0.0000000001A4800FE0p0", "0x0.0000000001ABC8104Ap0", "0x0.0000000001B32010B6p0", "0x0.0000000001BA881124p0",
"0x0.0000000001C2001194p0", "0x0.0000000001C9881205p0", "0x0.0000000001D1201278p0", "0x0.0000000001D8C812EEp0",
"0x0.0000000001E0801365p0", "0x0.0000000001E84813DEp0", "0x0.0000000001F0201459p0", "0x0.0000000001F80814D6p0",
"0x0.000000000200001555p0", "0x0.0000000002080815D6p0", "0x0.000000000210201659p0", "0x0.0000000002184816DEp0",
"0x0.000000000220801765p0", "0x0.000000000228C817EEp0", "0x0.000000000231201879p0", "0x0.000000000239881907p0",
"0x0.000000000242001996p0", "0x0.00000000024A881A28p0", "0x0.000000000253201ABBp0", "0x0.00000000025BC81B51p0",
"0x0.000000000264801BE9p0", "0x0.00000000026D481C84p0", "0x0.000000000276201D20p0", "0x0.00000000027F081DBFp0",
"0x0.000000000288001E60p0", "0x0.000000000291081F03p0", "0x0.00000000029A201FA8p0", "0x0.0000000002A3482050p0",
"0x0.0000000002AC8020FAp0", "0x0.0000000002B5C821A6p0", "0x0.0000000002BF202255p0", "0x0.0000000002C8882306p0",
"0x0.0000000002D20023B9p0", "0x0.0000000002DB88246Fp0", "0x0.0000000002E5202527p0", "0x0.0000000002EEC825E1p0",
"0x0.0000000002F880269Ep0", "0x0.00000000030248275Dp0", "0x0.00000000030C20281Fp0", "0x0.0000000003160828E3p0",
"0x0.0000000003200029AAp0", "0x0.00000000032A082A73p0", "0x0.000000000334202B3Fp0", "0x0.00000000033E482C0Dp0",
"0x0.000000000348802CDEp0", "0x0.000000000352C82DB2p0", "0x0.00000000035D202E88p0", "0x0.000000000367882F60p0",
"0x0.00000000037200303Cp0", "0x0.00000000037C883119p0", "0x0.0000000003872031FAp0", "0x0.000000000391C832DDp0",
"0x0.00000000039C8033C3p0", "0x0.0000000003A74834ABp0", "0x0.0000000003B2203596p0", "0x0.0000000003BD083684p0",
"0x0.0000000003C8003775p0", "0x0.0000000003D3083868p0", "0x0.0000000003DE20395Ep0", "0x0.0000000003E9483A57p0",
"0x0.0000000003F4803B53p0", "0x0.0000000003FFC83C52p0", "0x0.00000000040B203D53p0", "0x0.000000000416883E57p0",
"0x0.000000000422003F5Ep0", "0x0.00000000042D884068p0", "0x0.000000000439204175p0", "0x0.000000000444C84285p0",
"0x0.000000000450804397p0", "0x0.00000000045C4844ADp0", "0x0.0000000004682045C5p0", "0x0.0000000004740846E1p0",
"0x0.000000000480004800p0", "0x0.00000000048C084921p0", "0x0.000000000498204A46p0", "0x0.0000000004A4484B6Dp0",
"0x0.0000000004B0804C98p0", "0x0.0000000004BCC84DC5p0", "0x0.0000000004C9204EF6p0", "0x0.0000000004D588502Ap0",
"0x0.0000000004E2005161p0", "0x0.0000000004EE88529Bp0", "0x0.0000000004FB2053D8p0", "0x0.000000000507C85518p0",
"0x0.00000000051480565Cp0", "0x0.0000000005214857A3p0", "0x0.00000000052E2058EDp0", "0x0.00000000053B085A3Ap0",
"0x0.000000000548005B8Ap0", "0x0.000000000555085CDEp0", "0x0.000000000562205E35p0", "0x0.00000000056F485F8Fp0",
"0x0.00000000057C8060ECp0", "0x0.000000000589C8624Dp0", "0x0.0000000005972063B1p0", "0x0.0000000005A4886519p0",
"0x0.0000000005B2006684p0", "0x0.0000000005BF8867F2p0", "0x0.0000000005CD206963p0", "0x0.0000000005DAC86AD8p0",
"0x0.0000000005E8806C51p0", "0x0.0000000005F6486DCDp0", "0x0.000000000604206F4Cp0", "0x0.0000000006120870CFp0",
"0x0.000000000620007255p0", "0x0.00000000062E0873DFp0", "0x0.00000000063C20756Cp0", "0x0.00000000064A4876FDp0",
"0x0.000000000658807891p0", "0x0.000000000666C87A29p0", "0x0.000000000675207BC4p0", "0x0.000000000683887D64p0",
"0x0.000000000692007F06p0", "0x0.0000000006A08880ADp0", "0x0.0000000006AF208256p0", "0x0.0000000006BDC88404p0",
"0x0.0000000006CC8085B5p0", "0x0.0000000006DB48876Ap0", "0x0.0000000006EA208923p0", "0x0.0000000006F9088ADFp0",
"0x0.000000000708008CA0p0", "0x0.000000000717088E63p0", "0x0.00000000072620902Bp0", "0x0.0000000007354891F6p0",
"0x0.0000000007448093C6p0", "0x0.000000000753C89599p0", "0x0.000000000763209770p0", "0x0.00000000077288994Ap0",
"0x0.000000000782009B29p0", "0x0.000000000791889D0Bp0", "0x0.0000000007A1209EF2p0", "0x0.0000000007B0C8A0DCp0",
"0x0.0000000007C080A2CAp0", "0x0.0000000007D048A4BCp0", "0x0.0000000007E020A6B2p0", "0x0.0000000007F008A8ACp0",
            };
_ssdm_SpecConstant(f_x_msb_4_table);
# 1640 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<32,-37> f_x_msb_4 = f_x_msb_4_table[x_msb_ind_4];

            const static ap_ufixed<16,-53> f_x_msb_5_table[256] = {
"0x0.000000000000000000p0", "0x0.000000000000000008p0", "0x0.000000000000000020p0", "0x0.000000000000000048p0",
"0x0.000000000000000080p0", "0x0.0000000000000000C8p0", "0x0.000000000000000120p0", "0x0.000000000000000188p0",
"0x0.000000000000000200p0", "0x0.000000000000000288p0", "0x0.000000000000000320p0", "0x0.0000000000000003C8p0",
"0x0.000000000000000480p0", "0x0.000000000000000548p0", "0x0.000000000000000620p0", "0x0.000000000000000708p0",
"0x0.000000000000000800p0", "0x0.000000000000000908p0", "0x0.000000000000000A20p0", "0x0.000000000000000B48p0",
"0x0.000000000000000C80p0", "0x0.000000000000000DC8p0", "0x0.000000000000000F20p0", "0x0.000000000000001088p0",
"0x0.000000000000001200p0", "0x0.000000000000001388p0", "0x0.000000000000001520p0", "0x0.0000000000000016C8p0",
"0x0.000000000000001880p0", "0x0.000000000000001A48p0", "0x0.000000000000001C20p0", "0x0.000000000000001E08p0",
"0x0.000000000000002000p0", "0x0.000000000000002208p0", "0x0.000000000000002420p0", "0x0.000000000000002648p0",
"0x0.000000000000002880p0", "0x0.000000000000002AC8p0", "0x0.000000000000002D20p0", "0x0.000000000000002F88p0",
"0x0.000000000000003200p0", "0x0.000000000000003488p0", "0x0.000000000000003720p0", "0x0.0000000000000039C8p0",
"0x0.000000000000003C80p0", "0x0.000000000000003F48p0", "0x0.000000000000004220p0", "0x0.000000000000004508p0",
"0x0.000000000000004800p0", "0x0.000000000000004B08p0", "0x0.000000000000004E20p0", "0x0.000000000000005148p0",
"0x0.000000000000005480p0", "0x0.0000000000000057C8p0", "0x0.000000000000005B20p0", "0x0.000000000000005E88p0",
"0x0.000000000000006200p0", "0x0.000000000000006588p0", "0x0.000000000000006920p0", "0x0.000000000000006CC8p0",
"0x0.000000000000007080p0", "0x0.000000000000007448p0", "0x0.000000000000007820p0", "0x0.000000000000007C08p0",
"0x0.000000000000008000p0", "0x0.000000000000008408p0", "0x0.000000000000008820p0", "0x0.000000000000008C48p0",
"0x0.000000000000009080p0", "0x0.0000000000000094C8p0", "0x0.000000000000009920p0", "0x0.000000000000009D88p0",
"0x0.00000000000000A200p0", "0x0.00000000000000A688p0", "0x0.00000000000000AB20p0", "0x0.00000000000000AFC8p0",
"0x0.00000000000000B480p0", "0x0.00000000000000B948p0", "0x0.00000000000000BE20p0", "0x0.00000000000000C308p0",
"0x0.00000000000000C800p0", "0x0.00000000000000CD08p0", "0x0.00000000000000D220p0", "0x0.00000000000000D748p0",
"0x0.00000000000000DC80p0", "0x0.00000000000000E1C8p0", "0x0.00000000000000E720p0", "0x0.00000000000000EC88p0",
"0x0.00000000000000F200p0", "0x0.00000000000000F788p0", "0x0.00000000000000FD20p0", "0x0.0000000000000102C8p0",
"0x0.000000000000010880p0", "0x0.000000000000010E48p0", "0x0.000000000000011420p0", "0x0.000000000000011A08p0",
"0x0.000000000000012000p0", "0x0.000000000000012608p0", "0x0.000000000000012C20p0", "0x0.000000000000013248p0",
"0x0.000000000000013880p0", "0x0.000000000000013EC8p0", "0x0.000000000000014520p0", "0x0.000000000000014B88p0",
"0x0.000000000000015200p0", "0x0.000000000000015888p0", "0x0.000000000000015F20p0", "0x0.0000000000000165C8p0",
"0x0.000000000000016C80p0", "0x0.000000000000017348p0", "0x0.000000000000017A20p0", "0x0.000000000000018108p0",
"0x0.000000000000018800p0", "0x0.000000000000018F08p0", "0x0.000000000000019620p0", "0x0.000000000000019D48p0",
"0x0.00000000000001A480p0", "0x0.00000000000001ABC8p0", "0x0.00000000000001B320p0", "0x0.00000000000001BA88p0",
"0x0.00000000000001C200p0", "0x0.00000000000001C988p0", "0x0.00000000000001D120p0", "0x0.00000000000001D8C8p0",
"0x0.00000000000001E080p0", "0x0.00000000000001E848p0", "0x0.00000000000001F020p0", "0x0.00000000000001F808p0",
"0x0.000000000000020000p0", "0x0.000000000000020808p0", "0x0.000000000000021020p0", "0x0.000000000000021848p0",
"0x0.000000000000022080p0", "0x0.0000000000000228C8p0", "0x0.000000000000023120p0", "0x0.000000000000023988p0",
"0x0.000000000000024200p0", "0x0.000000000000024A88p0", "0x0.000000000000025320p0", "0x0.000000000000025BC8p0",
"0x0.000000000000026480p0", "0x0.000000000000026D48p0", "0x0.000000000000027620p0", "0x0.000000000000027F08p0",
"0x0.000000000000028800p0", "0x0.000000000000029108p0", "0x0.000000000000029A20p0", "0x0.00000000000002A348p0",
"0x0.00000000000002AC80p0", "0x0.00000000000002B5C8p0", "0x0.00000000000002BF20p0", "0x0.00000000000002C888p0",
"0x0.00000000000002D200p0", "0x0.00000000000002DB88p0", "0x0.00000000000002E520p0", "0x0.00000000000002EEC8p0",
"0x0.00000000000002F880p0", "0x0.000000000000030248p0", "0x0.000000000000030C20p0", "0x0.000000000000031608p0",
"0x0.000000000000032000p0", "0x0.000000000000032A08p0", "0x0.000000000000033420p0", "0x0.000000000000033E48p0",
"0x0.000000000000034880p0", "0x0.0000000000000352C8p0", "0x0.000000000000035D20p0", "0x0.000000000000036788p0",
"0x0.000000000000037200p0", "0x0.000000000000037C88p0", "0x0.000000000000038720p0", "0x0.0000000000000391C8p0",
"0x0.000000000000039C80p0", "0x0.00000000000003A748p0", "0x0.00000000000003B220p0", "0x0.00000000000003BD08p0",
"0x0.00000000000003C800p0", "0x0.00000000000003D308p0", "0x0.00000000000003DE20p0", "0x0.00000000000003E948p0",
"0x0.00000000000003F480p0", "0x0.00000000000003FFC8p0", "0x0.000000000000040B20p0", "0x0.000000000000041688p0",
"0x0.000000000000042200p0", "0x0.000000000000042D88p0", "0x0.000000000000043920p0", "0x0.0000000000000444C8p0",
"0x0.000000000000045080p0", "0x0.000000000000045C48p0", "0x0.000000000000046820p0", "0x0.000000000000047408p0",
"0x0.000000000000048000p0", "0x0.000000000000048C08p0", "0x0.000000000000049820p0", "0x0.00000000000004A448p0",
"0x0.00000000000004B080p0", "0x0.00000000000004BCC8p0", "0x0.00000000000004C920p0", "0x0.00000000000004D588p0",
"0x0.00000000000004E200p0", "0x0.00000000000004EE88p0", "0x0.00000000000004FB20p0", "0x0.0000000000000507C8p0",
"0x0.000000000000051480p0", "0x0.000000000000052148p0", "0x0.000000000000052E20p0", "0x0.000000000000053B08p0",
"0x0.000000000000054800p0", "0x0.000000000000055508p0", "0x0.000000000000056220p0", "0x0.000000000000056F48p0",
"0x0.000000000000057C80p0", "0x0.0000000000000589C8p0", "0x0.000000000000059720p0", "0x0.00000000000005A488p0",
"0x0.00000000000005B200p0", "0x0.00000000000005BF88p0", "0x0.00000000000005CD20p0", "0x0.00000000000005DAC8p0",
"0x0.00000000000005E880p0", "0x0.00000000000005F648p0", "0x0.000000000000060420p0", "0x0.000000000000061208p0",
"0x0.000000000000062000p0", "0x0.000000000000062E08p0", "0x0.000000000000063C20p0", "0x0.000000000000064A48p0",
"0x0.000000000000065880p0", "0x0.0000000000000666C8p0", "0x0.000000000000067520p0", "0x0.000000000000068388p0",
"0x0.000000000000069200p0", "0x0.00000000000006A088p0", "0x0.00000000000006AF20p0", "0x0.00000000000006BDC8p0",
"0x0.00000000000006CC80p0", "0x0.00000000000006DB48p0", "0x0.00000000000006EA20p0", "0x0.00000000000006F908p0",
"0x0.000000000000070800p0", "0x0.000000000000071708p0", "0x0.000000000000072620p0", "0x0.000000000000073548p0",
"0x0.000000000000074480p0", "0x0.0000000000000753C8p0", "0x0.000000000000076320p0", "0x0.000000000000077288p0",
"0x0.000000000000078200p0", "0x0.000000000000079188p0", "0x0.00000000000007A120p0", "0x0.00000000000007B0C8p0",
"0x0.00000000000007C080p0", "0x0.00000000000007D048p0", "0x0.00000000000007E020p0", "0x0.00000000000007F008p0",
            };
_ssdm_SpecConstant(f_x_msb_5_table);
# 1708 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"


            ap_ufixed<16,-53> f_x_msb_5 = f_x_msb_5_table[x_msb_ind_5];

            ap_ufixed<9,-60> f_x_msb_5_lsb = x_msb_5 * x_lsb;

            ap_ufixed<25,-26> x_msb_5_lsb = x_l;

            ap_ufixed<25,-44> f_x_msb_4_5_lsb = x_msb_5_lsb * x_msb_4;

            ap_ufixed<6,-37> f_x_msb_4_s = f_x_msb_4;
            ap_ufixed<6,-63> exp_x_msb_4_5_lsb_m_1_m1 = x_msb_5 * f_x_msb_4;

            ap_ufixed<10,-59> exp_x_msb_4_5_lsb_m_1_m2 = 0;
            exp_x_msb_4_5_lsb_m_1_m2(8,0) = f_x_msb_5_lsb(8,0);
            exp_x_msb_4_5_lsb_m_1_m2 = exp_x_msb_4_5_lsb_m_1_m1 + exp_x_msb_4_5_lsb_m_1_m2;

            ap_ufixed<17,-52> exp_x_msb_4_5_lsb_m_1_m3 = 0;
            exp_x_msb_4_5_lsb_m_1_m3(15,0) = f_x_msb_5(15,0);
            exp_x_msb_4_5_lsb_m_1_m3 = exp_x_msb_4_5_lsb_m_1_m2+exp_x_msb_4_5_lsb_m_1_m3;

            ap_ufixed<26,-43> exp_x_msb_4_5_lsb_m_1_m4 =0;
            exp_x_msb_4_5_lsb_m_1_m4(24,0) = f_x_msb_4_5_lsb(24,0);
            exp_x_msb_4_5_lsb_m_1_m4 = exp_x_msb_4_5_lsb_m_1_m4 + exp_x_msb_4_5_lsb_m_1_m3;

            ap_ufixed<33,-36> exp_x_msb_4_5_lsb_m_1_m5 = 0;
            exp_x_msb_4_5_lsb_m_1_m5(31,0) = f_x_msb_4(31,0);
            exp_x_msb_4_5_lsb_m_1_m5 = exp_x_msb_4_5_lsb_m_1_m5 + exp_x_msb_4_5_lsb_m_1_m4;

            ap_ufixed<wf-18,-18> x_msb_4_5_lsb = x_l;
            ap_ufixed<wf-17,-17> exp_x_msb_4_5_lsb_m_1_s = 0;
            exp_x_msb_4_5_lsb_m_1_s(30,0) = exp_x_msb_4_5_lsb_m_1_m5(32,2);
            exp_x_msb_4_5_lsb_m_1_s = exp_x_msb_4_5_lsb_m_1_s + x_msb_4_5_lsb;

            ap_ufixed<52,-17> exp_x_msb_4_5_lsb_m_1 = exp_x_msb_4_5_lsb_m_1_s;
            exp_x_msb_4_5_lsb_m_1(1,0) = exp_x_msb_4_5_lsb_m_1_m5(1,0);


            const static ap_ufixed<51,-21> f_x_msb_3_table[256] = {
"0x0", "0x0.00000000080000AAAAp0", "0x0.000000002000055556p0", "0x0.000000004800120003p0",
"0x0.0000000080002AAAB5p0", "0x0.00000000C80053556Fp0", "0x0.000000012000900036p0", "0x0.000000018800E4AB0Ep0",
"0x0.000000020001555600p0", "0x0.000000028801E60111p0", "0x0.0000000320029AAC4Bp0", "0x0.00000003C8037757B7p0",
"0x0.000000048004800360p0", "0x0.000000054805B8AF50p0", "0x0.000000062007255B96p0", "0x0.000000070808CA083Dp0",
"0x0.00000008000AAAB555p0", "0x0.00000009080CCB62EDp0", "0x0.0000000A200F301116p0", "0x0.0000000B4811DCBFE0p0",
"0x0.0000000C8014D56F60p0", "0x0.0000000DC8181E1FA7p0", "0x0.0000000F201BBAD0CBp0", "0x0.00000010881FAF82E1p0",
"0x0.000000120024003600p0", "0x0.000000138828B0EA3Fp0", "0x0.00000015202DC59FB6p0", "0x0.00000016C83342567Fp0",
"0x0.0000001880392B0EB5p0", "0x0.0000001A483F83C874p0", "0x0.0000001C20465083D6p0", "0x0.0000001E084D9540FBp0",
"0x0.000000200055560001p0", "0x0.00000022085D96C106p0", "0x0.0000002420665B842Cp0", "0x0.00000026486FA84995p0",
"0x0.000000288079811161p0", "0x0.0000002AC883E9DBB6p0", "0x0.0000002D208EE6A8B8p0", "0x0.0000002F889A7B788Cp0",
"0x0.0000003200A6AC4B58p0", "0x0.0000003488B37D2145p0", "0x0.0000003720C0F1FA7Ap0", "0x0.00000039C8CF0ED721p0",
"0x0.0000003C80DDD7B765p0", "0x0.0000003F48ED509B71p0", "0x0.0000004220FD7D8371p0", "0x0.00000045090E626F94p0",
"0x0.000000480120036008p0", "0x0.0000004B09326454FBp0", "0x0.0000004E2145894E9Fp0", "0x0.000000514959764D26p0",
"0x0.00000054816E2F50C1p0", "0x0.00000057C983B859A4p0", "0x0.0000005B219A156804p0", "0x0.0000005E89B14A7C16p0",
"0x0.0000006201C95B9611p0", "0x0.0000006589E24CB62Cp0", "0x0.0000006921FC21DCA0p0", "0x0.0000006CCA16DF09A6p0",
"0x0.000000708232883D78p0", "0x0.000000744A4F217853p0", "0x0.00000078226CAEBA73p0", "0x0.0000007C0A8B340414p0",
"0x0.0000008002AAB55577p0", "0x0.000000840ACB36AEDAp0", "0x0.0000008822ECBC107Dp0", "0x0.0000008C4B0F497AA3p0",
"0x0.000000908332E2ED8Ep0", "0x0.00000094CB578C6981p0", "0x0.00000099237D49EEC0p0", "0x0.0000009D8BA41F7D92p0",
"0x0.000000A203CC11163Dp0", "0x0.000000A68BF522B908p0", "0x0.000000AB241F58663Cp0", "0x0.000000AFCC4AB61E22p0",
"0x0.000000B484773FE105p0", "0x0.000000B94CA4F9AF31p0", "0x0.000000BE24D3E788F1p0", "0x0.000000C30D040D6E94p0",
"0x0.000000C805356F6068p0", "0x0.000000CD0D68115EBCp0", "0x0.000000D2259BF769E1p0", "0x0.000000D74DD1258228p0",
"0x0.000000DC86079FA7E4p0", "0x0.000000E1CE3F69DB69p0", "0x0.000000E72678881D0Bp0", "0x0.000000EC8EB2FE6D1Fp0",
"0x0.000000F206EED0CBFDp0", "0x0.000000F78F2C0339FAp0", "0x0.000000FD276A99B771p0", "0x0.00000102CFAA9844BBp0",
"0x0.0000010887EC02E231p0", "0x0.0000010E502EDD9030p0", "0x0.0000011428732C4F14p0", "0x0.0000011A10B8F31F3Bp0",
"0x0.000001200900360103p0", "0x0.000001261148F8F4CBp0", "0x0.0000012C29933FFAF5p0", "0x0.0000013251DF0F13E1p0",
"0x0.000001388A2C6A3FF3p0", "0x0.0000013ED27B557F8Dp0", "0x0.000001452ACBD4D315p0", "0x0.0000014B931DEC3AEFp0",
"0x0.000001520B719FB782p0", "0x0.0000015893C6F34937p0", "0x0.0000015F2C1DEAF074p0", "0x0.00000165D4768AADA5p0",
"0x0.0000016C8CD0D68133p0", "0x0.00000173552CD26B89p0", "0x0.0000017A2D8A826D16p0", "0x0.0000018115E9EA8645p0",
"0x0.000001880E4B0EB785p0", "0x0.0000018F16ADF30147p0", "0x0.000001962F129B63FAp0", "0x0.0000019D57790BE010p0",
"0x0.000001A48FE14875FBp0", "0x0.000001ABD84B552630p0", "0x0.000001B330B735F122p0", "0x0.000001BA9924EED748p0",
"0x0.000001C2119483D917p0", "0x0.000001C99A05F8F707p0", "0x0.000001D13279523191p0", "0x0.000001D8DAEE93892Ep0",
"0x0.000001E09365C0FE59p0", "0x0.000001E85BDEDE918Dp0", "0x0.000001F03459F04347p0", "0x0.000001F81CD6FA1405p0",
"0x0.000002001556000444p0", "0x0.000002081DD7061485p0", "0x0.00000210365A104547p0", "0x0.000002185EDF22970Dp0",
"0x0.000002209766410A5Ap0", "0x0.00000228DFEF6F9FAFp0", "0x0.00000231387AB25793p0", "0x0.00000239A1080D328Ap0",
"0x0.00000242199784311Cp0", "0x0.0000024AA2291B53CFp0", "0x0.000002533ABCD69B2Dp0", "0x0.0000025BE352BA07BEp0",
"0x0.000002649BEAC99A0Dp0", "0x0.0000026D64850952A7p0", "0x0.000002763D217D3216p0", "0x0.0000027F25C02938EAp0",
"0x0.000002881E611167B0p0", "0x0.00000291270439BEF8p0", "0x0.0000029A3FA9A63F53p0", "0x0.000002A368515AE951p0",
"0x0.000002ACA0FB5BBD86p0", "0x0.000002B5E9A7ACBC86p0", "0x0.000002BF425651E6E4p0", "0x0.000002C8AB074F3D36p0",
"0x0.000002D223BAA8C013p0", "0x0.000002DBAC70627012p0", "0x0.000002E54528804DCDp0", "0x0.000002EEEDE30659DBp0",
"0x0.000002F8A69FF894D9p0", "0x0.000003026F5F5AFF61p0", "0x0.0000030C4821319A10p0", "0x0.0000031630E5806584p0",
"0x0.0000032029AC4B625Bp0", "0x0.0000032A3275969134p0", "0x0.000003344B4165F2B1p0", "0x0.0000033E740FBD8772p0",
"0x0.00000348ACE0A1501Bp0", "0x0.00000352F5B4154D4Fp0", "0x0.0000035D4E8A1D7FB2p0", "0x0.00000367B762BDE7EAp0",
"0x0.00000372303DFA869Ep0", "0x0.0000037CB91BD75C75p0", "0x0.0000038751FC586A18p0", "0x0.00000391FADF81B02Fp0",
"0x0.0000039CB3C5572F67p0", "0x0.000003A77CADDCE86Ap0", "0x0.000003B2559916DBE4p0", "0x0.000003BD3E87090A84p0",
"0x0.000003C83777B774F8p0", "0x0.000003D3406B261BF0p0", "0x0.000003DE596159001Cp0", "0x0.000003E9825A54222Dp0",
"0x0.000003F4BB561B82D7p0", "0x0.000004000454B322CCp0", "0x0.0000040B5D561F02C2p0", "0x0.00000416C65A63236Ep0",
"0x0.000004223F61838586p0", "0x0.0000042DC86B8429C2p0", "0x0.0000043961786910DBp0", "0x0.000004450A88363B8Ap0",
"0x0.00000450C39AEFAA8Ap0", "0x0.0000045C8CB0995E96p0", "0x0.0000046865C937586Bp0", "0x0.000004744EE4CD98C6p0",
"0x0.000004804803602067p0", "0x0.0000048C5124F2F00Cp0", "0x0.000004986A498A0876p0", "0x0.000004A49371296A67p0",
"0x0.000004B0CC9BD516A1p0", "0x0.000004BD15C9910DE8p0", "0x0.000004C96EFA615101p0", "0x0.000004D5D82E49E0B0p0",
"0x0.000004E251654EBDBDp0", "0x0.000004EEDA9F73E8F0p0", "0x0.000004FB73DCBD6310p0", "0x0.000005081D1D2F2CE7p0",
"0x0.00000514D660CD4740p0", "0x0.000005219FA79BB2E7p0", "0x0.0000052E78F19E70A8p0", "0x0.0000053B623ED98150p0",
"0x0.000005485B8F50E5AFp0", "0x0.0000055564E3089E93p0", "0x0.000005627E3A04ACCEp0", "0x0.0000056FA794491131p0",
"0x0.0000057CE0F1D9CC8Ep0", "0x0.0000058A2A52BADFBAp0", "0x0.0000059783B6F04B88p0", "0x0.000005A4ED1E7E10CFp0",
"0x0.000005B26689683064p0", "0x0.000005BFEFF7B2AB20p0", "0x0.000005CD89696181DBp0", "0x0.000005DB32DE78B56Fp0",
"0x0.000005E8EC56FC46B6p0", "0x0.000005F6B5D2F0368Cp0", "0x0.000006048F525885CDp0", "0x0.0000061278D5393558p0",
"0x0.00000620725B96460Ap0", "0x0.0000062E7BE573B8C3p0", "0x0.0000063C9572D58E64p0", "0x0.0000064ABF03BFC7CEp0",
"0x0.00000658F8983665E5p0", "0x0.0000066742303D698Bp0", "0x0.000006759BCBD8D3A5p0", "0x0.00000684056B0CA519p0",
"0x0.000006927F0DDCDECEp0", "0x0.000006A108B44D81AAp0", "0x0.000006AFA25E628E98p0", "0x0.000006BE4C0C20067Fp0",
"0x0.000006CD05BD89EA4Bp0", "0x0.000006DBCF72A43AE8p0", "0x0.000006EAA92B72F942p0", "0x0.000006F992E7FA2646p0",
"0x0.000007088CA83DC2E4p0", "0x0.00000717966C41D00Ap0", "0x0.00000726B0340A4EAAp0", "0x0.00000735D9FF9B3FB6p0",
"0x0.0000074513CEF8A41Ep0", "0x0.000007545DA2267CD9p0", "0x0.00000763B77928CAD9p0", "0x0.000007732154038F14p0",
"0x0.000007829B32BACA82p0", "0x0.000007922515527E1Ap0", "0x0.000007A1BEFBCEAAD4p0", "0x0.000007B168E63351AAp0",
"0x0.000007C122D4847397p0", "0x0.000007D0ECC6C61195p0", "0x0.000007E0C6BCFC2CA3p0", "0x0.000007F0B0B72AC5BEp0",
            };
_ssdm_SpecConstant(f_x_msb_3_table);
# 1811 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<51,-21> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<62,-10> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(61,54) = x_msb_3(7,0);
            exp_x_msb_3_m_1(50, 0) = f_x_msb_3(50,0);

            ap_ufixed<50,-10> exp_x_msb_3_m_1_s = exp_x_msb_3_m_1;

            ap_ufixed<101,-27> f_x_msb_3_4_5_lsb = exp_x_msb_3_m_1_s * exp_x_msb_4_5_lsb_m_1;
            ap_ufixed<45,-27> f_x_msb_3_4_5_lsb_s = f_x_msb_3_4_5_lsb;
            ap_ufixed<63, -9> exp_x_msb_3_4_5_lsb_m_1 = f_x_msb_3_4_5_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_5_lsb_m_1;


            const static ap_ufixed<64,-4> f_x_msb_2_table[256] = {
"0x0.0p0", "0x0.00000800AAB555DDEp0", "0x0.00002005560011127p0", "0x0.00004812036081A9Cp0",
"0x0.0000802AB55777D28p0", "0x0.0000C8536F6684062p0", "0x0.0001209036103740Dp0", "0x0.000188E50ED8634A0p0",
"0x0.0002015600445B0C3p0", "0x0.000289E711DB32FD7p0", "0x0.0003229C4C260197Ep0", "0x0.0003CB79B8B01FE26p0",
"0x0.0004848362076A08Dp0", "0x0.00054DBD53BC80058p0", "0x0.0006272B9A630659Dp0", "0x0.000710D24391E6D7Ap0",
"0x0.00080AB55DE3917ABp0", "0x0.000914D8F8F63D524p0", "0x0.000A2F41256C297AFp0", "0x0.000B59F1F4EBDE291p0",
"0x0.000C94EF7A206DC2Dp0", "0x0.000DE03DC8B9B60B1p0", "0x0.000F3BE0F56CA15C4p0", "0x0.0010A7DD15F367F40p0",
"0x0.00122436410DD14E5p0", "0x0.0013B0F08E817591Ep0", "0x0.00154E101719FF0C5p0", "0x0.0016FB98F4A96BBEFp0",
"0x0.0018B98F42084EFBDp0", "0x0.001A87F71B1613137p0", "0x0.001C66D49CB93B127p0", "0x0.001E562BE4DFA4904p0",
"0x0.00205601127EC98E0p0", "0x0.00226658459402659p0", "0x0.002487359F24C7C99p0", "0x0.0026B89D413EF4D5Ep0",
"0x0.0028FA934EF909304p0", "0x0.002B4D1BEC726B39Cp0", "0x0.002DB03B3ED3AA50Ep0", "0x0.003023F56C4EC123Fp0",
"0x0.0032A84E9C1F58145p0", "0x0.00353D4AF68B07AA1p0", "0x0.0037E2EEA4E19B185p0", "0x0.003A993DD17D52D25p0",
"0x0.003D603CA7C32730Fp0", "0x0.004037EF54230B293p0", "0x0.0043205A04182F12Fp0", "0x0.00461980E62943810p0",
"0x0.0049236829E8BC292p0", "0x0.004C3E13FFF512DD8p0", "0x0.004F698899F90A966p0", "0x0.0052A5CA2AABF28D0p0",
"0x0.0055F2DCE5D1E966Ep0", "0x0.005950C5003C20723p0", "0x0.005CBF86AFC91EF2Bp0", "0x0.00603F262B65057FCp0",
"0x0.0063CFA7AB09D1732p0", "0x0.0067710F67BFA0687p0", "0x0.006B23619B9CF3CDEp0", "0x0.006EE6A281C6F4857p0",
"0x0.0072BAD65671B6977p0", "0x0.0076A00156E07CF57p0", "0x0.007A9627C165FD4EDp0", "0x0.007E9D4DD564A3F5Ep0",
"0x0.0082B577D34ED7D5Bp0", "0x0.0086DEA9FCA73E799p0", "0x0.008B18E8940100253p0", "0x0.008F6437DD000BFDAp0",
"0x0.0093C09C1C595C43Ep0", "0x0.00982E1997D33A9FCp0", "0x0.009CACB49645847CCp0", "0x0.00A13C715F99EF773p0",
"0x0.00A5DD543CCC4DDAFp0", "0x0.00AA8F6177EAD3336p0", "0x0.00AF529D5C1658EBCp0", "0x0.00B4270C3582A301Dp0",
"0x0.00B90CB25176A4C8Bp0", "0x0.00BE0393FE4CC5BD7p0", "0x0.00C30BB58B73266CAp0", "0x0.00C8251B496BE5696p0",
"0x0.00CD4FC989CD64555p0", "0x0.00D28BC49F428CFA3p0", "0x0.00D7D910DD8B16743p0", "0x0.00DD37B2997BCA6E6p0",
"0x0.00E2A7AE28FECA6FBp0", "0x0.00E82907E313D5399p0", "0x0.00EDBBC41FD08C383p0", "0x0.00F35FE73860B9038p0",
"0x0.00F91575870692F24p0", "0x0.00FEDC73671B04BDFp0", "0x0.0104B4E5350DF2386p0", "0x0.010A9ECF4E667E12Dp0",
"0x0.01109A3611C34FB64p0", "0x0.0116A71DDEDAD92D8p0", "0x0.011CC58B167B9D206p0", "0x0.0122F5821A8C74E0Dp0",
"0x0.012937074E0CD6893p0", "0x0.012F8A1F15151B2C6p0", "0x0.0135EECDD4D6C5172p0", "0x0.013C6517F39CC6233p0",
"0x0.0142ED01D8CBC61C4p0", "0x0.0149868FECE26935Dp0", "0x0.015031C6997996937p0", "0x0.0156EEAA4944BEE23p0",
"0x0.015DBD3F68122303Ep0", "0x0.01649D8A62CB1ACBEp0", "0x0.016B8F8FA7745BCDBp0", "0x0.01729353A52E403D8p0",
"0x0.0179A8DACC350DE1Dp0", "0x0.0180D0298DE13D179p0", "0x0.018809445CA7BFE78p0", "0x0.018F542FAC1A492D6p0",
"0x0.0196B0EFF0E793D15p0", "0x0.019E1F89A0DBAA128p0", "0x0.01A5A00132E02CE42p0", "0x0.01AD325B1EFC9B5BCp0",
"0x0.01B4D69BDE569A322p0", "0x0.01BC8CC7EB323B553p0", "0x0.01C454E3C0F2458C8p0", "0x0.01CC2EF3DC187C2F6p0",
"0x0.01D41AFCBA45E6ED2p0", "0x0.01DC1902DA3B19A6Dp0", "0x0.01E4290ABBD87C5BCp0", "0x0.01EC4B18E01E9326Fp0",
"0x0.01F47F31C92E464FCp0", "0x0.01FCC559FA492A6B6p0", "0x0.02051D95F7D1C8917p0", "0x0.020D87EA474BE6A1Cp0",
"0x0.0216045B6F5CCF9CEp0", "0x0.021E92EDF7CB9C0E4p0", "0x0.022733A669817A88Ap0", "0x0.022FE6894E89F834Cp0",
"0x0.0238AB9B321349722p0", "0x0.024182E0A06E9289Bp0", "0x0.024A6C5E271030733p0", "0x0.02536818549001AC1p0",
"0x0.025C7613B8A9AF215p0", "0x0.02659654E43CF52B1p0", "0x0.026EC8E0694DEC9A9p0", "0x0.02780DBADB0553DA6p0",
"0x0.028164E8CDB0D8211p0", "0x0.028ACE6ED6C35EB5Fp0", "0x0.02944A518CD54E484p0", "0x0.029DD89587A4D858Dp0",
"0x0.02A7793F601642B5Dp0", "0x0.02B12C53B03431090p0", "0x0.02BAF1D7132FEE788p0", "0x0.02C4C9CE2561B759Fp0",
"0x0.02CEB43D844902F7Ap0", "0x0.02D8B129CE8CCD68Fp0", "0x0.02E2C097A3FBE17C9p0", "0x0.02ECE28BA58D22B56p0",
"0x0.02F7170A755FD759Ep0", "0x0.03015E18B6BBF2966p0", "0x0.030BB7BB0E125EB13p0", "0x0.031623F620FD4751Ep0",
"0x0.0320A2CE964063DACp0", "0x0.032B344915C941D54p0", "0x0.0335D86A48AF8F70Cp0", "0x0.03408F36D93566140p0",
"0x0.034B58B372C795013p0", "0x0.035634E4C1FDEC0D0p0", "0x0.036123CF749B8667Cp0", "0x0.036C2578398F157A0p0",
"0x0.037739E3C0F32BD30p0", "0x0.03826116BC0E882ACp0", "0x0.038D9B15DD5460763p0", "0x0.0398E7E5D864AD0E9p0",
"0x0.03A4478B620C73EB5p0", "0x0.03AFBA0B304613EEDp0", "0x0.03BB3F69FA3990464p0", "0x0.03C6D7AC783CDBDBFp0",
"0x0.03D282D763D424DCDp0", "0x0.03DE40EF77B220509p0", "0x0.03EA11F96FB855C4Fp0", "0x0.03F5F5FA08F76B0BBp0",
"0x0.0401ECF601AF700BDp0", "0x0.040DF6F219502AA55p0", "0x0.041A13F3107962A88p0", "0x0.042643FDA8FB2DDFBp0",
"0x0.04328716A5D63C2C4p0", "0x0.043EDD42CB3C23B6Dp0", "0x0.044B4686DE8FAD325p0", "0x0.0457C2E7A66520322p0",
"0x0.04645269EA828F932p0", "0x0.0470F51273E025F89p0", "0x0.047DAAE60CA8725B3p0", "0x0.048A73E98038B4ABFp0",
"0x0.049750219B212A8A0p0", "0x0.04A43F932B255C0B7p0", "0x0.04B14242FF3C689A0p0", "0x0.04BE5835E79153E1Dp0",
"0x0.04CB8170B58352D4Ep0", "0x0.04D8BDF83BA618C04p0", "0x0.04E60DD14DC22475Ep0", "0x0.04F37100C0D50D88Ep0",
"0x0.0500E78B6B11D19D6p0", "0x0.050E717623E121CBAp0", "0x0.051C0EC5C3E1B016Cp0", "0x0.0529BF7F24E87CF6Ap0",
"0x0.053783A7220124F51p0", "0x0.05455B42976E2E5EAp0", "0x0.0553465662A95706Bp0", "0x0.056144E76263E21F4p0",
"0x0.056F56FA7686E623Ep0", "0x0.057D7C9480339AD83p0", "0x0.058BB5BA61C3A75A3p0", "0x0.059A0270FEC97047Ap0",
"0x0.05A862BD3C1065F74p0", "0x0.05B6D6A3FF9D52C58p0", "0x0.05C55E2A30AEA974Ep0", "0x0.05D3F954B7BCD3A1Bp0",
"0x0.05E2A8287E7A8049Ep0", "0x0.05F16AAA6FD4F267Bp0", "0x0.060040DF77F44FA13p0", "0x0.060F2ACC843BEF0A0p0",
"0x0.061E2876834AA7FA4p0", "0x0.062D39E264FB20F7Ep0", "0x0.063C5F151A641EB4Cp0", "0x0.064B981395D8D31FEp0",
"0x0.065AE4E2CAE92C8AAp0", "0x0.066A4587AE6224E1Cp0", "0x0.0679BA07364E10FA3p0", "0x0.0689426659F4EFF1Bp0",
"0x0.0698DEAA11DCBAA37p0", "0x0.06A88ED757C9B3304p0", "0x0.06B852F326BEB49B0p0", "0x0.06C82B027AFD8278Ap0",
"0x0.06D8170A520718B46p0", "0x0.06E8170FAA9BFB67Ep0", "0x0.06F82B1784BC86C72p0", "0x0.07085326E1A93F207p0",
"0x0.07188F42C3E320F0Bp0", "0x0.0728DF702F2BF10B2p0", "0x0.073943B428868CD5Ap0", "0x0.0749BC13B6373A98Fp0",
"0x0.075A4893DFC3F9E4Cp0", "0x0.076AE939ADF4D4083p0", "0x0.077B9E0A2AD42C9E8p0", "0x0.078C670A61AF122F4p0",
"0x0.079D443F5F158EE3Ap0", "0x0.07AE35AE30DAF94F1p0", "0x0.07BF3B5BE616454CBp0", "0x0.07D0554D8F2254F0Cp0",
"0x0.07E183883D9E498E2p0", "0x0.07F2C611046DD4D06p0", "0x0.08041CECF7B989EA2p0", "0x0.081588212CEF2ED73p0",
"0x0.082707B2BAC20DB40p0", "0x0.08389BA6B92B46284p0", "0x0.084A4402416A1EE6Fp0", "0x0.085C00CA6E045741Fp0",
"0x0.086DD2045AC678D2Bp0", "0x0.087FB7B524C42936Cp0", "0x0.0891B1E1EA587BE12p0", "0x0.08A3C08FCB2643FFEp0",
            };
_ssdm_SpecConstant(f_x_msb_2_table);
# 1889 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<64,-4> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 6,-4> f_x_msb_2_h;
            f_x_msb_2_h(5,0) = f_x_msb_2(63,58);
            ap_ufixed< 9,-1> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<67,-1> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(66,58) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(57, 0) = f_x_msb_2(57,0);

            ap_ufixed<130,-10> f_x_msb_2_3_4_5_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_5_lsb_m_1;
            ap_ufixed<62,-10> f_x_msb_2_3_4_5_lsb_s = f_x_msb_2_3_4_5_lsb;
            ap_ufixed<72,0> exp_x_msb_2_3_4_5_lsb_m_1 = f_x_msb_2_3_4_5_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_5_lsb_m_1;

            const static ap_ufixed<68,32> exp_x_msb_1_table[256] = {
"0x1.000000000p0", "0x1.48B5E3C3Ep0", "0x1.A61298E1Ep0", "0x2.1DF3B68CFp0",
"0x2.B7E151628p0", "0x3.7D871DB61p0", "0x4.7B4FF993Fp0", "0x5.C12DA416Ep0",
"0x7.63992E353p0", "0x9.7CDC417A3p0", "0xC.2EB7EC98Fp0", "0xF.A48385EDFp0",
"0x14.15E5BF6FBp0", "0x19.CA53B7811p0", "0x21.1D8E4272Dp0", "0x2A.8565A144Cp0",
"0x36.99205C4E7p0", "0x46.1AFC4DB59p0", "0x5A.0462B7877p0", "0x73.9593ABB7Dp0",
"0x94.69C4CB819p0", "0xBE.90F6F83E9p0", "0xF4.B122790DDp0", "0x13A.30CF1CCBBp0",
"0x193.6DC5690C0p0", "0x206.03487A3B1p0", "0x299.2442102D9p0", "0x356.0F0B0F980p0",
"0x448.A216ABB76p0", "0x580.1AD754FA3p0", "0x710.0ADBAC7DAp0", "0x911.9289C3923p0",
"0xBA4.F53EA3863p0", "0xEF3.A035D5798p0", "0x1332.C4D2B7C4Ap0", "0x18A6.B027DA0A7p0",
"0x1FA7.157C470F8p0", "0x28A4.90D2CCEF1p0", "0x342F.BA11823B8p0", "0x4302.3A933EE5Cp0",
"0x560A.773E54157p0", "0x6E7A.8ABB4A83Cp0", "0x8DDB.80AF4269Dp0", "0xB626.0748BAEC7p0",
"0xE9E2.2447727BFp0", "0x12C4F.EB75B2AB0p0", "0x1819B.C560F6113p0", "0x1EF21.8F1B001A4p0",
"0x27BC2.CA9A6F934p0", "0x33055.49F35D91Fp0", "0x41831.49596E996p0", "0x541E7.E56949D58p0",
"0x6C02D.645AB2554p0", "0x8AB06.0A3EE9FB1p0", "0xB2148.5EAE56C5Bp0", "0xE4A8D.2881EDBE8p0",
"0x1259AC.48BF05D6Ep0", "0x178FEE.7792E44B3p0", "0x1E4127.437732B71p0", "0x26D8F9.4A204BEA5p0",
"0x31E199.5F5A550DDp0", "0x400C7D.64D3386CBp0", "0x523D82.79EDAEF9Cp0", "0x69993D.D4F2D9524p0",
"0x87975E.854001024p0", "0xAE1A47.C38A42CD0p0", "0xDF8D5F.6DCFE5CEAp0", "0x11F0BF8.1E99FDEB6p0",
"0x1709348.C0EA4F8CEp0", "0x1D94295.464477ACCp0", "0x25FAD90.65C78E342p0", "0x30C4623.616ED2BE2p0",
"0x3E9E441.232817A61p0", "0x506744D.3B342FC94p0", "0x673D70B.C00F1F76Dp0", "0x849012B.C127FC962p0",
"0xAA36C7C.F69370B94p0", "0xDA8F202.DD9ACE661p0", "0x118A2AAE.0AA05236Bp0", "0x16857CFA.1AA8A5555p0",
"0x1CEB088B.68E804021p0", "0x2521AEDA.32CD52BE5p0", "0x2FAD89E1.79BAB8EADp0", "0x3D3838C6.BE0F13F06p0",
"0x4E9B87F6.7BB3F5597p0", "0x64EF201B.01109A4A5p0", "0x819A1801.9394C0D96p0", "0xA6698403.CF5D9E663p0",
"0xD5AD6DCE.21AFFC0DDp0", "0x1125E066B.0B19418CCp0", "0x1604B68CF.05F65FAA9p0", "0x1C45AED0A.D0C934CDCp0",
"0x244D5E676.3FB814AF0p0", "0x2E9CEBF49.9C21839C7p0", "0x3BDA2CBD0.9F5AC2146p0", "0x4CDA0FD41.989F004E7p0",
"0x62ADFED51.D7EDCCDE6p0", "0x7EB50B520.76F91D6E8p0", "0xA2B1FD3D9.A57B6C33Cp0", "0xD0E7A50F4.EF0D7447Fp0",
"0x10C3D39209.62C88AAFBp0", "0x1586D0722B.3EEB27301p0", "0x1BA4068AAC.2B6E3EE34p0", "0x237DCBF1E5.709A9F9C1p0",
"0x2D9264D2D4.D6B94153Bp0", "0x3A83F23B18.FE5BD524Ap0", "0x4B22A1B5C3.27A2FD85Ap0", "0x6079C1866C.71A93951Dp0",
"0x7BE08BDFD9.CC72249ABp0", "0x9F0FB7309C.B446D3919p0", "0xCC3D265776.C3D25779Ep0", "0x1063F7612B0.C0831CA6Cp0",
"0x150BBA37963.79A4FB6ADp0", "0x1B05FA9B62E.737D935B8p0", "0x22B2DC5C41D.AD89559EBp0", "0x2C8DD1AB28B.404414BE7p0",
"0x39355C8C638.0AC5631B1p0", "0x49750434675.301B8D0E7p0", "0x5E521E7A16E.51F9CD3C2p0", "0x791C3B06F8B.EA2DEC48Cp0",
"0x9B823857614.764F43E20p0", "0xC7AD559D438.E7C270C30p0", "0x10063F4E687B.A1A43A35Bp0", "0x149363C905BA.3641D0164p0",
"0x1A6B765D8CDF.6CDBF1C63p0", "0x21EC75240E66.E2891CE63p0", "0x2B8F1073A6AF.BA219DB61p0", "0x37EE3FFC0063.E360F931Fp0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000001p0", "0x0.000000001p0", "0x0.000000002p0",
"0x0.000000002p0", "0x0.000000003p0", "0x0.000000004p0", "0x0.000000005p0",
"0x0.000000007p0", "0x0.000000009p0", "0x0.00000000Bp0", "0x0.00000000Ep0",
"0x0.000000013p0", "0x0.000000018p0", "0x0.00000001Fp0", "0x0.000000028p0",
"0x0.000000034p0", "0x0.000000042p0", "0x0.000000055p0", "0x0.00000006Ep0",
"0x0.00000008Dp0", "0x0.0000000B5p0", "0x0.0000000E9p0", "0x0.00000012Bp0",
"0x0.000000181p0", "0x0.0000001EEp0", "0x0.00000027Ap0", "0x0.00000032Fp0",
"0x0.000000416p0", "0x0.00000053Fp0", "0x0.0000006BDp0", "0x0.0000008A7p0",
"0x0.000000B1Cp0", "0x0.000000E44p0", "0x0.000001252p0", "0x0.000001786p0",
"0x0.000001E35p0", "0x0.0000026C9p0", "0x0.0000031CEp0", "0x0.000003FF3p0",
"0x0.00000521Dp0", "0x0.000006970p0", "0x0.000008762p0", "0x0.00000ADD6p0",
"0x0.00000DF36p0", "0x0.000011E9Cp0", "0x0.000017003p0", "0x0.00001D88Ap0",
"0x0.000025EC0p0", "0x0.000030B15p0", "0x0.00003E85Dp0", "0x0.00005047Ep0",
"0x0.000067153p0", "0x0.0000845C6p0", "0x0.0000A9F46p0", "0x0.0000DA39Ep0",
"0x0.000118354p0", "0x0.000167CB5p0", "0x0.0001CDFC2p0", "0x0.000251334p0",
"0x0.0002F9AF3p0", "0x0.0003D205Ap0", "0x0.0004E7CE2p0", "0x0.00064C7C6p0",
"0x0.000816791p0", "0x0.000A628A3p0", "0x0.000D55A1Fp0", "0x0.00111F30Fp0",
"0x0.0015FC210p0", "0x0.001C3AA91p0", "0x0.00243F374p0", "0x0.002E8ABFCp0",
"0x0.003BC2D73p0", "0x0.004CBC19Ap0", "0x0.006287862p0", "0x0.007E83A56p0",
"0x0.00A2728F8p0", "0x0.00D096336p0", "0x0.010BD4A5Ap0", "0x0.0157E6BFEp0",
"0x0.01B993FE0p0", "0x0.0236FF5BFp0", "0x0.02D80A08Dp0", "0x0.03A6D2222p0",
"0x0.04B0556E0p0", "0x0.0605424D5p0", "0x0.07BB04063p0", "0x0.09ED1B429p0",
"0x0.0CBED8666p0", "0x0.105D93892p0", "0x0.150385C09p0", "0x0.1AFB718E8p0",
"0x0.22A555477p0", "0x0.2C7C72FC0p0", "0x0.391F0EE49p0", "0x0.495860DCAp0",
"0x0.5E2D58D8Bp0", "0x0.78ED03AFBp0", "0x0.9B4597E37p0", "0x0.C75F7CF56p0",
            };
_ssdm_SpecConstant(exp_x_msb_1_table);
# 1967 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<68,32> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<140,32> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_5_lsb_m_1;
            ap_ufixed<68,32> y_lo_s = y_lo;
            ap_ufixed<68,32> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        y += delta;

            overf = 0;
#pragma unroll
 for (int j = 64; j >= I_+31; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
 for (int j = 64; j >= I_+31; j--)
                    y[j] = 0;
#pragma unroll
 for (int j = I_+30; j >= 0; j--)
                    y[j] = 1;
            }

        r = y;
    }
    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> exp(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return exp(xf);
}

template<int I_>
ap_int<I_> exp(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return exp(xf);
}

template<int I_>
ap_uint<I_> exp(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return exp(xf);
}

template<int W, int I>
ap_fixed<W,I> expm1(ap_fixed<W,I> x) {
    ap_fixed<W,I> result, tmp;
    ap_ufixed<1,1> one = 1;
    if(I < 1) {
        result = 0;
    } else {
        ap_fixed<W,I> tmp = exp(x);
        ap_ufixed<1,1> one = 1;
        result = tmp - one;
    }
    return result;
}

template<int W, int I>
ap_ufixed<W,I> expm1(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return expm1(xf);
}

template<int I>
ap_int<I> expm1(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return expm1(xf);
}

template<int I>
ap_uint<I> expm1(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return expm1(xf);
}

template<int W, int I>
ap_fixed<W,I> exp2(ap_fixed<W,I> x) {

    int F = W - I;
    if(I > 33 || F > 32) {
        return 0;
    }

    int I_s;
    int M = ((I - 1) > F) ? (I - 1) : F;

    if(M == 1) {
        I_s = 1;
    } else if(M == 2) {
        I_s = 2;
    } else if(M <= 4) {
        I_s = 3;
    } else if(M <= 8) {
        I_s = 4;
    } else if(M <= 16) {
        I_s = 5;
    } else {
        I_s = 6;
    }

    ap_fixed<W,I> r;

    if(I_s == 1) {

        ap_fixed<3,2> x_l = x;
        ap_ufixed<2,1> y = 0;

        if(!x_l[2]) {
            y[1] = 1;
        }
        if(x_l[1]) {
            y[0] = 1;
        }

        if(I<2) {
            if(y[1]) {
                y[1]=0;
                y[0]=1;
            }
        }
        r = y;

    } else if(I_s == 2) {

        ap_fixed<5,3> x_l = x;
        ap_ufixed<4,2> y = 0;
        ap_fixed<2,2> x_l_int;
        x_l_int(1,0) = x_l(3,2);
        ap_ufixed<2,0> x_l_fract;
        x_l_fract(1,0) = x_l(1,0);

        if( (x_l[4]&&(!x_l[3])) || ((!x_l[4])&&x_l[3]) ) {
            if(!x_l[4]) {
                y = "0x3.cp0";
            }
        } else {
            if((!x_l[3])&(x_l[2])) y[3] = 1;
            if(((!x_l[3])&(!x_l[2])) | ((!x_l[3])&x_l[2]&x_l[1]&x_l[0])) y[2] = 1;
            if( (x_l[3]&x_l[2]) | ((!x_l[3])&( (x_l[2]&(x_l[1]^x_l[0])) | ((!x_l[2])&x_l[1]&x_l[0] )))) y[1] = 1;
            if((x_l[3]&(!x_l[2])) | (x_l[1]&((x_l[0]&x_l[2]) | ((!x_l[0])&(!x_l[3]))))) y[0] =1;
        }

        if(I<3) {
            bool overf = 0;
#pragma unroll
 for(int j=3; j>=I+1; j--) {
                if(y[j]) {
                    overf = 1;
                }
            }
            if (overf) {
#pragma unroll
 for(int j=3; j>=I+1; j--) {
                    y[j] = 0;
                }
#pragma unroll
 for(int j=I; j>=0; j--) {
                    y[j] = 1;
                }
            }
        }
        r = y;

    } else if(I_s == 3) {

        ap_fixed<9,5> x_l = x;
        ap_ufixed<8,4> y = 0;
        ap_fixed<3,3> x_l_int;
        x_l_int(2,0) = x_l(6,4);
        ap_ufixed<4,0> x_l_fract;
        x_l_fract(3,0) = x_l(3,0);

        if((x_l[8]!=x_l[7])||(x_l[8]!=x_l[6])) {
            if(!x_l[8]) {
                y = "0xf.fp0";
            }
        } else {
            ap_uint<4> x_msb_ind;
            ap_uint<3> x_lsb_ind;
            x_msb_ind[3] = x_l[8];
            x_msb_ind(2,0) = x_l(5,3);
            x_lsb_ind(2,0) = x_l(2,0);
            const static ap_ufixed<10,4> exp2_x_msb_table[16] = {
                "0x1.00p0", "0x1.6Cp0", "0x2.00p0", "0x2.D4p0",
                "0x4.00p0", "0x5.A8p0", "0x8.00p0", "0xB.50p0",
                "0x0.10p0", "0x0.18p0", "0x0.20p0", "0x0.2Cp0",
                "0x0.40p0", "0x0.5Cp0", "0x0.80p0", "0x0.B4p0"
            };
_ssdm_SpecConstant(exp2_x_msb_table);
# 2218 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            const static ap_ufixed<10,0> exp2_x_lsb_m_1_table[8] = {
                "0x0.0p0", "0x0.0B4p0", "0x0.174p0", "0x0.238p0",
                "0x0.308p0", "0x0.3E0p0", "0x0.4C0p0", "0x0.5ACp0"
            };
_ssdm_SpecConstant(exp2_x_lsb_m_1_table);
# 2224 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<11,0> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];
            ap_ufixed<10,4> exp2_x_msb = exp2_x_msb_table[x_msb_ind];
            ap_ufixed<21,4> y_lo = exp2_x_msb * exp2_x_lsb_m_1;
            ap_ufixed<10,4> y_lo_s = y_lo;
            ap_ufixed<10,4> y_l = y_lo_s + exp2_x_msb;
            y = y_l;
        }

        if(I < 5) {
            bool overf = 0;
#pragma unroll
 for(int j=7; j>=3+I; j--) {
                if(y[j]) {
                    overf = 1;
                }
            }
            if(overf) {
#pragma unroll
 for(int j=7; j>=3+I; j--) {
                    y[j] = 0;
                }
#pragma unroll
 for(int j=I+2; j>=0; j--) {
                    y[j] = 1;
                }
            }
        }
        r = y;

    } else if(I_s == 4) {

        ap_fixed<17,9> x_l=x;
        ap_ufixed<16,8> y = 0;
        ap_fixed<4,4> x_l_int;
        x_l_int(3,0) = x_l(11,8);
        ap_ufixed<8,0> x_l_fract;
        x_l_fract(7,0) = x_l(7,0);

        bool overf_1 = 0;
#pragma unroll
 for(int j=11; j<16; j++) {
            if(x_l[16]!=x_l[j]) {
                overf_1 = 1;
            }
        }
        if(overf_1) {
            if(!x_l[16]) {
                y = "0xff.ffp0";
            }
        } else {

            ap_uint<5> x_msb_ind_1;
            x_msb_ind_1(4,0) = x_l(11,7);
            ap_uint<4> x_msb_ind_2;
            x_msb_ind_2(3,0) = x_l(6,3);
            ap_uint<3> x_lsb_ind;
            x_lsb_ind = x_l(2,0);

            const static ap_ufixed<14,-5> exp2_x_lsb_m_1_table[8] = {
                "0x0.0p0", "0x0.00B1Ap0", "0x0.0163Ep0", "0x0.02168p0",
                "0x0.02C9Ap0", "0x0.037D4p0", "0x0.04316p0", "0x0.04E60p0"
            };
_ssdm_SpecConstant(exp2_x_lsb_m_1_table);
# 2286 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<14,-5> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<19,0> exp2_x_msb_2_m_1_table[16] = {
                "0x0.0p0,0", "0x0.059B0p0", "0x0.0B558p0", "0x0.11302p0",
                "0x0.172B8p0", "0x0.1D488p0", "0x0.2387Ap0", "0x0.29E9Ep0",
                "0x0.306FEp0", "0x0.371A8p0", "0x0.3DEA6p0", "0x0.44E08p0",
                "0x0.4BFDAp0", "0x0.5342Cp0", "0x0.5AB08p0", "0x0.6247Ep0"
            };
_ssdm_SpecConstant(exp2_x_msb_2_m_1_table);
# 2292 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<19,0> exp2_x_msb_2_m_1 = exp2_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<33,-5> f_x_msb_2_lsb = exp2_x_msb_2_m_1 * exp2_x_lsb_m_1;
            ap_ufixed<19,0> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<19,0> exp2_x_msb_2_lsb_m_1 = f_x_msb_2_lsb_s + exp2_x_msb_2_m_1 + exp2_x_lsb_m_1;

            const static ap_ufixed<19,8> exp2_x_msb_1_table[32] = {
                "0x1.000p0", "0x1.6A0p0", "0x2.000p0", "0x2.D42p0",
                "0x4.000p0", "0x5.A82p0", "0x8.000p0", "0xB.504p0",
                "0x10.000p0", "0x16.A0Ap0", "0x20.000p0", "0x2D.414p0",
                "0x40.000p0", "0x5A.828p0", "0x80.000p0", "0xB5.050p0",
                "0x0.010p0", "0x0.016p0", "0x0.020p0", "0x0.02Ep0",
                "0x0.040p0", "0x0.05Ap0", "0x0.080p0", "0x0.0B6p0",
                "0x0.100p0", "0x0.16Ap0", "0x0.200p0", "0x0.2D4p0",
                "0x0.400p0", "0x0.5A8p0", "0x0.800p0", "0x0.B50p0"
            };
_ssdm_SpecConstant(exp2_x_msb_1_table);
# 2303 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<19,8> exp2_x_msb_1 = exp2_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<38,8> y_lo = exp2_x_msb_1 * exp2_x_msb_2_lsb_m_1;
            ap_ufixed<19,8> y_lo_s = y_lo;
            ap_ufixed<19,8> y_l = y_lo_s + exp2_x_msb_1;
            y = y_l;
        }

        if(I < 9) {
            bool overf_2 = 0;
#pragma unroll
 for(int j=15; j>=7+I; j--) {
                if(y[j]) {
                    overf_2 = 1;
                }
            }
            if(overf_2) {
#pragma unroll
 for(int j=15; j>=7+I; j--) {
                    y[j] = 0;
                }
#pragma unroll
 for(int j=6+I; j>=0; j--) {
                    y[j] = 1;
                }
            }
        }
        r = y;

    } else if(I_s == 5) {

        ap_fixed<33,17> x_l = x;
        ap_ufixed<32,16> y = 0;
        ap_fixed<5,5> x_l_int;
        x_l_int(4,0) = x_l(20,16);
        ap_ufixed<16,0> x_l_fract;
        x_l_fract(15,0) = x_l(15,0);

        bool overf_1 = 0;
#pragma unroll
 for(int j=20; j<32; j++) {
            if(x_l[32]!=x_l[j]) {
                overf_1 = 1;
            }
        }
        if(overf_1) {
            if(!x_l[32]) {
                y = "0xffff.ffffp0";
            }
        } else {
            ap_uint<6> x_msb_ind_1;
            x_msb_ind_1(5,0) = x_l(20,15);
            ap_uint<5> x_msb_ind_2;
            x_msb_ind_2(4,0) = x_l(14,10);
            ap_uint<5> x_msb_ind_3;
            x_msb_ind_3(4,0) = x_l(9,5);
            ap_uint<5> x_lsb_ind;
            x_lsb_ind = x_l(4,0);

            const static ap_ufixed<25,-11> exp2_x_lsb_m_1_table[32] = {
                "0x0.0p0", "0x0.0000B1725p0", "0x0.000162E52p0", "0x0.000214587p0",
                "0x0.0002C5CC3p0", "0x0.000377408p0", "0x0.000428B53p0", "0x0.0004DA2A7p0",
                "0x0.00058BA02p0", "0x0.00063D165p0", "0x0.0006EE8CFp0", "0x0.0007A0042p0",
                "0x0.0008517BBp0", "0x0.000902F3Dp0", "0x0.0009B46C6p0", "0x0.000A65E57p0",
                "0x0.000B175F0p0", "0x0.000BC8D90p0", "0x0.000C7A538p0", "0x0.000D2BCE8p0",
                "0x0.000DDD4A0p0", "0x0.000E8EC5Fp0", "0x0.000F40425p0", "0x0.000FF1BF4p0",
                "0x0.0010A33CAp0", "0x0.001154BA8p0", "0x0.00120638Dp0", "0x0.0012B7B7Bp0",
                "0x0.001369370p0", "0x0.00141AB6Cp0", "0x0.0014CC371p0", "0x0.00157DB7Dp0"
            };
_ssdm_SpecConstant(exp2_x_lsb_m_1_table);
# 2371 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<25,-11> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<30,-6> exp2_x_msb_3_m_1_table[32] = {
                "0x0.0p0", "0x0.00162F390p0", "0x0.002C605E3p0", "0x0.0042936FBp0",
                "0x0.0058C86DAp0", "0x0.006EFF584p0", "0x0.0085382FBp0", "0x0.009B72F42p0",
                "0x0.00B1AFA5Bp0", "0x0.00C7EE449p0", "0x0.00DE2ED0Fp0", "0x0.00F4714AFp0",
                "0x0.010AB5B2Dp0", "0x0.0120FC08Ap0", "0x0.0137444CAp0", "0x0.014D8E7EFp0",
                "0x0.0163DA9FBp0", "0x0.017A28AF2p0", "0x0.019078AD7p0", "0x0.01A6CA9ABp0",
                "0x0.01BD1E771p0", "0x0.01D37442Dp0", "0x0.01E9CBFE1p0", "0x0.020025A8Fp0",
                "0x0.02168143Bp0", "0x0.022CDECE7p0", "0x0.02433E495p0", "0x0.02599FB48p0",
                "0x0.027003104p0", "0x0.0286685CAp0", "0x0.029CCF99Dp0", "0x0.02B338C81p0"
            };
_ssdm_SpecConstant(exp2_x_msb_3_m_1_table);
# 2383 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<30,-6> exp2_x_msb_3_m_1 = exp2_x_msb_3_m_1_table[x_msb_ind_3];
            ap_ufixed<55,-17> f_x_msb_3_lsb = exp2_x_msb_3_m_1 * exp2_x_lsb_m_1;
            ap_ufixed<19,-17> f_x_msb_3_lsb_s = f_x_msb_3_lsb;
            ap_ufixed<30,-6> exp2_x_msb_3_lsb_m_1 = f_x_msb_3_lsb_s + exp2_x_msb_3_m_1 + exp2_x_lsb_m_1;

            const static ap_ufixed<36,0> exp2_x_msb_2_m_1_table[32] = {
                "0x0.0p0", "0x0.02C9A3E78p0", "0x0.059B0D316p0", "0x0.087451876p0",
                "0x0.0B5586CFAp0", "0x0.0E3EC32D4p0", "0x0.11301D012p0", "0x0.1429AAEA9p0",
                "0x0.172B83C7Dp0", "0x0.1A35BEB70p0", "0x0.1D4873169p0", "0x0.2063B8863p0",
                "0x0.2387A6E75p0", "0x0.26B4565E2p0", "0x0.29E9DF520p0", "0x0.2D285A6E4p0",
                "0x0.306FE0A32p0", "0x0.33C08B264p0", "0x0.371A7373Bp0", "0x0.3A7DB34E6p0",
                "0x0.3DEA64C12p0", "0x0.4160A21F7p0", "0x0.44E086062p0", "0x0.486A2B5C1p0",
                "0x0.4BFDAD536p0", "0x0.4F9B2769Dp0", "0x0.5342B569Dp0", "0x0.56F4736B5p0",
                "0x0.5AB07DD48p0", "0x0.5E76F15ADp0", "0x0.6247EB03Ap0", "0x0.662388255p0"
            };
_ssdm_SpecConstant(exp2_x_msb_2_m_1_table);
# 2398 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<36,0> exp2_x_msb_2_m_1 = exp2_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<66,-6> f_x_msb_2_lsb = exp2_x_msb_2_m_1 * exp2_x_msb_3_lsb_m_1;
            ap_ufixed<30,-6> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<36,0> exp2_x_msb_2_3_lsb_m_1 = f_x_msb_2_lsb_s + exp2_x_msb_2_m_1 + exp2_x_msb_3_lsb_m_1;

            const static ap_ufixed<36,16> exp2_x_msb_1_table[64] = {
                "0x1.00000p0", "0x1.6A09Ep0", "0x2.00000p0", "0x2.D413Dp0",
                "0x4.00000p0", "0x5.A827Ap0", "0x8.00000p0", "0xB.504F3p0",
                "0x10.00000p0", "0x16.A09E6p0", "0x20.00000p0", "0x2D.413CDp0",
                "0x40.00000p0", "0x5A.8279Ap0", "0x80.00000p0", "0xB5.04F33p0",
                "0x100.00000p0", "0x16A.09E66p0", "0x200.00000p0", "0x2D4.13CCDp0",
                "0x400.00000p0", "0x5A8.2799Ap0", "0x800.00000p0", "0xB50.4F334p0",
                "0x1000.00000p0", "0x16A0.9E668p0", "0x2000.00000p0", "0x2D41.3CCD0p0",
                "0x4000.00000p0", "0x5A82.799A0p0", "0x8000.00000p0", "0xB504.F3340p0",
                "0x0.00010p0", "0x0.00017p0", "0x0.00020p0", "0x0.0002Dp0",
                "0x0.00040p0", "0x0.0005Bp0", "0x0.00080p0", "0x0.000B5p0",
                "0x0.00100p0", "0x0.0016Ap0", "0x0.00200p0", "0x0.002D4p0",
                "0x0.00400p0", "0x0.005A8p0", "0x0.00800p0", "0x0.00B50p0",
                "0x0.01000p0", "0x0.016A1p0", "0x0.02000p0", "0x0.02D41p0",
                "0x0.04000p0", "0x0.05A82p0", "0x0.08000p0", "0x0.0B505p0",
                "0x0.10000p0", "0x0.16A0Ap0", "0x0.20000p0", "0x0.2D414p0",
                "0x0.40000p0", "0x0.5A828p0", "0x0.80000p0", "0x0.B504Fp0"
            };
_ssdm_SpecConstant(exp2_x_msb_1_table);
# 2413 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<36,16> exp2_x_msb_1 = exp2_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<72,16> y_lo = exp2_x_msb_1 * exp2_x_msb_2_3_lsb_m_1;
            ap_ufixed<36,16> y_lo_s = y_lo;
            ap_ufixed<36,16> y_l = y_lo_s + exp2_x_msb_1;
            y = y_l;
        }

        if(I<17) {
            bool overf_2 = 0;
#pragma unroll
 for(int j=31; j>=I+15; j--) {
                if(y[j]) {
                    overf_2 = 1;
                }
            }
            if(overf_2) {
#pragma unroll
 for(int j=31; j>=I+15; j--) {
                    y[j] = 0;
                }
#pragma unroll
 for(int j=I+14; j>=0; j--) {
                    y[j] = 1;
                }
            }
        }
        r = y;

    } else {
        ap_fixed<65,33> x_l = 0;
#pragma unroll
 for(int j=32-F; j<32+I; j++) {
            x_l[j] = x[j-(32-F)];
        }
#pragma unroll
 for(int j=32+I; j<=64; j++) {
            x_l[j] = x[W-1];
        }
        ap_ufixed<64,32> y = 0;
        ap_fixed<6,6> x_l_int;
        x_l_int(5,0) = x_l(37,32);
        ap_ufixed<32,0> x_l_fract;
        x_l_fract(31,0) = x_l(31,0);

        bool overf_1 = 0;
#pragma unroll
 for(int j=37; j<64; j++) {
            if(x_l[j]!=x_l[64]) {
                overf_1 = 1;
            }
        }
        if(overf_1) {
            if(!x_l[64]) {
#pragma unroll
 for(int j=0; j<64; j++) {
                    y[j] = 1;
                }
            }
        } else {
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1(7,0) = x_l(37,30);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(29,22);
            ap_uint<8> x_msb_ind_3;
            x_msb_ind_3(7,0) = x_l(21,14);
            ap_uint<8> x_msb_ind_4;
            x_msb_ind_4(7,0) = x_l(13,6);
            ap_uint<6> x_lsb_ind;
            x_lsb_ind(5,0) = x_l(5,0);

            const static ap_ufixed<42,-26> exp2_x_lsb_m_1_table[64] = {
                "0x0.0p0", "0x0.00000000B17217F81p0", "0x0.0000000162E42FF0Ap0", "0x0.00000002145647E9Ap0",
                "0x0.00000002C5C85FE32p0", "0x0.00000003773A77DD2p0", "0x0.0000000428AC8FD79p0", "0x0.00000004DA1EA7D28p0",
                "0x0.000000058B90BFCDFp0", "0x0.000000063D02D7C9Dp0", "0x0.00000006EE74EFC63p0", "0x0.000000079FE707C31p0",
                "0x0.0000000851591FC07p0", "0x0.0000000902CB37BE4p0", "0x0.00000009B43D4FBC9p0", "0x0.0000000A65AF67BB6p0",
                "0x0.0000000B17217FBAAp0", "0x0.0000000BC89397BA6p0", "0x0.0000000C7A05AFBA9p0", "0x0.0000000D2B77C7BB5p0",
                "0x0.0000000DDCE9DFBC8p0", "0x0.0000000E8E5BF7BE2p0", "0x0.0000000F3FCE0FC05p0", "0x0.0000000FF14027C2Fp0",
                "0x0.00000010A2B23FC61p0", "0x0.00000011542457C9Ap0", "0x0.0000001205966FCDBp0", "0x0.00000012B70887D24p0",
                "0x0.00000013687A9FD75p0", "0x0.0000001419ECB7DCDp0", "0x0.00000014CB5ECFE2Dp0", "0x0.000000157CD0E7E94p0",
                "0x0.000000162E42FFF03p0", "0x0.00000016DFB517F7Ap0", "0x0.0000001791272FFF9p0", "0x0.0000001842994807Fp0",
                "0x0.00000018F40B6010Dp0", "0x0.00000019A57D781A3p0", "0x0.0000001A56EF90240p0", "0x0.0000001B0861A82E6p0",
                "0x0.0000001BB9D3C0392p0", "0x0.0000001C6B45D8447p0", "0x0.0000001D1CB7F0503p0", "0x0.0000001DCE2A085C7p0",
                "0x0.0000001E7F9C20692p0", "0x0.0000001F310E38765p0", "0x0.0000001FE28050840p0", "0x0.0000002093F268923p0",
                "0x0.00000021456480A0Dp0", "0x0.00000021F6D698AFFp0", "0x0.00000022A848B0BF9p0", "0x0.0000002359BAC8CFAp0",
                "0x0.000000240B2CE0E03p0", "0x0.00000024BC9EF8F14p0", "0x0.000000256E111102Cp0", "0x0.000000261F832914Cp0",
                "0x0.00000026D0F541274p0", "0x0.000000278267593A3p0", "0x0.0000002833D9714DBp0", "0x0.00000028E54B89619p0",
                "0x0.0000002996BDA1760p0", "0x0.0000002A482FB98AEp0", "0x0.0000002AF9A1D1A04p0", "0x0.0000002BAB13E9B61p0"
            };
_ssdm_SpecConstant(exp2_x_lsb_m_1_table);
# 2501 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<42,-26> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<50,-18> exp2_x_msb_4_m_1_table[256] = {
                "0x0.0p0", "0x0.0000002C5C8601CC7p0", "0x0.00000058B90C0B48Cp0", "0x0.0000008515921C751p0",
                "0x0.000000B1721835515p0", "0x0.000000DDCE9E55DD7p0", "0x0.0000010A2B247E199p0", "0x0.0000013687AAAE059p0",
                "0x0.00000162E430E5A19p0", "0x0.0000018F40B724ED7p0", "0x0.000001BB9D3D6BE95p0", "0x0.000001E7F9C3BA951p0",
                "0x0.00000214564A10F0Dp0", "0x0.00000240B2D06EFC7p0", "0x0.0000026D0F56D4B80p0", "0x0.000002996BDD42239p0",
                "0x0.000002C5C863B73F0p0", "0x0.000002F224EA340A6p0", "0x0.0000031E8170B885Cp0", "0x0.0000034ADDF744B10p0",
                "0x0.000003773A7DD88C3p0", "0x0.000003A3970474175p0", "0x0.000003CFF38B17526p0", "0x0.000003FC5011C23D6p0",
                "0x0.00000428AC9874D86p0", "0x0.00000455091F2F234p0", "0x0.0000048165A5F11E1p0", "0x0.000004ADC22CBAC8Dp0",
                "0x0.000004DA1EB38C238p0", "0x0.000005067B3A652E2p0", "0x0.00000532D7C145E8Bp0", "0x0.0000055F34482E533p0",
                "0x0.0000058B90CF1E6D9p0", "0x0.000005B7ED561637Fp0", "0x0.000005E449DD15B24p0", "0x0.00000610A6641CDC8p0",
                "0x0.0000063D02EB2BB6Bp0", "0x0.000006695F724240Dp0", "0x0.00000695BBF9607AEp0", "0x0.000006C218808664Dp0",
                "0x0.000006EE7507B3FECp0", "0x0.0000071AD18EE948Ap0", "0x0.000007472E1626427p0", "0x0.000007738A9D6AEC2p0",
                "0x0.0000079FE724B745Dp0", "0x0.000007CC43AC0B4F7p0", "0x0.000007F8A0336708Fp0", "0x0.00000824FCBACA727p0",
                "0x0.000008515942358BEp0", "0x0.0000087DB5C9A8553p0", "0x0.000008AA125122CE8p0", "0x0.000008D66ED8A4F7Bp0",
                "0x0.00000902CB602ED0Ep0", "0x0.0000092F27E7C059Fp0", "0x0.0000095B846F59930p0", "0x0.00000987E0F6FA7C0p0",
                "0x0.000009B43D7EA314Ep0", "0x0.000009E09A06535DCp0", "0x0.00000A0CF68E0B568p0", "0x0.00000A395315CAFF3p0",
                "0x0.00000A65AF9D9257Ep0", "0x0.00000A920C2561607p0", "0x0.00000ABE68AD38190p0", "0x0.00000AEAC53516817p0",
                "0x0.00000B1721BCFC99Ep0", "0x0.00000B437E44EA623p0", "0x0.00000B6FDACCDFDA7p0", "0x0.00000B9C3754DD02Bp0",
                "0x0.00000BC893DCE1DADp0", "0x0.00000BF4F064EE62Fp0", "0x0.00000C214CED029AFp0", "0x0.00000C4DA9751E82Ep0",
                "0x0.00000C7A05FD421ADp0", "0x0.00000CA662856D62Ap0", "0x0.00000CD2BF0DA05A6p0", "0x0.00000CFF1B95DB022p0",
                "0x0.00000D2B781E1D59Cp0", "0x0.00000D57D4A667615p0", "0x0.00000D84312EB918Dp0", "0x0.00000DB08DB712805p0",
                "0x0.00000DDCEA3F7397Bp0", "0x0.00000E0946C7DC5F0p0", "0x0.00000E35A3504CD65p0", "0x0.00000E61FFD8C4FD8p0",
                "0x0.00000E8E5C6144D4Ap0", "0x0.00000EBAB8E9CC5BBp0", "0x0.00000EE715725B92Cp0", "0x0.00000F1371FAF279Bp0",
                "0x0.00000F3FCE8391109p0", "0x0.00000F6C2B0C37576p0", "0x0.00000F988794E54E3p0", "0x0.00000FC4E41D9AF4Ep0",
                "0x0.00000FF140A6584B8p0", "0x0.0000101D9D2F1D521p0", "0x0.00001049F9B7EA08Ap0", "0x0.000010765640BE6F1p0",
                "0x0.000010A2B2C99A857p0", "0x0.000010CF0F527E4BCp0", "0x0.000010FB6BDB69C21p0", "0x0.00001127C8645CE84p0",
                "0x0.0000115424ED57BE6p0", "0x0.0000118081765A447p0", "0x0.000011ACDDFF647A7p0", "0x0.000011D93A8876607p0",
                "0x0.0000120597118FF65p0", "0x0.00001231F39AB13C2p0", "0x0.0000125E5023DA31Ep0", "0x0.0000128AACAD0AD7Ap0",
                "0x0.000012B70936432D4p0", "0x0.000012E365BF8332Dp0", "0x0.0000130FC248CAE85p0", "0x0.0000133C1ED21A4DDp0",
                "0x0.000013687B5B71633p0", "0x0.00001394D7E4D0288p0", "0x0.000013C1346E369DDp0", "0x0.000013ED90F7A4C30p0",
                "0x0.00001419ED811A982p0", "0x0.000014464A0A981D4p0", "0x0.00001472A6941D524p0", "0x0.0000149F031DAA373p0",
                "0x0.000014CB5FA73ECC1p0", "0x0.000014F7BC30DB10Fp0", "0x0.0000152418BA7F05Bp0", "0x0.0000155075442AAA6p0",
                "0x0.0000157CD1CDDDFF1p0", "0x0.000015A92E579903Ap0", "0x0.000015D58AE15BB83p0", "0x0.00001601E76B261CAp0",
                "0x0.0000162E43F4F8310p0", "0x0.0000165AA07ED1F56p0", "0x0.00001686FD08B369Ap0", "0x0.000016B359929C8DEp0",
                "0x0.000016DFB61C8D620p0", "0x0.0000170C12A685E62p0", "0x0.000017386F30861A2p0", "0x0.00001764CBBA8DFE1p0",
                "0x0.0000179128449D920p0", "0x0.000017BD84CEB4D5Dp0", "0x0.000017E9E158D3C9Ap0", "0x0.000018163DE2FA6D6p0",
                "0x0.000018429A6D28C10p0", "0x0.0000186EF6F75EC4Ap0", "0x0.0000189B53819C782p0", "0x0.000018C7B00BE1DBAp0",
                "0x0.000018F40C962EEF0p0", "0x0.00001920692083B26p0", "0x0.0000194CC5AAE025Bp0", "0x0.0000197922354448Ep0",
                "0x0.000019A57EBFB01C1p0", "0x0.000019D1DB4A239F3p0", "0x0.000019FE37D49ED23p0", "0x0.00001A2A945F21B53p0",
                "0x0.00001A56F0E9AC482p0", "0x0.00001A834D743E8B0p0", "0x0.00001AAFA9FED87DCp0", "0x0.00001ADC06897A208p0",
                "0x0.00001B08631423733p0", "0x0.00001B34BF9ED475Dp0", "0x0.00001B611C298D286p0", "0x0.00001B8D78B44D8ADp0",
                "0x0.00001BB9D53F159D4p0", "0x0.00001BE631C9E55FAp0", "0x0.00001C128E54BCD1Fp0", "0x0.00001C3EEADF9BF43p0",
                "0x0.00001C6B476A82C66p0", "0x0.00001C97A3F571488p0", "0x0.00001CC40080677A9p0", "0x0.00001CF05D0B655C9p0",
                "0x0.00001D1CB9966AEE8p0", "0x0.00001D49162178306p0", "0x0.00001D7572AC8D223p0", "0x0.00001DA1CF37A9C40p0",
                "0x0.00001DCE2BC2CE15Bp0", "0x0.00001DFA884DFA175p0", "0x0.00001E26E4D92DC8Ep0", "0x0.00001E534164692A6p0",
                "0x0.00001E7F9DEFAC3BEp0", "0x0.00001EABFA7AF6FD4p0", "0x0.00001ED85706496E9p0", "0x0.00001F04B391A38FEp0",
                "0x0.00001F31101D05611p0", "0x0.00001F5D6CA86EE23p0", "0x0.00001F89C933E0135p0", "0x0.00001FB625BF58F45p0",
                "0x0.00001FE2824AD9855p0", "0x0.0000200EDED661C63p0", "0x0.0000203B3B61F1B71p0", "0x0.0000206797ED8957Dp0",
                "0x0.00002093F47928A89p0", "0x0.000020C05104CFA93p0", "0x0.000020ECAD907E59Dp0", "0x0.000021190A1C34BA6p0",
                "0x0.0000214566A7F2CAEp0", "0x0.00002171C333B88B4p0", "0x0.0000219E1FBF85FBAp0", "0x0.000021CA7C4B5B1BFp0",
                "0x0.000021F6D8D737EC3p0", "0x0.0000222335631C6C6p0", "0x0.0000224F91EF089C7p0", "0x0.0000227BEE7AFC7C8p0",
                "0x0.000022A84B06F80C8p0", "0x0.000022D4A792FB4C7p0", "0x0.00002301041F063C5p0", "0x0.0000232D60AB18DC3p0",
                "0x0.00002359BD37332BFp0", "0x0.0000238619C3552BAp0", "0x0.000023B2764F7EDB4p0", "0x0.000023DED2DBB03ADp0",
                "0x0.0000240B2F67E94A5p0", "0x0.000024378BF42A09Dp0", "0x0.00002463E88072793p0", "0x0.00002490450CC2988p0",
                "0x0.000024BCA1991A67Dp0", "0x0.000024E8FE2579E70p0", "0x0.000025155AB1E1163p0", "0x0.00002541B73E4FF54p0",
                "0x0.0000256E13CAC6845p0", "0x0.0000259A705744C34p0", "0x0.000025C6CCE3CAB23p0", "0x0.000025F3297058511p0",
                "0x0.0000261F85FCED9FDp0", "0x0.0000264BE2898A9E9p0", "0x0.000026783F162F4D4p0", "0x0.000026A49BA2DBABEp0",
                "0x0.000026D0F82F8FBA7p0", "0x0.000026FD54BC4B78Fp0", "0x0.00002729B1490EE75p0", "0x0.000027560DD5DA05Bp0",
                "0x0.000027826A62ACD41p0", "0x0.000027AEC6EF87525p0", "0x0.000027DB237C69808p0", "0x0.000028078009535EAp0",
                "0x0.00002833DC9644ECBp0", "0x0.0000286039233E2ABp0", "0x0.0000288C95B03F18Bp0", "0x0.000028B8F23D47B69p0",
                "0x0.000028E54ECA58046p0", "0x0.00002911AB5770023p0", "0x0.0000293E07E48FAFEp0", "0x0.0000296A6471B70D9p0",
                "0x0.00002996C0FEE61B2p0", "0x0.000029C31D8C1CD8Bp0", "0x0.000029EF7A195B463p0", "0x0.00002A1BD6A6A1639p0",
                "0x0.00002A483333EF30Fp0", "0x0.00002A748FC144AE4p0", "0x0.00002AA0EC4EA1DB8p0", "0x0.00002ACD48DC06B8Bp0",
                "0x0.00002AF9A5697345Dp0", "0x0.00002B2601F6E782Ep0", "0x0.00002B525E84636FEp0", "0x0.00002B7EBB11E70CDp0",
                "0x0.00002BAB179F7259Bp0", "0x0.00002BD7742D05568p0", "0x0.00002C03D0BAA0035p0", "0x0.00002C302D4842600p0"
            };
_ssdm_SpecConstant(exp2_x_msb_4_m_1_table);
# 2521 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<50,-18> exp2_x_msb_4_m_1 = exp2_x_msb_4_m_1_table[x_msb_ind_4];
            ap_ufixed<92,-44> f_x_msb_4_lsb = exp2_x_lsb_m_1 * exp2_x_msb_4_m_1;
            ap_ufixed<24,-44> f_x_msb_4_lsb_s = f_x_msb_4_lsb;
            ap_ufixed<50,-18> exp2_x_msb_4_lsb_m_1 = f_x_msb_4_lsb_s + exp2_x_msb_4_m_1 + exp2_x_lsb_m_1;

            const static ap_ufixed<58,-10> exp2_x_msb_3_m_1_table[256] = {
                "0x0.0p0", "0x0.00002C5C89D5EC6CAp0", "0x0.000058B91B5BC9AE3p0", "0x0.00008515B4919919Ap0",
                "0x0.0000B17255775C040p0", "0x0.0000DDCEFE0D13C26p0", "0x0.00010A2BAE52C1A9Bp0", "0x0.000136886648670F0p0",
                "0x0.000162E525EE05475p0", "0x0.00018F41ED439DA7Bp0", "0x0.0001BB9EBC4931853p0", "0x0.0001E7FB92FEC234Bp0",
                "0x0.000214587164510B6p0", "0x0.000240B55779DF5E3p0", "0x0.00026D12453F6E823p0", "0x0.0002996F3AB4FFCC6p0",
                "0x0.0002C5CC37DA9491Dp0", "0x0.0002F2293CB02E278p0", "0x0.00031E864935CDE29p0", "0x0.00034AE35D6B7517Ep0",
                "0x0.000377407951251C9p0", "0x0.0003A39D9CE6DF45Bp0", "0x0.0003CFFAC82CA4E84p0", "0x0.0003FC57FB2277595p0",
                "0x0.000428B535C857EDDp0", "0x0.00045512781E47FAFp0", "0x0.0004816FC22448D5Ap0", "0x0.0004ADCD13DA5BD2Fp0",
                "0x0.0004DA2A6D408247Ep0", "0x0.00050687CE56BD89Ap0", "0x0.000532E5371D0EED1p0", "0x0.00055F42A79377C75p0",
                "0x0.00058BA01FB9F96D7p0", "0x0.0005B7FD9F9095347p0", "0x0.0005E45B27174C716p0", "0x0.000610B8B64E20794p0",
                "0x0.00063D164D3512A14p0", "0x0.00066973EBCC243E4p0", "0x0.000695D1921356A57p0", "0x0.0006C22F400AAB2BCp0",
                "0x0.0006EE8CF5B223266p0", "0x0.00071AEAB309BFEA4p0", "0x0.00074748781182CC7p0", "0x0.000773A644C96D221p0",
                "0x0.0007A004193180402p0", "0x0.0007CC61F549BD7BCp0", "0x0.0007F8BFD9122629Ep0", "0x0.0008251DC48ABB9FAp0",
                "0x0.0008517BB7B37F322p0", "0x0.00087DD9B28C72365p0", "0x0.0008AA37B51596015p0", "0x0.0008D695BF4EEBE83p0",
                "0x0.000902F3D13875400p0", "0x0.00092F51EAD2335DCp0", "0x0.00095BB00C1C2796Ap0", "0x0.0009880E3516533FAp0",
                "0x0.0009B46C65C0B7ADCp0", "0x0.0009E0CA9E1B56363p0", "0x0.000A0D28DE26302DFp0", "0x0.000A398725E146EA2p0",
                "0x0.000A65E5754C9BBFBp0", "0x0.000A9243CC683003Ep0", "0x0.000ABEA22B34050BAp0", "0x0.000AEB0091B01C2C1p0",
                "0x0.000B175EFFDC76BA4p0", "0x0.000B43BD75B9160B4p0", "0x0.000B701BF345FB742p0", "0x0.000B9C7A7883284A1p0",
                "0x0.000BC8D905709DE20p0", "0x0.000BF5379A0E5D912p0", "0x0.000C2196365C68AC6p0", "0x0.000C4DF4DA5AC0890p0",
                "0x0.000C7A538609667C0p0", "0x0.000CA6B239685BDA6p0", "0x0.000CD310F477A1F96p0", "0x0.000CFF6FB7373A2DFp0",
                "0x0.000D2BCE81A725CD4p0", "0x0.000D582D53C7662C6p0", "0x0.000D848C2D97FCA05p0", "0x0.000DB0EB0F18EA7E4p0",
                "0x0.000DDD49F84A311B4p0", "0x0.000E09A8E92BD1CC6p0", "0x0.000E3607E1BDCDE6Cp0", "0x0.000E6266E20026BF7p0",
                "0x0.000E8EC5E9F2DDAB9p0", "0x0.000EBB24F995F4003p0", "0x0.000EE78410E96B126p0", "0x0.000F13E32FED44375p0",
                "0x0.000F404256A180C40p0", "0x0.000F6CA18506220D9p0", "0x0.000F9900BB1B29692p0", "0x0.000FC55FF8E0982BDp0",
                "0x0.000FF1BF3E566FAAAp0", "0x0.00101E1E8B7CB13ACp0", "0x0.00104A7DE0535E314p0", "0x0.001076DD3CDA77E34p0",
                "0x0.0010A33CA111FFA5Dp0", "0x0.0010CF9C0CF9F6CE1p0", "0x0.0010FBFB80925EB11p0", "0x0.0011285AFBDB38A40p0",
                "0x0.001154BA7ED485FC0p0", "0x0.0011811A097E480E0p0", "0x0.0011AD799BD8802F5p0", "0x0.0011D9D935E32FB4Fp0",
                "0x0.00120638D79E57F3Fp0", "0x0.001232988109FA419p0", "0x0.00125EF8322617F2Dp0", "0x0.00128B57EAF2B25CDp0",
                "0x0.0012B7B7AB6FCAD4Bp0", "0x0.0012E417739D62AFAp0", "0x0.00131077437B7B42Ap0", "0x0.00133CD71B0A15E2Ep0",
                "0x0.00136936FA4933E58p0", "0x0.00139596E138D69F9p0", "0x0.0013C1F6CFD8FF663p0", "0x0.0013EE56C629AF8E9p0",
                "0x0.00141AB6C42AE86DBp0", "0x0.00144716C9DCAB58Dp0", "0x0.00147376D73EF9A50p0", "0x0.00149FD6EC51D4A76p0",
                "0x0.0014CC3709153DB51p0", "0x0.0014F8972D8936234p0", "0x0.001524F759ADBF46Fp0", "0x0.001551578D82DA755p0",
                "0x0.00157DB7C90889038p0", "0x0.0015AA180C3ECC46Bp0", "0x0.0015D6785725A593Fp0", "0x0.001602D8A9BD16406p0",
                "0x0.00162F3904051FA13p0", "0x0.00165B9965FDC30B7p0", "0x0.001687F9CFA701D45p0", "0x0.0016B45A4100DD50Ep0",
                "0x0.0016E0BABA0B56D66p0", "0x0.00170D1B3AC66FB9Ep0", "0x0.0017397BC33229508p0", "0x0.001765DC534E84EF7p0",
                "0x0.0017923CEB1B83EBCp0", "0x0.0017BE9D8A99279ABp0", "0x0.0017EAFE31C771515p0", "0x0.0018175EE0A66264Cp0",
                "0x0.001843BF9735FC2A3p0", "0x0.0018702055763FF6Cp0", "0x0.00189C811B672F1FAp0", "0x0.0018C8E1E908CAF9Ep0",
                "0x0.0018F542BE5B14DABp0", "0x0.001921A39B5E0E174p0", "0x0.00194E048011B804Ap0", "0x0.00197A656C7613F81p0",
                "0x0.0019A6C6608B2346Ap0", "0x0.0019D3275C50E7458p0", "0x0.0019FF885FC76149Dp0", "0x0.001A2BE96AEE92A8Cp0",
                "0x0.001A584A7DC67CB77p0", "0x0.001A84AB984F20CB1p0", "0x0.001AB10CBA888038Cp0", "0x0.001ADD6DE4729C55Ap0",
                "0x0.001B09CF160D7676Fp0", "0x0.001B36304F590FF1Dp0", "0x0.001B629190556A1B5p0", "0x0.001B8EF2D9028648Cp0",
                "0x0.001BBB54296065CF2p0", "0x0.001BE7B5816F0A03Cp0", "0x0.001C1416E12E743BBp0", "0x0.001C4078489EA5CC2p0",
                "0x0.001C6CD9B7BFA00A4p0", "0x0.001C993B2E91644B3p0", "0x0.001CC59CAD13F3E42p0", "0x0.001CF1FE3347502A4p0",
                "0x0.001D1E5FC12B7A72Bp0", "0x0.001D4AC156C07412Ap0", "0x0.001D7722F4063E5F4p0", "0x0.001DA38498FCDAADBp0",
                "0x0.001DCFE645A44A533p0", "0x0.001DFC47F9FC8EA4Dp0", "0x0.001E28A9B605A8F7Dp0", "0x0.001E550B79BF9AA16p0",
                "0x0.001E816D452A64F6Ap0", "0x0.001EADCF1846094CCp0", "0x0.001EDA30F31288F8Ep0", "0x0.001F0692D58FE5505p0",
                "0x0.001F32F4BFBE1FA82p0", "0x0.001F5F56B19D39559p0", "0x0.001F8BB8AB2D33ADCp0", "0x0.001FB81AAC6E1005Ep0",
                "0x0.001FE47CB55FCFB33p0", "0x0.002010DEC602740ACp0", "0x0.00203D40DE55FE61Ep0", "0x0.002069A2FE5A700DAp0",
                "0x0.00209605260FCA635p0", "0x0.0020C26755760EB80p0", "0x0.0020EEC98C8D3E60Fp0", "0x0.00211B2BCB555AB35p0",
                "0x0.0021478E11CE65045p0", "0x0.002173F05FF85EA93p0", "0x0.0021A052B5D348F70p0", "0x0.0021CCB5135F25430p0",
                "0x0.0021F917789BF4E26p0", "0x0.00222579E589B92A6p0", "0x0.002251DC5A2873702p0", "0x0.00227E3ED6782508Ep0",
                "0x0.0022AAA15A78CF49Cp0", "0x0.0022D703E62A73880p0", "0x0.00230366798D1318Dp0", "0x0.00232FC914A0AF516p0",
                "0x0.00235C2BB7654986Fp0", "0x0.0023888E61DAE30EAp0", "0x0.0023B4F114017D3DBp0", "0x0.0023E153CDD919695p0",
                "0x0.00240DB68F61B8E6Cp0", "0x0.00243A19589B5D0B2p0", "0x0.0024667C2986072BAp0", "0x0.002492DF0221B89D9p0",
                "0x0.0024BF41E26E72B62p0", "0x0.0024EBA4CA6C36CA7p0", "0x0.00251807BA1B062FDp0", "0x0.0025446AB17AE23B5p0",
                "0x0.002570CDB08BCC425p0", "0x0.00259D30B74DC599Fp0", "0x0.0025C993C5C0CF977p0", "0x0.0025F5F6DBE4EB900p0",
                "0x0.00262259F9BA1AD8Dp0", "0x0.00264EBD1F405EC72p0", "0x0.00267B204C77B8B03p0", "0x0.0026A783816029E92p0",
                "0x0.0026D3E6BDF9B3C74p0", "0x0.0027004A0244579FCp0", "0x0.00272CAD4E4016C7Dp0", "0x0.00275910A1ECF294Bp0",
                "0x0.00278573FD4AEC5BAp0", "0x0.0027B1D7605A0571Cp0", "0x0.0027DE3ACB1A3F2C6p0", "0x0.00280A9E3D8B9AE0Cp0",
                "0x0.00283701B7AE19E40p0", "0x0.002863653981BD8B6p0", "0x0.00288FC8C306872C3p0", "0x0.0028BC2C543C781B9p0",
                "0x0.0028E88FED2391AECp0", "0x0.002914F38DBBD53B1p0", "0x0.0029415736054415Ap0", "0x0.00296DBAE5FFDF93Cp0",
                "0x0.00299A1E9DABA90A9p0", "0x0.0029C6825D08A1CF7p0", "0x0.0029F2E62416CB378p0", "0x0.002A1F49F2D626981p0",
                "0x0.002A4BADC946B5464p0", "0x0.002A7811A76878977p0", "0x0.002AA4758D3B71E0Cp0", "0x0.002AD0D97ABFA2778p0",
                "0x0.002AFD3D6FF50BB0Ep0", "0x0.002B29A16CDBAEE23p0", "0x0.002B560571738D609p0", "0x0.002B82697DBCA8816p0",
                "0x0.002BAECD91B70199Cp0", "0x0.002BDB31AD6299FF0p0", "0x0.002C0795D0BF73066p0", "0x0.002C33F9FBCD8E052p0"
            };
_ssdm_SpecConstant(exp2_x_msb_3_m_1_table);
# 2592 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<58,-10> exp2_x_msb_3_m_1 = exp2_x_msb_3_m_1_table[x_msb_ind_3];
            ap_ufixed<108,-28> f_x_msb_3_lsb = exp2_x_msb_3_m_1 * exp2_x_msb_4_lsb_m_1;
            ap_ufixed<40, -28> f_x_msb_3_lsb_s = f_x_msb_3_lsb;
            ap_ufixed<58, -10> exp2_x_msb_3_4_lsb_m_1 = f_x_msb_3_lsb_s + exp2_x_msb_3_m_1 + exp2_x_msb_4_lsb_m_1;

            const static ap_ufixed<68,0> exp2_x_msb_2_m_1_table[256] = {
                "0x0.0p0", "0x0.002C605E2E8CEC507p0", "0x0.0058C86DA1C09EA20p0", "0x0.0085382FAEF831DA9p0",
                "0x0.00B1AFA5ABCBED613p0", "0x0.00DE2ED0EE0F4F5FDp0", "0x0.010AB5B2CBD117074p0", "0x0.0137444C9B5B4ED49p0",
                "0x0.0163DA9FB33356D85p0", "0x0.019078AD6A19EEFF7p0", "0x0.01BD1E77170B415E7p0", "0x0.01E9CBFE113EEC7DCp0",
                "0x0.02168143B0280DA82p0", "0x0.02433E494B754B3ADp0", "0x0.027003103B10DEF7Dp0", "0x0.029CCF99D720A0593p0",
                "0x0.02C9A3E778060EE6Fp0", "0x0.02F67FFA765E5C8E5p0", "0x0.032363D42B0277FAAp0", "0x0.03504F75EF0716F0Cp0",
                "0x0.037D42E11BBCC0AB4p0", "0x0.03AA3E170AAFD8396p0", "0x0.03D7411915A8A6DF0p0", "0x0.04044BE896AB66771p0",
                "0x0.04315E86E7F84BD74p0", "0x0.045E78F5640B9135Cp0", "0x0.048B9B35659D8090Ep0", "0x0.04B8C54847A27E186p0",
                "0x0.04E5F72F654B12987p0", "0x0.051330EC1A03F5E6Ap0", "0x0.0540727FC1761950Dp0", "0x0.056DBBEBB786B20D9p0",
                "0x0.059B0D31585743AE8p0", "0x0.05C866520045AA948p0", "0x0.05F5C74F0BEC2665Bp0", "0x0.06233029D82164855p0",
                "0x0.0650A0E3C1F88A8D2p0", "0x0.067E197E26C140C90p0", "0x0.06AB99FA6407BCB43p0", "0x0.06D92259D794CB783p0",
                "0x0.0706B29DDF6DDC6DCp0", "0x0.07344AC7D9D50B9FCp0", "0x0.0761EAD925492C4F5p0", "0x0.078F92D32085D37A9p0",
                "0x0.07BD42B72A8362646p0", "0x0.07EAFA86A277111EFp0", "0x0.0818BA42E7D2F916Ep0", "0x0.084681ED5A461FA1Ap0",
                "0x0.0874518759BC808C3p0", "0x0.08A22912465F18AD3p0", "0x0.08D0088F8093F0774p0", "0x0.08FDF00068FE268ECp0",
                "0x0.092BDF66607DFA5FEp0", "0x0.0959D6C2C830D6B7Fp0", "0x0.0987D61701715C5F5p0", "0x0.09B5DD646DD76CB61p0",
                "0x0.09E3ECAC6F3834522p0", "0x0.0A1203F067A6359F1p0", "0x0.0A402331B97153804p0", "0x0.0A6E4A71C726DBF42p0",
                "0x0.0A9C79B1F39192BA3p0", "0x0.0ACAB0F3A1B9BBF9Fp0", "0x0.0AF8F03834E526EC8p0", "0x0.0B273781109738876p0",
                "0x0.0B5586CF9890F6299p0", "0x0.0B83DE2530D1104A2p0", "0x0.0BB23D833D93ED290p0", "0x0.0BE0A4EB2353B3818p0",
                "0x0.0C0F145E46C8553E6p0", "0x0.0C3D8BDE0CE79A306p0", "0x0.0C6C0B6BDAE52AC5Dp0", "0x0.0C9A930916329AC51p0",
                "0x0.0CC922B7247F7407Bp0", "0x0.0CF7BA776BB94138Ap0", "0x0.0D265A4B520B98932p0", "0x0.0D5502343DE026A4Bp0",
                "0x0.0D83B23395DEB90FBp0", "0x0.0DB26A4AC0ED4950Dp0", "0x0.0DE12A7B263007860p0", "0x0.0E0FF2C62D0965371p0",
                "0x0.0E3EC32D3D1A20207p0", "0x0.0E6D9BB1BE414CFFDp0", "0x0.0E9C7C55189C62628p0", "0x0.0ECB6518B4874375Bp0",
                "0x0.0EFA55FDFA9C4AD89p0", "0x0.0F294F0653B45570Ap0", "0x0.0F58503328E6CD3F5p0", "0x0.0F875985E389B439Ep0",
                "0x0.0FB66AFFED31AF232p0", "0x0.0FE584A2AFB210670p0", "0x0.1014A66F951CE2F7Ep0", "0x0.1043D06807C2F52E1p0",
                "0x0.1073028D7233E3A8Ep0", "0x0.10A23CE13F3E2431Dp0", "0x0.10D17F64D9EF10A19p0", "0x0.1100CA19AD92F1C6Bp0",
                "0x0.11301D0125B50A4ECp0", "0x0.115F781CAE1FA1B08p0", "0x0.118EDB6DB2DC0F18Dp0", "0x0.11BE46F5A032C458Fp0",
                "0x0.11EDBAB5E2AB58D6Fp0", "0x0.121D36AFE70C947FBp0", "0x0.124CBAE51A5C7ABB5p0", "0x0.127C4756E9E055631p0",
                "0x0.12ABDC06C31CBFB93p0", "0x0.12DB78F613D5B162Dp0", "0x0.130B1E264A0E8963Cp0", "0x0.133ACB98D40A191C1p0",
                "0x0.136A814F204AAF478p0", "0x0.139A3F4A9D9222FF2p0", "0x0.13CA058CBAE1DEBC9p0", "0x0.13F9D416E77AEB5F6p0",
                "0x0.1429AAEA92DDFB341p0", "0x0.14598A092CCB74FD3p0", "0x0.1489717425437EFE9p0", "0x0.14B9612CEC860A09Ep0",
                "0x0.14E95934F312DC8DCp0", "0x0.1519598DA9A99DA67p0", "0x0.154962388149E0304p0", "0x0.15797336EB332DDCAp0",
                "0x0.15A98C8A58E512481p0", "0x0.15D9AE343C1F26130p0", "0x0.1609D83606E119FBFp0", "0x0.163A0A912B6AC1FBBp0",
                "0x0.166A45471C3C2063Dp0", "0x0.169A88594C1570FE6p0", "0x0.16CAD3C92DF734306p0", "0x0.16FB279835223A1D7p0",
                "0x0.172B83C7D517ADCDFp0", "0x0.175BE85981992056Cp0", "0x0.178C554EAEA894030p0", "0x0.17BCCAA8D088877FCp0",
                "0x0.17ED48695BBC0109Ep0", "0x0.181DCE91C506999D8p0", "0x0.184E5D23816C88275p0", "0x0.187EF4200632ACB89p0",
                "0x0.18AF9388C8DE9BBBFp0", "0x0.18E03B5F3F36A92D4p0", "0x0.1910EBA4DF41F3D2Ap0", "0x0.1941A45B1F487077Ap0",
                "0x0.1972658375D2F52ABp0", "0x0.19A32F1F59AB447C4p0", "0x0.19D4013041DC18BF8p0", "0x0.1A04DBB7A5B12F4DCp0",
                "0x0.1A35BEB6FCB753CB7p0", "0x0.1A66AA2FBEBC6B6ECp0", "0x0.1A979E2363CF8048Fp0", "0x0.1AC89A936440CC90Dp0",
                "0x0.1AF99F8138A1C5EFEp0", "0x0.1B2AACEE59C528D0Dp0", "0x0.1B5BC2DC40BF03B07p0", "0x0.1B8CE14C66E4C2704p0",
                "0x0.1BBE084045CD39AB2p0", "0x0.1BEF37B95750B20C0p0", "0x0.1C206FB91588F3A67p0", "0x0.1C51B040FAD151512p0",
                "0x0.1C82F95281C6B4026p0", "0x0.1CB44AEF2547A62ECp0", "0x0.1CE5A51860745F298p0", "0x0.1D1707CFAEAECE86Cp0",
                "0x0.1D4873168B9AA7806p0", "0x0.1D79E6EE731D6C5BDp0", "0x0.1DAB6358E15E79D2Fp0", "0x0.1DDCE85752C7127E2p0",
                "0x0.1E0E75EB44026A409p0", "0x0.1E400C1631FDB1B6Ap0", "0x0.1E71AAD999E821A64p0", "0x0.1EA35236F9330670Ep0",
                "0x0.1ED5022FCD91CB882p0", "0x0.1F06BAC594FA06E38p0", "0x0.1F387BF9CDA384793p0", "0x0.1F6A45CDF60851B7Cp0",
                "0x0.1F9C18438CE4C902Bp0", "0x0.1FCDF35C11379D307p0", "0x0.1FFFD7190241E50A9p0", "0x0.2031C37BDF8726CFFp0",
                "0x0.2063B88628CD63B8Fp0", "0x0.2095B6395E1D237DAp0", "0x0.20C7BC96FFC17FDDEp0", "0x0.20F9CBA08E48302B7p0",
                "0x0.212BE3578A8194D65p0", "0x0.215E03BD7580C2FABp0", "0x0.21902CD3D09B8FF15p0", "0x0.21C25E9C1D6A9CE17p0",
                "0x0.21F49917DDC962553p0", "0x0.2226DC4893D63BCFAp0", "0x0.2259282FC1F273650p0", "0x0.228B7CCEEAC24D54Fp0",
                "0x0.22BDDA27912D13A6Ap0", "0x0.22F0403B385D21C70p0", "0x0.2322AF0B63BFF0291p0", "0x0.2355269997061FE83p0",
                "0x0.2387A6E75623866C2p0", "0x0.23BA2FF6254F390FBp0", "0x0.23ECC1C7890398C8Ap0", "0x0.241F5C5D05FE5DD26p0",
                "0x0.2451FFB82140A35A0p0", "0x0.2484ABDA600EF32CEp0", "0x0.24B760C547F15168Fp0", "0x0.24EA1E7A5EB3482F4p0",
                "0x0.251CE4FB2A63F3583p0", "0x0.254FB44931560C2A2p0", "0x0.25828C65FA1FF511Fp0", "0x0.25B56D530B9BC55D9p0",
                "0x0.25E85711ECE754F87p0", "0x0.261B49A42564482A2p0", "0x0.264E450B3CB81B573p0", "0x0.26814948BACC2EC3Ap0",
                "0x0.26B4565E27CDD257Ap0", "0x0.26E76C4D0C2E51669p0", "0x0.271A8B16F0A2FE778p0", "0x0.274DB2BD5E253F101p0",
                "0x0.2780E341DDF29781Ap0", "0x0.27B41CA5F98CB6B7Ep0", "0x0.27E75EEB3AB9820A2p0", "0x0.281AAA132B83210E1p0",
                "0x0.284DFE1F5638096CFp0", "0x0.28815B11456B0ABADp0", "0x0.28B4C0EA83F35A4FAp0", "0x0.28E82FAC9CEC9F225p0",
                "0x0.291BA7591BB6FDA67p0", "0x0.294F27F18BF723AB3p0", "0x0.2982B1777996543D0p0", "0x0.29B643EC70C273890p0",
                "0x0.29E9DF51FDEE12C26p0", "0x0.2A1D83A9ADD07C0A3p0", "0x0.2A5130F50D65BE58Dp0", "0x0.2A84E735A9EEB96A0p0",
                "0x0.2AB8A66D10F129AA3p0", "0x0.2AEC6E9CD037B426Bp0", "0x0.2B203FC675D1F27F9p0", "0x0.2B5419EB90147EDB7p0",
                "0x0.2B87FD0DAD98FFDDFp0", "0x0.2BBBE92E5D3E349F5p0", "0x0.2BEFDE4F2E2800A73p0", "0x0.2C23DC71AFBF77E86p0",
                "0x0.2C57E39771B2EABFBp0", "0x0.2C8BF3C203F5F1F3Fp0", "0x0.2CC00CF2F6C17AB8Dp0", "0x0.2CF42F2BDA93D2B35p0",
                "0x0.2D285A6E4030B4009p0", "0x0.2D5C8EBBB8A1513E7p0", "0x0.2D90CC15D53461967p0", "0x0.2DC5127E277E2CCAFp0",
                "0x0.2DF961F641589745Bp0", "0x0.2E2DBA7FB4E32E298p0", "0x0.2E621C1C148333651p0", "0x0.2E9686CCF2E3A9C88p0",
                "0x0.2ECAFA93E2F5611CAp0", "0x0.2EFF777277EF023C8p0", "0x0.2F33FD6A454D1B313p0", "0x0.2F688C7CDED22B4F1p0",
                "0x0.2F9D24ABD886AF562p0", "0x0.2FD1C5F8C6B92D937p0", "0x0.300670653DFE42058p0", "0x0.303B23F2D330AA821p0"
            };
_ssdm_SpecConstant(exp2_x_msb_2_m_1_table);
# 2663 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<68,0> exp2_x_msb_2_m_1 = exp2_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<126,-10> f_x_msb_2_lsb = exp2_x_msb_2_m_1 * exp2_x_msb_3_4_lsb_m_1;
            ap_ufixed<58, -10> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<68,0> exp2_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_lsb_s + exp2_x_msb_2_m_1 + exp2_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<68,32> exp2_x_msb_1_table[256] = {
                "0x1.000000000p0", "0x1.306FE0A32p0", "0x1.6A09E667Fp0", "0x1.AE89F995Bp0",
                "0x2.000000000p0", "0x2.60DFC1463p0", "0x2.D413CCCFEp0", "0x3.5D13F32B6p0",
                "0x4.000000000p0", "0x4.C1BF828C7p0", "0x5.A827999FDp0", "0x6.BA27E656Bp0",
                "0x8.000000000p0", "0x9.837F0518Ep0", "0xB.504F333FAp0", "0xD.744FCCAD7p0",
                "0x10.000000000p0", "0x13.06FE0A31Bp0", "0x16.A09E667F4p0", "0x1A.E89F995ADp0",
                "0x20.000000000p0", "0x26.0DFC14637p0", "0x2D.413CCCFE7p0", "0x35.D13F32B5Ap0",
                "0x40.000000000p0", "0x4C.1BF828C6Ep0", "0x5A.827999FCFp0", "0x6B.A27E656B5p0",
                "0x80.000000000p0", "0x98.37F0518DCp0", "0xB5.04F333F9Ep0", "0xD7.44FCCAD6Ap0",
                "0x100.000000000p0", "0x130.6FE0A31B7p0", "0x16A.09E667F3Cp0", "0x1AE.89F995AD4p0",
                "0x200.000000000p0", "0x260.DFC14636Ep0", "0x2D4.13CCCFE78p0", "0x35D.13F32B5A7p0",
                "0x400.000000000p0", "0x4C1.BF828C6DCp0", "0x5A8.27999FCEFp0", "0x6BA.27E656B4Fp0",
                "0x800.000000000p0", "0x983.7F0518DB9p0", "0xB50.4F333F9DEp0", "0xD74.4FCCAD69Dp0",
                "0x1000.000000000p0", "0x1306.FE0A31B71p0", "0x16A0.9E667F3BDp0", "0x1AE8.9F995AD3Bp0",
                "0x2000.000000000p0", "0x260D.FC14636E3p0", "0x2D41.3CCCFE77Ap0", "0x35D1.3F32B5A76p0",
                "0x4000.000000000p0", "0x4C1B.F828C6DC5p0", "0x5A82.7999FCEF3p0", "0x6BA2.7E656B4EBp0",
                "0x8000.000000000p0", "0x9837.F0518DB8Bp0", "0xB504.F333F9DE6p0", "0xD744.FCCAD69D7p0",
                "0x10000.000000000p0", "0x1306F.E0A31B715p0", "0x16A09.E667F3BCDp0", "0x1AE89.F995AD3ADp0",
                "0x20000.000000000p0", "0x260DF.C14636E2Ap0", "0x2D413.CCCFE7799p0", "0x35D13.F32B5A75Bp0",
                "0x40000.000000000p0", "0x4C1BF.828C6DC55p0", "0x5A827.999FCEF32p0", "0x6BA27.E656B4EB5p0",
                "0x80000.000000000p0", "0x9837F.0518DB8A9p0", "0xB504F.333F9DE65p0", "0xD744F.CCAD69D6Bp0",
                "0x100000.000000000p0", "0x1306FE.0A31B7153p0", "0x16A09E.667F3BCC9p0", "0x1AE89F.995AD3AD6p0",
                "0x200000.000000000p0", "0x260DFC.14636E2A6p0", "0x2D413C.CCFE77992p0", "0x35D13F.32B5A75ACp0",
                "0x400000.000000000p0", "0x4C1BF8.28C6DC54Bp0", "0x5A8279.99FCEF324p0", "0x6BA27E.656B4EB58p0",
                "0x800000.000000000p0", "0x9837F0.518DB8A97p0", "0xB504F3.33F9DE648p0", "0xD744FC.CAD69D6AFp0",
                "0x1000000.000000000p0", "0x1306FE0.A31B7152Ep0", "0x16A09E6.67F3BCC91p0", "0x1AE89F9.95AD3AD5Fp0",
                "0x2000000.000000000p0", "0x260DFC1.4636E2A5Cp0", "0x2D413CC.CFE779921p0", "0x35D13F3.2B5A75ABDp0",
                "0x4000000.000000000p0", "0x4C1BF82.8C6DC54B8p0", "0x5A82799.9FCEF3242p0", "0x6BA27E6.56B4EB57Ap0",
                "0x8000000.000000000p0", "0x9837F05.18DB8A96Fp0", "0xB504F33.3F9DE6484p0", "0xD744FCC.AD69D6AF4p0",
                "0x10000000.000000000p0", "0x1306FE0A.31B7152DFp0", "0x16A09E66.7F3BCC909p0", "0x1AE89F99.5AD3AD5E8p0",
                "0x20000000.000000000p0", "0x260DFC14.636E2A5BDp0", "0x2D413CCC.FE7799211p0", "0x35D13F32.B5A75ABD1p0",
                "0x40000000.000000000p0", "0x4C1BF828.C6DC54B7Ap0", "0x5A827999.FCEF32423p0", "0x6BA27E65.6B4EB57A2p0",
                "0x80000000.000000000p0", "0x9837F051.8DB8A96F4p0", "0xB504F333.F9DE64846p0", "0xD744FCCA.D69D6AF44p0",
                "0x0.000000010p0", "0x0.000000013p0", "0x0.000000017p0", "0x0.00000001Bp0",
                "0x0.000000020p0", "0x0.000000026p0", "0x0.00000002Dp0", "0x0.000000036p0",
                "0x0.000000040p0", "0x0.00000004Cp0", "0x0.00000005Bp0", "0x0.00000006Cp0",
                "0x0.000000080p0", "0x0.000000098p0", "0x0.0000000B5p0", "0x0.0000000D7p0",
                "0x0.000000100p0", "0x0.000000130p0", "0x0.00000016Ap0", "0x0.0000001AFp0",
                "0x0.000000200p0", "0x0.000000261p0", "0x0.0000002D4p0", "0x0.00000035Dp0",
                "0x0.000000400p0", "0x0.0000004C2p0", "0x0.0000005A8p0", "0x0.0000006BAp0",
                "0x0.000000800p0", "0x0.000000983p0", "0x0.000000B50p0", "0x0.000000D74p0",
                "0x0.000001000p0", "0x0.000001307p0", "0x0.0000016A1p0", "0x0.000001AE9p0",
                "0x0.000002000p0", "0x0.00000260Ep0", "0x0.000002D41p0", "0x0.0000035D1p0",
                "0x0.000004000p0", "0x0.000004C1Cp0", "0x0.000005A82p0", "0x0.000006BA2p0",
                "0x0.000008000p0", "0x0.000009838p0", "0x0.00000B505p0", "0x0.00000D745p0",
                "0x0.000010000p0", "0x0.000013070p0", "0x0.000016A0Ap0", "0x0.00001AE8Ap0",
                "0x0.000020000p0", "0x0.0000260E0p0", "0x0.00002D414p0", "0x0.000035D14p0",
                "0x0.000040000p0", "0x0.00004C1C0p0", "0x0.00005A828p0", "0x0.00006BA28p0",
                "0x0.000080000p0", "0x0.00009837Fp0", "0x0.0000B504Fp0", "0x0.0000D7450p0",
                "0x0.000100000p0", "0x0.0001306FEp0", "0x0.00016A09Ep0", "0x0.0001AE8A0p0",
                "0x0.000200000p0", "0x0.000260DFCp0", "0x0.0002D413Dp0", "0x0.00035D13Fp0",
                "0x0.000400000p0", "0x0.0004C1BF8p0", "0x0.0005A827Ap0", "0x0.0006BA27Ep0",
                "0x0.000800000p0", "0x0.0009837F0p0", "0x0.000B504F3p0", "0x0.000D744FDp0",
                "0x0.001000000p0", "0x0.001306FE1p0", "0x0.0016A09E6p0", "0x0.001AE89FAp0",
                "0x0.002000000p0", "0x0.00260DFC1p0", "0x0.002D413CDp0", "0x0.0035D13F3p0",
                "0x0.004000000p0", "0x0.004C1BF83p0", "0x0.005A8279Ap0", "0x0.006BA27E6p0",
                "0x0.008000000p0", "0x0.009837F05p0", "0x0.00B504F33p0", "0x0.00D744FCDp0",
                "0x0.010000000p0", "0x0.01306FE0Ap0", "0x0.016A09E66p0", "0x0.01AE89F99p0",
                "0x0.020000000p0", "0x0.0260DFC14p0", "0x0.02D413CCDp0", "0x0.035D13F33p0",
                "0x0.040000000p0", "0x0.04C1BF829p0", "0x0.05A82799Ap0", "0x0.06BA27E65p0",
                "0x0.080000000p0", "0x0.09837F052p0", "0x0.0B504F334p0", "0x0.0D744FCCBp0",
                "0x0.100000000p0", "0x0.1306FE0A3p0", "0x0.16A09E668p0", "0x0.1AE89F996p0",
                "0x0.200000000p0", "0x0.260DFC146p0", "0x0.2D413CCD0p0", "0x0.35D13F32Bp0",
                "0x0.400000000p0", "0x0.4C1BF828Cp0", "0x0.5A82799A0p0", "0x0.6BA27E657p0",
                "0x0.800000000p0", "0x0.9837F0519p0", "0x0.B504F3340p0", "0x0.D744FCCADp0"
            };
_ssdm_SpecConstant(exp2_x_msb_1_table);
# 2734 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

            ap_ufixed<68,32> exp2_x_msb_1 = exp2_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<136,32> y_lo = exp2_x_msb_1 * exp2_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<68,32> y_lo_s = y_lo;
            ap_ufixed<68,32> y_l = y_lo_s + exp2_x_msb_1;
            y = y_l;
        }

        if(I<33) {
            bool overf_2 = 0;
#pragma unroll
 for(int j=63; j>=I+31; j--) {
                if(y[j]) {
                    overf_2 = 1;
                }
            }
            if(overf_2) {
#pragma unroll
 for(int j=63; j>=I+31; j--) {
                    y[j] = 0;
                }
#pragma unroll
 for(int j=I+30; j>=0; j--) {
                    y[j] = 1;
                }
            }
        }
        r = y;
    }
    return r;
}

template<int W, int I>
ap_ufixed<W,I> exp2(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return exp2(xf);
}

template<int I>
ap_int<I> exp2(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return exp2(xf);
}

template<int I>
ap_uint<I> exp2(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return exp2(xf);
}


template<int W_, int I_>
ap_fixed<W_,I_> exp10(ap_fixed<W_,I_> x) {

 int F_ = W_ - I_;
    if (I_>33) return 0;
    else if (F_>32) return 0;

 int I_s_;
    int M_ = (I_-1>F_) ? (I_-1) : F_;
 if (M_==1) I_s_ = 0;
    else if (M_<4) I_s_ = 1;
    else if (M_<7) I_s_ = 2;
    else if (M_<14) I_s_ = 3;
    else if (M_<27) I_s_ = 4;
    else I_s_ = 5;

 ap_fixed<W_,I_> r;
 if(I_s_==0) {
  ap_fixed<3,2> x_l = x;
  ap_ufixed<2,1> y = 0;
  if(x_l[2]) {
   if(x_l[1]&x_l[0]) {
    y = ap_ufixed<2,1>("0x0.8p0");
   }
  } else {
   if(x_l[1]|x_l[0]) {
    y = ap_ufixed<2,1>("0x1.8p0");
   } else {
    y = ap_ufixed<2,1>("0x1.0p0");
   }
  }
  if(I_<2) {
   bool overf = 0;
   if(y[1]) {
    y[1] = 0;
    y[0] = 1;
   }
  }
  r = y;
 } else if (I_s_==1) {
  ap_fixed<7,4> x_l = x;
  ap_ufixed<6,3> y = 0;
  if((x_l[6]!=x_l[5])||(x_l[5]!=x_l[4])||(x_l[4]!=x_l[3])) {
   if(!x_l[6]) {
    y = ap_ufixed<6,3>("0x7.Ep0");
   }
  } else {
   ap_uint<4> x_ind;
   x_ind[3] = x_l[6];
   x_ind(2,0) = x_l(2,0);
   const static ap_ufixed<6,3> exp_x_ind_table[16] = {
    "0x1.000p0", "0x1.600p0", "0x1.C00p0", "0x2.600p0", "0x3.200p0", "0x4.400p0", "0x5.A00p0", "0x7.800p0",
    "0x0.200p0", "0x0.200p0", "0x0.200p0", "0x0.400p0", "0x0.600p0", "0x0.600p0", "0x0.800p0", "0x0.C00p0"
   };
_ssdm_SpecConstant(exp_x_ind_table);
# 2900 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

   y = exp_x_ind_table[x_ind];
  }
  if(I_<4){
   bool overf = 0;
#pragma unroll
 for(int j = 5; j>=I_+2; j--) {
    if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
#pragma unroll
 for(int j = 5; j>=I_+2; j--) {
     y[j] = 0;
    }
    for(int j = I_+1; j>=0; j--) {
     y[j] = 1;
    }
   }
  }
  r = y;
 } else if (I_s_==2) {
  ap_fixed<13,7> x_l = x;
  ap_ufixed<12,6> y = 0;
  ap_fixed<2,2> x_l_int;
  x_l_int(1,0) = x_l(7,6);
  ap_ufixed<6,0> x_l_fract;
  x_l_fract(5,0) = x_l(5,0);
  bool overf = 0;
#pragma unroll
 for(int j = 11; j >=7; j--) {
   if(x_l[12]!=x_l[j]) {
    overf = 1;
   }
  }
  if(overf||((x_l_int==1)&&(x_l_fract>ap_ufixed<5,0>("0x.D0p0")))) {
   if(!x_l[12]) {
    y = ap_ufixed<12,6>("0x3F.FCp0");
   }
  } else {
   ap_uint<4> x_msb_ind;
   x_msb_ind(3,0) = x_l(7,4);
   ap_uint<4> x_lsb_ind;
   x_lsb_ind(3,0) = x_l(3,0);
   const static ap_ufixed<14,6> exp_x_msb_table[16] = {
    "0x1.00p0", "0x1.C7p0", "0x3.2Ap0", "0x5.A0p0", "0xA.00p0", "0x11.C8p0", "0x1F.9Fp0", "0x38.3Cp0",
    "0x0.03p0", "0x0.05p0", "0x0.08p0", "0x0.0Ep0", "0x0.1Ap0", "0x0.2Ep0", "0x0.51p0", "0x0.90p0"
   };
_ssdm_SpecConstant(exp_x_msb_table);
# 2948 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

   const static ap_ufixed<14,0> exp_x_lsb_m_1_table[16] = {
    "0x0.0p0", "0x0.0960p0", "0x0.1318p0", "0x0.1D2Cp0", "0x0.27A0p0", "0x0.3274p0", "0x0.3DB0p0", "0x0.4950p0",
    "0x0.5560p0", "0x0.61E4p0", "0x0.6ED8p0", "0x0.7C4Cp0", "0x0.8A38p0", "0x0.98A8p0", "0x0.A7A4p0", "0x0.B728p0"
   };
_ssdm_SpecConstant(exp_x_lsb_m_1_table);
# 2952 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

   ap_ufixed<14,6> exp_x_msb = exp_x_msb_table[x_msb_ind];
   ap_ufixed<14,0> exp_x_lsb_m_1 = exp_x_lsb_m_1_table[x_lsb_ind];
   ap_ufixed<28,6> y_lo = exp_x_msb * exp_x_lsb_m_1;
   ap_ufixed<14,6> y_lo_s = y_lo;
   ap_ufixed<14,6> y_l = y_lo_s + exp_x_msb;
   y = y_l;
  }
  if(I_<7) {
   bool overf = 0;
#pragma unroll
 for(int j = 11; j >= I_+5; j--) {
    if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
#pragma unroll
 for(int j = 11; j>= I_+5; j--) {
     y[j] = 0;
    }
#pragma unroll
 for(int j = I_+4; j>=0; j--) {
     y[j] = 1;
    }
   }
  }
  r = y;
 } else if (I_s_==3) {
  ap_fixed<27,14> x_l = x;
  ap_ufixed<26,13> y = 0;
  ap_fixed<3,3> x_l_int;
  x_l_int(2,0) = x_l(15,13);
  ap_ufixed<13,0> x_l_fract;
  x_l_fract(12,0) = x_l(12,0);
  bool overf = 0;
#pragma unroll
 for(int j = 25; j>=15; j--) {
   if(x_l[26]!=x_l[j]) {
    overf = 1;
   }
  }
  if(overf||((x_l_int==3)&&(x_l_fract>ap_ufixed<12,0>("0x3.E9D0p0")))) {
   if(!x_l[26]) {
    y = ap_ufixed<26,13>("0x1FFF.FFF8p0");
   }
  } else {
   ap_uint<6> x_msb_ind_1;
   x_msb_ind_1[5] = x_l[26];
   x_msb_ind_1(4,0) = x_l(14,10);
   ap_uint<5> x_msb_ind_2;
   x_msb_ind_2(4,0) = x_l(9,5);
   ap_uint<5> x_lsb_ind;
   x_lsb_ind(4,0) = x_l(4,0);
   const static ap_ufixed<24,-6> exp_lsb_ind_m_1_table[32] = {
    "0x0p0", "0x0.00126C5Cp0", "0x0.0024DA0Cp0", "0x0.0037490Cp0", "0x0.0049B964p0", "0x0.005C2B0Cp0", "0x0.006E9E08p0", "0x0.0081125Cp0",
    "0x0.00938800p0", "0x0.00A5FEF8p0", "0x0.00B87748p0", "0x0.00CAF0E8p0", "0x0.00DD6BE0p0", "0x0.00EFE82Cp0", "0x0.010265C8p0", "0x0.0114E4BCp0",
    "0x0.01276508p0", "0x0.0139E6A4p0", "0x0.014C6998p0", "0x0.015EEDDCp0", "0x0.0171737Cp0", "0x0.0183FA6Cp0", "0x0.019682B4p0", "0x0.01A90C50p0",
    "0x0.01BB9744p0", "0x0.01CE238Cp0", "0x0.01E0B128p0", "0x0.01F3401Cp0", "0x0.0205D064p0", "0x0.02186204p0", "0x0.022AF4F8p0", "0x0.023D8944p0"
   };
_ssdm_SpecConstant(exp_lsb_ind_m_1_table);
# 3009 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

   ap_ufixed<24,-6> exp_lsb_ind_m_1 = exp_lsb_ind_m_1_table[x_lsb_ind];
   const static ap_ufixed<29,-1> exp_msb_ind_2_m_1_table[32] = {
    "0x0p0", "0x0.02501EE8p0", "0x0.04A5975Cp0", "0x0.070075C0p0", "0x0.0960C68Cp0", "0x0.0BC69660p0", "0x0.0E31F1F0p0", "0x0.10A2E60Cp0",
    "0x0.13197FA8p0", "0x0.1595CBD4p0", "0x0.1817D7BCp0", "0x0.1A9FB0ACp0", "0x0.1D2D6410p0", "0x0.1FC0FF74p0", "0x0.225A9080p0", "0x0.24FA24F8p0",
    "0x0.279FCACCp0", "0x0.2A4B8FFCp0", "0x0.2CFD82BCp0", "0x0.2FB5B150p0", "0x0.32742A20p0", "0x0.3538FBC0p0", "0x0.380434D8p0", "0x0.3AD5E43Cp0",
    "0x0.3DAE18DCp0", "0x0.408CE1CCp0", "0x0.43724E48p0", "0x0.465E6DA8p0", "0x0.49514F68p0", "0x0.4C4B0330p0", "0x0.4F4B98C4p0", "0x0.5253200Cp0"
   };
_ssdm_SpecConstant(exp_msb_ind_2_m_1_table);
# 3016 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

   ap_ufixed<29,-1> exp_msb_ind_2_m1 = exp_msb_ind_2_m_1_table[x_msb_ind_2];
   ap_ufixed<53,-7> f_x_msb_2_lsb = exp_lsb_ind_m_1 * exp_msb_ind_2_m1;
   ap_ufixed<27,-1> exp_msb_2_lsb_m_1 = f_x_msb_2_lsb + exp_msb_ind_2_m1 + exp_lsb_ind_m_1;
   const static ap_ufixed<28,13> exp_msb_ind_1_table[64] = {
    "0x1.0000p0", "0x1.5562p0", "0x1.C73Ep0", "0x2.5F12p0", "0x3.298Cp0", "0x4.378Cp0", "0x5.9F98p0", "0x7.7FBAp0",
    "0xA.0000p0", "0xD.55D0p0", "0x11.C866p0", "0x17.B6B8p0", "0x1F.9F6Ep0", "0x2A.2B6Ep0", "0x38.3BF0p0", "0x4A.FD4Ap0",
    "0x64.0000p0", "0x85.5A26p0", "0xB1.D3F4p0", "0xED.232Ap0", "0x13C.3A4Ep0", "0x1A5.B24Ep0", "0x232.5762p0", "0x2ED.E4EAp0",
    "0x3E8.0000p0", "0x535.857Cp0", "0x6F2.4788p0", "0x943.5FACp0", "0xC5A.4714p0", "0x1078.F70Cp0", "0x15F7.69CAp0", "0x1D4A.F12Ep0",
    "0x0.0006p0", "0x0.0008p0", "0x0.000Cp0", "0x0.0010p0", "0x0.0014p0", "0x0.001Cp0", "0x0.0024p0", "0x0.0032p0",
    "0x0.0042p0", "0x0.0058p0", "0x0.0074p0", "0x0.009Cp0", "0x0.00D0p0", "0x0.0114p0", "0x0.0170p0", "0x0.01ECp0",
    "0x0.0290p0", "0x0.036Ap0", "0x0.048Ep0", "0x0.0612p0", "0x0.0818p0", "0x0.0ACCp0", "0x0.0E66p0", "0x0.1332p0",
    "0x0.199Ap0", "0x0.2224p0", "0x0.2D86p0", "0x0.3CB6p0", "0x0.50F4p0", "0x0.6BF4p0", "0x0.8FF6p0", "0x0.BFFAp0"
   };
_ssdm_SpecConstant(exp_msb_ind_1_table);
# 3025 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

   ap_ufixed<28,13> exp_msb_ind_1 = exp_msb_ind_1_table[x_msb_ind_1];
   ap_ufixed<28,13> f_x_msb_1_msb_2_lsb_l = exp_msb_ind_1 * exp_msb_2_lsb_m_1;
   y = f_x_msb_1_msb_2_lsb_l + exp_msb_ind_1;
  }
  if(I_<14) {
   bool overf = 0;
#pragma unroll
 for(int j = 25; j>= I_+12; j--) {
    if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
#pragma unroll
 for(int j = 25; j>=I_+12; j--) {
     y[j] = 0;
    }
#pragma unroll
 for(int j = I_+11; j>=0; j--) {
     y[j] = 1;
    }
   }
  }
  r = y;
 } else if (I_s_==4) {
  ap_fixed<53,27> x_l = x;
  ap_ufixed<52,26> y = 0;
  ap_fixed<4,4> x_l_int;
  x_l_int(3,0) = x_l(29,26);
  ap_ufixed<26,0> x_l_fract;
  x_l_fract(25,0) = x_l(25,0);
  bool overf = 0;
#pragma unroll
 for(int j = 51; j >= 29; j--) {
   if(x_l[52]!=x_l[j]) {
    overf = 1;
   }
  }
  if(overf||((x_l_int==7)&&(x_l_fract>ap_ufixed<26,0>("0x0.D3A7D8C")))) {
   if(!x_l[52]) {
    y = ap_ufixed<52,26>("0x3FFFFFF.FFFFFFCp0");
   }
  } else {
   ap_uint<8> x_msb_ind_1;
   x_msb_ind_1[7] = x_l[52];
   x_msb_ind_1(6,0) = x_l(28,22);
   ap_uint<8> x_msb_ind_2;
   x_msb_ind_2(7,0) = x_l(21,14);
   ap_uint<7> x_msb_ind_3;
   x_msb_ind_3(6,0) = x_l(13,7);
   ap_uint<7> x_lsb_ind;
   x_lsb_ind(6,0) = x_l(6,0);
   const static ap_ufixed<41,-17> exp_lsb_ind_m_1_table[128] = {
    "0x0.0p0", "0x0.000000935D8E080p0", "0x0.00000126BB1C650p0", "0x0.000001BA18AB16Cp0", "0x0.0000024D763A1D4p0", "0x0.000002E0D3C978Cp0", "0x0.000003743159290p0", "0x0.000004078EE92E0p0",
    "0x0.0000049AEC79880p0", "0x0.0000052E4A0A368p0", "0x0.000005C1A79B3A4p0", "0x0.00000655052C928p0", "0x0.000006E862BE3FCp0", "0x0.0000077BC05041Cp0", "0x0.0000080F1DE298Cp0", "0x0.000008A27B75448p0",
    "0x0.00000935D908450p0", "0x0.000009C9369B9A4p0", "0x0.00000A5C942F448p0", "0x0.00000AEFF1C3438p0", "0x0.00000B834F57978p0", "0x0.00000C16ACEC400p0", "0x0.00000CAA0A813D8p0", "0x0.00000D3D6816900p0",
    "0x0.00000DD0C5AC370p0", "0x0.00000E642342334p0", "0x0.00000EF780D8840p0", "0x0.00000F8ADE6F29Cp0", "0x0.0000101E3C06244p0", "0x0.000010B1999D738p0", "0x0.00001144F73517Cp0", "0x0.000011D854CD10Cp0",
    "0x0.0000126BB2655E8p0", "0x0.000012FF0FFE010p0", "0x0.000013926D96F88p0", "0x0.00001425CB30450p0", "0x0.000014B928C9E60p0", "0x0.0000154C8663DC0p0", "0x0.000015DFE3FE26Cp0", "0x0.000016734198C68p0",
    "0x0.000017069F33BB0p0", "0x0.00001799FCCF044p0", "0x0.0000182D5A6AA24p0", "0x0.000018C0B806954p0", "0x0.0000195415A2DD0p0", "0x0.000019E7733F79Cp0", "0x0.00001A7AD0DC6B4p0", "0x0.00001B0E2E79B18p0",
    "0x0.00001BA18C174C8p0", "0x0.00001C34E9B53C8p0", "0x0.00001CC84753814p0", "0x0.00001D5BA4F21B0p0", "0x0.00001DEF0291094p0", "0x0.00001E8260304C8p0", "0x0.00001F15BDCFE4Cp0", "0x0.00001FA91B6FD18p0",
    "0x0.0000203C7910134p0", "0x0.000020CFD6B0AA0p0", "0x0.000021633451954p0", "0x0.000021F691F2D58p0", "0x0.00002289EF946ACp0", "0x0.0000231D4D36548p0", "0x0.000023B0AAD8934p0", "0x0.00002444087B270p0",
    "0x0.000024D7661E0F4p0", "0x0.0000256AC3C14C8p0", "0x0.000025FE2164DE8p0", "0x0.000026917F08C58p0", "0x0.00002724DCAD014p0", "0x0.000027B83A5191Cp0", "0x0.0000284B97F6774p0", "0x0.000028DEF59BB14p0",
    "0x0.000029725341408p0", "0x0.00002A05B0E7244p0", "0x0.00002A990E8D5D0p0", "0x0.00002B2C6C33EA8p0", "0x0.00002BBFC9DACD0p0", "0x0.00002C532782040p0", "0x0.00002CE68529900p0", "0x0.00002D79E2D1710p0",
    "0x0.00002E0D4079A6Cp0", "0x0.00002EA09E22314p0", "0x0.00002F33FBCB108p0", "0x0.00002FC7597444Cp0", "0x0.0000305AB71DCDCp0", "0x0.000030EE14C7AB8p0", "0x0.000031817271DE4p0", "0x0.00003214D01C65Cp0",
    "0x0.000032A82DC7420p0", "0x0.0000333B8B72734p0", "0x0.000033CEE91DF94p0", "0x0.0000346246C9D40p0", "0x0.000034F5A47603Cp0", "0x0.000035890222884p0", "0x0.0000361C5FCF618p0", "0x0.000036AFBD7C8FCp0",
    "0x0.000037431B2A12Cp0", "0x0.000037D678D7EA8p0", "0x0.00003869D686170p0", "0x0.000038FD3434988p0", "0x0.0000399091E36ECp0", "0x0.00003A23EF929A0p0", "0x0.00003AB74D421A0p0", "0x0.00003B4AAAF1EECp0",
    "0x0.00003BDE08A2188p0", "0x0.00003C71665296Cp0", "0x0.00003D04C4036A0p0", "0x0.00003D9821B4924p0", "0x0.00003E2B7F660F4p0", "0x0.00003EBEDD17E10p0", "0x0.00003F523ACA078p0", "0x0.00003FE5987C830p0",
    "0x0.00004078F62F534p0", "0x0.0000410C53E2788p0", "0x0.0000419FB195F24p0", "0x0.000042330F49C10p0", "0x0.000042C66CFDE4Cp0", "0x0.00004359CAB25D0p0", "0x0.000043ED28672A4p0", "0x0.00004480861C4C8p0",
    "0x0.00004513E3D1C34p0", "0x0.000045A741878F0p0", "0x0.0000463A9F3DAFCp0", "0x0.000046CDFCF4250p0", "0x0.000047615AAAEF4p0", "0x0.000047F4B8620E8p0", "0x0.000048881619824p0", "0x0.0000491B73D14B0p0"
   };
_ssdm_SpecConstant(exp_lsb_ind_m_1_table);
# 3087 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

   ap_ufixed<41,-17> exp_lsb_ind_m_1 = exp_lsb_ind_m_1_table[x_lsb_ind];
   const static ap_ufixed<48,-10> exp_msb_ind_3_m_1_table[128] = {
    "0x0.0p0", "0x0.000049AED18968Cp0", "0x0.0000935DB847FC4p0", "0x0.0000DD0CB43BC10p0", "0x0.000126BBC564BCCp0", "0x0.0001706AEBC2F58p0", "0x0.0001BA1A275671Cp0", "0x0.000203C9781F374p0",
    "0x0.00024D78DE1D4C8p0", "0x0.000297285950B74p0", "0x0.0002E0D7E9B97D8p0", "0x0.00032A878F57A5Cp0", "0x0.000374374A2B360p0", "0x0.0003BDE71A34344p0", "0x0.00040796FF72A68p0", "0x0.00045146F9E6930p0",
    "0x0.00049AF70990000p0", "0x0.0004E4A72E6EF34p0", "0x0.00052E576883734p0", "0x0.00057807B7CD85Cp0", "0x0.0005C1B81C4D314p0", "0x0.00060B6896027B4p0", "0x0.0006551924ED6A8p0", "0x0.00069EC9C90E04Cp0",
    "0x0.0006E87A8264500p0", "0x0.0007322B50F052Cp0", "0x0.00077BDC34B2130p0", "0x0.0007C58D2DA9968p0", "0x0.00080F3E3BD6E3Cp0", "0x0.000858EF5F3A008p0", "0x0.0008A2A097D2F34p0", "0x0.0008EC51E5A1C1Cp0",
    "0x0.0009360348A6724p0", "0x0.00097FB4C0E10B0p0", "0x0.0009C9664E51920p0", "0x0.000A1317F0F80D4p0", "0x0.000A5CC9A8D4830p0", "0x0.000AA67B75E6F94p0", "0x0.000AF02D582F764p0", "0x0.000B39DF4FADFFCp0",
    "0x0.000B83915C629C4p0", "0x0.000BCD437E4D51Cp0", "0x0.000C16F5B56E268p0", "0x0.000C60A801C5200p0", "0x0.000CAA5A6352450p0", "0x0.000CF40CDA159B8p0", "0x0.000D3DBF660F294p0", "0x0.000D8772073EF4Cp0",
    "0x0.000DD124BDA5040p0", "0x0.000E1AD789415CCp0", "0x0.000E648A6A1405Cp0", "0x0.000EAE3D601D048p0", "0x0.000EF7F06B5C5F8p0", "0x0.000F41A38BD21CCp0", "0x0.000F8B56C17E424p0", "0x0.000FD50A0C60D64p0",
    "0x0.00101EBD6C79DECp0", "0x0.00106870E1C9620p0", "0x0.0010B2246C4F660p0", "0x0.0010FBD80C0BF0Cp0", "0x0.0011458BC0FF088p0", "0x0.00118F3F8B28B34p0", "0x0.0011D8F36A88F74p0", "0x0.001222A75F1FDA8p0",
    "0x0.00126C5B68ED630p0", "0x0.0012B60F87F1974p0", "0x0.0012FFC3BC2C7D0p0", "0x0.00134978059E1A8p0", "0x0.0013932C644675Cp0", "0x0.0013DCE0D82594Cp0", "0x0.00142695613B7E0p0", "0x0.00147049FF88374p0",
    "0x0.0014B9FEB30BC70p0", "0x0.001503B37BC632Cp0", "0x0.00154D6859B7810p0", "0x0.0015971D4CDFB80p0", "0x0.0015E0D2553EDD8p0", "0x0.00162A8772D4F7Cp0", "0x0.0016743CA5A20D0p0", "0x0.0016BDF1EDA6230p0",
    "0x0.001707A74AE1404p0", "0x0.0017515CBD536ACp0", "0x0.00179B1244FCA88p0", "0x0.0017E4C7E1DCFF8p0", "0x0.00182E7D93F4760p0", "0x0.001878335B43124p0", "0x0.0018C1E937C8DA4p0", "0x0.00190B9F2985D40p0",
    "0x0.00195555307A05Cp0", "0x0.00199F0B4CA5758p0", "0x0.0019E8C17E08294p0", "0x0.001A3277C4A2278p0", "0x0.001A7C2E2073760p0", "0x0.001AC5E4917C1ACp0", "0x0.001B0F9B17BC1C4p0", "0x0.001B5951B333808p0",
    "0x0.001BA30863E24D8p0", "0x0.001BECBF29C8894p0", "0x0.001C367604E63A4p0", "0x0.001C802CF53B664p0", "0x0.001CC9E3FAC8134p0", "0x0.001D139B158C47Cp0", "0x0.001D5D52458809Cp0", "0x0.001DA7098ABB5F4p0",
    "0x0.001DF0C0E5264E4p0", "0x0.001E3A7854C8DD0p0", "0x0.001E842FD9A311Cp0", "0x0.001ECDE773B4F24p0", "0x0.001F179F22FE850p0", "0x0.001F6156E77FCFCp0", "0x0.001FAB0EC138D90p0", "0x0.001FF4C6B029A68p0",
    "0x0.00203E7EB4523E8p0", "0x0.00208836CDB2A70p0", "0x0.0020D1EEFC4AE68p0", "0x0.00211BA7401B028p0", "0x0.0021655F9923018p0", "0x0.0021AF180762E98p0", "0x0.0021F8D08ADAC0Cp0", "0x0.00224289238A8D4p0",
    "0x0.00228C41D172550p0", "0x0.0022D5FA94921E4p0", "0x0.00231FB36CE9EF0p0", "0x0.0023696C5A79CD8p0", "0x0.0023B3255D41BFCp0", "0x0.0023FCDE7541CC0p0", "0x0.00244697A279F80p0", "0x0.00249050E4EA4A4p0"
   };
_ssdm_SpecConstant(exp_msb_ind_3_m_1_table);
# 3106 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

   ap_ufixed<48,-10> exp_msb_ind_3_m_1 = exp_msb_ind_3_m_1_table[x_msb_ind_3];
   ap_ufixed<89,-27> f_x_msb_ind_3_lsb = exp_lsb_ind_m_1 * exp_msb_ind_3_m_1;
   ap_ufixed<46,-10> exp_msb_ind_3_lsb_ind_m_1 = f_x_msb_ind_3_lsb + exp_lsb_ind_m_1 + exp_msb_ind_3_m_1;
   const static ap_ufixed<54,-2> exp_msb_ind_2_m_1_table[256] = {
    "0x0.0p0", "0x0.0024DA0A3C92C9p0", "0x0.0049B96285BC0Ap0", "0x0.006E9E099EFA37p0", "0x0.009388004BE7E5p0", "0x0.00B87747503BD4p0", "0x0.00DD6BDF6FC8EEp0", "0x0.010265C96E7E4Fp0",
    "0x0.01276506106748p0", "0x0.014C699619AB60p0", "0x0.0171737A4E8E5Ep0", "0x0.019682B3737048p0", "0x0.01BB97424CCD67p0", "0x0.01E0B1279F3E51p0", "0x0.0205D0642F77E5p0", "0x0.022AF4F8C24B54p0",
    "0x0.02501EE61CA626p0", "0x0.02754E2D03923Bp0", "0x0.029A82CE3C35CEp0", "0x0.02BFBCCA8BD37Fp0", "0x0.02E4FC22B7CA50p0", "0x0.030A40D78595AFp0", "0x0.032F8AE9BACD76p0", "0x0.0354DA5A1D25F2p0",
    "0x0.037A2F29726FE5p0", "0x0.039F895880988Ap0", "0x0.03C4E8E80DA99Bp0", "0x0.03EA4DD8DFC955p0", "0x0.040FB82BBD3A78p0", "0x0.043527E16C5C51p0", "0x0.045A9CFAB3AABBp0", "0x0.0480177859BE22p0",
    "0x0.04A5975B254B8Bp0", "0x0.04CB1CA3DD2493p0", "0x0.04F0A753483778p0", "0x0.0516376A2D8F1Ap0", "0x0.053BCCE95452FFp0", "0x0.056167D183C75Bp0", "0x0.05870823834D0Ep0", "0x0.05ACADE01A61AEp0",
    "0x0.05D25908109F88p0", "0x0.05F8099C2DBDA3p0", "0x0.061DBF9D398FC8p0", "0x0.06437B0BFC0683p0", "0x0.06693BE93D2F28p0", "0x0.068F0235C533D7p0", "0x0.06B4CDF25C5B83p0", "0x0.06DA9F1FCB09EFp0",
    "0x0.070075BED9BFBBp0", "0x0.072651D0511A61p0", "0x0.074C3354F9D43Dp0", "0x0.07721A4D9CC491p0", "0x0.079806BB02DF87p0", "0x0.07BDF89DF53637p0", "0x0.07E3EFF73CF6ACp0", "0x0.0809ECC7A36BE3p0",
    "0x0.082FEF0FF1FDD7p0", "0x0.0855F6D0F23180p0", "0x0.087C040B6DA8D8p0", "0x0.08A216C02E22DFp0", "0x0.08C82EEFFD7BA0p0", "0x0.08EE4C9BA5AC35p0", "0x0.09146FC3F0CACCp0", "0x0.093A9869A90AA9p0",
    "0x0.0960C68D98BC2Cp0", "0x0.0986FA308A4CD4p0", "0x0.09AD3353484744p0", "0x0.09D371F69D5348p0", "0x0.09F9B61B5435D7p0", "0x0.0A1FFFC237D119p0", "0x0.0A464EEC13246Bp0", "0x0.0A6CA399B14C61p0",
    "0x0.0A92FDCBDD82CEp0", "0x0.0AB95D83631EC5p0", "0x0.0ADFC2C10D94A0p0", "0x0.0B062D85A87601p0", "0x0.0B2C9DD1FF71D8p0", "0x0.0B5313A6DE5467p0", "0x0.0B798F05110749p0", "0x0.0BA00FED63916Fp0",
    "0x0.0BC69660A2172Dp0", "0x0.0BED225F98DA36p0", "0x0.0C13B3EB1439A8p0", "0x0.0C3A4B03E0B20Ap0", "0x0.0C60E7AACADD54p0", "0x0.0C8789E09F72F1p0", "0x0.0CAE31A62B47C4p0", "0x0.0CD4DEFC3B4E2Dp0",
    "0x0.0CFB91E39C960Dp0", "0x0.0D224A5D1C4CC9p0", "0x0.0D49086987BD4Fp0", "0x0.0D6FCC09AC501Cp0", "0x0.0D96953E578B3Ep0", "0x0.0DBD6408571257p0", "0x0.0DE4386878A6A5p0", "0x0.0E0B125F8A2704p0",
    "0x0.0E31F1EE598FF3p0", "0x0.0E58D715B4FB98p0", "0x0.0E7FC1D66AA1C4p0", "0x0.0EA6B23148D7F6p0", "0x0.0ECDA8271E1164p0", "0x0.0EF4A3B8B8DEF8p0", "0x0.0F1BA4E6E7EF5Dp0", "0x0.0F42ABB27A0EFAp0",
    "0x0.0F69B81C3E27FEp0", "0x0.0F90CA25034260p0", "0x0.0FB7E1CD9883E5p0", "0x0.0FDEFF16CD3022p0", "0x0.1006220170A885p0", "0x0.102D4A8E526C53p0", "0x0.105478BE4218B3p0", "0x0.107BAC920F68ACp0",
    "0x0.10A2E60A8A352Ep0", "0x0.10CA2528827515p0", "0x0.10F169ECC83D2Ap0", "0x0.1118B4582BC02Dp0", "0x0.1140046B7D4ED5p0", "0x0.11675A278D57D7p0", "0x0.118EB58D2C67E8p0", "0x0.11B6169D2B29C2p0",
    "0x0.11DD7D585A662Bp0", "0x0.1204E9BF8B03F4p0", "0x0.122C5BD38E0803p0", "0x0.1253D395349553p0", "0x0.127B51054FECFBp0", "0x0.12A2D424B16E31p0", "0x0.12CA5CF42A964Fp0", "0x0.12F1EB748D00D7p0",
    "0x0.13197FA6AA6777p0", "0x0.1341198B54A20Dp0", "0x0.1368B9235DA6AEp0", "0x0.13905E6F9789A8p0", "0x0.13B80970D47D86p0", "0x0.13DFBA27E6D314p0", "0x0.14077095A0F967p0", "0x0.142F2CBAD57DDEp0",
    "0x0.1456EE98570C27p0", "0x0.147EB62EF86E43p0", "0x0.14A6837F8C8C8Cp0", "0x0.14CE568AE66DB7p0", "0x0.14F62F51D936DBp0", "0x0.151E0DD5382B74p0", "0x0.1545F215D6AD66p0", "0x0.156DDC14883D04p0",
    "0x0.1595CBD2207913p0", "0x0.15BDC14F731ECFp0", "0x0.15E5BC8D5409EEp0", "0x0.160DBD8C9734A6p0", "0x0.1635C44E10B7B0p0", "0x0.165DD0D294CA4Ep0", "0x0.1685E31AF7C24Ep0", "0x0.16ADFB280E140Fp0",
    "0x0.16D618FAAC5286p0", "0x0.16FE3C93A72F41p0", "0x0.172665F3D37A6Cp0", "0x0.174E951C0622D6p0", "0x0.1776CA0D1435F4p0", "0x0.179F04C7D2DFE7p0", "0x0.17C7454D176B81p0", "0x0.17EF8B9DB74247p0",
    "0x0.1817D7BA87EC75p0", "0x0.184029A45F1107p0", "0x0.1868815C1275B9p0", "0x0.1890DEE277FF0Dp0", "0x0.18B9423865B04Fp0", "0x0.18E1AB5EB1AB9Ap0", "0x0.190A1A563231DCp0", "0x0.19328F1FBDA2DCp0",
    "0x0.195B09BC2A7D3Ap0", "0x0.19838A2C4F5E7Ap0", "0x0.19AC1071030303p0", "0x0.19D49C8B1C4625p0", "0x0.19FD2E7B722220p0", "0x0.1A25C642DBB023p0", "0x0.1A4E63E2302857p0", "0x0.1A77075A46E1DEp0",
    "0x0.1A9FB0ABF752DBp0", "0x0.1AC85FD8191074p0", "0x0.1AF114DF83CED8p0", "0x0.1B19CFC30F6145p0", "0x0.1B42908393BA07p0", "0x0.1B6B5721E8EA82p0", "0x0.1B94239EE72334p0", "0x0.1BBCF5FB66B3BCp0",
    "0x0.1BE5CE38400AD8p0", "0x0.1C0EAC564BB672p0", "0x0.1C37905662639Fp0", "0x0.1C607A395CDEA5p0", "0x0.1C896A001412FEp0", "0x0.1CB25FAB610B61p0", "0x0.1CDB5B3C1CF1BFp0", "0x0.1D045CB3210F50p0",
    "0x0.1D2D641146CC91p0", "0x0.1D56715767B14Cp0", "0x0.1D7F84865D649Ap0", "0x0.1DA89D9F01ACEBp0", "0x0.1DD1BCA22E7006p0", "0x0.1DFAE190BDB311p0", "0x0.1E240C6B899A96p0", "0x0.1E4D3D336C6A83p0",
    "0x0.1E7673E9408633p0", "0x0.1E9FB08DE07072p0", "0x0.1EC8F32226CB7Ep0", "0x0.1EF23BA6EE590Fp0", "0x0.1F1B8A1D11FA5Cp0", "0x0.1F44DE856CB01Dp0", "0x0.1F6E38E0D99A90p0", "0x0.1F97993033F980p0",
    "0x0.1FC0FF74572C45p0", "0x0.1FEA6BAE1EB1CEp0", "0x0.2013DDDE6628A0p0", "0x0.203D5606094EE1p0", "0x0.2066D425E40256p0", "0x0.2090583ED2406Ap0", "0x0.20B9E251B02636p0", "0x0.20E3725F59F080p0",
    "0x0.210D0868ABFBC3p0", "0x0.2136A46E82C433p0", "0x0.21604671BAE5C1p0", "0x0.2189EE73311C20p0", "0x0.21B39C73C242C8p0", "0x0.21DD50744B54FDp0", "0x0.22070A75A96DD4p0", "0x0.2230CA78B9C835p0",
    "0x0.225A907E59BEDFp0", "0x0.22845C8766CC70p0", "0x0.22AE2E94BE8B69p0", "0x0.22D806A73EB62Fp0", "0x0.2301E4BFC52713p0", "0x0.232BC8DF2FD857p0", "0x0.2355B3065CE42Fp0", "0x0.237FA3362A84CAp0",
    "0x0.23A9996F771453p0", "0x0.23D395B3210CF7p0", "0x0.23FD98020708EAp0", "0x0.2427A05D07C26Dp0", "0x0.2451AEC50213CEp0", "0x0.247BC33AD4F771p0", "0x0.24A5DDBF5F87D3p0", "0x0.24CFFE5380FF8Fp0",
    "0x0.24FA24F818B962p0", "0x0.252451AE063030p0", "0x0.254E847628FF09p0", "0x0.2578BD5160E12Cp0", "0x0.25A2FC408DB20Fp0", "0x0.25CD41448F6D5Fp0", "0x0.25F78C5E462F0Ap0", "0x0.2621DD8E92333Fp0",
    "0x0.264C34D653D674p0", "0x0.267692366B956Dp0", "0x0.26A0F5AFBA0D3Cp0", "0x0.26CB5F431FFB4Cp0", "0x0.26F5CEF17E3D5Fp0", "0x0.272044BBB5D196p0", "0x0.274AC0A2A7D678p0", "0x0.277542A7358AF1p0"
   };
_ssdm_SpecConstant(exp_msb_ind_2_m_1_table);
# 3127 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

   ap_ufixed<54,-2> exp_msb_ind_2_m_1 = exp_msb_ind_2_m_1_table[x_msb_ind_2];
   ap_ufixed<100,-12> f_x_msb_ind_2_msb_ind3_lsb = exp_msb_ind_3_lsb_ind_m_1 * exp_msb_ind_2_m_1;
   ap_ufixed<52,-2> exp_msb_ind2_msb_ind3_lsb_ind_m_1 = f_x_msb_ind_2_msb_ind3_lsb + exp_msb_ind_3_lsb_ind_m_1 + exp_msb_ind_2_m_1;
   const static ap_ufixed<54,26> exp_msb_ind_1_table[256] = {
    "0x1.0000000p0", "0x1.279FCADp0", "0x1.5561A92p0", "0x1.8A389FFp0", "0x1.C73D51Cp0", "0x2.0DB3D0Fp0", "0x2.5F1258Ep0", "0x2.BD0911Bp0",
    "0x3.298B076p0", "0x3.A6D8842p0", "0x4.378B054p0", "0x4.DEA3099p0", "0x5.9F9802Dp0", "0x6.7E6ABF0p0", "0x7.7FBAAB4p0", "0x8.A8DE610p0",
    "0xA.0000000p0", "0xB.8C3DEBEp0", "0xD.55D09B1p0", "0xF.66363F8p0", "0x11.C86531Bp0", "0x14.8906295p0", "0x17.B6B778Cp0", "0x1B.625AB10p0",
    "0x1F.9F6E499p0", "0x24.8475291p0", "0x2A.2B6E347p0", "0x30.B25E5F8p0", "0x38.3BF01BEp0", "0x40.F02B75Fp0", "0x4A.FD4AB0Bp0", "0x56.98AFCA2p0",
    "0x64.0000000p0", "0x73.7A6B370p0", "0x85.5A260EDp0", "0x99.FE1E7B3p0", "0xB1.D3F3F11p0", "0xCD.5A3D9D0p0", "0xED.232AB7Bp0", "0x111.D78AEA4p0",
    "0x13C.3A4EDFBp0", "0x16D.2C939A9p0", "0x1A5.B24E0C7p0", "0x1E6.F7AFBABp0", "0x232.5761167p0", "0x289.61B29B6p0", "0x2ED.E4EAE72p0", "0x361.F6DDE55p0",
    "0x3E8.0000000p0", "0x482.C830261p0", "0x535.857C941p0", "0x603.ED30CFDp0", "0x6F2.47876A9p0", "0x805.8668224p0", "0x943.5FAB2CAp0", "0xAB2.6B6D26Bp0",
    "0xC5A.4714BCAp0", "0xE43.BDC409Bp0", "0x1078.F70C7CBp0", "0x1305.ACDD4AFp0", "0x15F7.69CAE07p0", "0x195D.D0FA11Ep0", "0x1D4A.F12D073p0", "0x21D3.A4AAF51p0",
    "0x2710.0000000p0", "0x2D1B.D1E17C7p0", "0x3417.36DDC85p0", "0x3C27.43E81E5p0", "0x4576.CB4A29Cp0", "0x5037.401156Cp0", "0x5CA1.BCAFBE1p0", "0x6AF8.324382Fp0",
    "0x7B86.C6CF5E3p0", "0x8EA5.69A8609p0", "0xA4B9.A67CDEAp0", "0xBE38.C0A4ED5p0", "0xDBAA.21ECC48p0", "0xFDAA.29C4B2Ap0", "0x124ED.6BC2480p0", "0x15244.6EAD929p0",
    "0x186A0.0000000p0", "0x1C316.32CEDC6p0", "0x208E8.24A9D35p0", "0x25988.A7112F0p0", "0x2B6A3.F0E5A19p0", "0x32228.80AD63Cp0", "0x39E51.5EDD6CAp0", "0x42DB1.F6A31D7p0",
    "0x4D343.C419ADFp0", "0x59276.2093C5Ep0", "0x66F40.80E0B21p0", "0x76E37.8671452p0", "0x894A5.533FACCp0", "0x9E8A5.A1AEFA8p0", "0xB7146.3596CFDp0", "0xD36AC.52C7B9Bp0",
    "0xF4240.0000000p0", "0x119EDD.FC149BCp0", "0x145911.6EA2417p0", "0x177F56.86ABD5Cp0", "0x1B2267.68F84F9p0", "0x1F5595.06C5E54p0", "0x242F2D.B4A63E0p0", "0x29C8F3.A25F263p0",
    "0x3040A5.A900CB8p0", "0x37B89D.45C5BB0p0", "0x405885.08C6F4Ap0", "0x4A4E2B.406CB33p0", "0x55CE75.407CBF4p0", "0x631678.50D5C93p0", "0x726CBE.17E41E4p0", "0x8422BB.3BCD40Ap0",
    "0x989680.0000000p0", "0xB034AB.D8CE155p0", "0xCB7AAE.52568E6p0", "0xEAF961.42B6594p0", "0x10F580A.19B31BCp0", "0x13957D2.43BAF49p0", "0x169D7C9.0E7E6C2p0", "0x1A1D984.57B77DEp0",
    "0x1E28678.9A07F2Fp0", "0x22D3624.B9B94DFp0", "0x2837532.57C58E8p0", "0x2E70DB0.843F002p0", "0x35A1094.84DF78Cp0", "0x3DEE0B3.2859DBCp0", "0x4783F6C.EEE92ECp0", "0x5295B50.5604864p0",
    "0x0.0000003p0", "0x0.0000003p0", "0x0.0000004p0", "0x0.0000004p0", "0x0.0000005p0", "0x0.0000006p0", "0x0.0000006p0", "0x0.0000007p0",
    "0x0.0000008p0", "0x0.000000Ap0", "0x0.000000Bp0", "0x0.000000Dp0", "0x0.000000Fp0", "0x0.0000011p0", "0x0.0000014p0", "0x0.0000017p0",
    "0x0.000001Bp0", "0x0.000001Fp0", "0x0.0000024p0", "0x0.0000029p0", "0x0.0000030p0", "0x0.0000037p0", "0x0.0000040p0", "0x0.000004Ap0",
    "0x0.0000055p0", "0x0.0000062p0", "0x0.0000071p0", "0x0.0000083p0", "0x0.0000097p0", "0x0.00000AEp0", "0x0.00000C9p0", "0x0.00000E8p0",
    "0x0.000010Cp0", "0x0.0000136p0", "0x0.0000166p0", "0x0.000019Dp0", "0x0.00001DDp0", "0x0.0000227p0", "0x0.000027Dp0", "0x0.00002DFp0",
    "0x0.0000351p0", "0x0.00003D4p0", "0x0.000046Cp0", "0x0.000051Bp0", "0x0.00005E6p0", "0x0.00006CFp0", "0x0.00007DDp0", "0x0.0000915p0",
    "0x0.0000A7Cp0", "0x0.0000C1Cp0", "0x0.0000DFCp0", "0x0.0001026p0", "0x0.00012A6p0", "0x0.0001588p0", "0x0.00018DEp0", "0x0.0001CB7p0",
    "0x0.0002129p0", "0x0.000264Bp0", "0x0.0002C38p0", "0x0.0003310p0", "0x0.0003AF7p0", "0x0.0004418p0", "0x0.0004EA2p0", "0x0.0005ACEp0",
    "0x0.00068DCp0", "0x0.0007916p0", "0x0.0008BD4p0", "0x0.000A179p0", "0x0.000BA77p0", "0x0.000D754p0", "0x0.000F8A8p0", "0x0.0011F25p0",
    "0x0.0014B97p0", "0x0.0017EEAp0", "0x0.001BA2Ep0", "0x0.001FE9Fp0", "0x0.0024DA8p0", "0x0.002A8EDp0", "0x0.0031252p0", "0x0.0038C08p0",
    "0x0.0041893p0", "0x0.004BAE0p0", "0x0.005764Cp0", "0x0.0064EBBp0", "0x0.00748A9p0", "0x0.0086947p0", "0x0.009B691p0", "0x0.00B3771p0",
    "0x0.00CF3E3p0", "0x0.00EF521p0", "0x0.01145CFp0", "0x0.013F239p0", "0x0.0170894p0", "0x0.01A9943p0", "0x0.01EB736p0", "0x0.023784Bp0",
    "0x0.028F5C3p0", "0x0.02F4CC4p0", "0x0.0369EFCp0", "0x0.03F134Dp0", "0x0.048D69Cp0", "0x0.0541CC5p0", "0x0.06121A8p0", "0x0.0702A69p0",
    "0x0.08186E2p0", "0x0.0959348p0", "0x0.0ACBA15p0", "0x0.0C7763Fp0", "0x0.0E655C3p0", "0x0.109FC99p0", "0x0.133281Bp0", "0x0.162B2F1p0",
    "0x0.199999Ap0", "0x0.1D8FFABp0", "0x0.22235DBp0", "0x0.276C100p0", "0x0.2D8621Cp0", "0x0.3491FB5p0", "0x0.3CB508Ep0", "0x0.461A81Cp0",
    "0x0.50F44D9p0", "0x0.5D7C0D3p0", "0x0.6BF44D5p0", "0x0.7CA9E76p0", "0x0.8FF599Ep0", "0x0.A63DDFEp0", "0x0.BFF9112p0", "0x0.DDAFD68p0"
   };
_ssdm_SpecConstant(exp_msb_ind_1_table);
# 3164 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

   ap_ufixed<54,26> exp_msb_ind_1 = exp_msb_ind_1_table[x_msb_ind_1];
   ap_ufixed<106,24> f_x_msb_ind_1_ind_2_ind_1_lsb = exp_msb_ind_1 * exp_msb_ind2_msb_ind3_lsb_ind_m_1;
   y = f_x_msb_ind_1_ind_2_ind_1_lsb + exp_msb_ind_1;
  }
  if(I_<27) {
   bool overf = 0;
#pragma unroll
 for(int j = 51; j >= 25 + I_; j--) {
    if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
#pragma unroll
 for(int j = 51; j>=25 + I_; j--) {
     y[j] = 0;
    }
#pragma unroll
 for(int j = 24 + I_; j >= 0; j--) {
     y[j] = 1;
    }
   }
  }
  r = y;
 } else {
  ap_fixed<65,33> x_l = x;
  ap_ufixed<64,32> y = 0;
  ap_fixed<5,5> x_l_int;
  x_l_int(4,0) = x_l(36,32);
  ap_ufixed<32,0> x_l_fract;
  x_l_fract(31,0) = x_l(31,0);
  bool overf = 0;
#pragma unroll
 for(int j = 63; j >= 36; j--) {
   if(x_l[64]!=x_l[j]) {
    overf = 1;
   }
  }
  if(overf||(x_l_int >= 10)||((x_l_int==9)&&(x_l_fract>ap_fixed<32,0>("0x0.A209A84F")))) {
   if(!x_l[64]) {
    y = ap_ufixed<64,32>("0xFFFFFFFF.FFFFFFFFp0");
   }
  } else {
   ap_uint<8> x_msb_ind_1;
   x_msb_ind_1[7] = x_l[64];
   x_msb_ind_1(6,0) = x_l(35,29);
   ap_uint<8> x_msb_ind_2;
   x_msb_ind_2(7,0) = x_l(28,21);
   ap_uint<7> x_msb_ind_3;
   x_msb_ind_3(6,0) = x_l(20,14);
   ap_uint<7> x_msb_ind_4;
   x_msb_ind_4(6,0) = x_l(13,7);
   ap_uint<7> x_lsb_ind;
   x_lsb_ind(6,0) = x_l(6,0);
   const static ap_ufixed<49,-23> exp_x_lsb_ind_m_1_table[128] = {
    "0x0.0p0", "0x0.000000024D76377927p0", "0x0.000000049AEC6EF79Cp0", "0x0.00000006E862A67B5Dp0", "0x0.0000000935D8DE046Dp0", "0x0.0000000B834F1592C9p0", "0x0.0000000DD0C54D2672p0", "0x0.000000101E3B84BF69p0",
    "0x0.000000126BB1BC5DAEp0", "0x0.00000014B927F4013Fp0", "0x0.00000017069E2BAA1Ep0", "0x0.00000019541463584Ap0", "0x0.0000001BA18A9B0BC3p0", "0x0.0000001DEF00D2C48Ap0", "0x0.000000203C770A829Ep0", "0x0.0000002289ED4245FFp0",
    "0x0.00000024D7637A0EAEp0", "0x0.0000002724D9B1DCA9p0", "0x0.00000029724FE9AFF2p0", "0x0.0000002BBFC6218889p0", "0x0.0000002E0D3C59666Cp0", "0x0.000000305AB291499Dp0", "0x0.00000032A828C9321Bp0", "0x0.00000034F59F011FE7p0",
    "0x0.000000374315391300p0", "0x0.00000039908B710B66p0", "0x0.0000003BDE01A90919p0", "0x0.0000003E2B77E10C1Ap0", "0x0.0000004078EE191468p0", "0x0.00000042C664512203p0", "0x0.0000004513DA8934EBp0", "0x0.000000476150C14D21p0",
    "0x0.00000049AEC6F96AA4p0", "0x0.0000004BFC3D318D75p0", "0x0.0000004E49B369B592p0", "0x0.000000509729A1E2FDp0", "0x0.00000052E49FDA15B5p0", "0x0.000000553216124DBBp0", "0x0.000000577F8C4A8B0Ep0", "0x0.00000059CD0282CDAEp0",
    "0x0.0000005C1A78BB159Bp0", "0x0.0000005E67EEF362D6p0", "0x0.00000060B5652BB55Ep0", "0x0.0000006302DB640D33p0", "0x0.0000006550519C6A55p0", "0x0.000000679DC7D4CCC5p0", "0x0.00000069EB3E0D3482p0", "0x0.0000006C38B445A18Dp0",
    "0x0.0000006E862A7E13E4p0", "0x0.00000070D3A0B68B89p0", "0x0.000000732116EF087Bp0", "0x0.000000756E8D278ABBp0", "0x0.00000077BC03601248p0", "0x0.0000007A0979989F22p0", "0x0.0000007C56EFD13149p0", "0x0.0000007EA46609C8BEp0",
    "0x0.00000080F1DC426580p0", "0x0.000000833F527B078Fp0", "0x0.000000858CC8B3AEEBp0", "0x0.00000087DA3EEC5B95p0", "0x0.0000008A27B5250D8Cp0", "0x0.0000008C752B5DC4D1p0", "0x0.0000008EC2A1968162p0", "0x0.000000911017CF4341p0",
    "0x0.000000935D8E080A6Dp0", "0x0.00000095AB0440D6E7p0", "0x0.00000097F87A79A8AEp0", "0x0.0000009A45F0B27FC2p0", "0x0.0000009C9366EB5C23p0", "0x0.0000009EE0DD243DD2p0", "0x0.000000A12E535D24CEp0", "0x0.000000A37BC9961117p0",
    "0x0.000000A5C93FCF02ADp0", "0x0.000000A816B607F991p0", "0x0.000000AA642C40F5C2p0", "0x0.000000ACB1A279F741p0", "0x0.000000AEFF18B2FE0Cp0", "0x0.000000B14C8EEC0A25p0", "0x0.000000B39A05251B8Bp0", "0x0.000000B5E77B5E323Fp0",
    "0x0.000000B834F1974E40p0", "0x0.000000BA8267D06F8Ep0", "0x0.000000BCCFDE099629p0", "0x0.000000BF1D5442C212p0", "0x0.000000C16ACA7BF348p0", "0x0.000000C3B840B529CBp0", "0x0.000000C605B6EE659Bp0", "0x0.000000C8532D27A6B9p0",
    "0x0.000000CAA0A360ED24p0", "0x0.000000CCEE199A38DDp0", "0x0.000000CF3B8FD389E2p0", "0x0.000000D189060CE035p0", "0x0.000000D3D67C463BD5p0", "0x0.000000D623F27F9CC3p0", "0x0.000000D87168B902FEp0", "0x0.000000DABEDEF26E86p0",
    "0x0.000000DD0C552BDF5Bp0", "0x0.000000DF59CB65557Ep0", "0x0.000000E1A7419ED0EEp0", "0x0.000000E3F4B7D851ABp0", "0x0.000000E6422E11D7B6p0", "0x0.000000E88FA44B630Dp0", "0x0.000000EADD1A84F3B2p0", "0x0.000000ED2A90BE89A5p0",
    "0x0.000000EF7806F824E4p0", "0x0.000000F1C57D31C571p0", "0x0.000000F412F36B6B4Cp0", "0x0.000000F66069A51673p0", "0x0.000000F8ADDFDEC6E8p0", "0x0.000000FAFB56187CAAp0", "0x0.000000FD48CC5237B9p0", "0x0.000000FF96428BF816p0",
    "0x0.00000101E3B8C5BDC0p0", "0x0.00000104312EFF88B7p0", "0x0.000001067EA53958FCp0", "0x0.00000108CC1B732E8Ep0", "0x0.0000010B1991AD096Dp0", "0x0.0000010D6707E6E999p0", "0x0.0000010FB47E20CF13p0", "0x0.0000011201F45AB9DAp0",
    "0x0.000001144F6A94A9EEp0", "0x0.000001169CE0CE9F4Fp0", "0x0.00000118EA570899FEp0", "0x0.0000011B37CD4299FAp0", "0x0.0000011D85437C9F44p0", "0x0.0000011FD2B9B6A9DAp0", "0x0.00000122202FF0B9BEp0", "0x0.000001246DA62ACEEFp0"
   };
_ssdm_SpecConstant(exp_x_lsb_ind_m_1_table);
# 3252 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

   ap_ufixed<49,-23> exp_x_lsb_ind_m_1 = exp_x_lsb_ind_m_1_table[x_lsb_ind];
   const static ap_ufixed<56,-16> exp_x_msb_ind_4_m_1_table[128] = {
    "0x0.0p0", "0x0.00000126BB1C64FE3Ep0", "0x0.0000024D763A1D4ECAp0", "0x0.00000374315928F1A6p0", "0x0.0000049AEC7987E6D2p0", "0x0.000005C1A79B3A2E51p0", "0x0.000006E862BE3FC825p0", "0x0.0000080F1DE298B44Dp0",
    "0x0.00000935D90844F2CDp0", "0x0.00000A5C942F4483A6p0", "0x0.00000B834F579766D9p0", "0x0.00000CAA0A813D9C67p0", "0x0.00000DD0C5AC372453p0", "0x0.00000EF780D883FE9Ep0", "0x0.0000101E3C06242B48p0", "0x0.00001144F73517AA55p0",
    "0x0.0000126BB2655E7BC5p0", "0x0.000013926D96F89F9Ap0", "0x0.000014B928C9E615D5p0", "0x0.000015DFE3FE26DE78p0", "0x0.000017069F33BAF985p0", "0x0.0000182D5A6AA266FCp0", "0x0.0000195415A2DD26E0p0", "0x0.00001A7AD0DC6B3932p0",
    "0x0.00001BA18C174C9DF4p0", "0x0.00001CC84753815527p0", "0x0.00001DEF0291095ECCp0", "0x0.00001F15BDCFE4BAE6p0", "0x0.0000203C7910136975p0", "0x0.000021633451956A7Bp0", "0x0.00002289EF946ABDFAp0", "0x0.000023B0AAD89363F3p0",
    "0x0.000024D7661E0F5C68p0", "0x0.000025FE2164DEA75Ap0", "0x0.00002724DCAD0144CCp0", "0x0.0000284B97F67734BDp0", "0x0.000029725341407730p0", "0x0.00002A990E8D5D0C27p0", "0x0.00002BBFC9DACCF3A2p0", "0x0.00002CE68529902DA4p0",
    "0x0.00002E0D4079A6BA2Ep0", "0x0.00002F33FBCB109942p0", "0x0.0000305AB71DCDCAE0p0", "0x0.000031817271DE4F0Bp0", "0x0.000032A82DC74225C5p0", "0x0.000033CEE91DF94F0Dp0", "0x0.000034F5A47603CAE7p0", "0x0.0000361C5FCF619954p0",
    "0x0.000037431B2A12BA54p0", "0x0.00003869D686172DEBp0", "0x0.0000399091E36EF418p0", "0x0.00003AB74D421A0CDFp0", "0x0.00003BDE08A218783Fp0", "0x0.00003D04C4036A363Cp0", "0x0.00003E2B7F660F46D5p0", "0x0.00003F523ACA07AA0Ep0",
    "0x0.00004078F62F535FE7p0", "0x0.0000419FB195F26862p0", "0x0.000042C66CFDE4C380p0", "0x0.000043ED28672A7144p0", "0x0.00004513E3D1C371ADp0", "0x0.0000463A9F3DAFC4BFp0", "0x0.000047615AAAEF6A7Ap0", "0x0.0000488816198262E1p0",
    "0x0.000049AED18968ADF4p0", "0x0.00004AD58CFAA24BB5p0", "0x0.00004BFC486D2F3C26p0", "0x0.00004D2303E10F7F48p0", "0x0.00004E49BF5643151Cp0", "0x0.00004F707ACCC9FDA5p0", "0x0.000050973644A438E4p0", "0x0.000051BDF1BDD1C6DAp0",
    "0x0.000052E4AD3852A788p0", "0x0.0000540B68B426DAF1p0", "0x0.0000553224314E6116p0", "0x0.00005658DFAFC939F8p0", "0x0.0000577F9B2F976599p0", "0x0.000058A656B0B8E3FBp0", "0x0.000059CD12332DB51Ep0", "0x0.00005AF3CDB6F5D905p0",
    "0x0.00005C1A893C114FB1p0", "0x0.00005D4144C2801924p0", "0x0.00005E68004A42355Fp0", "0x0.00005F8EBBD357A463p0", "0x0.000060B5775DC06632p0", "0x0.000061DC32E97C7ACEp0", "0x0.00006302EE768BE238p0", "0x0.00006429AA04EE9C72p0",
    "0x0.000065506594A4A97Dp0", "0x0.000066772125AE095Ap0", "0x0.0000679DDCB80ABC0Cp0", "0x0.000068C4984BBAC194p0", "0x0.000069EB53E0BE19F3p0", "0x0.00006B120F7714C52Bp0", "0x0.00006C38CB0EBEC33Ep0", "0x0.00006D5F86A7BC142Cp0",
    "0x0.00006E8642420CB7F8p0", "0x0.00006FACFDDDB0AEA2p0", "0x0.000070D3B97AA7F82Dp0", "0x0.000071FA7518F2949Ap0", "0x0.0000732130B89083EBp0", "0x0.00007447EC5981C621p0", "0x0.0000756EA7FBC65B3Dp0", "0x0.00007695639F5E4341p0",
    "0x0.000077BC1F44497E2Fp0", "0x0.000078E2DAEA880C08p0", "0x0.00007A09969219ECCEp0", "0x0.00007B30523AFF2082p0", "0x0.00007C570DE537A726p0", "0x0.00007D7DC990C380BBp0", "0x0.00007EA4853DA2AD43p0", "0x0.00007FCB40EBD52CBFp0",
    "0x0.000080F1FC9B5AFF31p0", "0x0.00008218B84C34249Ap0", "0x0.0000833F73FE609CFCp0", "0x0.000084662FB1E06859p0", "0x0.0000858CEB66B386B2p0", "0x0.000086B3A71CD9F808p0", "0x0.000087DA62D453BC5Dp0", "0x0.000089011E8D20D3B2p0",
    "0x0.00008A27DA47413E0Ap0", "0x0.00008B4E9602B4FB65p0", "0x0.00008C7551BF7C0BC5p0", "0x0.00008D9C0D7D966F2Cp0", "0x0.00008EC2C93D04259Bp0", "0x0.00008FE984FDC52F14p0", "0x0.0000911040BFD98B98p0", "0x0.00009236FC83413B29p0"
   };
_ssdm_SpecConstant(exp_x_msb_ind_4_m_1_table);
# 3271 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

   ap_ufixed<56,-16> exp_x_msb_ind_4_m_1 = exp_x_msb_ind_4_m_1_table[x_msb_ind_4];
   ap_ufixed<105,-39> f_x_msb_ind_4_lsb_ind = exp_x_msb_ind_4_m_1 * exp_x_lsb_ind_m_1;
   ap_ufixed<54,-16> exp_x_msb_ind_4_lsb_ind_m_1 = f_x_msb_ind_4_lsb_ind + exp_x_msb_ind_4_m_1 + exp_x_lsb_ind_m_1;
   const static ap_ufixed<61,-9> exp_x_msb_ind_3_m_1_table[128] = {
    "0x0.0p0", "0x0.0000935DB847FC5AA8p0", "0x0.000126BBC564BCA768p0", "0x0.0001BA1A275671BB78p0", "0x0.00024D78DE1D4C6C2Cp0", "0x0.0002E0D7E9B97D8EFCp0", "0x0.000374374A2B35F970p0", "0x0.00040796FF72A6813Cp0",
    "0x0.00049AF7098FFFFC24p0", "0x0.00052E57688373400Cp0", "0x0.0005C1B81C4D3122F0p0", "0x0.0006551924ED6A7AF0p0", "0x0.0006E87A8264501E44p0", "0x0.00077BDC34B212E340p0", "0x0.00080F3E3BD6E3A04Cp0", "0x0.0008A2A097D2F32C00p0",
    "0x0.0009360348A6725D00p0", "0x0.0009C9664E51920A0Cp0", "0x0.000A5CC9A8D4830A0Cp0", "0x0.000AF02D582F7633F4p0", "0x0.000B83915C629C5EE4p0", "0x0.000C16F5B56E266210p0", "0x0.000CAA5A63524514C8p0", "0x0.000D3DBF660F294E74p0",
    "0x0.000DD124BDA503E6A8p0", "0x0.000E648A6A1405B500p0", "0x0.000EF7F06B5C5F9140p0", "0x0.000F8B56C17E425348p0", "0x0.00101EBD6C79DED310p0", "0x0.0010B2246C4F65E8ACp0", "0x0.0011458BC0FF086C50p0", "0x0.0011D8F36A88F7364Cp0",
    "0x0.00126C5B68ED631F08p0", "0x0.0012FFC3BC2C7CFF0Cp0", "0x0.0013932C644675AEF4p0", "0x0.00142695613B7E0788p0", "0x0.0014B9FEB30BC6E19Cp0", "0x0.00154D6859B7811628p0", "0x0.0015E0D2553EDD7E44p0", "0x0.0016743CA5A20CF314p0",
    "0x0.001707A74AE1404DF0p0", "0x0.00179B1244FCA86834p0", "0x0.00182E7D93F4761B6Cp0", "0x0.0018C1E937C8DA4134p0", "0x0.00195555307A05B348p0", "0x0.0019E8C17E08294B7Cp0", "0x0.001A7C2E207375E3C8p0", "0x0.001B0F9B17BC1C563Cp0",
    "0x0.001BA30863E24D7D04p0", "0x0.001C367604E63A3268p0", "0x0.001CC9E3FAC81350CCp0", "0x0.001D5D52458809B2ACp0", "0x0.001DF0C0E5264E32ACp0", "0x0.001E842FD9A311AB84p0", "0x0.001F179F22FE84F804p0", "0x0.001FAB0EC138D8F320p0",
    "0x0.00203E7EB4523E77E4p0", "0x0.0020D1EEFC4AE66178p0", "0x0.0021655F9923018B24p0", "0x0.0021F8D08ADAC0D048p0", "0x0.00228C41D172550C64p0", "0x0.00231FB36CE9EF1B0Cp0", "0x0.0023B3255D41BFD7FCp0", "0x0.00244697A279F81F04p0",
    "0x0.0024DA0A3C92C8CC10p0", "0x0.00256D7D2B8C62BB2Cp0", "0x0.002600F06F66F6C880p0", "0x0.002694640822B5D04Cp0", "0x0.002727D7F5BFD0AEECp0", "0x0.0027BB4C383E7840E0p0", "0x0.00284EC0CF9EDD62C0p0", "0x0.0028E235BBE130F138p0",
    "0x0.002975AAFD05A3C918p0", "0x0.002A0920930C66C754p0", "0x0.002A9C967DF5AAC8E8p0", "0x0.002B300CBDC1A0AB00p0", "0x0.002BC3835270794AD4p0", "0x0.002C56FA3C026585C8p0", "0x0.002CEA717A77963950p0", "0x0.002D7DE90DD03C4300p0",
    "0x0.002E1160F60C888084p0", "0x0.002EA4D9332CABCFB0p0", "0x0.002F3851C530D70E68p0", "0x0.002FCBCAAC193B1AB0p0", "0x0.00305F43E7E608D2ACp0", "0x0.0030F2BD7897711494p0", "0x0.003186375E2DA4BEC4p0", "0x0.003219B198A8D4AFB0p0",
    "0x0.0032AD2C280931C5ECp0", "0x0.003340A70C4EECE020p0", "0x0.0033D422457A36DD1Cp0", "0x0.0034679DD38B409BBCp0", "0x0.0034FB19B6823AFB0Cp0", "0x0.00358E95EE5F56DA24p0", "0x0.003622127B22C51840p0", "0x0.0036B58F5CCCB694B4p0",
    "0x0.0037490C935D5C2EF8p0", "0x0.0037DC8A1ED4E6C690p0", "0x0.00387007FF33873B30p0", "0x0.0039038634796E6C9Cp0", "0x0.00399704BEA6CD3AB4p0", "0x0.003A2A839DBBD48578p0", "0x0.003ABE02D1B8B52D04p0", "0x0.003B51825A9DA01190p0",
    "0x0.003BE502386AC6136Cp0", "0x0.003C78826B2058130Cp0", "0x0.003D0C02F2BE86F0F8p0", "0x0.003D9F83CF45838DD8p0", "0x0.003E330500B57ECA74p0", "0x0.003EC686870EA987A4p0", "0x0.003F5A08625134A66Cp0", "0x0.003FED8A927D5107E4p0",
    "0x0.0040810D17932F8D38p0", "0x0.0041148FF1930117C0p0", "0x0.0041A813207CF688E8p0", "0x0.00423B96A45140C234p0", "0x0.0042CF1A7D1010A550p0", "0x0.0043629EAAB99713F8p0", "0x0.0043F6232D4E04F00Cp0", "0x0.004489A804CD8B1B80p0",
    "0x0.00451D2D31385A7870p0", "0x0.0045B0B2B28EA3E90Cp0", "0x0.0046443888D0984FA0p0", "0x0.0046D7BEB3FE688E98p0", "0x0.00476B453418458878p0", "0x0.0047FECC091E601FE4p0", "0x0.004892533310E93798p0", "0x0.004925DAB1F011B270p0"
   };
_ssdm_SpecConstant(exp_x_msb_ind_3_m_1_table);
# 3292 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

   ap_ufixed<61,-9> exp_x_msb_ind_3_m_1 = exp_x_msb_ind_3_m_1_table[x_msb_ind_3];
   ap_ufixed<115,-25> f_x_msb_ind_3_msb_ind_4_lsb_ind = exp_x_msb_ind_3_m_1 * exp_x_msb_ind_4_lsb_ind_m_1;
   ap_ufixed<59,-9> exp_x_msb_ind_3_msb_ind_4_lsb_ind_m_1 = f_x_msb_ind_3_msb_ind_4_lsb_ind + exp_x_msb_ind_3_m_1 + exp_x_msb_ind_4_lsb_ind_m_1;
   const static ap_ufixed<67,-1> exp_x_msb_ind_2_m_1_table[256] = {
    "0x0.0p0", "0x0.0049B96285BC0A736p0", "0x0.009388004BE7E5593p0", "0x0.00DD6BDF6FC8EDEABp0", "0x0.01276506106747AA4p0", "0x0.0171737A4E8E5E346p0", "0x0.01BB97424CCD67360p0", "0x0.0205D0642F77E4885p0",
    "0x.02501EE61CA62671Ep0", "0x0.029A82CE3C35CE0DBp0", "0x0.02E4FC22B7CA4FD73p0", "0x0.032F8AE9BACD765C6p0", "0x0.037A2F29726FE5154p0", "0x0.03C4E8E80DA99B612p0", "0x0.040FB82BBD3A77A9Ap0", "0x0.045A9CFAB3AABAAB4p0",
    "0x.04A5975B254B8AE40p0", "0x0.04F0A75348377827Fp0", "0x0.053BCCE95452FF5B2p0", "0x0.05870823834D0E520p0", "0x0.05D25908109F87D7Ap0", "0x0.061DBF9D398FC7D9Dp0", "0x0.06693BE93D2F27BB7p0", "0x0.06B4CDF25C5B82CCDp0",
    "0x.070075BED9BFBAEA4p0", "0x0.074C3354F9D43D40Ap0", "0x0.079806BB02DF8738Ap0", "0x0.07E3EFF73CF6AB87Ap0", "0x0.082FEF0FF1FDD767Bp0", "0x0.087C040B6DA8D7F50p0", "0x0.08C82EEFFD7B9FB28p0", "0x0.09146FC3F0CACC34Cp0",
    "0x.0960C68D98BC2BF2Ep0", "0x0.09AD33534847443EAp0", "0x0.09F9B61B5435D762Cp0", "0x0.0A464EEC13246AE7Ep0", "0x0.0A92FDCBDD82CE006p0", "0x0.0ADFC2C10D94A01AAp0", "0x0.0B2C9DD1FF71D79A4p0", "0x0.0B798F05110748B7Fp0",
    "0x.0BC69660A2172C887p0", "0x0.0C13B3EB1439A82A1p0", "0x0.0C60E7AACADD54194p0", "0x0.0CAE31A62B47C3AC7p0", "0x0.0CFB91E39C960CB66p0", "0x0.0D49086987BD4F4FEp0", "0x0.0D96953E578B3DC88p0", "0x0.0DE4386878A6A4BEAp0",
    "0x.0E31F1EE598FF35E7p0", "0x0.0E7FC1D66AA1C3C87p0", "0x0.0ECDA8271E11639EAp0", "0x0.0F1BA4E6E7EF5CBA0p0", "0x0.0F69B81C3E27FE069p0", "0x0.0FB7E1CD9883E4871p0", "0x0.1006220170A884803p0", "0x0.105478BE4218B2CB7p0",
    "0x.10A2E60A8A352E513p0", "0x0.10F169ECC83D29AA6p0", "0x0.1140046B7D4ED4EA6p0", "0x0.118EB58D2C67E78FCp0", "0x0.11DD7D585A662A9D7p0", "0x0.122C5BD38E0802DB1p0", "0x0.127B51054FECFB3DBp0", "0x0.12CA5CF42A964F780p0",
    "0x.13197FA6AA6776B28p0", "0x0.1368B9235DA6AE6BAp0", "0x0.13B80970D47D85804p0", "0x0.14077095A0F9675B6p0", "0x0.1456EE98570C274EEp0", "0x0.14A6837F8C8C8C138p0", "0x0.14F62F51D936DB71Dp0", "0x0.1545F215D6AD6612Fp0",
    "0x.1595CBD2207913796p0", "0x0.15E5BC8D5409EE22Bp0", "0x0.1635C44E10B7AFD11p0", "0x0.1685E31AF7C24DFD9p0", "0x0.16D618FAAC528672Ap0", "0x0.172665F3D37A6C0F3p0", "0x0.1776CA0D1435F3B24p0", "0x0.17C7454D176B814F4p0",
    "0x.1817D7BA87EC752AAp0", "0x0.1868815C1275B93F8p0", "0x0.18B9423865B04ECDCp0", "0x0.190A1A563231DC114p0", "0x0.195B09BC2A7D3A217p0", "0x0.19AC1071030302FA1p0", "0x0.19FD2E7B72221FACBp0", "0x0.1A4E63E2302856BB6p0",
    "0x.1A9FB0ABF752DA9BEp0", "0x0.1AF114DF83CED8647p0", "0x0.1B42908393BA06A18p0", "0x0.1B94239EE72334542p0", "0x0.1BE5CE38400AD81A5p0", "0x0.1C37905662639F7FEp0", "0x0.1C896A001412FE793p0", "0x0.1CDB5B3C1CF1BF06Bp0",
    "0x.1D2D641146CC91022p0", "0x0.1D7F84865D649A153p0", "0x0.1DD1BCA22E7005D96p0", "0x0.1E240C6B899A96219p0", "0x0.1E7673E94086336D2p0", "0x0.1EC8F32226CB7D849p0", "0x0.1F1B8A1D11FA5C3FAp0", "0x0.1F6E38E0D99A9075Cp0",
    "0x.1FC0FF74572C45177p0", "0x0.2013DDDE6628A071Cp0", "0x0.2066D425E402559C1p0", "0x0.20B9E251B026360EFp0", "0x0.210D0868ABFBC3658p0", "0x0.21604671BAE5C1485p0", "0x0.21B39C73C242C7830p0", "0x0.22070A75A96DD4433p0",
    "0x.225A907E59BEDE81Cp0", "0x0.22AE2E94BE8B6896Ap0", "0x0.2301E4BFC52712F67p0", "0x0.2355B3065CE42F1A7p0", "0x0.23A9996F77145292Cp0", "0x0.23FD98020708EA434p0", "0x0.2451AEC50213CDCA7p0", "0x0.24A5DDBF5F87D312Ep0",
    "0x.24FA24F818B9620F7p0", "0x0.254E847628FF08A1Bp0", "0x0.25A2FC408DB20EAB1p0", "0x0.25F78C5E462F0A48Bp0", "0x0.264C34D653D67439Bp0", "0x0.26A0F5AFBA0D3C70Bp0", "0x0.26F5CEF17E3D5ECF9p0", "0x0.274AC0A2A7D6780E4p0",
    "0x.279FCACA404E5ACCBp0", "0x0.27F4ED6F5321A4CF5p0", "0x0.284A2898EDD45466Ap0", "0x0.289F7C4E1FF25E01Ep0", "0x0.28F4E895FB1041ECEp0", "0x0.294A6D7792CBA238Bp0", "0x0.29A00AF9FCCBD8CFCp0", "0x0.29F5C12450C28DB50p0",
    "0x.2A4B8FFDA86C4D6E8p0", "0x0.2AA1778D1F911F9B4p0", "0x0.2AF777D9D4051DB44p0", "0x0.2B4D90EAE5A909F93p0", "0x0.2BA3C2C7766AE6888p0", "0x0.2BFA0D76AA468CA2Fp0", "0x0.2C5070FFA746441ACp0", "0x0.2CA6ED6995835AEE4p0",
    "0x.2CFD82BB9F26BD0EAp0", "0x0.2D5430FCF0698C518p0", "0x0.2DAAF834B795B88F5p0", "0x0.2E01D86A250697ECCp0", "0x0.2E58D1A46B297F504p0", "0x0.2EAFE3EABE7E5B03Bp0", "0x0.2F070F44559847819p0", "0x0.2F5E53B8691E2A6E5p0",
    "0x.2FB5B14E33CB4BBE3p0", "0x0.300D280CF26FEF065p0", "0x0.3064B7FBE3F1ECFAEp0", "0x0.30BC6122494D4D18Bp0", "0x0.311423876594DF7B7p0", "0x0.316BFF327DF2D6E06p0", "0x0.31C3F42AD9A962D4Ep0", "0x0.321C0277C2134A11Dp0",
    "0x.32742A2082A485035p0", "0x0.32CC6B2C68EAD87CAp0", "0x0.3324C5A2C48E70995p0", "0x0.337D398AE7527BCA2p0", "0x0.33D5C6EC2515C60F8p0", "0x0.342E6DCDD3D3545FDp0", "0x0.34872E374BA3003AFp0", "0x0.34E0082FE6BA136ADp0",
    "0x.3538FBBF016BE3F00p0", "0x0.359208EBFA2A701C4p0", "0x0.35EB2FBE3186FAD90p0", "0x0.3644703D0A32A81BDp0", "0x0.369DCA6FE8FF1986Fp0", "0x0.36F73E5E34DF0B37Bp0", "0x0.3750CC0F56E6F0C1Ep0", "0x0.37AA738ABA4D92580p0",
    "0x.380434D7CC6CAA213p0", "0x0.385E0FFDFCC181BC3p0", "0x0.38B80504BCED8FF00p0", "0x0.391213F380B716895p0", "0x0.396C3CD1BE09C0665p0", "0x0.39C67FA6ECF73FAF1p0", "0x0.3A20DC7A87B7EC3C5p0", "0x0.3A7B53540AAB622AFp0",
    "0x.3AD5E43AF459209E5p0", "0x0.3B308F36C57128AF1p0", "0x0.3B8B544F00CC9C88Ap0", "0x0.3BE6338B2B6E5EB41p0", "0x0.3C412CF2CC83B1910p0", "0x0.3C9C408D6D64D6FC5p0", "0x0.3CF76E629995B0251p0", "0x0.3D52B679DEC65D8F1p0",
    "0x.3DAE18DACCD3DF440p0", "0x0.3E09958CF5C8B5321p0", "0x0.3E652C97EDDD7FB9Bp0", "0x0.3EC0DE034B79A0686p0", "0x0.3F1CA9D6A733DAE2Ep0", "0x0.3F7890199BD2F5FCFp0", "0x0.3FD490D3C64E5D001p0", "0x0.4030AC0CC5CEC11FFp0",
    "0x.408CE1CC3BAEBB1E6p0", "0x0.40E93219CB7B6D1CCp0", "0x0.41459CFD1AF5249CFp0", "0x0.41A2227DD20FFCB02p0", "0x0.41FEC2A39AF480553p0", "0x0.425B7D7622004D04Dp0", "0x0.42B852FD15C6B56D6p0", "0x0.431543402711645D2p0",
    "0x.43724E4708E0FFDB7p0", "0x0.43CF7419706DCC711p0", "0x0.442CB4BF1528509F4p0", "0x0.448A103FB0B9F8866p0", "0x0.44E786A2FF05B9BB0p0", "0x0.454517F0BE28B74ACp0", "0x0.45A2C430AE7AE5F03p0", "0x0.46008B6A928FB075Ep0",
    "0x.465E6DA62F369C48Ep0", "0x0.46BC6AEB4B7BEE3AAp0", "0x0.471A8341B0A94F727p0", "0x0.4778B6B12A46728E1p0", "0x0.47D705418619B8F25p0", "0x0.48356EFA9428D84B1p0", "0x0.4893F3E426B9803ABp0", "0x0.48F2940612520039Ap0",
    "0x.49514F682DB9EDA59p0", "0x0.49B0261251FACA004p0", "0x0.4A0F180C5A60A95E7p0", "0x0.4A6E255E247AD906Ap0", "0x0.4ACD4E0F901C863FEp0", "0x0.4B2C92287F5D65507p0", "0x0.4B8BF1B0D69A58AD0p0", "0x0.4BEB6CB07C7618574p0",
    "0x.4C4B032F59D9D96D8p0", "0x0.4CAAB53559F5F5E9Fp0", "0x0.4D0A82CA6A429492Bp0", "0x0.4D6A6BF67A8051199p0", "0x0.4DCA70C17CB8E46D2p0", "0x0.4E2A9133653FCD395p0", "0x0.4E8ACD542AB2F8995p0", "0x0.4EEB252BC5FB6AF99p0",
    "0x.4F4B98C2324DE92ACp0", "0x0.4FAC281F6D2BA1A4Fp0", "0x0.500CD34B7662D5FC3p0", "0x0.506D9A4E500F84855p0", "0x0.50CE7D2FFE9C122BEp0", "0x0.512F7BF888C1F4791p0", "0x0.519096AFF78A5BCB5p0", "0x0.51F1CD5E564EDDBF2p0",
    "0x.5253200BB2BA1FC90p0", "0x0.52B48EC01CC882005p0", "0x0.53161983A6C8CA1BBp0", "0x0.5377C05E655CCE9E1p0", "0x0.53D983586F7A2235Ep0", "0x0.543B6279DE6ABF4CAp0", "0x0.549D5DCACDCDB3C8Dp0", "0x0.54FF75535B97CD007p0"
   };
_ssdm_SpecConstant(exp_x_msb_ind_2_m_1_table);
# 3313 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

   ap_ufixed<67,-1> exp_x_msb_ind_2_m_1 = exp_x_msb_ind_2_m_1_table[x_msb_ind_2];
   ap_ufixed<126,-10> f_x_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind = exp_x_msb_ind_2_m_1 * exp_x_msb_ind_3_msb_ind_4_lsb_ind_m_1;
   ap_ufixed<65,-1> exp_x_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind_m_1 = f_x_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind + exp_x_msb_ind_2_m_1 + exp_x_msb_ind_3_msb_ind_4_lsb_ind_m_1;
   const static ap_ufixed<66,32> exp_x_msb_ind_1_table[256] = {
    "0x1.000000000p0", "0x1.5561A91BCp0", "0x1.C73D51C54p0", "0x2.5F1258E08p0", "0x3.298B075B4p0", "0x4.378B053ECp0", "0x5.9F9802C8Cp0", "0x7.7FBAAB458p0",
    "0xA.000000000p0", "0xD.55D09B148p0", "0x11.C86531B4Cp0", "0x17.B6B778C40p0", "0x1F.9F6E49910p0", "0x2A.2B6E34724p0", "0x38.3BF01BD84p0", "0x4A.FD4AB0B64p0",
    "0x64.000000000p0", "0x85.5A260ECDCp0", "0xB1.D3F3F10ECp0", "0xED.232AB7A90p0", "0x13C.3A4EDFA98p0", "0x1A5.B24E0C774p0", "0x232.57611671Cp0", "0x2ED.E4EAE71ECp0",
    "0x3E8.000000000p0", "0x535.857C94088p0", "0x6F2.47876A934p0", "0x943.5FAB2C9B4p0", "0xC5A.4714BC9E8p0", "0x1078.F70C7CA94p0", "0x15F7.69CAE0728p0", "0x1D4A.F12D0732Cp0",
    "0x2710.000000000p0", "0x3417.36DDC8558p0", "0x4576.CB4A29C18p0", "0x5CA1.BCAFBE0F8p0", "0x7B86.C6CF5E320p0", "0xA4B9.A67CDE9B4p0", "0xDBAA.21ECC4790p0", "0x124ED.6BC247FB8p0",
    "0x186A0.000000000p0", "0x208E8.24A9D3580p0", "0x2B6A3.F0E5A18ECp0", "0x39E51.5EDD6C9A0p0", "0x4D343.C419ADF30p0", "0x66F40.80E0B210Cp0", "0x894A5.533FACBA4p0", "0xB7146.3596CFD3Cp0",
    "0xF4240.000000000p0", "0x145911.6EA2416F4p0", "0x1B2267.68F84F938p0", "0x242F2D.B4A63E038p0", "0x3040A5.A900CB7F0p0", "0x405885.08C6F4A64p0", "0x55CE75.407CBF46Cp0", "0x726CBE.17E41E45Cp0",
    "0x989680.000000000p0", "0xCB7AAE.52568E584p0", "0x10F580A.19B31BC34p0", "0x169D7C9.0E7E6C220p0", "0x1E28678.9A07F2F6Cp0", "0x2837532.57C58E7F0p0", "0x35A1094.84DF78C38p0", "0x4783F6C.EEE92EB90p0",
    "0x5F5E100.000000000p0", "0x7F2CACF.37618F720p0", "0xA997065.00FF159FCp0", "0xE226DDA.90F039530p0", "0x12D940B6.044F7DA48p0", "0x192293F7.6DB790F54p0", "0x2184A5CD.30BAB7A30p0", "0x2CB27A41.551BD339Cp0",
    "0x3B9ACA00.000000000p0", "0x4F7BEC18.29CF9A750p0", "0x69FE63F2.09F6D83E4p0", "0x8D584A89.A9623D3E0p0", "0xBC7C871C.2B1AE86C4p0", "0xFB59C7AA.492BA9948p0", "0x14F2E7A03.E74B2C5F4p0", "0x1BEF8C68D.531640404p0",
    "0x2540BE400.000000000p0", "0x31AD738F1.A21C08914p0", "0x423EFE774.63A4726F4p0", "0x58572E960.9DD6646C4p0", "0x75CDD4719.AF0D143A8p0", "0x9D181CCA6.DBB49FCD0p0", "0xD17D0C427.08EFBBB80p0", "0x1175B7C185.3EDE8282Cp0",
    "0x174876E800.000000000p0", "0x1F0C683970.551855AD0p0", "0x29675F0A8B.E46C78594p0", "0x37367D1DC6.2A5FEC3A0p0", "0x49A0A4C700.D682CA49Cp0", "0x622F11FE84.950E3E020p0", "0x82EE27A986.595D55300p0", "0xAE992D8F34.74B1191B8p0",
    "0xE8D4A51000.000000000p0", "0x1367C123E63.52F358C14p0", "0x19E09B66976.EC3CB37C0p0", "0x22820E329BD.A7BF3A448p0", "0x2E0466FC608.611BE6E18p0", "0x3D5D6B3F12D.D28E6C148p0", "0x51D4D8C9F3F.7DA553E00p0", "0x6D1FBC7980C.8EEAFB130p0",
    "0x9184E72A000.000000000p0", "0xC20D8B66FE1.3D81778C0p0", "0x102C61201EA5.3A5F02D70p0", "0x159148DFA168.8D7846AE0p0", "0x1CC2C05DBC53.CB1704CFCp0", "0x265A63076BCA.399038CD8p0", "0x3325077E387A.E87546BF0p0", "0x4433D5CBF07D.952DCEBE8p0",
    "0x5AF3107A4000.000000000p0", "0x794877205ECC.670EAB770p0", "0xA1BBCB413274.47B61C654p0", "0xD7ACD8BC4E15.86B2C2CC0p0", "0x11F9B83A95B45.EEE6301D8p0", "0x17F87DE4A35E6.3FA238074p0", "0x1FF724AEE34CD.1494C3758p0", "0x2AA0659F764E7.D3CA13714p0",
    "0x38D7EA4C68000.000000000p0", "0x4BCD4A743B3FC.0692B2A70p0", "0x65155F08BF88A.CD1D1BF4Cp0", "0x86CC0775B0CD7.42FB9BF90p0", "0xB3C13249D90BB.54FDE1260p0", "0xEFB4EAEE61AFE.7C563047Cp0", "0x13FA76ED4E1002.CDCFA296Cp0", "0x1AA43F83A9F10E.45E4C26DCp0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x.000000004p0", "0x.000000004p0", "0x.000000004p0", "0x.000000004p0",
    "0x0.000000008p0", "0x.000000008p0", "0x.00000000Cp0", "0x.000000010p0", "0x.000000014p0", "0x.00000001Cp0", "0x.000000028p0", "0x.000000034p0",
    "0x0.000000044p0", "0x.00000005Cp0", "0x.00000007Cp0", "0x.0000000A4p0", "0x.0000000D8p0", "0x.000000120p0", "0x.000000184p0", "0x.000000204p0",
    "0x0.0000002B0p0", "0x.000000394p0", "0x.0000004C8p0", "0x.00000065Cp0", "0x.00000087Cp0", "0x.000000B50p0", "0x.000000F18p0", "0x.000001420p0",
    "0x0.000001AD8p0", "0x.0000023CCp0", "0x.000002FBCp0", "0x.000003FA8p0", "0x.0000054E4p0", "0x.000007134p0", "0x.0000096F4p0", "0x.00000C94Cp0",
    "0x0.000010C70p0", "0x.0000165F8p0", "0x.00001DD5Cp0", "0x.000027C90p0", "0x.0000350E0p0", "0x.000046BFCp0", "0x.00005E588p0", "0x.00007DCFCp0",
    "0x0.0000A7C5Cp0", "0x.0000DFBA4p0", "0x.00012A588p0", "0x.00018DD9Cp0", "0x.0002128ACp0", "0x.0002C37D4p0", "0x.0003AF73Cp0", "0x.0004EA1D0p0",
    "0x0.00068DB8Cp0", "0x.0008BD470p0", "0x.000BA7754p0", "0x.000F8A814p0", "0x.0014B96C0p0", "0x.001BA2E4Cp0", "0x.0024DA858p0", "0x.003125230p0",
    "0x0.004189374p0", "0x.005764C70p0", "0x.00748A940p0", "0x.009B690C8p0", "0x.00CF3E374p0", "0x.01145CEF0p0", "0x.017089380p0", "0x.01EB735F0p0",
    "0x0.028F5C290p0", "0x.0369EFC58p0", "0x.048D69C70p0", "0x.06121A7D0p0", "0x.08186E274p0", "0x.0ACBA1550p0", "0x.0E655C300p0", "0x.133281B68p0",
    "0x0.199999998p0", "0x.22235DB60p0", "0x.2D8621C70p0", "0x.3CB508E34p0", "0x.50F44D894p0", "0x.6BF44D530p0", "0x.8FF599E10p0", "0x.BFF911208p0"
   };
_ssdm_SpecConstant(exp_x_msb_ind_1_table);
# 3350 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_exp_apfixed.h"

   ap_ufixed<66,32> exp_x_msb_ind_1 = exp_x_msb_ind_1_table[x_msb_ind_1];
   ap_ufixed<131,31> f_x_msb_ind_1_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind = exp_x_msb_ind_1 * exp_x_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind_m_1;
   y = f_x_msb_ind_1_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind + exp_x_msb_ind_1;
  }
  if(I_<33) {
   bool overf = 0;
#pragma unroll
 for(int j = 63; j >= 31 + I_; j--) {
    if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
#pragma unroll
 for(int j = 63; j >= 31 + I_; j--) {
     y[j] = 0;
    }
#pragma unroll
 for(int j = 30 + I_; j >= 0; j--) {
     y[j] = 1;
    }
   }
  }
  r = y;
 }
 return r;
}

template<int W, int I>
ap_ufixed<W,I> exp10(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return exp10(xf);
}

template<int I>
ap_int<I> exp10(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return exp10(xf);
}

template<int I>
ap_uint<I> exp10(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return exp10(xf);
}

}
# 1021 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h" 1
# 39 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"
namespace log_apfixed_reduce {


template <typename T, int p, int alpha, int size> class log_lut_table { public:
log_lut_table<T,p,alpha,size>();
static const T array [size];};
template <> class log_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};

template <> class log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <typename T, int p, int alpha, int size> class log0_lut_table { public:
log0_lut_table<T,p,alpha,size>();
static const T array[size];};
template <> class log0_lut_table<ap_fixed<20, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<20, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();

static const ap_fixed<20, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

class log_inverse_lut_table { public:
log_inverse_lut_table();
static const ap_ufixed<6, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array[64];};


template <typename LOG_TYPE, int p, int alpha, int size, int sizeout>
void range_reduce(ap_ufixed<size, -p> zN, LOG_TYPE &log, ap_ufixed<sizeout, -(p+alpha-1)> &zN1)
{

    const int T1size = 1 << alpha;




    ap_ufixed<alpha, -p> a = zN;
    ap_ufixed<size-alpha, -p-alpha> b = zN;
    ap_ufixed<size+p+2*p+1, 1> zNext = 1+zN;
    int e_shift = (p!=4 || a[a.wl()-1]==1) ? 2*p : 2*p+1;
    ap_ufixed<size+p+1, 1-2*p> eZ = zNext >> e_shift;

    zN1 = ((b + eZ) - a*zN);
    ap_uint<alpha> index = a(alpha-1,0);
    log = log_lut_table<LOG_TYPE, p,alpha,T1size>::array[index];


}




const int p0 = 0;
const int alpha0 = 5;
const int p1 = (alpha0 == 5) ? 4 : (alpha0-2);
const int alpha1 = 4;
const int p2 = p1 + alpha1 - 1;
const int alpha2 = 6;
const int p3 = p2 + alpha2 - 1;
const int alpha3 = 6;
const int p4 = p3 + alpha3 - 1;
const int alpha4 = 6;
const int p5 = p4 + alpha4 - 1;
const int alpha5 = 6;
const int p6 = p5 + alpha5 - 1;
const int alpha6 = 6;
const int p7 = p6 + alpha6 - 1;
const int alpha7 = 6;
const int p8 = p7 + alpha7 - 1;

template <int W_s_> class log_traits{};

template <>
class log_traits<1>{
public:
    const static int we = 6;
    const static int wf = 11;
    const static int org_wf = wf;

    const static int gbits = 1;
    const static int p_generic = p1;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        return z1;
    }
};

template <>
class log_traits<2>{
public:
    const static int we = 6;
    const static int wf = 19;
    const static int org_wf = wf;

    const static int gbits = 2;
    const static int p_generic = p2;
    const static int MaxPrecision =wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        return z2;
    }
};

template <>
class log_traits<3>{
public:
    const static int we = 6;
    const static int wf = 33;
    const static int org_wf = wf;

    const static int gbits = 3;
    const static int p_generic = p3;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        return z3;
    }
};

template <>
class log_traits<4>{
public:
    const static int we = 6;
    const static int wf = 48;
    const static int org_wf = wf;

    const static int gbits = 3;
    const static int p_generic = p4;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        return z4;
    }
};

template <>
class log_traits<5>{
public:
    const static int we = 6;
    const static int wf = 63;
    const static int org_wf = wf;

    const static int gbits = 3;
    const static int p_generic = p5;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        return z5;
    }
};

template <>
class log_traits<6>{
public:
    const static int we = 6;
    const static int wf = 76;
    const static int org_wf = wf;

    const static int gbits = 4;
    const static int p_generic = p6;
    const static int MaxPrecision = wf+gbits+2;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < MaxPrecision-p6) ? w6 : (MaxPrecision-p6), -p6> z6;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        return z6;
    }
};

template <>
class log_traits<7>{
public:
    const static int we = 6;
    const static int wf = 91;
    const static int org_wf = wf;

    const static int gbits = 4;
    const static int p_generic = p7;
    const static int MaxPrecision = wf+gbits+2;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);
    const static int w7 = w6+2*p6+1-(alpha6-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < MaxPrecision-p6) ? w6 : (MaxPrecision-p6), -p6> z6;
        ap_ufixed<(w7 < MaxPrecision-p7) ? w7 : (MaxPrecision-p7), -p7> z7;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        range_reduce<LOG_TYPE, p6, alpha6> (z6, logn, z7);
        log_sum += logn;
        return z7;
    }
};

template <>
class log_traits<8>{
public:
    const static int we = 6;
    const static int wf = 106;
    const static int org_wf = wf;

    const static int gbits = 4;
    const static int p_generic = p8;
    const static int MaxPrecision = wf+gbits+2;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);
    const static int w7 = w6+2*p6+1-(alpha6-1);
    const static int w8 = w7+2*p7+1-(alpha7-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < MaxPrecision-p6) ? w6 : (MaxPrecision-p6), -p6> z6;
        ap_ufixed<(w7 < MaxPrecision-p7) ? w7 : (MaxPrecision-p7), -p7> z7;
        ap_ufixed<(w8 < MaxPrecision-p8) ? w8 : (MaxPrecision-p8), -p8> z8;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        range_reduce<LOG_TYPE, p6, alpha6> (z6, logn, z7);
        log_sum += logn;
        range_reduce<LOG_TYPE, p7, alpha7> (z7, logn, z8);
        log_sum += logn;
        return z8;
    }
};
template<int W_, int I_>
ap_fixed<W_,I_> log(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


 const static int F_ = W_ - I_;
_ssdm_SpecConstant(&F_);
# 503 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"

    if (I_>34) return 0;
    else if (F_>100) return 0;


    ap_fixed<W_,I_> r = 0;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if (F_==0) {
        if (I_<=7) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else r = 4;
        } else if (I_<=10) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else r = 6;
        } else if (I_<=13) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else r = 8;
        } else if (I_<=17) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else r = 11;
        } else if (I_<=19) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else r = 12;
        } else if (I_<=26) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x41831p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb2148p0")) r = 13;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e4127p0")) r = 14;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x523d82p0")) r = 15;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xdf8d5fp0")) r = 16;
            else r = 17;
        } else if (I_<=32) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x41831p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb2148p0")) r = 13;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e4127p0")) r = 14;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x523d82p0")) r = 15;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xdf8d5fp0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x25fad90p0")) r = 17;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x673d70bp0")) r = 18;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x118a2aaep0")) r = 19;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2fad89e1p0")) r = 20;
            else r = 21;
        } else {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x41831p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb2148p0")) r = 13;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e4127p0")) r = 14;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x523d82p0")) r = 15;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xdf8d5fp0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x25fad90p0")) r = 17;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x673d70bp0")) r = 18;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x118a2aaep0")) r = 19;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2fad89e1p0")) r = 20;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x819a1801p0")) r = 21;
            else r = 22;
        }
    } else if (F_<=4 && I_<=5) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "-0x2.cp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "-0x2.1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "-0x1.bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "-0x1.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "-0x1.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "-0x1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.7p0")) r = "-0x0.dp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "-0x0.bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "-0x0.9p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.ap0")) r = "-0x0.8p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.bp0")) r = "-0x0.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.cp0")) r = "-0x0.5p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.dp0")) r = "-0x0.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.ep0")) r = "-0x0.2p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.fp0")) r = "-0x0.1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1p0")) r = "0x0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x0.1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.2p0")) r = "0x0.2p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x0.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.5p0")) r = "0x0.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.6p0")) r = "0x0.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.8p0")) r = "0x0.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.9p0")) r = "0x0.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.bp0")) r = "0x0.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.cp0")) r = "0x0.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ep0")) r = "0x0.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = "0x0.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.2p0")) r = "0x0.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.5p0")) r = "0x0.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.7p0")) r = "0x0.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.ap0")) r = "0x0.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.cp0")) r = "0x1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.fp0")) r = "0x1.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.2p0")) r = "0x1.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x1.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.9p0")) r = "0x1.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.dp0")) r = "0x1.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.1p0")) r = "0x1.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.5p0")) r = "0x1.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.9p0")) r = "0x1.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.ep0")) r = "0x1.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.3p0")) r = "0x1.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.9p0")) r = "0x1.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.ep0")) r = "0x1.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.5p0")) r = "0x1.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.bp0")) r = "0x1.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.2p0")) r = "0x1.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.9p0")) r = "0x2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.1p0")) r = "0x2.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.ap0")) r = "0x2.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.3p0")) r = "0x2.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.cp0")) r = "0x2.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.6p0")) r = "0x2.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.1p0")) r = "0x2.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.cp0")) r = "0x2.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.9p0")) r = "0x2.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xd.6p0")) r = "0x2.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.3p0")) r = "0x2.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf.2p0")) r = "0x2.bp0";
            else r = "0x2.cp0";
    } else {

        if (x<=0) {r[W_-1] = 1;}
        else {


            const static int W_s_ = (F_+F_/77*2+12)/15-(100+F_)/133+(99+F_)/133-(100+F_)/118+(98+F_)/118+1;
_ssdm_SpecConstant(&W_s_);
# 706 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"

# 716 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"
            const static int wf = log_traits<W_s_>::wf;
_ssdm_SpecConstant(&wf);
# 716 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"

            const static int I_s= I_>0? I_:-I_;
_ssdm_SpecConstant(&I_s);
# 717 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"

            const static int org_wf = log_traits<W_s_>::org_wf+I_s;
_ssdm_SpecConstant(&org_wf);
# 718 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"

            const static int MaxPrecision = log_traits<W_s_>::MaxPrecision;
_ssdm_SpecConstant(&MaxPrecision);
# 719 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"





            ap_int<7> b_exp;
            ap_ufixed<1 + org_wf,1> b_frac=0;
            b_frac[org_wf] = 0;
            b_frac(org_wf-1,org_wf-W_+1) = x(W_-2,0);
#pragma unroll
 for (b_exp = I_-1; b_exp >= -F_; b_exp--) {
                if ((!b_frac[org_wf]&b_frac[org_wf-1]&b_frac[org_wf-2])|(b_frac[org_wf]&!b_frac[org_wf-1]))
                    break;
                b_frac <<= 1;
            }



            const ap_ufixed<MaxPrecision,0> LOG2 = "0x0.B17217F7D1CF79ABC9E3B39803p0";
            ap_fixed<MaxPrecision,6> Elog2 = LOG2 * b_exp;



            typedef typename log_traits<W_s_>::LOG_TYPE LOG_TYPE;
            const static int bypass_threshold = log_traits<W_s_>::p_generic;
_ssdm_SpecConstant(&bypass_threshold);
# 743 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"



            ap_uint<1+alpha0> index0;
            if (b_frac[org_wf]) index0 = b_frac(org_wf-1,org_wf-6);
            else index0 = b_frac(org_wf-2,org_wf-7);

            const int T0size = 1 << (1+alpha0);




            ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table::array[index0];


            LOG_TYPE log_sum = log0_lut_table<LOG_TYPE,p0,alpha0,T0size>::array[index0];

            ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;





            const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
            ap_ufixed<z1_width, -p1> z1 = b_frac1;


            ap_fixed<1-bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk;
            zk = log_traits<W_s_>::range_reduction(z1,log_sum);


            ap_fixed<1-2*bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk_trunc = zk;
            LOG_TYPE sum = zk-(zk_trunc*zk_trunc/2);

            LOG_TYPE log_base;
            log_base = Elog2 + log_sum + sum;



            ap_fixed<2 + F_, 1> delta = 0;
            delta[delta.wl()-1] = log_base[log_base.wl()-1];
            delta[delta.wl()-delta.iwl()-1] = 1;
            log_base = log_base + ( delta >> F_ );

            r = log_base;
        }

    }

    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> log(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return log(xf);
}

template<int I_>
ap_int<I_> log(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return log(xf);
}

template<int I_>
ap_uint<I_> log(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return log(xf);
}


template<int W_, int I_>
ap_fixed<W_,I_> log10(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


 const static int F_ = W_ - I_;
_ssdm_SpecConstant(&F_);
# 820 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"

    if (I_>33) return 0;
    else if (F_>32) return 0;


    ap_fixed<W_,I_> r = 0;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if (F_==0) {
        if (I_<=9) {
            if (x<=0) {r[W_-1] = 1;}
            else {
                ap_ufixed<8,8> x_s_l = x_s;
                if (x_s_l(7,2)==0) r = 0;
                else if (x_s_l(7,5)==0) r = 1;
                else r = 2;
            }
        } else if (I_<=15) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else r = 4;
        } else if (I_<=19) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else r = 5;
        } else if (I_<=25) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4d343p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3040a5p0")) r = 6;
            else r = 7;
        } else if (I_<=32) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4d343p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3040a5p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e28678p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x12d940b6p0")) r = 8;
            else r = 9;
        } else {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4d343p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3040a5p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e28678p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x12d940b6p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xbc7c871cp0")) r = 9;
            else r = 10;
        }
    } else if (F_<=4 && I_<=5) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "-0x1.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "-0x0.ep0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "-0x0.cp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "-0x0.ap0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "-0x0.8p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "-0x0.7p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.7p0")) r = "-0x0.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "-0x0.5p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "-0x0.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.bp0")) r = "-0x0.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.cp0")) r = "-0x0.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.ep0")) r = "-0x0.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x0.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.6p0")) r = "0x0.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ap0")) r = "0x0.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ep0")) r = "0x0.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.3p0")) r = "0x0.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.8p0")) r = "0x0.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.fp0")) r = "0x0.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x0.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.ep0")) r = "0x0.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.8p0")) r = "0x0.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.3p0")) r = "0x0.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = "0x0.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.fp0")) r = "0x0.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8p0")) r = "0x0.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.4p0")) r = "0x0.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.bp0")) r = "0x1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.6p0")) r = "0x1.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.5p0")) r = "0x1.2p0";
            else r = "0x1.3p0";
    } else {

        if (x<=0) {r[W_-1] = 1;}
        else {
            const static int W_s_= (F_+F_/77*2+12)/15-(100+F_)/133+(99+F_)/133-(100+F_)/118+(98+F_)/118+1;
_ssdm_SpecConstant(&W_s_);
# 926 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"







            const static int wf = log_traits<W_s_>::wf;
_ssdm_SpecConstant(&wf);
# 933 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"

            const static int I_s= I_>0? I_:-I_;
_ssdm_SpecConstant(&I_s);
# 934 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"

            const static int org_wf = log_traits<W_s_>::org_wf+I_s;
_ssdm_SpecConstant(&org_wf);
# 935 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"

            const static int MaxPrecision = log_traits<W_s_>::MaxPrecision;
_ssdm_SpecConstant(&MaxPrecision);
# 936 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"






            ap_int<7> b_exp=0;
            ap_ufixed<1 + org_wf,1> b_frac=0;
            b_frac[org_wf] = 0;
            b_frac(org_wf-1,org_wf-W_+1) = x(W_-2,0);
#pragma unroll
 for (b_exp = I_-1; b_exp >= -F_; b_exp--) {
                if ((!b_frac[org_wf]&b_frac[org_wf-1]&b_frac[org_wf-2])|(b_frac[org_wf]&!b_frac[org_wf-1]))
                    break;
                b_frac <<= 1;
            }

            const ap_ufixed<25,0> LOG1_35_s = 0.3010300099849700927734375;
            const ap_ufixed<43,0> LOG1_35_l = 0.30102999566395283181918784976006;
            ap_fixed<30,5> Elog2_s = LOG1_35_s * b_exp;
            ap_fixed<48,5> Elog2_l = LOG1_35_l * b_exp;


            typedef typename log_traits<W_s_>::LOG_TYPE LOG_TYPE;
            const static int bypass_threshold = log_traits<W_s_>::p_generic;
_ssdm_SpecConstant(&bypass_threshold);
# 960 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"


            ap_uint<1+alpha0> index0;
            if (b_frac[org_wf]) index0 = b_frac(org_wf-1,org_wf-6);
            else index0 = b_frac(org_wf-2,org_wf-7);

            const int T0size = 1 << (1+alpha0);




            ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table::array[index0];

            LOG_TYPE log_sum = log0_lut_table<LOG_TYPE,p0,alpha0,T0size>::array[index0];

            ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;




            const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
            ap_ufixed<z1_width, -p1> z1 = b_frac1;

            ap_fixed<1-bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk;
            zk = log_traits<W_s_>::range_reduction(z1,log_sum);

            ap_fixed<1-2*bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk_trunc = zk;
            LOG_TYPE sum = zk-(zk_trunc*zk_trunc/2);

            LOG_TYPE log_base = log_sum + sum;

            const ap_ufixed<25,0> LOG1_54_s = 0.4342944920063018798828125;
            const ap_ufixed<43,0> LOG1_54_l = 0.43429448190329367207596078515053;

            if (F_<=16) log_base = Elog2_s + log_base * LOG1_54_s;
            else log_base = Elog2_l + log_base * LOG1_54_l;
# 1004 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"
            r = log_base;
        }

    }

    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> log10(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return log10(xf);
}

template<int I_>
ap_int<I_> log10(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return log10(xf);
}

template<int I_>
ap_uint<I_> log10(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return log10(xf);
}

template<int W, int I>
ap_fixed<W,I> log1p(ap_fixed<W,I> x) {
    ap_ufixed<1,1> inc = 1;
    ap_fixed<W+1,I+1> xp1 = x + inc;
    return log(xp1);
}

template<int W, int I>
ap_ufixed<W,I> log1p(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return log1p(xf);
}

template<int I>
ap_int<I> log1p(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return log1p(xf);
}

template<int I>
ap_uint<I> log1p(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return log1p(xf);
}

template<int W,int I>
ap_fixed<W,I> ilogb(ap_fixed<W,I> x) {
    int F = W - I;
    if(F>32 || I>33) {
        return 0;
    }
    ap_fixed<W+1,I+1> xf;
    if(x>0) {
        xf = x;
    }
    else {
        xf = -x;
    }
    return I + 1 - xf.countLeadingZeros() - 1;
}

template<int W,int I>
ap_ufixed<W,I> ilogb(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return ilogb(xf);
}

template<int I>
ap_int<I> ilogb(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return ilogb(xf);
}

template<int I>
ap_uint<I> ilogb(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return ilogb(xf);
}


template<int W_, int I_>
ap_fixed<W_,I_> log2(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


 const static int F_ = W_ - I_;
_ssdm_SpecConstant(&F_);
# 1096 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"

    if (I_>33) return 0;
    else if (F_>32) return 0;


    ap_fixed<W_,I_> r = 0;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if (F_==0) {
        if (I_<=5) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
            else r = 4;
  } else if (I_<=9) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
            else r = 8;
        } else if (I_<=13) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
            else r = 12;
  } else if (I_<=17) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
            else r = 16;
        } else if (I_<=21) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09p0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413p0")) r = 17;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827p0")) r = 18;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504Fp0")) r = 19;
            else r = 20;
        } else if (I_<=25) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09p0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413p0")) r = 17;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827p0")) r = 18;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504Fp0")) r = 19;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09Ep0")) r = 20;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413Cp0")) r = 21;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8279p0")) r = 22;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F3p0")) r = 23;
            else r = 24;
        } else if (I_<=29) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09p0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413p0")) r = 17;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827p0")) r = 18;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504Fp0")) r = 19;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09Ep0")) r = 20;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413Cp0")) r = 21;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8279p0")) r = 22;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F3p0")) r = 23;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09E6p0")) r = 24;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413CCp0")) r = 25;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82799p0")) r = 26;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F33p0")) r = 27;
            else r = 28;
        } else {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09p0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413p0")) r = 17;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827p0")) r = 18;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504Fp0")) r = 19;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09Ep0")) r = 20;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413Cp0")) r = 21;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8279p0")) r = 22;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F3p0")) r = 23;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09E6p0")) r = 24;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413CCp0")) r = 25;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82799p0")) r = 26;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F33p0")) r = 27;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09E66p0")) r = 28;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413CCCp0")) r = 29;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827999p0")) r = 30;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F333p0")) r = 31;
            else r = 32;
        }
    } else if (F_<=4 && I_<=5) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "-0x4.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "-0x3.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "-0x2.7p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "-0x2.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "-0x1.Bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "-0x1.7p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.7p0")) r = "-0x1.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "-0x1.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "-0x0.Dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.Ap0")) r = "-0x0.Bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Bp0")) r = "-0x0.9p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Cp0")) r = "-0x0.7p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Dp0")) r = "-0x0.5p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Ep0")) r = "-0x0.3p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Fp0")) r = "-0x0.1p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.0p0")) r = "0x0.0p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x0.1p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.2p0")) r = "0x0.3p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x0.4p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.4p0")) r = "0x0.5p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.5p0")) r = "0x0.6p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.6p0")) r = "0x0.7p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.7p0")) r = "0x0.8p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.8p0")) r = "0x0.9p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.9p0")) r = "0x0.Ap0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Ap0")) r = "0x0.Bp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Bp0")) r = "0x0.Cp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Cp0")) r = "0x0.Dp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Dp0")) r = "0x0.Ep0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Fp0")) r = "0x0.Fp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.0p0")) r = "0x1.0p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.2p0")) r = "0x1.1p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.3p0")) r = "0x1.2p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.5p0")) r = "0x1.3p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.6p0")) r = "0x1.4p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.8p0")) r = "0x1.5p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.Ap0")) r = "0x1.6p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.Cp0")) r = "0x1.7p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.Ep0")) r = "0x1.8p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.0p0")) r = "0x1.9p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.2p0")) r = "0x1.Ap0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.4p0")) r = "0x1.Bp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x1.Cp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.9p0")) r = "0x1.Dp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.Bp0")) r = "0x1.Ep0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.Ep0")) r = "0x1.Fp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.1p0")) r = "0x2.0p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.4p0")) r = "0x2.1p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.7p0")) r = "0x2.2p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.Ap0")) r = "0x2.3p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.Dp0")) r = "0x2.4p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.1p0")) r = "0x2.5p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.4p0")) r = "0x2.6p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.8p0")) r = "0x2.7p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.Cp0")) r = "0x2.8p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.0p0")) r = "0x2.9p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.4p0")) r = "0x2.Ap0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.9p0")) r = "0x2.Bp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.Dp0")) r = "0x2.Cp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.2p0")) r = "0x2.Dp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.7p0")) r = "0x2.Ep0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.Dp0")) r = "0x2.Fp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.2p0")) r = "0x3.0p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.8p0")) r = "0x3.1p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.Ep0")) r = "0x3.2p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.4p0")) r = "0x3.3p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.Bp0")) r = "0x3.4p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xA.2p0")) r = "0x3.5p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xA.9p0")) r = "0x3.6p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB.1p0")) r = "0x3.7p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB.8p0")) r = "0x3.8p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xC.1p0")) r = "0x3.9p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xC.9p0")) r = "0x3.Ap0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xD.2p0")) r = "0x3.Bp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xD.Bp0")) r = "0x3.Cp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xE.5p0")) r = "0x3.Dp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xE.Fp0")) r = "0x3.Ep0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xF.Ap0")) r = "0x3.Fp0";
            else r = "0x4.0p0";
    } else {

        if (x<=0) {r[W_-1] = 1;}
        else {
            const static int W_s_= (F_+F_/77*2+12)/15-(100+F_)/133+(99+F_)/133-(100+F_)/118+(98+F_)/118+1;
_ssdm_SpecConstant(&W_s_);
# 1359 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"


            const static int wf = log_traits<W_s_>::wf;
_ssdm_SpecConstant(&wf);
# 1361 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"

            const static int I_s= I_>0? I_:-I_;
_ssdm_SpecConstant(&I_s);
# 1362 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"

            const static int org_wf = log_traits<W_s_>::org_wf+I_s;
_ssdm_SpecConstant(&org_wf);
# 1363 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"

            const static int MaxPrecision = log_traits<W_s_>::MaxPrecision;
_ssdm_SpecConstant(&MaxPrecision);
# 1364 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"


            ap_int<7> b_exp=0;
            ap_ufixed<1 + org_wf,1> b_frac=0;
            b_frac[org_wf] = 0;
            b_frac(org_wf-1,org_wf-W_+1) = x(W_-2,0);
#pragma unroll
 for (b_exp = I_-1; b_exp >= -F_; b_exp--) {
                if ((!b_frac[org_wf]&b_frac[org_wf-1]&b_frac[org_wf-2])|(b_frac[org_wf]&!b_frac[org_wf-1]))
                    break;
                b_frac <<= 1;
            }

            ap_fixed<30,5> Elog2_s = b_exp;
            ap_fixed<48,5> Elog2_l = b_exp;


            typedef typename log_traits<W_s_>::LOG_TYPE LOG_TYPE;
            const static int bypass_threshold = log_traits<W_s_>::p_generic;
_ssdm_SpecConstant(&bypass_threshold);
# 1382 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_log_apfixed.h"


            ap_uint<1+alpha0> index0;
            if (b_frac[org_wf]) index0 = b_frac(org_wf-1,org_wf-6);
            else index0 = b_frac(org_wf-2,org_wf-7);

            const int T0size = 1 << (1+alpha0);




            ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table::array[index0];

            LOG_TYPE log_sum = log0_lut_table<LOG_TYPE,p0,alpha0,T0size>::array[index0];

            ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;




            const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
            ap_ufixed<z1_width, -p1> z1 = b_frac1;

            ap_fixed<1-bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk;
            zk = log_traits<W_s_>::range_reduction(z1,log_sum);

            ap_fixed<1-2*bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk_trunc = zk;
            LOG_TYPE sum = zk-(zk_trunc*zk_trunc/2);

            LOG_TYPE log_base = log_sum + sum;

            const ap_ufixed<26,1> LOG1_54_s = "0x1.7154765p0";
            const ap_ufixed<44,1> LOG1_54_l = "0x1.71547652B82Fp0";

            if (F_<=16) log_base = Elog2_s + log_base * LOG1_54_s;
            else log_base = Elog2_l + log_base * LOG1_54_l;



            r = log_base;
        }

    }

    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> log2(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return log2(xf);
}

template<int I_>
ap_int<I_> log2(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return log2(xf);
}

template<int I_>
ap_uint<I_> log2(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return log2(xf);
}

template<int W_, int I_>
ap_fixed<W_,I_> logb(ap_fixed<W_,I_> x) {
 return log2(x);
}

template<int W_, int I_>
ap_ufixed<W_,I_> logb(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return logb(xf);
}

template<int I_>
ap_int<I_> logb(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return logb(xf);
}

template<int I_>
ap_uint<I_> logb(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return logb(xf);
}

}
# 1022 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_sqrt_apfixed.h" 1
# 34 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_sqrt_apfixed.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 35 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_sqrt_apfixed.h" 2






template <int W_, int I_>
ap_fixed<W_,I_> sqrt_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


 const int F_ = W_ - I_;
    if (I_>34) return 0;
    else if (F_>32) return 0;


    ap_ufixed<F_+(I_+1)/2,(I_+1)/2> r;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if ((F_==0)&&(I_==2)) {
            r = x_s;
    } else if ((F_==0)&&(I_<=13)) {
        ap_ufixed<W_,I_> x_s_l = x_s + 1;
        ap_ufixed<W_-1,I_-1> x_s_1;
        x_s_1(W_-2,0) = x_s_l(W_-1,1);
        if (I_<=8) {
            if (x_s_1==ap_ufixed<W_-1,I_-1>("0x0p0")) r = 0;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 1;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 2;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = 3;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xap0")) r = 4;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfp0")) r = 5;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15p0")) r = 6;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1cp0")) r = 7;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x24p0")) r = 8;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2dp0")) r = 9;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x37p0")) r = 10;
            else r = 11;
        } else if (I_<=9) {
            if (x_s_1==ap_ufixed<W_-1,I_-1>("0x0p0")) r = 0;
            else if (x_s_1==ap_ufixed<W_-1,I_-1>("0x1p0")) r = 1;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 2;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = 3;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xap0")) r = 4;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfp0")) r = 5;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15p0")) r = 6;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1cp0")) r = 7;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x24p0")) r = 8;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2dp0")) r = 9;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x37p0")) r = 10;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x42p0")) r = 11;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4ep0")) r = 12;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x5bp0")) r = 13;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x69p0")) r = 14;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x78p0")) r = 15;
            else r = 16;
        } else {
            if (x_s_1==ap_ufixed<W_-1,I_-1>("0x0p0")) r = 0;
            else if (x_s_1==ap_ufixed<W_-1,I_-1>("0x1p0")) r = 1;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 2;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = 3;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xap0")) r = 4;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfp0")) r = 5;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15p0")) r = 6;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1cp0")) r = 7;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x24p0")) r = 8;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2dp0")) r = 9;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x37p0")) r = 10;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x42p0")) r = 11;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4ep0")) r = 12;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x5bp0")) r = 13;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x69p0")) r = 14;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x78p0")) r = 15;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x88p0")) r = 16;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x99p0")) r = 17;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xabp0")) r = 18;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xbep0")) r = 19;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xd2p0")) r = 20;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xe7p0")) r = 21;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfdp0")) r = 22;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x114p0")) r = 23;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x12cp0")) r = 24;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x145p0")) r = 25;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15fp0")) r = 26;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x17ap0")) r = 27;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x196p0")) r = 28;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1b3p0")) r = 29;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1d1p0")) r = 30;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1f0p0")) r = 31;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x210p0")) r = 32;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x231p0")) r = 33;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x253p0")) r = 34;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x276p0")) r = 35;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x29ap0")) r = 36;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2bfp0")) r = 37;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2e5p0")) r = 38;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x30cp0")) r = 39;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x334p0")) r = 40;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x35dp0")) r = 41;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x387p0")) r = 42;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3b2p0")) r = 43;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3dep0")) r = 44;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x40bp0")) r = 45;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x439p0")) r = 46;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x468p0")) r = 47;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x498p0")) r = 48;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4c9p0")) r = 49;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4fbp0")) r = 50;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x52ep0")) r = 51;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x562p0")) r = 52;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x597p0")) r = 53;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x5cdp0")) r = 54;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x604p0")) r = 55;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x63cp0")) r = 56;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x675p0")) r = 57;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6afp0")) r = 58;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6eap0")) r = 59;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x726p0")) r = 60;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x763p0")) r = 61;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x7a1p0")) r = 62;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x7e0p0")) r = 63;
            else r = 64;
        }
    } else if (F_<=4 && I_<=5) {
            if (x_s==ap_ufixed<W_-1,I_-1>("0x0.0p0")) r = "0x0.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "0x0.4p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "0x0.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "0x0.7p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "0x0.8p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "0x0.9p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "0x0.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "0x0.bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "0x0.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.bp0")) r = "0x0.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.dp0")) r = "0x0.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.fp0")) r = "0x0.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x1.0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x1.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.5p0")) r = "0x1.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.7p0")) r = "0x1.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ap0")) r = "0x1.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.cp0")) r = "0x1.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.fp0")) r = "0x1.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.2p0")) r = "0x1.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.5p0")) r = "0x1.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.8p0")) r = "0x1.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.bp0")) r = "0x1.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.fp0")) r = "0x1.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.2p0")) r = "0x1.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x1.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.ap0")) r = "0x1.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.ep0")) r = "0x1.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.2p0")) r = "0x2.0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.6p0")) r = "0x2.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.ap0")) r = "0x2.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.ep0")) r = "0x2.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.3p0")) r = "0x2.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.7p0")) r = "0x2.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.cp0")) r = "0x2.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.1p0")) r = "0x2.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.6p0")) r = "0x2.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.bp0")) r = "0x2.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.0p0")) r = "0x2.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.6p0")) r = "0x2.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.bp0")) r = "0x2.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.1p0")) r = "0x2.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.7p0")) r = "0x2.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.dp0")) r = "0x2.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.3p0")) r = "0x3.0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.9p0")) r = "0x3.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.fp0")) r = "0x3.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.5p0")) r = "0x3.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.cp0")) r = "0x3.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.2p0")) r = "0x3.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.9p0")) r = "0x3.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.0p0")) r = "0x3.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.7p0")) r = "0x3.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.ep0")) r = "0x3.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xd.5p0")) r = "0x3.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xd.dp0")) r = "0x3.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.4p0")) r = "0x3.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.cp0")) r = "0x3.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf.4p0")) r = "0x3.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf.cp0")) r = "0x3.fp0";
            else r = "0x4.0p0";
    } else {

        if (x[W_-1]) return 0;
        if (I_<=0) {
            const static int lsbx = (-I_+2<=W_) ? (W_+I_-2) : 0;
_ssdm_SpecConstant(&lsbx);
# 225 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_sqrt_apfixed.h"

            if ( x(W_-1,lsbx) != 0 ) return 0;
        }

        const static int prcs = (F_+1)*2;
_ssdm_SpecConstant(&prcs);
# 229 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_sqrt_apfixed.h"

        const static int msbr = (I_>0) ? (I_+1)/2 : 1;
_ssdm_SpecConstant(&msbr);
# 230 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_sqrt_apfixed.h"

        const static int msbx = (I_>0) ? I_+3 : 4;
_ssdm_SpecConstant(&msbx);
# 231 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_sqrt_apfixed.h"

        const static int msbm = (I_>0) ? I_+1 : 2;
_ssdm_SpecConstant(&msbm);
# 232 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_sqrt_apfixed.h"



        ap_ufixed<msbx , msbx> x_l_I = x;
        ap_ufixed< prcs/2, 0> x_l_FH = x;
        ap_ufixed< prcs/2, -prcs/2> x_l_FL = 0;
        ap_ufixed<msbr + prcs , msbr> res = 0;
        ap_ufixed<msbr , msbr> res_I = 0;
        ap_ufixed< prcs/2, 0> res_FH = 0;
# 265 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_sqrt_apfixed.h"
    if (I_>0)
#pragma unroll
 for ( int pos = msbr-1; pos >= 0; pos-- ) {
            ap_ufixed<msbm , msbm> mul_I = 0;



            mul_I ( msbr+pos , pos*2+1 ) = res_I ( msbr-1 , pos );



            mul_I [ pos*2 ] = 1;




            if ( x_l_I ( msbr+pos+1 , pos*2 ) >= mul_I ( msbr+pos , pos*2 ) ) {



                ap_ufixed<msbx,msbx> x_l_I_ = x_l_I;
                x_l_I ( msbr+pos+1 , pos*2 ) = x_l_I ( msbr+pos+1 , pos*2 ) - mul_I ( msbr+pos , pos*2 );




                res_I [ pos ] = 1;
            }
        }
#pragma unroll
 for ( int pos = -1; pos >= -F_-1; pos-- ) {
            ap_ufixed<msbm + prcs , msbm> mul = 0;




            mul ( msbr+pos + prcs , pos +1 + prcs ) = res_I ( msbr-1 , 0 );
            mul ( pos + prcs , pos*2+1 + prcs ) = res_FH ( -1+prcs/2 , pos+prcs/2 );



            mul [ pos*2 + prcs ] = 1;
            ap_ufixed<msbm , msbm> mul_I = mul;
            ap_ufixed< prcs/2, 0> mul_FH = mul;
            ap_ufixed< prcs/2, -prcs/2> mul_FL = mul;

            ap_ufixed<msbx + prcs , msbx> x_l;
            x_l ( -1+msbx + prcs , prcs ) = x_l_I ( -1+msbx , 0 );
            x_l ( -1 + prcs , prcs/2 ) = x_l_FH ( -1+prcs/2 , 0 );
            x_l ( -1 + prcs/2 , 0 ) = x_l_FL ( -1+prcs/2 , 0 );



            if ( (x_l_I>mul_I) || ((x_l_I==mul_I)&&(x_l_FH>mul_FH)) || ((x_l_I==mul_I)&&(x_l_FH==mul_FH)&&(x_l_FL>=mul_FL)) ) {




                ap_ufixed< prcs/2+1 , -prcs/2+1 > x_l_FL_l = x_l_FL;
                if ( x_l_FL < mul_FL ) x_l_FL_l[prcs/2] = 1;
                                                  x_l_FL_l -= mul_FL;




                ap_ufixed< prcs/2+1 , 1 > x_l_FH_l = x_l_FH;
                if ( (x_l_FH<mul_FH)||((x_l_FH==mul_FH)&&(x_l_FL<mul_FL)) ) x_l_FH_l[prcs/2] = 1;
                ap_ufixed< 1 , -prcs/2+1 > delta = 0;
                if ( x_l_FL < mul_FL ) delta[0] = 1;
                                                                             x_l_FH_l -= delta;
                                                                             x_l_FH_l -= mul_FH;



                if ( (x_l_FH<mul_FH)||((x_l_FH==mul_FH)&&(x_l_FL<mul_FL)) ) x_l_I --;
                                                                             x_l_I -= mul_I;

                                                                             x_l_FH = x_l_FH_l;
                                                                             x_l_FL = x_l_FL_l;

                ap_ufixed<msbx + prcs , msbx> x_l_ = x_l;
                x_l ( -1+msbx + prcs , prcs ) = x_l_I ( -1+msbx , 0 );
                x_l ( -1 + prcs , prcs/2 ) = x_l_FH ( -1+prcs/2 , 0 );
                x_l ( -1 + prcs/2 , 0 ) = x_l_FL ( -1+prcs/2 , 0 );



                res_FH [ pos+prcs/2 ] = 1;
            }
        }



        ap_ufixed< prcs/2+1 , 1 > res_FH_l = res_FH;
        ap_ufixed< prcs/2 , 0 > delta;
                                  delta[delta.wl()-1] = 1;
                                  res_FH_l += ( delta >> F_ );
                                  res_FH = res_FH_l;
        if (res_FH_l[prcs/2]) res_I ++;

        res ( msbr-1 + prcs , prcs ) = res_I ( msbr-1 , 0 );
        res ( -1 + prcs , prcs/2 ) = res_FH ( -1+prcs/2 , 0 );

        r = res;
    }

    return r;
}
template<int W_, int I_>
ap_ufixed<W_,I_> sqrt_fixed(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return sqrt_fixed(xf);
}
template<int I_>
ap_int<I_> sqrt_fixed(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return sqrt_fixed(xf);
}
template<int I_>
ap_uint<I_> sqrt_fixed(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return sqrt_fixed(xf);
}


template <int W_, int I_>
ap_fixed<W_,I_> rsqrt_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 ap_ufixed<W_-1,I_-1> xs = x;
    const int Ix = ( I_ > 1 )? I_-1 : 1;
    ap_ufixed<Ix,Ix> xs_I = xs;
    ap_ufixed<W_-1,I_-1> r;
    const int I = ( I_-1 > W_-I_+1 ) ? I_-1 : W_-I_+1;
    ap_ufixed<I+W_-I_,I> y1;
    ap_ufixed<I+W_-I_,I> y2;
    if ( xs == 0 ) {
        return 0;
    } else if ( xs_I != 0 ) {
        y1 = xs;
    } else {
        y1 = 1;
        y1 = y1/xs;
    }
    y2 = sqrt_fixed(y1);
    if ( y2 == 0 ) {
        return 0;
    } else if ( xs_I != 0 ) {
        r = 1;
        r = r/y2;
    } else {
        r = y2;
    }
    return r;
}
template<int W_, int I_>
ap_ufixed<W_,I_> rsqrt_fixed(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return rsqrt_fixed(xf);
}
template<int I_>
ap_int<I_> rsqrt_fixed(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return rsqrt_fixed(xf);
}
template<int I_>
ap_uint<I_> rsqrt_fixed(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return rsqrt_fixed(xf);
}


template<int W_, int I_>
ap_fixed<W_,I_> recip_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if ( x == 0 ) return 0;
    ap_fixed<W_,I_> r = 1;
    return r/x;
}
template<int W_, int I_>
ap_ufixed<W_,I_> recip_fixed(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return recip_fixed(xf);
}
template<int I_>
ap_int<I_> recip_fixed(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return recip_fixed(xf);
}
template<int I_>
ap_uint<I_> recip_fixed(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return recip_fixed(xf);
}
# 1023 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_round_copysign_apfixed.h" 1
# 35 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_round_copysign_apfixed.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 36 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_round_copysign_apfixed.h" 2

template <int W_, int I_>
ap_fixed<W_,I_> ceil_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    } else {
        if(I_<0) return 0;
        else {
           if ( x(W_-I_-1,0) != 0 ) {
               x(W_-I_-1,0) = 0;
               x += 1;
           }
           return x;
        }
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> ceil_fixed(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    }
    else {
        if(I_ < 0) return 0;
        else {
           if ( x(W_-I_-1,0) != 0 ) {
               x(W_-I_-1,0) = 0;
               x += 1;
           }
           return x;
        }
    }
}
template <int I_>
ap_int<I_> ceil_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> ceil_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> floor_fixed(ap_fixed<W_,I_> x)
{
    if(W_ == I_) {
        return x;
    }
    else {
        if(I_<0) return 0;
        else {
            if ( x(W_-I_-1,0) != 0 ) x(W_-I_-1,0) = 0;
            return x;
        }
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> floor_fixed(ap_ufixed<W_,I_> x)
{
    ap_fixed<W_+1,I_+1> xi = x;
    return floor_fixed(xi);
}
template <int I_>
ap_int<I_> floor_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> floor_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> trunc_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    }
    else {
        if(I_<0) return 0;
        else {
            if ( x(W_-I_-1,0) != 0 ) {
                x(W_-I_-1,0) = 0;
                if ( x[W_-1] )
                    x += 1;
            }
            return x;
        }
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> trunc_fixed(ap_ufixed<W_,I_> x)
{
    ap_fixed<W_+1,I_+1> xi = x;
    return trunc_fixed(xi);
}
template <int I_>
ap_int<I_> trunc_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> trunc_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> copysign_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y)
{
    x[W_-1] = y[W_-1];
    return x;
}
template <int W_, int I_>
ap_ufixed<W_,I_> copysign_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    return x;
}
template <int I_>
ap_int<I_> copysign_fixed(ap_int<I_> x, ap_int<I_> y)
{
    x[I_-1] = y[I_-1];
    return x;
}
template <int I_>
ap_uint<I_> copysign_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> fabs_fixed(ap_fixed<W_,I_> x)
{
    ap_fixed<W_,I_> xs = -x;
                    xs[W_-1] = 0;
    return ( ( x[W_-1] ) ? xs : x );
}
template <int W_, int I_>
ap_ufixed<W_,I_> fabs_fixed(ap_ufixed<W_,I_> x)
{
    return x;
}
template <int I_>
ap_int<I_> fabs_fixed(ap_int<I_> x)
{
    ap_int<I_> xs = -x;
               xs[I_-1] = 0;
    return ( ( x[I_-1] ) ? xs : x );
}
template <int I_>
ap_uint<I_> fabs_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> round_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    }
    else {
        if(I_<0) return 0;
        else {
            ap_ufixed<1, 0> half_val = 0.5;
            ap_ufixed<W_,I_> x_pos = fabs_fixed(x);
            ap_ufixed<W_+1,I_+1> r = x_pos + half_val;
            r(W_-I_-1,0) = 0;
            if(x[W_-1]) return -r;
            else return r;
        }
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> round_fixed(ap_ufixed<W_,I_> x)
{
    ap_fixed<W_+1,I_+1> xi = x;
    return round_fixed(xi);
}
template <int I_>
ap_int<I_> round_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> round_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> rint_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    }
    else {
        if(I_<0) return 0;
        else {
            ap_ufixed<W_, I_> x_p = fabs_fixed((ap_fixed<W_+1,I_+1>)x);
            ap_ufixed<1,0> half_val = 0.5;
            ap_ufixed<W_+1,I_+1> xUp = x_p + half_val;

            if(xUp(W_-I_-1,0) == 0) {

               xUp[W_-I_] = 0;
            } else {
               xUp(W_-I_-1,0) = 0;
            }
            if(x[W_-1]) return -xUp;
            else return xUp;
        }
# 287 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_round_copysign_apfixed.h"
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> rint_fixed(ap_ufixed<W_,I_> x)
{
   ap_fixed<W_+1, I_+1> xi = x;
   return rint_fixed(xi);
}
template <int I_>
ap_int<I_> rint_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> rint_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> nearbyint_fixed(ap_fixed<W_,I_> x)
{

    return rint_fixed(x);
}
template <int W_, int I_>
ap_ufixed<W_,I_> nearbyint_fixed(ap_ufixed<W_,I_> x)
{
    ap_fixed<W_+1,I_+1> xi = x;
    return nearbyint_fixed(xi);
}
template <int I_>
ap_int<I_> nearbyint_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> nearbyint_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
bool signbit_fixed(ap_fixed<W_, I_> x){
    if(x[W_-1]) return true;
    else return false;
}
template <int W_, int I_>
bool signbit_fixed(ap_ufixed<W_, I_> x){
    return false;
}

template <int I_>
bool signbit_fixed(ap_int<I_> x){
    if(x[I_-1]) return true;
    else return false;
}

template <int I_>
bool signbit_fixed(ap_uint<I_> x){
    return false;
}
namespace fp_internal {
  template<int W, int I>
  ap_fixed<W, I> nextafter(ap_fixed<W, I> x, ap_fixed<W, I> y){
     const static int F = W - I;
_ssdm_SpecConstant(&F);
# 352 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_round_copysign_apfixed.h"

     ap_ufixed<1, -F+1> ulp = 0;
     ulp[0] = 1;
     ap_fixed<W, I> r = 0;
     if(x == y) r = y;
     else if(x < y) r = x + ulp;
     else r = x - ulp;
     return r;
  }
  template<int W, int I>
  ap_ufixed<W, I> nextafter(ap_ufixed<W, I> x, ap_ufixed<W, I> y) {
     ap_fixed<W+1, I+1> xi = x;
     ap_fixed<W+1, I+1> yi = y;
     return nextafter(xi, yi);

  }
  template<int I>
  ap_int<I> nextafter(ap_int<I> x, ap_int<I> y) {
     ap_fixed<I, I> xi = x;
     ap_fixed<I, I> yi = y;
     return nextafter(xi, yi);
  }
  template<int I>
  ap_uint<I> nextafter(ap_uint<I> x, ap_uint<I> y) {
     ap_fixed<I+1, I+1> xi = x;
     ap_fixed<I+1, I+1> yi = y;
     return nextafter(xi, yi);
  }
  template<int W, int I>
  ap_fixed<W, I> nexttoward(ap_fixed<W, I> x, ap_fixed<W, I> y){
     return nextafter(x,y);
  }
  template<int W, int I>
  ap_ufixed<W, I> nexttoward(ap_ufixed<W, I> x, ap_ufixed<W, I> y){
     return nextafter(x,y);
  }
  template<int I>
  ap_int<I> nexttoward(ap_int<I> x, ap_int<I> y){
     return nextafter(x,y);
  }
  template<int I>
  ap_uint<I> nexttoward(ap_uint<I> x, ap_uint<I> y){
     return nextafter(x,y);
  }
}


template <int W, int I>
long long int llround_fixed(ap_fixed<W,I> x){
    return round_fixed<W+1,I+1>(ap_fixed<W+1,I+1> (x));
}


template <int W, int I>
long long int llround_fixed(ap_ufixed<W,I> x){
    return round_fixed<W+1,I+1>(ap_ufixed<W+1,I+1> (x));
}


template <int I>
long long int llround_fixed(ap_int<I> x){
    return x;
}


template <int I>
long long int llround_fixed(ap_uint<I> x){
    return x;
}


template <int W, int I>
long int lround_fixed(ap_fixed<W,I> x){
    ap_int<8*sizeof(long int)> minval = 0;
    minval[8*sizeof(long int)-1] = 1;
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) || (x<minval)) {
        return (x[W-1])? minval : maxval;
    }
    else {
        return round_fixed<W+1,I+1>(ap_fixed<W+1,I+1> (x));
    }
}


template <int W, int I>
long int lround_fixed(ap_ufixed<W,I> x){
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) ) {
        return maxval;
    }
    else {
        return round_fixed<W+1,I+1>(ap_ufixed<W+1,I+1> (x));
    }
}


template <int I>
long int lround_fixed(ap_int<I> x){
    ap_int<8*sizeof(long int)> minval = 0;
    minval[8*sizeof(long int)-1] = 1;
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) || (x<minval)) {
        return (x[I-1])? minval : maxval;
    }
    else {
        return x;
    }
}


template <int I>
long int lround_fixed(ap_uint<I> x){
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) ) {
        return maxval;
    }
    else {
        return x;
    }
}


template <int W, int I>
long long int llrint_fixed(ap_fixed<W,I> x){
    return rint_fixed<W+1,I+1>(ap_fixed<W+1,I+1> (x));
}


template <int W, int I>
long long int llrint_fixed(ap_ufixed<W,I> x){
    return rint_fixed<W+1,I+1>(ap_ufixed<W+1,I+1> (x));
}


template <int I>
long long int llrint_fixed(ap_int<I> x){
    return x;
}


template <int I>
long long int llrint_fixed(ap_uint<I> x){
    return x;
}


template <int W, int I>
long int lrint_fixed(ap_fixed<W,I> x){
    ap_int<8*sizeof(long int)> minval = 0;
    minval[8*sizeof(long int)-1] = 1;
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) || (x<minval)) {
        return (x[W-1])? minval : maxval;
    }
    else {
        return rint_fixed<W+1, I+1>(ap_fixed<W+1,I+1> (x));
    }
}



template <int W, int I>
long int lrint_fixed(ap_ufixed<W,I> x){
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if(x>maxval){
        return maxval;
    }
    else {
        return rint_fixed<W+1, I+1>(ap_ufixed<W+1,I+1> (x));
    }
}


template <int I>
long int lrint_fixed(ap_int<I> x){
    ap_int<8*sizeof(long int)> minval = 0;
    minval[8*sizeof(long int)-1] = 1;
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) || (x>minval)) {
        return (x[I-1])? minval : maxval;
    }
    else {
        return x;
    }
}


template <int I>
long int lrint_fixed(ap_uint<I> x){
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if(x>maxval) {
        return maxval;
    }
    else {
        return x;
    }
}
# 1024 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h" 1
# 37 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"
namespace pow_apfixed_reduce{
# 52 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"
template<int W_,int I_>
ap_fixed<W_,I_> pow(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y) {
    const static int F_ = W_ - I_;
_ssdm_SpecConstant(&F_);
# 54 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"


    if (I_>34) return 0;
    else if (F_>33) return 0;
    ap_fixed<W_,I_> r = 0;

    bool r_is_neg = 0;
    bool y_is_frac = 0;

    if (F_>0&&y(F_-1,0)>0)
        y_is_frac =1;
    if (x==0) {

        if (y==0&&I_>1) {
            return 1;

        } else if (y>0) {
            return 0;
        } else {

#pragma unroll
 for (int j = 0; j < W_-1; j++) r[j] = 1;
               r[W_-1] = 0;
            return r;
        }
    } else if (x<0) {

        if (y_is_frac) return 0;

        else {
            if (y==0||(I_>1&&y[F_]==0))
                r_is_neg = 0;
            else
                r_is_neg = 1;
        }
    }

    ap_fixed<W_+1,I_+1> x_e_1 = x;

    ap_fixed<W_+1,I_+1> x_p = 0;
    x_p = fabs_fixed(x_e_1);


    const static int E_l = I_+2;
_ssdm_SpecConstant(&E_l);
# 97 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"

    const static int F_l = W_+E_l;
_ssdm_SpecConstant(&F_l);
# 98 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"


    const static int I_l = I_+1>6?I_+1:6;
_ssdm_SpecConstant(&I_l);
# 100 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"

    const static int W_l = F_l + I_l;
_ssdm_SpecConstant(&W_l);
# 101 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"


    ap_fixed<W_l,I_l> x_l = x_p;


    ap_fixed<W_l,I_l> ln_x = log_apfixed_reduce::log(x_l);


    ap_fixed<F_l+6,6> ln_x_s = ln_x;


    const static int FI_m = W_+2;
_ssdm_SpecConstant(&FI_m);
# 112 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"


    const static int I_m = I_>6 ? I_ : 6;
_ssdm_SpecConstant(&I_m);
# 114 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"

    const static int WI_m = FI_m + I_m;
_ssdm_SpecConstant(&WI_m);
# 115 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"

    const static int WO_m = F_ + I_m;
_ssdm_SpecConstant(&WO_m);
# 116 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"

    ap_fixed<F_l+W_+6,6+I_> mul_y_ln = ln_x_s * y;
# 127 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"
    ap_fixed<WO_m,I_m> exp_r = 0;
    ap_fixed<W_,I_> r_1 = 0;
    bool m_overf = 0;
    bool e_overf = 0;
    bool overf = 0;

#pragma unroll
 for (int j = F_l+F_+I_m-1; j < F_l+W_+5; j++)
        if (mul_y_ln[F_l+W_+5]!=mul_y_ln[j])
            m_overf = 1;

    if (!m_overf) {

        ap_fixed<WI_m,I_m> mul_y_ln_s = mul_y_ln;

        exp_r = exp_reduce::exp_core<WO_m,I_m,WI_m>(mul_y_ln_s);


        if (I_<I_m) {
#pragma unroll
 for (int j = WO_m-1; j >= W_-1; j--) {
                if (exp_r[j])
                    e_overf=1;
            }
        }
        r_1 = exp_r;
    }

    if (e_overf||(m_overf&&!mul_y_ln[F_l+W_+5])) {
        overf = 1;
    }

    if (r_is_neg) {

        if (overf) {
            r=0;
            r[W_-1]=1;

        } else {
            if (r_1!=0) {
                r = -r_1;
                r[W_-1] = 1;
            }
        }

    } else {

        if(overf) {
            r[W_-1] = 0;
#pragma unroll
 for (int j = W_-2; j >= 0; j--)
               r[j] = 1;

        } else {
            r = r_1;
        }
    }

    return r;
}
# 206 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"
template<int W_, int I_>
ap_fixed<W_,I_> pown(ap_fixed<W_,I_> x, int n) {






    const static int F_ = W_ - I_;
_ssdm_SpecConstant(&F_);
# 214 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"


    if (I_>34) return 0;
    else if (F_>33) return 0;

    ap_fixed<W_,I_> r = 0;
    ap_fixed<32,32> n_fix = n;

    bool x_sig = x[W_-1];
    bool n_sig = n_fix[31];
    bool n_is_odd = n_fix[0];
    bool x_gt_0 = 0;

    if (x == 0 && n_fix != 0) r = 0;
    else if(n_fix == 0) r = 1;
    else if(n_fix == 1) r = x;

    else if(x == 1) r = 1;
    else if(x == -1) {
        if(n_is_odd) r = -1;
        else r = 1;
    }else {
# 262 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"
       const static int we_n = F_ > 26? 32 : 6 + F_;
_ssdm_SpecConstant(&we_n);
# 262 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"


       const static int wf_log = I_ == F_>26 ? (31+F_+I_) : (we_n-1+F_+I_);
_ssdm_SpecConstant(&wf_log);
# 264 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"

       const static int I_e = I_>6 ? I_ : 6;
_ssdm_SpecConstant(&I_e);
# 265 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"

       const static int WI_e = I_e + wf_log - we_n;
_ssdm_SpecConstant(&WI_e);
# 266 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"

       const static int WO_e = F_ + I_e;
_ssdm_SpecConstant(&WO_e);
# 267 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"

       ap_fixed<33,33> max_n = 0;
       max_n[we_n-1] = 1;
       ap_ufixed<32,32> n_pos = fabs_fixed(ap_fixed<33,33>(n));
       ap_ufixed<WO_e,I_e> exp_r=0;
       bool ovf = 0;
       ap_ufixed<W_,I_> x_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)x);
       if(x_pos>1) x_gt_0 = 1;
       ap_fixed<32,32> min_n = -max_n;
       if(n_fix != -1 && ((n >= max_n) || (n < min_n))){

           ovf = 1;
       }else {
           ap_fixed<we_n, we_n> n_s = n;





           const static int I_l = I_+1 < 6? 6 : I_+1;
_ssdm_SpecConstant(&I_l);
# 286 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"

           ap_fixed<wf_log+I_l,I_l> x_e = x_pos;
           const static int we_log = 6;
_ssdm_SpecConstant(&we_log);
# 288 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"

           ap_fixed<wf_log+we_log,we_log> x_log = log_apfixed_reduce::log(x_e);






           ap_fixed<wf_log+we_log, we_log+we_n> x_log_mul_n = n_s * x_log;






           for(int i = wf_log+we_log-2; i > WI_e - 2; --i) {
#pragma HLS unroll
 if(x_log_mul_n[i] != x_log_mul_n[wf_log+we_log-1]){

                    ovf = 1;
                }
           }
           ap_fixed<WI_e, I_e> x_log_mul_n_1 = x_log_mul_n ;





           exp_r = exp_reduce::exp_core<WO_e,I_e,WI_e>(x_log_mul_n_1);





           if (I_<I_e) {
               for (int j = WO_e-1; j >= W_-1; j--) {
#pragma hls unroll

 if (exp_r[j])
                       ovf=1;
               }
           }
       }
       if(ovf) {
           if(x_gt_0 ^ n_sig) {

               if(x_sig && !n_is_odd) {
                   r[W_-1] = 1;
               } else {
                   for(int i = 0; i < W_-1; ++i) {
#pragma HLS unroll
 r[W_-1] = 1;
                   }
               }
           }
       } else {
           if(x_sig && n_is_odd) r = -exp_r;
           else r = exp_r;
       }
   }
   return r;
}
# 376 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"
template<int W_,int I_>
ap_fixed<W_,I_> rootn(ap_fixed<W_,I_> x, int n) {






    const static int F_ = W_ - I_;
_ssdm_SpecConstant(&F_);
# 384 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"


    if (I_ > 34) return 0;
    else if (F_ > 33) return 0;

    ap_fixed<W_,I_> r = 0;
    ap_fixed<32,32> n_fix = n;
    bool n_is_odd = 0;
    if(n_fix[0]) n_is_odd = 1;

    if (x == 0) r = 0;
    else if(n_fix == 0) r = 0;
    else if(n_fix == 1) r = x;
    else if(n_fix == -1) r = ap_fixed<W_, I_>(1)/x;
    else if(x<0 && !n_is_odd) r = 0;
    else if(x==1) r = 1;
    else if(x==-1 && n_is_odd) r = -1;
    else {

        ap_ufixed<W_,I_> x_p = fabs_fixed((ap_fixed<W_+1,I_+1>)x);


        const static int m_we = (F_+1)/2 > (I_+1)/2? (F_+1)/2:(I_+1)/2;
_ssdm_SpecConstant(&m_we);
# 406 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"

        const static int we = I_ > m_we ? m_we : I_;
_ssdm_SpecConstant(&we);
# 407 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"

        const static int E_l = we - 1;
_ssdm_SpecConstant(&E_l);
# 408 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"

        const static int F_l = F_ + E_l;
_ssdm_SpecConstant(&F_l);
# 409 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"


        const static int I_l = I_ + 1 > 6 ? I_ + 1 : 6;
_ssdm_SpecConstant(&I_l);
# 411 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"

        const static int W_l = F_l + I_l;
_ssdm_SpecConstant(&W_l);
# 412 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"


        ap_fixed<W_l,I_l> x_l = x_p;


        ap_fixed<W_l,I_l> ln_x = log_apfixed_reduce::log(x_l);






        ap_fixed<F_l+6,6> ln_x_s = ln_x;


        const static int FI_d = F_l + 1;
_ssdm_SpecConstant(&FI_d);
# 427 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"


        const static int I_d = we+1 > 5? we+1 : 5;
_ssdm_SpecConstant(&I_d);
# 429 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"

        const static int WI_d = FI_d + I_d;
_ssdm_SpecConstant(&WI_d);
# 430 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"

        const static int WO_d = F_ + I_d;
_ssdm_SpecConstant(&WO_d);
# 431 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_pow_apfixed.h"

        ap_fixed<F_l+6,5> divd_n_ln = ln_x_s / n_fix;







        ap_fixed<WI_d,I_d> divd_n_ln_s = divd_n_ln;





        ap_ufixed<WO_d, I_d> exp_r = exp_reduce::exp_core<WO_d,I_d,WI_d>(divd_n_ln_s);





        bool ovf = 0;

        if(I_ < I_d) {
           for (int j =WO_d-1; j >= W_-1; j--) {
#pragma hls unroll

 if (exp_r[j])
                   ovf=1;
           }
        }
        if(!ovf) {
           if(x[W_-1]&&n_is_odd) r = -exp_r;
           else r = exp_r;
        }else {
           if(x[W_-1]&&n_is_odd) {
              r[W_-1] = 1;
           } else {
              for(int i = 0; i < W_-1; ++i) {
#pragma HLS unroll
 r[i] = 1;
              }
           }
        }
   }
   return r;
}


template<int W_, int I_>
ap_ufixed<W_,I_> pow(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y) {
    ap_fixed<W_+1,I_+1> xf = x;
    ap_fixed<W_+1,I_+1> yf = y;
    return pow(xf,yf);
}

template<int I_>
ap_int<I_> pow(ap_int<I_> x, ap_int<I_> y) {
    ap_fixed<I_,I_> xf = x;
    ap_fixed<I_,I_> yf = y;
    return pow(xf,yf);
}

template<int I_>
ap_uint<I_> pow(ap_uint<I_> x,ap_uint<I_> y) {
    ap_fixed<I_+1,I_+1> xf = x;
    ap_fixed<I_+1,I_+1> yf = y;
    return pow(xf,yf);
}


template<int W_, int I_>
ap_fixed<W_,I_> powr(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y) {
    return pow(x,y);
}

template<int W_, int I_>
ap_ufixed<W_,I_> powr(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y) {
    ap_fixed<W_+1,I_+1> xf = x;
    ap_fixed<W_+1,I_+1> yf = y;
    return pow(xf,yf);
}

template<int I_>
ap_int<I_> powr(ap_int<I_> x, ap_int<I_> y) {
    ap_fixed<I_,I_> xf = x;
    ap_fixed<I_,I_> yf = y;
    return pow(xf,yf);
}

template<int I_>
ap_uint<I_> powr(ap_uint<I_> x,ap_uint<I_> y) {
    ap_fixed<I_+1,I_+1> xf = x;
    ap_fixed<I_+1,I_+1> yf = y;
    return pow(xf,yf);
}

template<int W_, int I_>
ap_ufixed<W_,I_> pown(ap_ufixed<W_, I_> x, int n) {
    ap_fixed<W_+1,I_+1> xi = x;
    return pown(xi, n);
}

template<int I_>
ap_int<I_> pown(ap_int<I_> x, int n) {
   ap_fixed<I_, I_> xi = x;
   return pown(xi, n);
}

template<int I_>
ap_uint<I_> pown(ap_uint<I_> x, int n) {
   ap_fixed<I_+1, I_+1> xi = x;
   return pown(xi, n);
}
template<int W_, int I_>
ap_ufixed<W_,I_> rootn(ap_ufixed<W_, I_> x, int n) {
    ap_fixed<W_+1,I_+1> xi = x;
    return rootn(xi, n);
}

template<int I_>
ap_int<I_> rootn(ap_int<I_> x, int n) {
   ap_fixed<I_, I_> xi = x;
   return rootn(xi, n);
}

template<int I_>
ap_uint<I_> rootn(ap_uint<I_> x, int n) {
   ap_fixed<I_+1, I_+1> xi = x;
   return rootn(xi, n);
}
}
# 1025 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_diff_apfixed.h" 1
# 35 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_diff_apfixed.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 36 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_diff_apfixed.h" 2
# 46 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> fdim_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
#pragma HLS PIPELINE II=1
 ap_fixed<W_+1,I_+1> x_overf = 0;
    ap_fixed<W_ ,I_ > xs = 0;
        bool overf = 0;

    if(x > y)
    {
        x_overf = x - y;
        overf = x_overf[W_-1];
        if(overf) {
#pragma UNROLL
 for (int i = 0; i < W_-1; i++){
                xs[i] = 1;
            }
            xs[W_-1] = 0;
        }
        else{
            x_overf[W_] = 0;
            xs = x_overf;
        }
    }
    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> fdim_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x > y){ xs = x - y; }
    return xs;
}
template <int I_>
ap_int<I_> fdim_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_fixed<I_,I_> xs = x;
    ap_fixed<I_,I_> ys = y;
    return fdim_fixed(xs, ys);
}
template <int I_>
ap_uint<I_> fdim_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x > y) { xs = x - y; }
    return xs;
}
# 102 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> fmax_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
    ap_fixed<W_ ,I_ > xs = 0;
    if(x >= y) xs = x ;
        else xs = y ;
    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> fmax_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> fmax_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_int<I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_uint<I_> fmax_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
# 143 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> fmin_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
    ap_fixed<W_ ,I_ > xs = 0;
    if(x <= y) xs = x ;
        else xs = y ;
    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> fmin_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> fmin_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_int<I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_uint<I_> fmin_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
# 186 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> maxmag_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
#pragma HLS PIPELINE II=1
 ap_fixed<W_+1,I_+1> xm = -x;
    ap_fixed<W_+1,I_+1> ym = -y;
    ap_fixed<W_+1,I_+1> x_fabs = ( x[W_-1] ) ? xm : ap_fixed<W_+1,I_+1>(x);
    ap_fixed<W_+1,I_+1> y_fabs = ( y[W_-1] ) ? ym : ap_fixed<W_+1,I_+1>(y);

    ap_fixed<W_+1,I_+1> xs_t = 0;
    ap_fixed<W_,I_> xs = 0;
    if(x_fabs >= y_fabs)
    {
     xs_t = x_fabs ;
     xs = x;
    }
    else{
     xs_t = y_fabs ;
     xs = y;
    }

    if(xs_t[W_-1])
    {
#pragma UNROLL
 for (int i = 0; i < W_-1; i++){
                xs[i] = 1;
            }
            xs[W_-1] = 0;
    }

    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> maxmag_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> maxmag_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_fixed<I_,I_> xs = x;
    ap_fixed<I_,I_> ys = y;
    return maxmag_fixed(xs, ys);
}
template <int I_>
ap_uint<I_> maxmag_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
# 252 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> minmag_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
#pragma HLS PIPELINE II=1
 ap_fixed<W_+1,I_+1> xm = -x;
    ap_fixed<W_+1,I_+1> ym = -y;
    ap_fixed<W_+1,I_+1> x_fabs = ( x[W_-1] ) ? xm : ap_fixed<W_+1,I_+1>(x);
    ap_fixed<W_+1,I_+1> y_fabs = ( y[W_-1] ) ? ym : ap_fixed<W_+1,I_+1>(y);

    ap_fixed<W_+1,I_+1> xs_t = 0;
    ap_fixed<W_,I_> xs = 0;
    if(x_fabs <= y_fabs)
    {
     xs_t = x_fabs ;
     xs = x;
    }
    else{
     xs_t = y_fabs ;
     xs = y;
    }
    if(xs_t[W_-1])
    {
#pragma UNROLL
 for (int i = 0; i < W_-1; i++){
                xs[i] = 1;
            }
            xs[W_-1] = 0;
    }

    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> minmag_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> minmag_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_fixed<I_,I_> xs = x;
    ap_fixed<I_,I_> ys = y;
    return minmag_fixed(xs, ys);
}
template <int I_>
ap_uint<I_> minmag_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
# 1026 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_comparison_apfixed.h" 1
# 35 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_comparison_apfixed.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 36 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_comparison_apfixed.h" 2



template<int W, int I>
bool isgreater_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool isgreater_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreater_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreater_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool isgreaterequal_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool isgreaterequal_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreaterequal_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreaterequal_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool isless_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool isless_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isless_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isless_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool islessequal_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool islessequal_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessequal_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessequal_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool islessgreater_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool islessgreater_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessgreater_fixed(ap_int<I> x1, ap_int<I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessgreater_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
# 1027 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_frexp_apfixed.h" 1
# 41 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_frexp_apfixed.h"
namespace frexp_internal {

template<int W, int I>
ap_fixed<W,I> frexp(ap_fixed<W,I> x,
                    ap_fixed<W,I>* exp){
    if(I<0) {
           *exp = 0;
           return x;
    }
    static const int F = W - I;
_ssdm_SpecConstant(&F);
# 50 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_frexp_apfixed.h"

    static const int we = W > 5 ? W/2 : 3;
_ssdm_SpecConstant(&we);
# 51 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_frexp_apfixed.h"


    ap_int<we> e = 0;
    ap_ufixed<W, I> r_p = 0;

    ap_fixed<W+1, I+1> xi = x;
    ap_ufixed<W, I> x_p = fabs_fixed(xi);

    static const ap_uint<3> clz_table_6bit[64] = {7, 6, 5, 5, 4, 4, 4, 4,
                                                  3, 3, 3, 3, 3, 3, 3, 3,
                                                  2, 2, 2, 2, 2, 2, 2, 2,
                                                  2, 2, 2, 2, 2, 2, 2, 2,
                                                  1, 1, 1, 1, 1, 1, 1, 1,
                                                  1, 1, 1, 1, 1, 1, 1, 1,
                                                  1, 1, 1, 1, 1, 1, 1, 1,
                                                  1, 1, 1, 1, 1, 1, 1, 1};
_ssdm_SpecConstant(clz_table_6bit);
# 59 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_frexp_apfixed.h"

    int pos = 0;

    static const int loop_nm = W > 6 ? (W + 5)/6 : 1;
_ssdm_SpecConstant(&loop_nm);
# 69 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_frexp_apfixed.h"

    CLZ_LOOP:
    for(int l = loop_nm; l > 0; --l){
#pragma HLS pipeline II=1
 ap_uint<6> t = 0;
       if(l*6 > W) t = x_p(W - 1, (l - 1) * 6);
       else t = x_p(l * 6 - 1, (l - 1) * 6);
       if((t & 0x3f) != 0) {
          pos = l * 6 - clz_table_6bit[t];
          break;
       }
    }
    if(pos >= 0) {
        e = pos + 1 - F;
        if(F > 0) {
           ap_uint<we> w_f = (pos + 1) < F ? (pos + 1) : F;
           r_p(F - 1,F - w_f) = x_p(pos, pos + 1 - w_f);
        }
    } else {
        e = 0;
        r_p = 0;
    }
    ap_fixed<W, I> r = 0;
    if(xi[W-1]) r = -r_p;
    else r = r_p;



    *exp = e;
    return r;
}
template<int W, int I>
ap_ufixed<W,I> frexp(ap_ufixed<W,I> x,
                     ap_ufixed<W,I>* exp){
    ap_fixed<W+1, I+1> xe = x;
    ap_fixed<W+1, I+1> ee = 0;
    ap_fixed<W+1, I+1> r = frexp(xe,&ee);
    *exp = ee;
    return r;
}
template<int I>
ap_uint<I> frexp(ap_uint<I> x,
                 ap_uint<I>* exp) {
   ap_fixed<I, I> xe = x;
   ap_fixed<I, I> ee = 0;
   ap_fixed<I, I> r = frexp(xe,&ee);
   *exp = ee;
   return r;
}
template<int I>
ap_int<I> frexp(ap_int<I> x,
                ap_int<I>* exp) {
   ap_fixed<I+1, I+1> xe = x;
   ap_fixed<I+1, I+1> ee = 0;
   ap_fixed<I+1, I+1> r = frexp(xe,&ee);
   *exp = ee;
   return r;
}
}
# 1028 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_modf_apfixed.h" 1
# 40 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_modf_apfixed.h"
namespace modf_internal {
template<int W, int I>
ap_fixed<W,I> modf(ap_fixed<W, I> x,
                   ap_fixed<W, I>* int_part){
    ap_fixed<W, I> frac_part = 0;
    if(W == I) {
        *int_part = x;
        frac_part = 0;
    } else if(I > 0) {
        ap_fixed<W+1, I+1> xi = x;
        ap_ufixed<W, I> x_p = fabs_fixed(xi);
        frac_part(W - I - 1,0) = x_p(W - I - 1,0);
        if(xi[W-1]) frac_part = - frac_part;
        *int_part = x_p(W-1, W-I);
        if(xi[W-1]) *int_part = -*int_part;
    } else {
       *int_part = 0;
       frac_part = x;
    }
    return frac_part;
}
template<int W, int I>
ap_ufixed<W,I> modf(ap_ufixed<W, I> x,
                    ap_ufixed<W, I>* int_part){
    ap_fixed<W+1, I+1> xi = x;
    ap_fixed<W+1, I+1> ii = 0;
    ap_fixed<W+1, I+1> r = modf(xi, &ii);
    *int_part = ii;
    return r;
}
template<int I>
ap_int<I> modf(ap_int<I> x,
               ap_int<I>* int_part){
    *int_part = x;
    return 0;
}
template<int I>
ap_uint<I> modf(ap_uint<I> x,
                ap_uint<I>* int_part){
    *int_part = x;
    return 0;
}
}
# 1029 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_isequal_isnotequal_apfixed.h" 1
# 40 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_isequal_isnotequal_apfixed.h"
template <int W_, int I_>
bool generic_isequal(ap_fixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_fixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int W_, int I_>
bool generic_isequal(ap_ufixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_ufixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int W_, int I_>
bool generic_isequal(ap_fixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_fixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int W_, int I_>
bool generic_isequal(ap_ufixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_ufixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}



template <int I_>
bool generic_isequal(ap_int<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_int<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int I_>
bool generic_isequal(ap_uint<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_uint<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int I_>
bool generic_isequal(ap_int<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_int<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int I_>
bool generic_isequal(ap_uint<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_uint<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}
# 1030 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_all_any_apfixed.h" 1
# 35 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_all_any_apfixed.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 35 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_all_any_apfixed.h" 2



template <int W_, int I_>
bool generic_all(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline II=1
 for (int i=0; i<W_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int W_, int I_>
bool generic_all(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline II=1
 for (int i=0; i<W_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int I_>
bool generic_all(ap_int<I_> x)
{
#pragma HLS pipeline II=1
 for (int i=0; i<I_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int I_>
bool generic_all(ap_uint<I_> x)
{
#pragma HLS pipeline II=1
 for (int i=0; i<I_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int W_, int I_>
bool generic_any(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline II=1
 for (int i=0; i<W_;i++)
     if (x[i]==1)
      return true;
    return false;
}


template <int W_, int I_>
bool generic_any(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline II=1
 for (int i=0; i<W_;i++)
     if (x[i]==1)
      return true;
    return false;
}


template <int I_>
bool generic_any(ap_int<I_> x)
{
#pragma HLS pipeline II=1
 for (int i=0; i<I_;i++)
     if (x[i]==1)
      return true;
    return false;
}


template <int I_>
bool generic_any(ap_uint<I_> x)
{
#pragma HLS pipeline II=1
 for (int i=0; i<I_;i++)
     if (x[i]==1)
      return true;
    return false;
}
# 1031 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_select_bitselect_apfixed.h" 1
# 35 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_select_bitselect_apfixed.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 36 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_select_bitselect_apfixed.h" 2
# 62 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_select_bitselect_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> generic_bitselect(ap_fixed<W_,I_> x,ap_fixed<W_,I_> y, ap_fixed<W_,I_> z)
{
#pragma HLS pipeline
 return (z & y)|(~z & x);
}


template <int W_, int I_>
ap_ufixed<W_,I_> generic_bitselect(ap_ufixed<W_,I_> x,ap_ufixed<W_,I_> y, ap_ufixed<W_,I_> z)
{
#pragma HLS pipeline
 return (z & y)|(~z & x);
}


template <int I_>
ap_int<I_> generic_bitselect(ap_int<I_> x,ap_int<I_> y, ap_int<I_> z)
{
#pragma HLS pipeline
 return (z & y)|(~z & x);
}

template <int I_>
ap_uint<I_> generic_bitselect(ap_uint<I_> x,ap_uint<I_> y, ap_uint<I_> z)
{
#pragma HLS pipeline
 return (z & y)|(~z & x);
}
# 1032 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_erf_apfixed.h" 1
# 35 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_erf_apfixed.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 36 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_erf_apfixed.h" 2



namespace erf_erfc_fixed {

    namespace {
 template <typename T> class coeff { };

 template <> class coeff<double> {

 public:
   static const double tiny;
   static const double one_over_two;
   static const double one;
   static const double two;
   static const double erx;
   static const double efx;
   static const double efx8;
   static const double pp[5];
   static const double qq[6];
   static const double pa[7];
   static const double qa[7];
   static const double ra[8];
   static const double sa[9];
   static const double rb[7];
   static const double sb[8];
 };
 const double coeff<double>::tiny = 1e-300;
 const double coeff<double>::one_over_two= 5.00000000000000000000e-01;
 const double coeff<double>::one = 1.00000000000000000000e+00;
 const double coeff<double>::two = 2.00000000000000000000e+00;

 const double coeff<double>::erx = 8.45062911510467529297e-01;



 const double coeff<double>::efx = 1.28379167095512586316e-01;
 const double coeff<double>::efx8= 1.02703333676410069053e+00;
 const double coeff<double>::pp[] =
   {1.28379167095512558561e-01,
    -3.25042107247001499370e-01,
    -2.84817495755985104766e-02,
    -5.77027029648944159157e-03,
    -2.37630166566501626084e-05};
 const double coeff<double>::qq[] =
   {0.0, 3.97917223959155352819e-01,
    6.50222499887672944485e-02,
    5.08130628187576562776e-03,
    1.32494738004321644526e-04,
    -3.96022827877536812320e-06};



 const double coeff<double>::pa[] =
   {-2.36211856075265944077e-03,
    4.14856118683748331666e-01,
    -3.72207876035701323847e-01,
    3.18346619901161753674e-01,
    -1.10894694282396677476e-01,
    3.54783043256182359371e-02,
    -2.16637559486879084300e-03};
 const double coeff<double>::qa[] =
   {0.0, 1.06420880400844228286e-01,
    5.40397917702171048937e-01,
    7.18286544141962662868e-02,
    1.26171219808761642112e-01,
    1.36370839120290507362e-02,
    1.19844998467991074170e-02};



 const double coeff<double>::ra[] =
   {-9.86494403484714822705e-03,
    -6.93858572707181764372e-01,
    -1.05586262253232909814e+01,
    -6.23753324503260060396e+01,
    -1.62396669462573470355e+02,
    -1.84605092906711035994e+02,
    -8.12874355063065934246e+01,
    -9.81432934416914548592e+00};
 const double coeff<double>::sa[] =
   {0.0,1.96512716674392571292e+01,
    1.37657754143519042600e+02,
    4.34565877475229228821e+02,
    6.45387271733267880336e+02,
    4.29008140027567833386e+02,
    1.08635005541779435134e+02,
    6.57024977031928170135e+00,
    -6.04244152148580987438e-02};



 const double coeff<double>::rb[] =
   {-9.86494292470009928597e-03,
    -7.99283237680523006574e-01,
    -1.77579549177547519889e+01,
    -1.60636384855821916062e+02,
    -6.37566443368389627722e+02,
    -1.02509513161107724954e+03,
    -4.83519191608651397019e+02};
 const double coeff<double>::sb[] =
   {0.0,3.03380607434824582924e+01,
    3.25792512996573918826e+02,
    1.53672958608443695994e+03,
    3.19985821950859553908e+03,
    2.55305040643316442583e+03,
    4.74528541206955367215e+02,
    -2.24409524465858183362e+01};
# 245 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_erf_apfixed.h"
 template<typename T> class erf_traits{ };
# 267 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_erf_apfixed.h"
 template<> class erf_traits<double> {
 public:
   static const uint64_t mask;
   static const uint32_t segment[10];
 };
 const uint64_t erf_traits<double>::mask = 0xffffffff00000000;
 const uint32_t erf_traits<double>::segment[10] =
   {
  0x7fffffff,
  0x7ff00000,
  0x3feb0000,
  0x3e300000,
  0x00800000,
  0x3ff40000,
  0x40180000,
  0x4006DB6E,
  63,
  32
   };

 template<typename T> class erfc_traits{};
# 308 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_erf_apfixed.h"
 template<> class erfc_traits<double>{
 public:
   static const uint32_t segment[11];
 };
 const uint32_t erfc_traits<double>::segment[11] =
   {
  0x7fffffff,
  0x7ff00000,
  0x3feb0000,
  0x3c700000,
  0x3fd00000,
  0x3ff40000,
  0x403c0000,
  0x4006DB6D,
  0x40180000,
  63,
  32
   };
  }
# 346 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_erf_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> erf(ap_fixed<W_,I_> x_fixed )
{
    int F_ = W_ - I_;

    if (I_>33) return 0;
    else if (F_>32) return 0;

    double x = x_fixed.to_double();
 int32_t hx;
    uint32_t ix;
 double R,S,P,Q,s,y,z,r;

    fp_struct<double> fp_abs(x);
      fp_abs.sign=0;
    fp_struct<double> fp_x(x);
    ap_uint<32> tmp = fp_x.data()(erf_traits<double>::segment[8],erf_traits<double>::segment[9]);
    hx = tmp.to_int();
 ix = hx & erf_traits<double>::segment[0];






    if(fp_x.exp == 0x0 && fp_x.sign!= 0x0){
   return 0;
 }

 if(ix>=erf_traits<double>::segment[1]) {

   if(hx>0)
  return ap_fixed<W_,I_>((double)1.0 +coeff<double>::one/x);
   else
  return ap_fixed<W_,I_>(coeff<double>::one/x-(double)1.0);
 }

 if(ix < erf_traits<double>::segment[2]) {
   double r1,r2,s1,s2,s3,z2,z4;
   if(ix < erf_traits<double>::segment[3]) {
  if (ix < erf_traits<double>::segment[2])
    return ap_fixed<W_,I_>(((double)0.125)*((double)8.0*x+coeff<double>::efx8*x));
  return ap_fixed<W_,I_>(x + coeff<double>::efx*x);
   }
   z = x*x;




   r1 = coeff<double>::pp[0]+z*coeff<double>::pp[1]; z2=z*z;
   r2 = coeff<double>::pp[2]+z*coeff<double>::pp[3]; z4=z2*z2;
   s1 = coeff<double>::one+z* coeff<double>::qq[1];
   s2 = coeff<double>::qq[2]+z*coeff<double>::qq[3];
   s3 = coeff<double>::qq[4]+z*coeff<double>::qq[5];
   r = r1 + z2*r2 + z4*coeff<double>::pp[4];
   s = s1 + z2*s2 + z4*s3;

   y = r/s;
   return ap_fixed<W_,I_>(x + x*y);
 }
 if(ix < erf_traits<double>::segment[5]) {
   double s2,s4,s6,P1,P2,P3,P4,Q1,Q2,Q3,Q4;

      s = fp_abs.to_ieee()-coeff<double>::one;




   P1 = coeff<double>::pa[0]+s*coeff<double>::pa[1]; s2=s*s;
   Q1 = coeff<double>::one+s*coeff<double>::qa[1]; s4=s2*s2;
   P2 = coeff<double>::pa[2]+s*coeff<double>::pa[3]; s6=s4*s2;
   Q2 = coeff<double>::qa[2]+s*coeff<double>::qa[3];
   P3 = coeff<double>::pa[4]+s*coeff<double>::pa[5];
   Q3 = coeff<double>::qa[4]+s*coeff<double>::qa[5];
   P4 = coeff<double>::pa[6];
   Q4 = coeff<double>::qa[6];
   P = P1 + s2*P2 + s4*P3 + s6*P4;
   Q = Q1 + s2*Q2 + s4*Q3 + s6*Q4;

   if(hx>=0) return ap_fixed<W_,I_>(coeff<double>::erx + P/Q);
      else return ap_fixed<W_,I_>(-coeff<double>::erx - P/Q);
 }
 if (ix >= erf_traits<double>::segment[6]) {
   if(hx>=0) return ap_fixed<W_,I_>(coeff<double>::one-coeff<double>::tiny);
      else return ap_fixed<W_,I_>(coeff<double>::tiny-coeff<double>::one);
 }
 x = fp_abs.to_ieee();
  s = coeff<double>::one/(x*x);
 if(ix< erf_traits<double>::segment[7]) {






   double R1,R2,R3,R4,S1,S2,S3,S4,s2,s4,s6,s8;
   R1 = coeff<double>::ra[0]+s*coeff<double>::ra[1];s2 = s*s;
   S1 = coeff<double>::one+ s*coeff<double>::sa[1]; s4 = s2*s2;
   R2 = coeff<double>::ra[2]+s*coeff<double>::ra[3];s6 = s4*s2;
   S2 = coeff<double>::sa[2]+s*coeff<double>::sa[3];s8 = s4*s4;
   R3 = coeff<double>::ra[4]+s*coeff<double>::ra[5];
   S3 = coeff<double>::sa[4]+s*coeff<double>::sa[5];
   R4 = coeff<double>::ra[6]+s*coeff<double>::ra[7];
   S4 = coeff<double>::sa[6]+s*coeff<double>::sa[7];
   R = R1 + s2*R2 + s4*R3 + s6*R4;
   S = S1 + s2*S2 + s4*S3 + s6*S4 + s8*coeff<double>::sa[8];

 } else {






   double R1,R2,R3,S1,S2,S3,S4,s2,s4,s6;
   R1 = coeff<double>::rb[0]+s*coeff<double>::rb[1];s2 = s*s;
   S1 = coeff<double>::one+ s*coeff<double>::sb[1]; s4 = s2*s2;
   R2 = coeff<double>::rb[2]+s*coeff<double>::rb[3];s6 = s4*s2;
   S2 = coeff<double>::sb[2]+s*coeff<double>::sb[3];
   R3 = coeff<double>::rb[4]+s*coeff<double>::rb[5];
   S3 = coeff<double>::sb[4]+s*coeff<double>::sb[5];
   S4 = coeff<double>::sb[6]+s*coeff<double>::sb[7];
   R = R1 + s2*R2 + s4*R3 + s6*coeff<double>::rb[6];
   S = S1 + s2*S2 + s4*S3 + s6*S4;

 }
 z = x;

    fp_struct<double> fp_z(z);
    ap_uint<Type_BitWidth<double>::Value> data = fp_z.data() & erf_traits<double>::mask;
    fp_struct<double> fp_z_new(data);
    z = fp_z_new.to_ieee();


    ap_fixed<W_, I_> r_fixed = exp_reduce::exp(ap_fixed<W_, I_>(-z*z-(double)0.5625))*exp_reduce::exp(ap_fixed<W_, I_>((z-x)*(z+x)+R/S));
 r = r_fixed.to_double();

 if(hx>=0) return ap_fixed<W_,I_>(coeff<double>::one-r/x);
    else return ap_fixed<W_,I_>(r/x-coeff<double>::one);
  }


template <int W_, int I_>
ap_ufixed<W_,I_> erf(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xs = x;
    return erf(xs);
}

template <int I_>
ap_int<I_> erf(ap_int<I_> x) {
    ap_fixed<I_,I_> xs = x;
    return erf(xs);
}

template <int I_>
ap_uint<I_> erf(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xs = x;
    return erf(xs);
}
# 513 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_erf_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> erfc(ap_fixed<W_,I_> x_fixed)
{
#pragma HLS PIPELINE II=1
 int F_ = W_ - I_;

    if (I_>33) return 0;
    else if (F_>32) return 0;

    double x = x_fixed.to_double();
    int32_t hx;
    uint32_t ix;
 double R,S,P,Q,s,y,z,r;

    fp_struct<double> fp_abs(x);
    fp_abs.sign=0;
    fp_struct<double> fp_x(x);
    ap_uint<32> tmp = fp_x.data()(erfc_traits<double>::segment[9],erfc_traits<double>::segment[10]);
    hx = tmp.to_int();
 ix = hx & erfc_traits<double>::segment[0];
 if(ix>=erfc_traits<double>::segment[1]) {

   if(hx>0)
  return ap_fixed<W_,I_>(coeff<double>::one/x);
   else
  return ap_fixed<W_,I_>(coeff<double>::two + coeff<double>::one/x);

 }

 if(ix < erfc_traits<double>::segment[2]) {
   double r1,r2,s1,s2,s3,z2,z4;
   if(ix < erfc_traits<double>::segment[3])
  return ap_fixed<W_,I_>(coeff<double>::one-x);
   z = x*x;




   r1 = coeff<double>::pp[0]+z*coeff<double>::pp[1]; z2=z*z;
   r2 = coeff<double>::pp[2]+z*coeff<double>::pp[3]; z4=z2*z2;
   s1 = coeff<double>::one+z*coeff<double>::qq[1];
   s2 = coeff<double>::qq[2]+z*coeff<double>::qq[3];
   s3 = coeff<double>::qq[4]+z*coeff<double>::qq[5];
   r = r1 + z2*r2 + z4*coeff<double>::pp[4];
   s = s1 + z2*s2 + z4*s3;

   y = r/s;
   if(ix < erfc_traits<double>::segment[4]) {
  return ap_fixed<W_,I_>(coeff<double>::one-(x+x*y));
   } else {
  r = x*y;
  r += (x-coeff<double>::one_over_two);
  return ap_fixed<W_,I_>(coeff<double>::one_over_two - r) ;
   }
 }
 if(ix < erfc_traits<double>::segment[5]) {
   double s2,s4,s6,P1,P2,P3,P4,Q1,Q2,Q3,Q4;
   s =fp_abs.to_ieee()-coeff<double>::one;




   P1 = coeff<double>::pa[0]+s*coeff<double>::pa[1]; s2=s*s;
   Q1 = coeff<double>::one+s*coeff<double>::qa[1]; s4=s2*s2;
   P2 = coeff<double>::pa[2]+s*coeff<double>::pa[3]; s6=s4*s2;
   Q2 = coeff<double>::qa[2]+s*coeff<double>::qa[3];
   P3 = coeff<double>::pa[4]+s*coeff<double>::pa[5];
   Q3 = coeff<double>::qa[4]+s*coeff<double>::qa[5];
   P4 = coeff<double>::pa[6];
   Q4 = coeff<double>::qa[6];
   P = P1 + s2*P2 + s4*P3 + s6*P4;
   Q = Q1 + s2*Q2 + s4*Q3 + s6*Q4;

   if(hx>=0) {
  z = coeff<double>::one-coeff<double>::erx;
        return ap_fixed<W_,I_>(z - P/Q);
   } else {
  z = coeff<double>::erx+P/Q; return ap_fixed<W_,I_>(coeff<double>::one+z);
   }
 }
 if (ix < erfc_traits<double>::segment[6]) {
   x = fp_abs.to_ieee();
   s = coeff<double>::one/(x*x);
   if(ix< erfc_traits<double>::segment[7]) {






  double R1,R2,R3,R4,S1,S2,S3,S4,s2,s4,s6,s8;
     R1 = coeff<double>::ra[0]+s*coeff<double>::ra[1];s2 = s*s;
     S1 = coeff<double>::one+s*coeff<double>::sa[1]; s4 = s2*s2;
     R2 = coeff<double>::ra[2]+s*coeff<double>::ra[3];s6 = s4*s2;
     S2 = coeff<double>::sa[2]+s*coeff<double>::sa[3];s8 = s4*s4;
     R3 = coeff<double>::ra[4]+s*coeff<double>::ra[5];
     S3 = coeff<double>::sa[4]+s*coeff<double>::sa[5];
     R4 = coeff<double>::ra[6]+s*coeff<double>::ra[7];
     S4 = coeff<double>::sa[6]+s*coeff<double>::sa[7];
     R = R1 + s2*R2 + s4*R3 + s6*R4;
     S = S1 + s2*S2 + s4*S3 + s6*S4 + s8*coeff<double>::sa[8];

   } else {
  double R1,R2,R3,S1,S2,S3,S4,s2,s4,s6;
  if(hx<0&&ix>=erfc_traits<double>::segment[8]) return ap_fixed<W_,I_>(coeff<double>::two-coeff<double>::tiny);






  R1 = coeff<double>::rb[0]+s*coeff<double>::rb[1];s2 = s*s;
  S1 = coeff<double>::one+s*coeff<double>::sb[1]; s4 = s2*s2;
  R2 = coeff<double>::rb[2]+s*coeff<double>::rb[3];s6 = s4*s2;
  S2 = coeff<double>::sb[2]+s*coeff<double>::sb[3];
  R3 = coeff<double>::rb[4]+s*coeff<double>::rb[5];
  S3 = coeff<double>::sb[4]+s*coeff<double>::sb[5];
  S4 = coeff<double>::sb[6]+s*coeff<double>::sb[7];
  R = R1 + s2*R2 + s4*R3 + s6*coeff<double>::rb[6];
  S = S1 + s2*S2 + s4*S3 + s6*S4;

   }
   z = x;

   fp_struct<double> fp_z(z);
   ap_uint<Type_BitWidth<double>::Value> data = fp_z.data() & erf_traits<double>::mask;
   fp_struct<double> fp_z_new(data);
   z = fp_z_new.to_ieee();


   ap_fixed<W_, I_> r_fixed = exp_reduce::exp((ap_fixed<W_, I_>)(-z*z-(double)0.5625))*exp_reduce::exp((ap_fixed<W_, I_>)((z-x)*(z+x)+R/S));
   double r = r_fixed.to_double();
   double r_x = r/x;
   if(hx>0) {





        if(fp_x.exp == 0x0 && fp_x.sign!= 0x0){
   return 0;
        }
  return ap_fixed<W_,I_>(r_x);
   } else
  return ap_fixed<W_,I_>(coeff<double>::two-r_x);
 } else {
   if(hx>0) return ap_fixed<W_,I_>(coeff<double>::tiny*coeff<double>::tiny);
      else return ap_fixed<W_,I_>(coeff<double>::two-coeff<double>::tiny);
 }

}
template <int W_, int I_>
ap_ufixed<W_,I_> erfc(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xs = x;
    return erfc(xs);
}

template <int I_>
ap_int<I_> erfc(ap_int<I_> x) {
    ap_fixed<I_,I_> xs = x;
    return erfc(xs);
}

template <int I_>
ap_uint<I_> erfc(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xs = x;
    return erfc(xs);
}

}
# 1033 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_fmod_rem_quo_remainder_divide_apfixed.h" 1
# 40 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_fmod_rem_quo_remainder_divide_apfixed.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 41 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_fmod_rem_quo_remainder_divide_apfixed.h" 2



namespace hls_internal{

    template <int W_, int I_>
    ap_fixed<W_,I_> generic_divide(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y){
        if(y==0){




                return 0;

        } else{
     return(x/y);
        }
    }

    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_divide(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y){
     ap_fixed<W_+1,I_+1> x1 = x;
     ap_fixed<W_+1,I_+1> y1 = y;
     return generic_divide(x1,y1);
    }

    template <int I_>
    ap_int<I_> generic_divide(ap_int<I_> x, ap_int<I_> y){
     ap_fixed<I_,I_> x1 = x;
     ap_fixed<I_,I_> y1 = y;
     return generic_divide(x1,y1);
    }

    template <int I_>
    ap_uint<I_> generic_divide(ap_uint<I_> x, ap_uint<I_> y){
     ap_ufixed<I_,I_> x1 = x;
     ap_ufixed<I_,I_> y1 = y;
     return generic_divide(x1,y1);
    }

    template <int W_, int I_>
    ap_fixed<W_,I_> generic_fmod(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y){
        ap_ufixed<W_,I_> x_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)x);
        ap_ufixed<W_,I_> y_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)y);


        if(x_pos==0 || y_pos==0) return 0;
     else if(x_pos == y_pos) return 0;
        else if(x_pos < y_pos) return x;
        else {
            ap_uint<W_> x_int = 0;
            ap_uint<W_> y_int = 0;
            x_int(W_-1,0) = x_pos(W_-1,0);
            y_int(W_-1,0) = y_pos(W_-1,0);






            ap_uint<W_> d = x_int/y_int;

            ap_uint<W_> rem = x_int - d*y_int;

            ap_fixed<W_,I_> r = 0;
            r(W_-1,0) = rem(W_-1,0);
            if(x[W_-1]) return -r;
            else return r;
        }
    }


    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_fmod(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y){
        ap_fixed<W_+1,I_+1> xi = x;
        ap_fixed<W_+1,I_+1> yi = y;
        return generic_fmod(xi,yi);
    }

    template <int I_>
    ap_int<I_> generic_fmod(ap_int<I_> x, ap_int<I_> y){
     ap_fixed<I_,I_> xi = x;
     ap_fixed<I_,I_> yi = y;
     return generic_fmod(xi,yi);
    }

    template <int I_>
    ap_uint<I_> generic_fmod(ap_uint<I_> x, ap_uint<I_> y){
     ap_fixed<I_+1,I_+1> xi = x;
     ap_fixed<I_+1,I_+1> yi = y;
     return generic_fmod(xi,yi);
    }


    template <int W_, int I_>
    ap_fixed<W_,I_> generic_remquo(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y, int* quo){
        ap_ufixed<W_,I_> x_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)x);
        ap_ufixed<W_,I_> y_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)y);
        if(x_pos==0 || y_pos==0) {
           *quo = 0;
           return 0;
        } else if(x_pos == y_pos) {
           if(x[W_-1]==y[W_-1]) *quo = 1;
           else *quo = -1;
           return 0;
        }

        else {
            ap_uint<W_> x_int = 0;
            ap_uint<W_> y_int = 0;
            x_int(W_-1,0) = x_pos(W_-1,0);
            y_int(W_-1,0) = y_pos(W_-1,0);





            ap_uint<W_> d = x_int/y_int;
            ap_uint<W_> rem = x_int - d*y_int;

            ap_uint<W_> y_half = 0;
            y_half(W_-2,0) = y_int(W_-1,1);
            ap_uint<1> r_sig = x[W_-1];
            if(rem > y_half) {
                rem = y_int - rem;
                d++;
                if(x[W_-1]) r_sig = 0;
                else r_sig = 1;
            }

            if(x[W_-1]==y[W_-1]) *quo = d;
            else *quo = -d;
            ap_fixed<W_,I_> r = 0;
            r(W_-1,0) = rem(W_-1,0);
            if(r_sig) return -r;
            else return r;
        }
    }

    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_remquo(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y, int* quo){
     ap_fixed<W_+1,I_+1> xi = x;
     ap_fixed<W_+1,I_+1> yi = y;
     return generic_remquo(xi,yi,quo);
    }

    template <int I_>
    ap_int<I_> generic_remquo(ap_int<I_> x, ap_int<I_> y, int* quo){
     ap_fixed<I_,I_> xi = x;
     ap_fixed<I_,I_> yi = y;
     return generic_remquo(xi,yi,quo);
    }

    template <int I_>
    ap_uint<I_> generic_remquo(ap_uint<I_> x, ap_uint<I_> y, int* quo){
     ap_fixed<I_+1,I_+1> xi = x;
     ap_fixed<I_+1,I_+1> yi = y;
     return generic_remquo(xi,yi,quo);
    }


    template <int W_, int I_>
    ap_fixed<W_,I_> generic_remainder(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y){
        int quo = 0;
        return generic_remquo(x, y, &quo);
    }

    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_remainder(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y){
        ap_fixed<W_+1, I_+1> xi = x;
        ap_fixed<W_+1, I_+1> yi = y;
        return generic_remainder(xi,yi);
    }

    template <int I_>
    ap_int<I_> generic_remainder(ap_int<I_> x, ap_int<I_> y){
     ap_fixed<I_,I_> xi = x;
     ap_fixed<I_,I_> yi = y;
     return generic_remainder(xi,yi);
    }

    template <int I_>
    ap_uint<I_> generic_remainder(ap_uint<I_> x, ap_uint<I_> y){
     ap_fixed<I_+1,I_+1> xi = x;
     ap_fixed<I_+1,I_+1> yi = y;
     return generic_remainder(xi,yi);
    }
}
# 1034 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_fract_apfixed.h" 1






# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_traits.h" 1
# 36 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_traits.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 37 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_traits.h" 2





namespace hls
{

template<typename T>
struct x_traits_default {
  typedef T ADD_T;
  typedef T SUB_T;
  typedef T SAT_T;
  typedef T MULT_T;
  typedef T MADD_T;
};

template<typename T1, typename T2>
struct x_traits {
# 67 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_traits.h"
};
template<typename T2>
struct x_traits<double, T2> : public x_traits_default<double> { };

template<typename T1>
struct x_traits<T1, double> : public x_traits_default<double> { };

template<typename T2>
struct x_traits<float, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, float> : public x_traits_default<float> { };

template<typename T2>
struct x_traits<half, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, half> : public x_traits_default<float> { };
# 100 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_traits.h"
template<>
struct x_traits< char , char > : public x_traits_default< char > {};

template<>
struct x_traits< char , signed char > : public x_traits_default< signed char > {};

template<>
struct x_traits< char , unsigned char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< char , short > : public x_traits_default< short > {};

template<>
struct x_traits< char , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< char , int > : public x_traits_default< int > {};

template<>
struct x_traits< char , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< char , long > : public x_traits_default< long > {};

template<>
struct x_traits< char , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< char , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< char , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< char , half > : public x_traits_default< float > {};

template<>
struct x_traits< char , float > : public x_traits_default< float > {};

template<>
struct x_traits< char , double > : public x_traits_default< double > {};

template<>
struct x_traits< signed char , char > : public x_traits_default< signed char > {};

template<>
struct x_traits< signed char , signed char > : public x_traits_default< signed char > {};

template<>
struct x_traits< signed char , unsigned char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< signed char , short > : public x_traits_default< short > {};

template<>
struct x_traits< signed char , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< signed char , int > : public x_traits_default< int > {};

template<>
struct x_traits< signed char , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< signed char , long > : public x_traits_default< long > {};

template<>
struct x_traits< signed char , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< signed char , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< signed char , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< signed char , half > : public x_traits_default< float > {};

template<>
struct x_traits< signed char , float > : public x_traits_default< float > {};

template<>
struct x_traits< signed char , double > : public x_traits_default< double > {};

template<>
struct x_traits< unsigned char , char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< unsigned char , signed char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< unsigned char , unsigned char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< unsigned char , short > : public x_traits_default< short > {};

template<>
struct x_traits< unsigned char , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned char , int > : public x_traits_default< int > {};

template<>
struct x_traits< unsigned char , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned char , long > : public x_traits_default< long > {};

template<>
struct x_traits< unsigned char , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned char , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< unsigned char , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< unsigned char , half > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned char , float > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned char , double > : public x_traits_default< double > {};

template<>
struct x_traits< short , char > : public x_traits_default< short > {};

template<>
struct x_traits< short , signed char > : public x_traits_default< short > {};

template<>
struct x_traits< short , unsigned char > : public x_traits_default< short > {};

template<>
struct x_traits< short , short > : public x_traits_default< short > {};

template<>
struct x_traits< short , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< short , int > : public x_traits_default< int > {};

template<>
struct x_traits< short , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< short , long > : public x_traits_default< long > {};

template<>
struct x_traits< short , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< short , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< short , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< short , half > : public x_traits_default< float > {};

template<>
struct x_traits< short , float > : public x_traits_default< float > {};

template<>
struct x_traits< short , double > : public x_traits_default< double > {};

template<>
struct x_traits< unsigned short , char > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , signed char > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , unsigned char > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , int > : public x_traits_default< int > {};

template<>
struct x_traits< unsigned short , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned short , long > : public x_traits_default< long > {};

template<>
struct x_traits< unsigned short , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned short , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< unsigned short , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< unsigned short , half > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned short , float > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned short , double > : public x_traits_default< double > {};

template<>
struct x_traits< int , char > : public x_traits_default< int > {};

template<>
struct x_traits< int , signed char > : public x_traits_default< int > {};

template<>
struct x_traits< int , unsigned char > : public x_traits_default< int > {};

template<>
struct x_traits< int , short > : public x_traits_default< int > {};

template<>
struct x_traits< int , unsigned short > : public x_traits_default< int > {};

template<>
struct x_traits< int , int > : public x_traits_default< int > {};

template<>
struct x_traits< int , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< int , long > : public x_traits_default< long > {};

template<>
struct x_traits< int , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< int , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< int , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< int , half > : public x_traits_default< float > {};

template<>
struct x_traits< int , float > : public x_traits_default< float > {};

template<>
struct x_traits< int , double > : public x_traits_default< double > {};

template<>
struct x_traits< unsigned int , char > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , signed char > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , unsigned char > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , short > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , unsigned short > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , long > : public x_traits_default< long > {};

template<>
struct x_traits< unsigned int , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned int , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< unsigned int , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< unsigned int , half > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned int , float > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned int , double > : public x_traits_default< double > {};

template<>
struct x_traits< long , char > : public x_traits_default< long > {};

template<>
struct x_traits< long , signed char > : public x_traits_default< long > {};

template<>
struct x_traits< long , unsigned char > : public x_traits_default< long > {};

template<>
struct x_traits< long , short > : public x_traits_default< long > {};

template<>
struct x_traits< long , unsigned short > : public x_traits_default< long > {};

template<>
struct x_traits< long , int > : public x_traits_default< long > {};

template<>
struct x_traits< long , unsigned int > : public x_traits_default< long > {};

template<>
struct x_traits< long , long > : public x_traits_default< long > {};

template<>
struct x_traits< long , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< long , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< long , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< long , half > : public x_traits_default< float > {};

template<>
struct x_traits< long , float > : public x_traits_default< float > {};

template<>
struct x_traits< long , double > : public x_traits_default< double > {};

template<>
struct x_traits< unsigned long , char > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , signed char > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , unsigned char > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , short > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , unsigned short > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , int > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , unsigned int > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< unsigned long , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< unsigned long , half > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned long , float > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned long , double > : public x_traits_default< double > {};

template<>
struct x_traits< ap_slong , char > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , signed char > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , unsigned char > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , short > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , unsigned short > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , int > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , unsigned int > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , long > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , unsigned long > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_slong , half > : public x_traits_default< float > {};

template<>
struct x_traits< ap_slong , float > : public x_traits_default< float > {};

template<>
struct x_traits< ap_slong , double > : public x_traits_default< double > {};

template<>
struct x_traits< ap_ulong , char > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , signed char > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , unsigned char > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , short > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , unsigned short > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , int > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , unsigned int > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , long > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , unsigned long > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , ap_slong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , half > : public x_traits_default< float > {};

template<>
struct x_traits< ap_ulong , float > : public x_traits_default< float > {};

template<>
struct x_traits< ap_ulong , double > : public x_traits_default< double > {};

template<>
struct x_traits< half , char > : public x_traits_default< float > {};

template<>
struct x_traits< half , signed char > : public x_traits_default< float > {};

template<>
struct x_traits< half , unsigned char > : public x_traits_default< float > {};

template<>
struct x_traits< half , short > : public x_traits_default< float > {};

template<>
struct x_traits< half , unsigned short > : public x_traits_default< float > {};

template<>
struct x_traits< half , int > : public x_traits_default< float > {};

template<>
struct x_traits< half , unsigned int > : public x_traits_default< float > {};

template<>
struct x_traits< half , long > : public x_traits_default< float > {};

template<>
struct x_traits< half , unsigned long > : public x_traits_default< float > {};

template<>
struct x_traits< half , ap_slong > : public x_traits_default< float > {};

template<>
struct x_traits< half , ap_ulong > : public x_traits_default< float > {};

template<>
struct x_traits< half , half > : public x_traits_default< half > {};

template<>
struct x_traits< half , float > : public x_traits_default< float > {};

template<>
struct x_traits< half , double > : public x_traits_default< double > {};

template<>
struct x_traits< float , char > : public x_traits_default< float > {};

template<>
struct x_traits< float , signed char > : public x_traits_default< float > {};

template<>
struct x_traits< float , unsigned char > : public x_traits_default< float > {};

template<>
struct x_traits< float , short > : public x_traits_default< float > {};

template<>
struct x_traits< float , unsigned short > : public x_traits_default< float > {};

template<>
struct x_traits< float , int > : public x_traits_default< float > {};

template<>
struct x_traits< float , unsigned int > : public x_traits_default< float > {};

template<>
struct x_traits< float , long > : public x_traits_default< float > {};

template<>
struct x_traits< float , unsigned long > : public x_traits_default< float > {};

template<>
struct x_traits< float , ap_slong > : public x_traits_default< float > {};

template<>
struct x_traits< float , ap_ulong > : public x_traits_default< float > {};

template<>
struct x_traits< float , half > : public x_traits_default< float > {};

template<>
struct x_traits< float , float > : public x_traits_default< float > {};

template<>
struct x_traits< float , double > : public x_traits_default< double > {};

template<>
struct x_traits< double , char > : public x_traits_default< double > {};

template<>
struct x_traits< double , signed char > : public x_traits_default< double > {};

template<>
struct x_traits< double , unsigned char > : public x_traits_default< double > {};

template<>
struct x_traits< double , short > : public x_traits_default< double > {};

template<>
struct x_traits< double , unsigned short > : public x_traits_default< double > {};

template<>
struct x_traits< double , int > : public x_traits_default< double > {};

template<>
struct x_traits< double , unsigned int > : public x_traits_default< double > {};

template<>
struct x_traits< double , long > : public x_traits_default< double > {};

template<>
struct x_traits< double , unsigned long > : public x_traits_default< double > {};

template<>
struct x_traits< double , ap_slong > : public x_traits_default< double > {};

template<>
struct x_traits< double , ap_ulong > : public x_traits_default< double > {};

template<>
struct x_traits< double , half > : public x_traits_default< double > {};

template<>
struct x_traits< double , float > : public x_traits_default< double > {};

template<>
struct x_traits< double , double > : public x_traits_default< double > {};





template<int A,int B> class MAX{
  public:
    const static int value = (A > B) ? A : B;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_fixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_fixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_fixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_fixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_fixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_fixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_ufixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_ufixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_ufixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_ufixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_ufixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_ufixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_ufixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_ufixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
 typedef ap_int<(W1 > W2)? W1:W2> MADD_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_uint<W2> > {
 typedef ap_int<MAX<W1,W2+1>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2+1>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1+1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1+1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_uint<W2> > {
 typedef ap_uint<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_uint<W1+W2> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_fixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_fixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_ufixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_ufixed<W2,I2> > {};




    template<typename T> struct fixed_type { };
    template<> struct fixed_type<char> { typedef ap_fixed<8,8> T; };
    template<> struct fixed_type<unsigned char> { typedef ap_ufixed<8,8> T; };
    template<> struct fixed_type<short> { typedef ap_fixed<16,16> T; };
    template<> struct fixed_type<unsigned short> { typedef ap_ufixed<16,16> T; };
    template<> struct fixed_type<int> { typedef ap_fixed<32,32> T; };
    template<> struct fixed_type<unsigned int> { typedef ap_ufixed<32,32> T; };
    template<> struct fixed_type<float> { typedef ap_ufixed<64,32> T; };
    template<int W> struct fixed_type<ap_int<W> > { typedef ap_fixed<W,W> T; };
    template<int W> struct fixed_type<ap_uint<W> > { typedef ap_ufixed<W,W> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_fixed<W,I, _AP_Q, _AP_O> > { typedef ap_fixed<W,I> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_ufixed<W,I, _AP_Q, _AP_O> > { typedef ap_ufixed<W,I> T; };

template<typename T1, int DIM>
struct x_traits_d_default {
    typedef T1 ACCUM_T;
    typedef T1 ACCUM2_T;
    typedef T1 ADD_TREE_T;
};

template<typename T1, int DIM>
struct x_traits_d {};

template<int DIM>
struct x_traits_d <int,DIM>:x_traits_d_default<int, DIM> {};

template<int DIM>
struct x_traits_d <float,DIM>:x_traits_d_default<float, DIM> {};

template<int DIM>
struct x_traits_d <double,DIM>:x_traits_d_default<double, DIM> {};

template<int DIM>
struct x_traits_d <half,DIM>:x_traits_d_default<half, DIM> {};

template<int W, int DIM>
struct x_traits_d <ap_int<W>,DIM> {
    typedef ap_int<W> ACCUM_T;
    typedef ap_int<2*W> ACCUM2_T;
    typedef ap_int<25+W> ADD_TREE_T;
};

template<int W, int DIM>
struct x_traits_d <ap_uint<W>,DIM> {
    typedef ap_uint<W> ACCUM_T;
    typedef ap_uint<2*W> ACCUM2_T;
    typedef ap_uint<25+W> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_fixed<W,I,Q,O>,DIM> {
    typedef ap_fixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_fixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_fixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_ufixed<W,I,Q,O>,DIM> {
    typedef ap_ufixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_ufixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_ufixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

}



namespace hlstmp
{

template<typename T>
struct x_traits_default {
  typedef T ADD_T;
  typedef T SUB_T;
  typedef T SAT_T;
  typedef T MULT_T;
  typedef T MADD_T;
};

template<typename T1, typename T2>
struct x_traits {
# 893 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/utils/x_hls_traits.h"
};

template<>
struct x_traits<double, double> : public x_traits_default<double> { };

template<typename T2>
struct x_traits<double, T2> : public x_traits_default<double> { };

template<typename T1>
struct x_traits<T1, double> : public x_traits_default<double> { };

template<>
struct x_traits<float, float> : public x_traits_default<float> { };

template<typename T2>
struct x_traits<float, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, float> : public x_traits_default<float> { };

template<>
struct x_traits<half, half> : public x_traits_default<half> { };

template<typename T2>
struct x_traits<half, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, half> : public x_traits_default<float> { };

template<>
struct x_traits<double, float> : public x_traits_default<double> { };

template<>
struct x_traits<float, double> : public x_traits_default<double> { };

template<>
struct x_traits<double, half> : public x_traits_default<double> { };

template<>
struct x_traits<half, double> : public x_traits_default<double> { };

template<>
struct x_traits<int, int> : public x_traits_default<int> { };

template<>
struct x_traits<unsigned int, unsigned int> : public x_traits_default<unsigned int> { };

template<>
struct x_traits<int64_t, int64_t> : public x_traits_default<int64_t> { };

template<int A,int B> class MAX{
  public:
    const static int value = (A > B) ? A : B;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_fixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_fixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_fixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_fixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_fixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_fixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_ufixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_ufixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_ufixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_ufixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_ufixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_ufixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_ufixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_ufixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
 typedef ap_int<(W1 > W2)? W1:W2> MADD_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_uint<W2> > {
 typedef ap_int<MAX<W1,W2+1>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2+1>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1+1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1+1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_uint<W2> > {
 typedef ap_uint<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_uint<W1+W2> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_fixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_fixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_ufixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_ufixed<W2,I2> > {};




    template<typename T> struct fixed_type { };
    template<> struct fixed_type<char> { typedef ap_fixed<8,8> T; };
    template<> struct fixed_type<unsigned char> { typedef ap_ufixed<8,8> T; };
    template<> struct fixed_type<short> { typedef ap_fixed<16,16> T; };
    template<> struct fixed_type<unsigned short> { typedef ap_ufixed<16,16> T; };
    template<> struct fixed_type<int> { typedef ap_fixed<32,32> T; };
    template<> struct fixed_type<unsigned int> { typedef ap_ufixed<32,32> T; };
    template<> struct fixed_type<float> { typedef ap_ufixed<64,32> T; };
    template<int W> struct fixed_type<ap_int<W> > { typedef ap_fixed<W,W> T; };
    template<int W> struct fixed_type<ap_uint<W> > { typedef ap_ufixed<W,W> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_fixed<W,I, _AP_Q, _AP_O> > { typedef ap_fixed<W,I> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_ufixed<W,I, _AP_Q, _AP_O> > { typedef ap_ufixed<W,I> T; };

template<typename T1, int DIM>
struct x_traits_d_default {
    typedef T1 ACCUM_T;
    typedef T1 ACCUM2_T;
    typedef T1 ADD_TREE_T;
};

template<typename T1, int DIM>
struct x_traits_d {};

template<int DIM>
struct x_traits_d <int,DIM>:x_traits_d_default<int, DIM> {};

template<int DIM>
struct x_traits_d <float,DIM>:x_traits_d_default<float, DIM> {};

template<int DIM>
struct x_traits_d <double,DIM>:x_traits_d_default<double, DIM> {};

template<int DIM>
struct x_traits_d <half,DIM>:x_traits_d_default<half, DIM> {};

template<int W, int DIM>
struct x_traits_d <ap_int<W>,DIM> {
    typedef ap_int<W> ACCUM_T;
    typedef ap_int<2*W> ACCUM2_T;
    typedef ap_int<25+W> ADD_TREE_T;
};

template<int W, int DIM>
struct x_traits_d <ap_uint<W>,DIM> {
    typedef ap_uint<W> ACCUM_T;
    typedef ap_uint<2*W> ACCUM2_T;
    typedef ap_uint<25+W> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_fixed<W,I,Q,O>,DIM> {
    typedef ap_fixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_fixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_fixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_ufixed<W,I,Q,O>,DIM> {
    typedef ap_ufixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_ufixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_ufixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

}
# 8 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_fract_apfixed.h" 2

namespace hls_fract {

template <int W_, int I_>
ap_fixed<W_,I_> generic_fract(ap_fixed<W_,I_> x){
 if (W_==I_)return 0;
 ap_fixed<W_-I_+1,1> x1=x;
 ap_fixed<W_-I_+1,1> x2=x1+ap_int<2>(1);
 return x[W_-1]?x2:x1;
}

template <int W_, int I_>
ap_ufixed<W_,I_> generic_fract(ap_ufixed<W_,I_> x){
 ap_fixed<W_+1,I_+1> x1=x;
 return generic_fract(x1);
}

template <int I_>
ap_int<I_> generic_fract(ap_int<I_> x){
 ap_fixed<I_,I_> x1 = x;
 return generic_fract(x1);
}

template <int I_>
ap_uint<I_> generic_fract(ap_uint<I_> x){
 ap_ufixed<I_,I_> x1 = x;
 return generic_fract(x1);
}
}
# 1035 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_mad_apfixed.h" 1




namespace hls_mad {

    template <int W_, int I_>
    ap_fixed<W_,I_> generic_mad(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y, ap_fixed<W_,I_> z){
        const unsigned int F_ = W_ - I_;
        ap_fixed<2*W_, 2*I_> mul = x * y;

        ap_fixed<2, -F_> delta = 0;
        delta[0] = 1;
        delta[1] = mul[2*W_-1];

        mul += delta;

        ap_fixed<W_+1, I_+1> mul_s = mul;
        ap_fixed<W_+1, I_+1> sum = mul_s + z;
        ap_fixed<W_,I_> r = 0;

        if(sum[W_-1]!=sum[W_]) {
           for(int i = 0; i < W_-1; ++i) {
#pragma HLS unroll
 r[i] = !sum[W_];
           }
           r[W_-1] = sum[W_];
        } else {
           r = sum;
        }
        return r;
    }

    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_mad(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y, ap_ufixed<W_,I_> z){
        ap_fixed<W_+1, I_+1> xi = x;
        ap_fixed<W_+1, I_+1> yi = y;
        ap_fixed<W_+1, I_+1> zi = z;
        return generic_mad(xi, yi, zi);
    }

    template <int I_>
    ap_int<I_> generic_mad(ap_int<I_> x, ap_int<I_> y, ap_int<I_> z){
        ap_fixed<I_, I_> xi = x;
        ap_fixed<I_, I_> yi = y;
        ap_fixed<I_, I_> zi = z;
        return generic_mad(xi, yi, zi);
    }

    template <int I_>
    ap_uint<I_> generic_mad(ap_uint<I_> x, ap_uint<I_> y, ap_uint<I_> z){
        ap_fixed<I_+1,I_+1> xi = x;
        ap_fixed<I_+1,I_+1> yi = y;
        ap_fixed<I_+1,I_+1> zi = z;
        return generic_mad(xi,yi,zi);
    }
}
# 1036 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cbrt_apfixed.h" 1
# 40 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cbrt_apfixed.h"
namespace cbrt_internal{
template <int W, int I>
ap_fixed<W, I> cbrt_fixed(ap_fixed<W,I> x) {






   const int F = W - I;
   if(I > 33) return 0;
   else if(F > 32) return 0;

   ap_fixed<W+1, I+1> xi = x;
   ap_ufixed<W, I> x_p = fabs_fixed(xi);





   ap_ufixed<F +(I+2)/3, (I+2)/3> r = 0;;
      const static int prcs = (F+1)*3;
_ssdm_SpecConstant(&prcs);
# 61 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cbrt_apfixed.h"

      const static int msbr = (I>0)? (I+2)/3 : 1;
_ssdm_SpecConstant(&msbr);
# 62 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cbrt_apfixed.h"

      ap_ufixed<2*msbr+prcs+2,2*msbr+2> resq = 0;
      ap_ufixed<msbr+prcs+1, msbr+1> res = 0;
      ap_ufixed<3*msbr+prcs+4, 3*msbr+4> x_rem = x_p;
      for(int pos = msbr - 1 ; pos >= -F-1; pos--) {
          ap_ufixed<3*msbr+prcs+2, 3*msbr+2> mul1a = 0;
          ap_ufixed<3*msbr+prcs+1, 3*msbr+1> mul1b = 0;




          mul1a(pos+2*msbr+prcs+2, prcs+3*pos+3) = resq(prcs+2*msbr+1, prcs+2*pos+2);

          mul1b(pos+2*msbr+prcs+1, prcs+3*pos+2) = resq(prcs+2*msbr+1, prcs+2*pos+2);



          ap_ufixed<3*msbr+prcs, 3*msbr> mul2a = 0;
          ap_ufixed<3*msbr+prcs-1, 3*msbr-1> mul2b = 0;

          mul2a(pos*2+msbr+prcs+1, pos*3+2+prcs) = res(msbr+prcs, pos+1+prcs);

          mul2b(pos*2+msbr+prcs, pos*3+1+prcs) = res(msbr+prcs, pos+1+prcs);

          ap_ufixed<3*msbr+prcs+3, 3*msbr+3> mulL = 0;
          ap_ufixed<3*msbr+prcs+3, 3*msbr+3> mulH = 0;


          mulL(pos*2+msbr+prcs+3, pos*3+1+prcs) = mul2b(pos*2+msbr+prcs, pos*3+1+prcs) + mul2a(pos*2+msbr+prcs+1, pos*3+1+prcs) + mul1a(pos*2+msbr+prcs+1, pos*3+1+prcs) + mul1b(pos*2+msbr+prcs+1,pos*3+1+prcs);

          mulH(pos+2*msbr+prcs+3, pos*2+msbr+prcs+2) = mulL(pos*2+msbr+prcs+3, pos*2+msbr+prcs+2) + mul1a(pos+2*msbr+prcs+2,pos*2+msbr+prcs+2) + mul1b(pos+2*msbr+prcs+1,pos*2+msbr+prcs+2);
          mulL[3*pos+prcs] = 1;







          bool cond1 = (x_rem(pos+2*msbr+prcs+4,pos*2+msbr+prcs+2) > mulH(pos+2*msbr+prcs+3,pos*2+msbr+prcs+2));
          bool cond2 = (x_rem(pos+2*msbr+prcs+4,pos*2+msbr+prcs+2) == mulH(pos+2*msbr+prcs+3,pos*2+msbr+prcs+2));
          bool cond3 = (x_rem(pos*2+msbr+prcs+1,pos*3+prcs) >= mulL(pos*2+msbr+prcs+1,pos*3+prcs));
          if(cond1 | (cond2 & cond3)) {
             ap_ufixed<3*msbr+prcs+3,3*msbr+3> x_rem_L = 0;
             x_rem_L(pos*2+msbr+prcs+1, pos*3+prcs) = x_rem(pos*2+msbr+prcs+1, pos*3+prcs);

             x_rem_L[pos*2+msbr+prcs+2] = cond3? 0 : 1;
             x_rem(pos+2*msbr+prcs+4,pos*2+msbr+prcs+2) = x_rem(pos+2*msbr+prcs+4, pos*2+msbr+prcs+2) - mulH(pos+2*msbr+prcs+3,pos*2+msbr+prcs+2) - x_rem_L(pos*2+msbr+prcs+2,pos*2+msbr+prcs+2);
             x_rem(pos*2+msbr+prcs+1,pos*3+prcs) = x_rem_L(pos*2+msbr+prcs+2, pos*3+prcs) - mulL(pos*2+msbr+prcs+1,pos*3+prcs);





             ap_ufixed<2*msbr+prcs+1,2*msbr+1> mul1 = 0;
             mul1(pos+msbr+prcs+1, 2*pos+2+prcs) = res(msbr+prcs, pos+1+prcs);
             ap_ufixed<2*msbr+prcs+2,2*msbr+2> resq_L = 0;
             resq_L(pos+msbr+prcs+2,2*pos+2+prcs) = resq(pos+msbr+prcs+1,2*pos+2+prcs) + mul1(pos+msbr+prcs+1,2*pos+2+prcs);
             resq(pos+msbr+prcs+1,2*pos+2+prcs) = resq_L(pos+msbr+prcs+1,2*pos+2+prcs);
             resq(2*msbr+prcs+1,pos+msbr+2+prcs) = resq(2*msbr+prcs+1,pos+msbr+2+prcs) + resq_L(pos+msbr+2+prcs,pos+msbr+2+prcs);
             resq[2*pos+prcs] = 1;
             res[pos+prcs] = 1;
         }
# 133 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_cbrt_apfixed.h"
      }





      ap_ufixed<1,-F-1> delta;
      delta[0] = 1;
      ap_ufixed<msbr+F+1,msbr> res_s = res;
      res_s += delta;
      r = res_s;
      if(x[W-1]) return -r;
      else return r;
}

template<int W, int I>
ap_ufixed<W, I> cbrt_fixed(ap_ufixed<W, I> x) {
   ap_fixed<W+1,I+1> xi = x;
   return cbrt_fixed(xi);
}
template<int I>
ap_int<I> cbrt_fixed(ap_int<I> x) {
   ap_fixed<I,I> xi = x;
   return cbrt_fixed(xi);
}
template<int I>
ap_uint<I> cbrt_fixed(ap_uint<I> x) {
   ap_fixed<I+1,I+1> xi = x;
   return cbrt_fixed(xi);
}
}
# 1037 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hypot_apfixed.h" 1
# 39 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hypot_apfixed.h"
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/ap_int.h" 1
# 40 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hypot_apfixed.h" 2

namespace hypot_internal {
template<int W, int I>
ap_fixed<W, I> hypot_fixed(ap_fixed<W, I> x, ap_fixed<W, I> y) {
    const static int F = W - I;
_ssdm_SpecConstant(&F);
# 44 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hypot_apfixed.h"

    if(I > 33) return 0;
    else if(F > 32) return 0;
# 55 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hypot_apfixed.h"
    if(x==0) return fabs_fixed(y);
    if(y==0) return fabs_fixed(x);

    ap_ufixed<2*W, I*2> x_sq = x * x;
    ap_ufixed<2*W, I*2> y_sq = y * y;
    ap_ufixed<2*W, I*2> xy_sq = x_sq + y_sq;
# 69 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hypot_apfixed.h"
    const static int prcs = (F+1)*2;
_ssdm_SpecConstant(&prcs);
# 69 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hypot_apfixed.h"

    const static int msbr = I > 0? I : 1;
_ssdm_SpecConstant(&msbr);
# 70 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hypot_apfixed.h"

    ap_ufixed<msbr, msbr> res_I = 0;
    ap_ufixed<2*msbr+1,2*msbr+1> x_l_I = 0;
    if(I>0) {
        x_l_I = xy_sq(2*W-1, 2*W-2*I);
        for(int pos = msbr - 1; pos >= 0; pos--) {
            ap_ufixed<2*msbr,2*msbr> mul_I = 0;



            mul_I(msbr+pos, 2*pos+1) = res_I(msbr-1, pos);
            mul_I[2*pos] = 1;
            if(x_l_I(msbr+pos+1, 2*pos) >= mul_I(msbr+pos, 2*pos)){



                ap_ufixed<2*msbr+1, 2*msbr+1> x_l_I_ = x_l_I;
                x_l_I(msbr+pos+1, 2*pos) = x_l_I(msbr+pos+1,2*pos) - mul_I(msbr+pos, 2*pos);



                res_I[pos] = 1;
           }
       }
    }
    ap_ufixed<msbr+1, msbr+1> x_l_I_s = x_l_I;
# 104 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hypot_apfixed.h"
    ap_ufixed<prcs/2,0> res_F = 0;
    ap_ufixed<prcs/2,0> x_l_FH = xy_sq;
    ap_ufixed<prcs/2, -prcs/2> x_l_FL = xy_sq;
    for(int pos = -1; pos >= -F-1; pos--) {
        ap_ufixed<msbr+prcs, msbr> mul = 0;



        mul(msbr+pos+prcs, pos+1+prcs) = res_I(msbr-1, 0);
        mul(pos+prcs, 2*pos+1+prcs) = res_F(prcs/2-1,pos+prcs/2);
        mul[2*pos+prcs] = 1;

        ap_ufixed<msbr, msbr> mul_I = 0;
        mul_I = mul;
        ap_ufixed<prcs/2, 0> mul_FH = mul;
        ap_ufixed<prcs/2, -prcs/2> mul_FL = mul;
# 139 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_hypot_apfixed.h"
        if((x_l_I_s > mul_I) || ((x_l_I_s == mul_I) && (x_l_FH > mul_FH)) || ((x_l_I_s == mul_I) && (x_l_FH == mul_FH) && (x_l_FL >= mul_FL))) {







           ap_ufixed<prcs/2+1, -prcs/2+1> x_l_FL_1 = x_l_FL;

           if(x_l_FL < mul_FL) x_l_FL_1[prcs/2] = 1;
           x_l_FL_1 -= mul_FL;



           ap_ufixed<prcs/2+1,1> x_l_FH_1 = x_l_FH;

           if((x_l_FH < mul_FH) || ((x_l_FH == mul_FH) && (x_l_FL < mul_FL))) x_l_FH_1[prcs/2] = 1;
           ap_ufixed<1, -prcs/2+1> delta = 0;
           if(x_l_FL < mul_FL) delta[0] = 1;

           x_l_FH_1 -= delta;
           x_l_FH_1 -= mul_FH;

           if((x_l_FH < mul_FH) || ((x_l_FH == mul_FH) && (x_l_FL < mul_FL))) x_l_I_s--;
           x_l_I_s -= mul_I;
           x_l_FH = x_l_FH_1;
           x_l_FL = x_l_FL_1;







           res_F[pos+prcs/2] = 1;
       }
    }
    ap_ufixed<prcs/2+1, 1> res_F_1 = res_F;

    ap_ufixed<1, -prcs/2+1> delta = 0;
    delta[0] = 1;
    res_F_1 += delta;
    if(res_F_1[prcs/2]) res_I++;
    ap_ufixed<msbr+prcs/2, msbr> res = 0;
    res(msbr+prcs/2-1, prcs/2) = res_I(msbr-1,0);
    res(prcs/2-1, 0) = res_F(prcs/2-1, 0);






    ap_fixed<W,I> r = 0;
    if(res[msbr+prcs/2-1]) {

       for(int i = 0; i < W - 1; ++i) {
#pragma HLS unroll
 r[i] = 1;
       }
    } else {
       r = res;
    }





    return r;
}
template<int W, int I>
ap_ufixed<W, I> hypot_fixed(ap_ufixed<W, I> x, ap_fixed<W, I> y) {
   ap_fixed<W+1, I+1> xi = x;
   ap_fixed<W+1, I+1> yi = y;
   return hypot_fixed(xi, yi);
}
template<int I>
ap_int<I> hypot_fixed(ap_int<I> x, ap_int<I> y) {
   ap_fixed<I, I> xi = x;
   ap_fixed<I, I> yi = y;
   return hypot_fixed(xi, yi);
}
template<int I>
ap_uint<I> hypot_fixed(ap_uint<I> x, ap_uint<I> y) {
   ap_fixed<I+1, I+1> xi = x;
   ap_fixed<I+1, I+1> yi = y;
   return hypot_fixed(xi, yi);
}
}
# 1038 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_ldexp_apfixed.h" 1
# 36 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_ldexp_apfixed.h"
namespace hls_ldexp {

template<int W, int I>
ap_fixed<W,I> ldexp(ap_fixed<W,I> x, int exp) {
    ap_fixed<W,I> result;
    if(exp >= W || exp <= -W) {
        result = 0;
    } else {
        result = x << exp;
    }
    return result;
}

template<int W, int I>
ap_ufixed<W,I> ldexp(ap_ufixed<W,I> x, int exp) {
    ap_fixed<W+1,I+1> xf = x;
    return ldexp(xf, exp);
}

template<int I>
ap_int<I> ldexp(ap_int<I> x, int exp) {
    ap_fixed<I,I> xf = x;
    return ldexp(xf, exp);
}

template<int I>
ap_uint<I> ldexp(ap_uint<I> x, int exp) {
    ap_fixed<I+1,I+1> xf = x;
    return ldexp(xf, exp);
}

template<int W, int I>
ap_fixed<W,I> scalbn(ap_fixed<W,I> x, int n) {
    ap_fixed<W,I> result;
    if(n >= W || n <= -W) {
        result = 0;
    } else {
        result = x << n;
    }
    return result;
}

template<int W, int I>
ap_ufixed<W,I> scalbn(ap_ufixed<W,I> x, int n) {
    ap_fixed<W+1,I+1> xf = x;
    return scalbn(xf, n);
}

template<int I>
ap_int<I> scalbn(ap_int<I> x, int n) {
    ap_fixed<I,I> xf = x;
    return scalbn(xf, n);
}

template<int I>
ap_uint<I> scalbn(ap_uint<I> x, int n) {
    ap_fixed<I+1,I+1> xf = x;
    return scalbn(xf, n);
}

template<int W, int I>
ap_fixed<W,I> scalbln(ap_fixed<W,I> x, long int n) {
    ap_fixed<W,I> result;
    if(n >= W || n <= -W) {
        result = 0;
    } else {
        result = x << n;
    }
    return result;
}

template<int W, int I>
ap_ufixed<W,I> scalbln(ap_ufixed<W,I> x, long int n) {
    ap_fixed<W+1,I+1> xf = x;
    return scalbln(xf, n);
}

template<int I>
ap_int<I> scalbln(ap_int<I> x, long int n) {
    ap_fixed<I,I> xf = x;
    return scalbln(xf, n);
}

template<int I>
ap_uint<I> scalbln(ap_uint<I> x, long int n) {
    ap_fixed<I+1,I+1> xf = x;
    return scalbln(xf, n);
}

}
# 1039 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h" 2

namespace hls {
# 1063 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h"
  template<int W, int I>
  ap_fixed<W, 2> sinpi(ap_fixed<W,I> x){
    return hotbm_apfixed::sinf_or_cosf<W,I>(x, 0, 1);
  }




  template<int W, int I>
  ap_ufixed<W, 2> sinpi(ap_ufixed<W,I> x){
      ap_fixed<W+1, I+1> xin = x;
      ap_fixed<W+1, 3> xout = hls::sinpi<W+1, I+1>(x);
   ap_ufixed<W, 2> out = 0;
   if(xout[W]==0){
    out = xout;
   }
   return out;
  }

  template<int W, int I>
  ap_fixed<W, 2> cospi(ap_fixed<W,I> x){
    return hotbm_apfixed::sinf_or_cosf<W,I>(x, 1, 1);
  }
  template<int W, int I>
  ap_ufixed<W, 2> cospi(ap_ufixed<W,I> x){
   ap_fixed<W+1, I+1> xin = x;
   ap_fixed<W+1, 3> xout = hls::cospi<W+1, I+1>(x);
   ap_ufixed<W, 2> out = 0;
   if(xout[W]==0){
    out = xout;
   }
   return out;
  }





  template<int I>
  ap_int<I> sinpi(ap_int<I> in){
 return ap_int<I>(0);
  }

  template<int I>
  ap_int<I> cospi(ap_int<I> in){
 return ap_int<I>(0);
  }

  template<int I>
  ap_uint<I> sinpi(ap_uint<I> in){
 return ap_uint<I>(0);
  }

  template<int I>
  ap_uint<I> cospi(ap_uint<I> in){
 return ap_uint<I>(0);
  }
  int8_t sinpi(int8_t);
  uint8_t sinpi(uint8_t);
  int16_t sinpi(int16_t);
  uint16_t sinpi(uint16_t);
  int32_t sinpi(int32_t);
  uint32_t sinpi(uint32_t);

  int8_t cospi(int8_t);
  uint8_t cospi(uint8_t);
  int16_t cospi(int16_t);
  uint16_t cospi(uint16_t);
  int32_t cospi(int32_t);
  uint32_t cospi(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> exp(ap_fixed<W,I> x){
    return exp_reduce::exp(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> exp(ap_ufixed<W,I> x){
    return exp_reduce::exp(x);
  }
  template<int I>
  ap_int<I> exp(ap_int<I> x){
    return exp_reduce::exp(x);
  }
  template<int I>
  ap_uint<I> exp(ap_uint<I> x){
    return exp_reduce::exp(x);
  }


  template<int W, int I>
  ap_fixed<W,I> log(ap_fixed<W,I> x){
    return log_apfixed_reduce::log(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> log(ap_ufixed<W,I> x){
    return log_apfixed_reduce::log(x);
  }
  template<int I>
  ap_int<I> log(ap_int<I> x){
    return log_apfixed_reduce::log(x);
  }
  template<int I>
  ap_uint<I> log(ap_uint<I> x){
    return log_apfixed_reduce::log(x);
  }


  template<int W, int I>
  ap_fixed<W,I> log10(ap_fixed<W,I> x){
    return log_apfixed_reduce::log10(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> log10(ap_ufixed<W,I> x){
    return log_apfixed_reduce::log10(x);
  }
  template<int I>
  ap_int<I> log10(ap_int<I> x){
    return log_apfixed_reduce::log10(x);
  }
  template<int I>
  ap_uint<I> log10(ap_uint<I> x){
 return log_apfixed_reduce::log10(x);
  }


  template<int W, int I>
  ap_fixed<W,I> log2(ap_fixed<W,I> x){
    return log_apfixed_reduce::log2(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> log2(ap_ufixed<W,I> x){
    return log_apfixed_reduce::log2(x);
  }
  template<int I>
  ap_int<I> log2(ap_int<I> x){
    return log_apfixed_reduce::log2(x);
  }
  template<int I>
  ap_uint<I> log2(ap_uint<I> x){
 return log_apfixed_reduce::log2(x);
  }


  template<int W, int I>
  ap_fixed<W,I> logb(ap_fixed<W,I> x){
    return log_apfixed_reduce::logb(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> logb(ap_ufixed<W,I> x){
    return log_apfixed_reduce::logb(x);
  }
  template<int I>
  ap_int<I> logb(ap_int<I> x){
    return log_apfixed_reduce::logb(x);
  }
  template<int I>
  ap_uint<I> logb(ap_uint<I> x){
 return log_apfixed_reduce::logb(x);
  }


  template<int W, int I>
  ap_fixed<W,I> sqrt(ap_fixed<W,I> x){
    return sqrt_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> sqrt(ap_ufixed<W,I> x){
    return sqrt_fixed(x);
  }
  template<int I>
  ap_int<I> sqrt(ap_int<I> x){
    return sqrt_fixed(x);
  }
  template<int I>
  ap_uint<I> sqrt(ap_uint<I> x){
    return sqrt_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> rsqrt(ap_fixed<W,I> x){
    return rsqrt_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> rsqrt(ap_ufixed<W,I> x){
    return rsqrt_fixed(x);
  }
  template<int I>
  ap_int<I> rsqrt(ap_int<I> x){
    return rsqrt_fixed(x);
  }
  template<int I>
  ap_uint<I> rsqrt(ap_uint<I> x){
    return rsqrt_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> recip(ap_fixed<W,I> x){
    return recip_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> recip(ap_ufixed<W,I> x){
    return recip_fixed(x);
  }
  template<int I>
  ap_int<I> recip(ap_int<I> x){
    return recip_fixed(x);
  }
  template<int I>
  ap_uint<I> recip(ap_uint<I> x){
    return recip_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> ceil(ap_fixed<W,I> x){
    return ceil_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> ceil(ap_ufixed<W,I> x){
    return ceil_fixed(x);
  }
  template<int I>
  ap_int<I> ceil(ap_int<I> x){
    return ceil_fixed(x);
  }
  template<int I>
  ap_uint<I> ceil(ap_uint<I> x){
    return ceil_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> floor(ap_fixed<W,I> x){
    return floor_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> floor(ap_ufixed<W,I> x){
    return floor_fixed(x);
  }
  template<int I>
  ap_int<I> floor(ap_int<I> x){
    return floor_fixed(x);
  }
  template<int I>
  ap_uint<I> floor(ap_uint<I> x){
    return floor_fixed(x);
  }

  template<int W, int I>
  ap_fixed<W,I> trunc(ap_fixed<W,I> x){
    return trunc_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> trunc(ap_ufixed<W,I> x){
    return trunc_fixed(x);
  }
  template<int I>
  ap_int<I> trunc(ap_int<I> x){
    return trunc_fixed(x);
  }
  template<int I>
  ap_uint<I> trunc(ap_uint<I> x){
    return trunc_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> copysign(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return copysign_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> copysign(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return copysign_fixed(x,y);
  }
  template<int I>
  ap_int<I> copysign(ap_int<I> x, ap_int<I> y){
    return copysign_fixed(x,y);
  }
  template<int I>
  ap_uint<I> copysign(ap_uint<I> x, ap_uint<I> y){
    return copysign_fixed(x,y);
  }


  template<int W, int I>
  ap_fixed<W,I> fabs(ap_fixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> fabs(ap_ufixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_int<I> fabs(ap_int<I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_uint<I> fabs(ap_uint<I> x){
    return fabs_fixed(x);
  }

  template<int W, int I>
  ap_fixed<W,I> abs(ap_fixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> abs(ap_ufixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_int<I> abs(ap_int<I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_uint<I> abs(ap_uint<I> x){
    return fabs_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> fdim(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return fdim_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fdim(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return fdim_fixed(x,y);
  }
  template<int I>
  ap_int<I> fdim(ap_int<I> x, ap_int<I> y){
    return fdim_fixed(x,y);
  }
  template<int I>
  ap_uint<I> fdim(ap_uint<I> x, ap_uint<I> y){
    return fdim_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> fmax(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return fmax_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fmax(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return fmax_fixed(x,y);
  }
  template<int I>
  ap_int<I> fmax(ap_int<I> x, ap_int<I> y){
    return fmax_fixed(x,y);
  }
  template<int I>
  ap_uint<I> fmax(ap_uint<I> x, ap_uint<I> y){
    return fmax_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> fmin(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return fmin_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fmin(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return fmin_fixed(x,y);
  }
  template<int I>
  ap_int<I> fmin(ap_int<I> x, ap_int<I> y){
    return fmin_fixed(x,y);
  }
  template<int I>
  ap_uint<I> fmin(ap_uint<I> x, ap_uint<I> y){
    return fmin_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> maxmag(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return maxmag_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> maxmag(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return maxmag_fixed(x,y);
  }
  template<int I>
  ap_int<I> maxmag(ap_int<I> x, ap_int<I> y){
    return maxmag_fixed(x,y);
  }
  template<int I>
  ap_uint<I> maxmag(ap_uint<I> x, ap_uint<I> y){
    return maxmag_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> minmag(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return minmag_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> minmag(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return minmag_fixed(x,y);
  }
  template<int I>
  ap_int<I> minmag(ap_int<I> x, ap_int<I> y){
    return minmag_fixed(x,y);
  }
  template<int I>
  ap_uint<I> minmag(ap_uint<I> x, ap_uint<I> y){
    return minmag_fixed(x,y);
  }



  template<int W, int I>
  ap_fixed<W,I> sinh(ap_fixed<W,I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> sinh(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int I>
  ap_int<I> sinh(ap_int<I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int I>
  ap_uint<I> sinh(ap_uint<I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> cosh(ap_fixed<W,I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> cosh(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int I>
  ap_int<I> cosh(ap_int<I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int I>
  ap_uint<I> cosh(ap_uint<I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> tanh(ap_fixed<W,I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> tanh(ap_ufixed<W,I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int I>
  ap_int<I> tanh(ap_int<I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int I>
  ap_uint<I> tanh(ap_uint<I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> atanh(ap_fixed<W,I> x){
    ap_fixed<W,I> one_plus_x = 1 + x;
    ap_fixed<W,I> one_minus_x = 1 - x;
    ap_fixed<W,I> input = one_plus_x / one_minus_x ;
    ap_fixed<W,I> result = log_apfixed_reduce::log(input);
    result >>= 1;
    return result;
  }


  template<int W, int I>
  ap_ufixed<W,I> atanh(ap_ufixed<W,I> x){
  ap_fixed<W+1,I+1> input = x;
    ap_fixed<W+1,I+1> result = hls::atanh(input);
    return result;
  }


  template<int I>
  ap_int<I> atanh(ap_int<I> x){
    ap_fixed<I,I> input = x;
    ap_fixed<I,I> result = hls::atanh(input);
    return result;
  }


  template<int I>
  ap_uint<I> atanh(ap_uint<I> x){
    ap_fixed<I+1,I+1> input = x;
    ap_fixed<I+1,I+1> result = hls::atanh(input);
    return result;
  }


  template<int W, int I>
  ap_fixed<W,I> asinh(ap_fixed<W,I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> asinh(ap_ufixed<W,I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int I>
  ap_int<I> asinh(ap_int<I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int I>
  ap_uint<I> asinh(ap_uint<I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> acosh(ap_fixed<W,I> x){
    return cordic_apfixed::generic_acosh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> acosh(ap_ufixed<W,I> x){
    return cordic_apfixed::generic_acosh(x);
  }


  template<int I>
  ap_int<I> acosh(ap_int<I> x){
    return cordic_apfixed::generic_acosh(x);
  }


  template<int I>
  ap_uint<I> acosh(ap_uint<I> x){
    return cordic_apfixed::generic_acosh(x);
  }

  int8_t sinh(int8_t);
  uint8_t sinh(uint8_t);
  int16_t sinh(int16_t);
  uint16_t sinh(uint16_t);
  int32_t sinh(int32_t);
  uint32_t sinh(uint32_t);

  int8_t cosh(int8_t);
  uint8_t cosh(uint8_t);
  int16_t cosh(int16_t);
  uint16_t cosh(uint16_t);
  int32_t cosh(int32_t);
  uint32_t cosh(uint32_t);

  int8_t tanh(int8_t);
  uint8_t tanh(uint8_t);
  int16_t tanh(int16_t);
  uint16_t tanh(uint16_t);
  int32_t tanh(int32_t);
  uint32_t tanh(uint32_t);

  int8_t atanh(int8_t);
  uint8_t atanh(uint8_t);
  int16_t atanh(int16_t);
  uint16_t atanh(uint16_t);
  int32_t atanh(int32_t);
  uint32_t atanh(uint32_t);

  int8_t asinh(int8_t);
  uint8_t asinh(uint8_t);
  int16_t asinh(int16_t);
  uint16_t asinh(uint16_t);
  int32_t asinh(int32_t);
  uint32_t asinh(uint32_t);

  int8_t acosh(int8_t);
  uint8_t acosh(uint8_t);
  int16_t acosh(int16_t);
  uint16_t acosh(uint16_t);
  int32_t acosh(int32_t);
  uint32_t acosh(uint32_t);


  template<int W, int I>
  ap_fixed<W-I+3,3> asin(ap_fixed<W,I> x){
 return cordic_apfixed::generic_asin(x);
  }


  template<int W, int I>
  ap_fixed<W-I+3,3> acos(ap_fixed<W,I> x){
 return cordic_apfixed::generic_acos(x);
  }


  template<int W, int I>
  ap_fixed<W,2> atan(ap_fixed<W,I> x){
 return cordic_apfixed::generic_atan(x);
  }


  template<int W, int I>
  ap_ufixed<W,2> atan(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_atan(x);
  }


  template<int I>
  ap_int<2> atan(ap_int<I> x){
   return cordic_apfixed::generic_atan(x);
  }


  template<int I>
  ap_uint<1> atan(ap_uint<I> x){
   return cordic_apfixed::generic_atan(x);
  }

  int8_t asin(int8_t);
  uint8_t asin(uint8_t);
  int16_t asin(int16_t);
  uint16_t asin(uint16_t);
  int32_t asin(int32_t);
  uint32_t asin(uint32_t);

  int8_t acos(int8_t);
  uint8_t acos(uint8_t);
  int16_t acos(int16_t);
  uint16_t acos(uint16_t);
  int32_t acos(int32_t);
  uint32_t acos(uint32_t);

  int8_t atan(int8_t);
  uint8_t atan(uint8_t);
  int16_t atan(int16_t);
  uint16_t atan(uint16_t);
  int32_t atan(int32_t);
  uint32_t atan(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> asinpi(ap_fixed<W,I> x){
      return cordic_apfixed::generic_asinpi(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> asinpi(ap_ufixed<W,I> x){
      return cordic_apfixed::generic_asinpi(x);
  }

  template<int I>
  ap_int<I> asinpi(ap_int<I> x){
     return cordic_apfixed::generic_asinpi(x);
  }

  template<int I>
  ap_uint<I> asinpi(ap_uint<I> x){
     return cordic_apfixed::generic_asinpi(x);
  }


  int8_t asinpi(int8_t);
  uint8_t asinpi(uint8_t);
  int16_t asinpi(int16_t);
  uint16_t asinpi(uint16_t);
  int32_t asinpi(int32_t);
  uint32_t asinpi(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> acospi(ap_fixed<W,I> x){
      return cordic_apfixed::generic_acospi(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> acospi(ap_ufixed<W,I> x){
      return cordic_apfixed::generic_acospi(x);
  }

  template<int I>
  ap_int<I> acospi(ap_int<I> x){
     return cordic_apfixed::generic_acospi(x);
  }

  template<int I>
  ap_uint<I> acospi(ap_uint<I> x){
     return cordic_apfixed::generic_acospi(x);
  }

  int8_t acospi(int8_t);
  uint8_t acospi(uint8_t);
  int16_t acospi(int16_t);
  uint16_t acospi(uint16_t);
  int32_t acospi(int32_t);
  uint32_t acospi(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> atanpi(ap_fixed<W,I> x){
 return cordic_apfixed::generic_atanpi(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> atanpi(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_atanpi(x);
  }


  template<int I>
  ap_int<2> atanpi(ap_int<I> x){
   return cordic_apfixed::generic_atanpi(x);
  }


  template<int I>
  ap_uint<1> atanpi(ap_uint<I> x){
   return cordic_apfixed::generic_atanpi(x);
  }

  int8_t atanpi(int8_t);
  uint8_t atanpi(uint8_t);
  int16_t atanpi(int16_t);
  uint16_t atanpi(uint16_t);
  int32_t atanpi(int32_t);
  uint32_t atanpi(uint32_t);


  template<int W, int I>
  ap_fixed<W,3> atan2(ap_fixed<W,I> x, ap_fixed<W,I> y){
 return cordic_apfixed::generic_atan2(x,y);
  }


  template<int W, int I>
  ap_ufixed<W,3> atan2(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
 return cordic_apfixed::generic_atan2(x,y);
  }


  template<int I>
  ap_int<3> atan2(ap_int<I> x, ap_int<I> y){
   return cordic_apfixed::generic_atan2(x,y);
  }


  template<int I>
  ap_uint<2> atan2(ap_uint<I> x, ap_uint<I> y){
   return cordic_apfixed::generic_atan2(x,y);
  }

  int8_t atan2(int8_t, int8_t);
  uint8_t atan2(uint8_t, uint8_t);
  int16_t atan2(int16_t, int16_t);
  uint16_t atan2(uint16_t, uint16_t);
  int32_t atan2(int32_t, int32_t);
  uint32_t atan2(uint32_t, uint32_t);


  template<int W, int I>
  ap_fixed<W,I> atan2pi(ap_fixed<W,I> x, ap_fixed<W,I> y){
 return cordic_apfixed::generic_atan2pi(x,y);
  }


  template<int W, int I>
  ap_ufixed<W,I> atan2pi(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
 return cordic_apfixed::generic_atan2pi(x,y);
  }


  template<int I>
  ap_int<I> atan2pi(ap_int<I> x, ap_int<I> y){
   return cordic_apfixed::generic_atan2pi(x,y);
  }


  template<int I>
  ap_uint<I> atan2pi(ap_uint<I> x, ap_uint<I> y){
   return cordic_apfixed::generic_atan2pi(x,y);
  }

  int8_t atan2pi(int8_t, int8_t);
  uint8_t atan2pi(uint8_t, uint8_t);
  int16_t atan2pi(int16_t, int16_t);
  uint16_t atan2pi(uint16_t, uint16_t);
  int32_t atan2pi(int32_t, int32_t);
  uint32_t atan2pi(uint32_t, uint32_t);
  template<int W, int I>
  void sincos(ap_fixed<W,I> in,
       ap_fixed<W-I+2,2>* outsin, ap_fixed<W-I+2,2>* outcos){
   cordic_apfixed::generic_sincos(in, *outsin, *outcos);
  }

  template<int W, int I>
  ap_fixed<W-I+2,2> sin(ap_fixed<W,I> x){
        ap_fixed<W-I+2,2> outsin;
        ap_fixed<W-I+2,2> outcos;
        cordic_apfixed::generic_sincos(x, outsin, outcos);
        return outsin;
  }

  template<int W, int I>
  ap_ufixed<W-I+2,2> sin(ap_ufixed<W,I> x){
  ap_fixed<W+1, I+1> xin = x;
  ap_fixed<W-I+3, 3> xout = hls::sin(x);
  ap_fixed<W-I+2, 2> out = 0;
  if(xout[W-I+2]==0){
   out=xout;
  }
  return out;
  }

  template<int W, int I>
  ap_fixed<W-I+2,2> cos(ap_fixed<W,I> x){
        ap_fixed<W-I+2,2> outsin;
        ap_fixed<W-I+2,2> outcos;
        cordic_apfixed::generic_sincos(x, outsin, outcos);
        return outcos;
  }

  template<int W, int I>
  ap_ufixed<W-I+2,2> cos(ap_ufixed<W,I> x){
  ap_fixed<W+1, I+1> xin = x;
  ap_fixed<W-I+3, 3> xout = hls::cos(x);
  ap_fixed<W-I+2, 2> out = 0;
  if(xout[W-I+2]==0){
   out=xout;
  }
  return out;
  }
# 1935 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_math.h"
  template<int I>
  ap_int<I> sin(ap_int<I> in) {
 return ap_int<I>(0);
  };
  template<int I>
  ap_int<I> cos(ap_int<I> in) {
 return ap_int<I>(0);
  };


  template<int I>
  ap_uint<I> sin(ap_uint<I> in) {
 return ap_uint<I>(0);
  };
  template<int I>
  ap_uint<I> cos(ap_uint<I> in) {
 return ap_uint<I>(0);
  };

  void sincos(int8_t, int8_t*, int8_t*);
  void sincos(uint8_t, uint8_t*, uint8_t*);
  void sincos(int16_t, int16_t*, int16_t*);
  void sincos(uint16_t, uint16_t*, uint16_t*);
  void sincos(int32_t, int32_t*, int32_t*);
  void sincos(uint32_t, uint32_t*, uint32_t*);

  int8_t sin(int8_t);
  uint8_t sin(uint8_t);
  int16_t sin(int16_t);
  uint16_t sin(uint16_t);
  int32_t sin(int32_t);
  uint32_t sin(uint32_t);

  int8_t cos(int8_t);
  uint8_t cos(uint8_t);
  int16_t cos(int16_t);
  uint16_t cos(uint16_t);
  int32_t cos(int32_t);
  uint32_t cos(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> tan(ap_fixed<W,I> x){
 return cordic_apfixed::generic_tan(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> tan(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_tan(x);
  }
  template<int I>
  ap_int<I> tan(ap_int<I> x){
   return cordic_apfixed::generic_tan(x);
  }
  template<int I>
  ap_uint<I> tan(ap_uint<I> x){
   return cordic_apfixed::generic_tan(x);
  }

  int8_t tan(int8_t);
  uint8_t tan(uint8_t);
  int16_t tan(int16_t);
  uint16_t tan(uint16_t);
  int32_t tan(int32_t);
  uint32_t tan(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> tanpi(ap_fixed<W,I> x){
 return cordic_apfixed::generic_tanpi(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> tanpi(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_tanpi(x);
  }
  template<int I>
  ap_int<I> tanpi(ap_int<I> x){
   return cordic_apfixed::generic_tanpi(x);
  }
  template<int I>
  ap_uint<I> tanpi(ap_uint<I> x){
   return cordic_apfixed::generic_tanpi(x);
  }

  int8_t tanpi(int8_t);
  uint8_t tanpi(uint8_t);
  int16_t tanpi(int16_t);
  uint16_t tanpi(uint16_t);
  int32_t tanpi(int32_t);
  uint32_t tanpi(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> pow(ap_fixed<W,I> x, ap_fixed<W,I> y) {
    return pow_apfixed_reduce::pow(x,y);
  }

  template<int W, int I>
  ap_ufixed<W,I> pow(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return pow_apfixed_reduce::pow(x,y);
  }
  template<int I>
  ap_int<I> pow(ap_int<I> x, ap_int<I> y){
    return pow_apfixed_reduce::pow(x,y);
  }
  template<int I>
  ap_uint<I> pow(ap_uint<I> x,ap_uint<I> y){
    return pow_apfixed_reduce::pow(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> pown(ap_fixed<W,I> x, int n) {
    return pow_apfixed_reduce::pown(x,n);
  }

  template<int W, int I>
  ap_ufixed<W,I> pown(ap_ufixed<W,I> x, int n){
    return pow_apfixed_reduce::pown(x,n);
  }
  template<int I>
  ap_int<I> pown(ap_int<I> x, int n){
    return pow_apfixed_reduce::pown(x,n);
  }
  template<int I>
  ap_uint<I> pown(ap_uint<I> x, int n){
    return pow_apfixed_reduce::pown(x,n);
  }
  int8_t pown(int8_t, int n);
  uint8_t pown(uint8_t, int n);
  int16_t pown(int16_t, int n);
  uint16_t pown(uint16_t, int n);
  int32_t pown(int32_t, int n);
  uint32_t pown(uint32_t, int n);

  template<int W, int I>
  ap_fixed<W,I> rootn(ap_fixed<W,I> x, int n) {
    return pow_apfixed_reduce::rootn(x,n);
  }

  template<int W, int I>
  ap_ufixed<W,I> rootn(ap_ufixed<W,I> x, int n){
    return pow_apfixed_reduce::rootn(x,n);
  }
  template<int I>
  ap_int<I> rootn(ap_int<I> x, int n){
    return pow_apfixed_reduce::rootn(x,n);
  }
  template<int I>
  ap_uint<I> rootn(ap_uint<I> x, int n){
    return pow_apfixed_reduce::rootn(x,n);
  }
  int8_t rootn(int8_t, int n);
  uint8_t rootn(uint8_t, int n);
  int16_t rootn(int16_t, int n);
  uint16_t rootn(uint16_t, int n);
  int32_t rootn(int32_t, int n);
  uint32_t rootn(uint32_t, int n);

  template<int W, int I>
  ap_fixed<W,I> powr(ap_fixed<W,I> x, ap_fixed<W,I> y) {
    return pow_apfixed_reduce::powr(x,y);
  }

  template<int W, int I>
  ap_ufixed<W,I> powr(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return pow_apfixed_reduce::powr(x,y);
  }
  template<int I>
  ap_int<I> powr(ap_int<I> x, ap_int<I> y){
    return pow_apfixed_reduce::powr(x,y);
  }
  template<int I>
  ap_uint<I> powr(ap_uint<I> x,ap_uint<I> y){
    return pow_apfixed_reduce::powr(x,y);
  }



  template<int W, int I>
  ap_fixed<W,I> round(ap_fixed<W,I> x){
    return round_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> round(ap_ufixed<W,I> x){
    return round_fixed(x);
  }
  template<int I>
  ap_int<I> round(ap_int<I> x){
    return round_fixed(x);
  }
  template<int I>
  ap_uint<I> round(ap_uint<I> x){
    return round_fixed(x);
  }
  int8_t round(int8_t);
  uint8_t round(uint8_t);
  int16_t round(int16_t);
  uint16_t round(uint16_t);
  int32_t round(int32_t);
  uint32_t round(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> rint(ap_fixed<W,I> x){
    return rint_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> rint(ap_ufixed<W,I> x){
    return rint_fixed(x);
  }
  template<int I>
  ap_int<I> rint(ap_int<I> x){
    return rint_fixed(x);
  }
  template<int I>
  ap_uint<I> rint(ap_uint<I> x){
    return rint_fixed(x);
  }
  int8_t rint(int8_t);
  uint8_t rint(uint8_t);
  int16_t rint(int16_t);
  uint16_t rint(uint16_t);
  int32_t rint(int32_t);
  uint32_t rint(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> nearbyint(ap_fixed<W,I> x){
    return nearbyint_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> nearbyint(ap_ufixed<W,I> x){
    return nearbyint_fixed(x);
  }
  template<int I>
  ap_int<I> nearbyint(ap_int<I> x){
    return nearbyint_fixed(x);
  }
  template<int I>
  ap_uint<I> nearbyint(ap_uint<I> x){
    return nearbyint_fixed(x);
  }
  int8_t nearbyint(int8_t);
  uint8_t nearbyint(uint8_t);
  int16_t nearbyint(int16_t);
  uint16_t nearbyint(uint16_t);
  int32_t nearbyint(int32_t);
  uint32_t nearbyint(uint32_t);


  template<int W, int I>
  long long int llround(ap_fixed<W,I> x){
    return llround_fixed(x);
  }
  template<int W, int I>
  long long int llround(ap_ufixed<W,I> x){
    return llround_fixed(x);
  }
  template<int I>
  long long int llround(ap_int<I> x){
    return llround_fixed(x);
  }
  template<int I>
  long long int llround(ap_uint<I> x){
    return llround_fixed(x);
  }


  long long int llround(int8_t);
  long long int llround(uint8_t);
  long long int llround(int16_t);
  long long int llround(uint16_t);
  long long int llround(int32_t);
  long long int llround(uint32_t);


  template<int W, int I>
  long int lround(ap_fixed<W,I> x){
    return lround_fixed(x);
  }
  template<int W, int I>
  long int lround(ap_ufixed<W,I> x){
    return lround_fixed(x);
  }
  template<int I>
  long int lround(ap_int<I> x){
    return lround_fixed(x);
  }
  template<int I>
  long int lround(ap_uint<I> x){
    return lround_fixed(x);
  }


  long int lround(int8_t);
  long int lround(uint8_t);
  long int lround(int16_t);
  long int lround(uint16_t);
  long int lround(int32_t);
  long int lround(uint32_t);


  template<int W, int I>
  long long int llrint(ap_fixed<W,I> x){
    return llrint_fixed(x);
  }
  template<int W, int I>
  long long int llrint(ap_ufixed<W,I> x){
    return llrint_fixed(x);
  }
  template<int I>
  long long int llrint(ap_int<I> x){
    return llrint_fixed(x);
  }
  template<int I>
  long long int llrint(ap_uint<I> x){
    return llrint_fixed(x);
  }


  long long int llrint(int8_t);
  long long int llrint(uint8_t);
  long long int llrint(int16_t);
  long long int llrint(uint16_t);
  long long int llrint(int32_t);
  long long int llrint(uint32_t);


  template<int W, int I>
  long int lrint(ap_fixed<W,I> x){
    return lrint_fixed(x);
  }
  template<int W, int I>
  long int lrint(ap_ufixed<W,I> x){
    return lrint_fixed(x);
  }
  template<int I>
  long int lrint(ap_int<I> x){
    return lrint_fixed(x);
  }
  template<int I>
  long int lrint(ap_uint<I> x){
    return lrint_fixed(x);
  }


  long int lrint(int8_t);
  long int lrint(uint8_t);
  long int lrint(int16_t);
  long int lrint(uint16_t);
  long int lrint(int32_t);
  long int lrint(uint32_t);


  template<int W, int I>
  bool isgreater(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return isgreater_fixed(x1, x2);
  }
  template<int W, int I>
  bool isgreater(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return isgreater_fixed(x1, x2);
  }
  template<int I>
  bool isgreater(ap_int<I> x1, ap_int<I> x2){
    return isgreater_fixed(x1, x2);
  }
  template<int I>
  bool isgreater(ap_uint<I> x1, ap_uint<I> x2){
    return isgreater_fixed(x1, x2);
  }
  bool isgreater(int8_t, int8_t);
  bool isgreater(uint8_t, uint8_t);
  bool isgreater(int16_t, int16_t);
  bool isgreater(uint16_t, uint16_t);
  bool isgreater(int32_t, int32_t);
  bool isgreater(uint32_t, uint32_t);


  template<int W, int I>
  bool isgreaterequal(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return isgreaterequal_fixed(x1, x2);
  }
  template<int W, int I>
  bool isgreaterequal(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return isgreaterequal_fixed(x1, x2);
  }
  template<int I>
  bool isgreaterequal(ap_int<I> x1, ap_int<I> x2){
    return isgreaterequal_int(x1, x2);
  }
  template<int I>
  bool isgreaterequal(ap_uint<I> x1, ap_uint<I> x2){
    return isgreaterequal_fixed(x1, x2);
  }
  bool isgreaterequal(int8_t, int8_t);
  bool isgreaterequal(uint8_t, uint8_t);
  bool isgreaterequal(int16_t, int16_t);
  bool isgreaterequal(uint16_t, uint16_t);
  bool isgreaterequal(int32_t, int32_t);
  bool isgreaterequal(uint32_t, uint32_t);


  template<int W, int I>
  bool isless(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return isless_fixed(x1, x2);
  }
  template<int W, int I>
  bool isless(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return isless_fixed(x1, x2);
  }
  template<int I>
  bool isless(ap_int<I> x1, ap_int<I> x2){
    return isless_fixed(x1, x2);
  }
  template<int I>
  bool isless(ap_uint<I> x1, ap_uint<I> x2){
    return isless_fixed(x1, x2);
  }
  bool isless(int8_t, int8_t);
  bool isless(uint8_t, uint8_t);
  bool isless(int16_t, int16_t);
  bool isless(uint16_t, uint16_t);
  bool isless(int32_t, int32_t);
  bool isless(uint32_t, uint32_t);


  template<int W, int I>
  bool islessequal(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return islessequal_fixed(x1, x2);
  }
  template<int W, int I>
  bool islessequal(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return islessequal_fixed(x1, x2);
  }
  template<int I>
  bool islessequal(ap_int<I> x1, ap_int<I> x2){
    return islessequal_fixed(x1, x2);
  }
  template<int I>
  bool islessequal(ap_uint<I> x1, ap_uint<I> x2){
    return islessequal_fixed(x1, x2);
  }
  bool islessequal(int8_t, int8_t);
  bool islessequal(uint8_t, uint8_t);
  bool islessequal(int16_t, int16_t);
  bool islessequal(uint16_t, uint16_t);
  bool islessequal(int32_t, int32_t);
  bool islessequal(uint32_t, uint32_t);


  template<int W, int I>
  bool islessgreater(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return islessgreater_fixed(x1, x2);
  }
  template<int W, int I>
  bool islessgreater(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return islessgreater_fixed(x1, x2);
  }
  template<int I>
  bool islessgreater(ap_int<I> x1, ap_int<I> x2){
    return islessgreater_fixed(x1, x2);
  }
  template<int I>
  bool islessgreater(ap_uint<I> x1, ap_uint<I> x2){
    return islessgreater_fixed(x1, x2);
  }

  bool islessgreater(int8_t, int8_t);
  bool islessgreater(uint8_t, uint8_t);
  bool islessgreater(int16_t, int16_t);
  bool islessgreater(uint16_t, uint16_t);
  bool islessgreater(int32_t, int32_t);
  bool islessgreater(uint32_t, uint32_t);

  int8_t frexp(int8_t,int8_t*);
  uint8_t frexp(uint8_t, uint8_t*);
  int16_t frexp(int16_t, int16_t*);
  uint16_t frexp(uint16_t, uint16_t*);
  int32_t frexp(int32_t, int32_t*);
  uint32_t frexp(uint32_t, uint32_t*);

  template<int W, int I>
  ap_fixed<W,I> frexp(ap_fixed<W,I> x, ap_fixed<W,I>* exp) {
    return frexp_internal::frexp(x,exp);
  }

  template<int W, int I>
  ap_ufixed<W,I> frexp(ap_ufixed<W,I> x, ap_ufixed<W,I>* exp){
    return frexp_internal::frexp(x,exp);
  }
  template<int I>
  ap_int<I> frexp(ap_int<I> x, ap_int<I>* exp){
    return frexp_internal::frexp(x,exp);
  }
  template<int I>
  ap_uint<I> frexp(ap_uint<I> x,ap_uint<I>* exp){
    return frexp_internal::frexp(x,exp);
  }

  int8_t modf(int8_t, int8_t*);
  uint8_t modf(uint8_t, uint8_t*);
  int16_t modf(int16_t, int16_t*);
  uint16_t modf(uint16_t, uint16_t*);
  int32_t modf(int32_t, int32_t*);
  uint32_t modf(uint32_t, uint32_t*);

  template<int W, int I>
  ap_fixed<W,I> modf(ap_fixed<W,I> x, ap_fixed<W,I>* intpart) {
    return modf_internal::modf(x,intpart);
  }

  template<int W, int I>
  ap_ufixed<W,I> modf(ap_ufixed<W,I> x, ap_ufixed<W,I>* intpart){
    return modf_internal::modf(x,exp);
  }
  template<int I>
  ap_int<I> modf(ap_int<I> x, ap_int<I>* intpart){
    return modf_internal::modf(x,intpart);
  }
  template<int I>
  ap_uint<I> modf(ap_uint<I> x,ap_uint<I>* intpart){
    return modf_internal::modf(x,intpart);
  }


  bool isequal(int8_t,int8_t);
  bool isequal(uint8_t,uint8_t);
  bool isequal(int16_t,int16_t);
  bool isequal(uint16_t,uint16_t);
  bool isequal(int32_t,int32_t);
  bool isequal(uint32_t,uint32_t);

  bool isnotequal(int8_t,int8_t);
  bool isnotequal(uint8_t,uint8_t);
  bool isnotequal(int16_t,int16_t);
  bool isnotequal(uint16_t,uint16_t);
  bool isnotequal(int32_t,int32_t);
  bool isnotequal(uint32_t,uint32_t);

  template<int W,int I>
  bool isequal(ap_fixed<W,I> x,ap_fixed<W,I> y){
    return generic_isequal(x,y);
  };
  template<int W,int I>
  bool isequal(ap_ufixed<W,I> x,ap_ufixed<W,I> y){
    return generic_isequal(x,y);
  };
  template<int I>
  bool isequal(ap_int<I> x,ap_int<I> y){
    return generic_isequal(x,y);
  };
  template<int I>
  bool isequal(ap_uint<I> x,ap_uint<I> y){
    return generic_isequal(x,y);
  };

  template<int W,int I>
  bool isnotequal(ap_fixed<W,I> x,ap_fixed<W,I> y){
    return generic_isnotequal(x,y);
  };
  template<int W,int I>
  bool isnotequal(ap_ufixed<W,I> x,ap_ufixed<W,I> y){
    return generic_isnotequal(x,y);
  };
  template<int I>
  bool isnotequal(ap_int<I> x,ap_int<I> y){
    return generic_isnotequal(x,y);
  };
  template<int I>
  bool isnotequal(ap_uint<I> x,ap_uint<I> y){
    return generic_isnotequal(x,y);
  };

  template<int W,int I>
  bool any(ap_fixed<W,I> x){
    return generic_any(x);
  };
  template<int W,int I>
  bool any(ap_ufixed<W,I> x){
    return generic_any(x);
  };
  template<int I>
  bool any(ap_int<I> x){
    return generic_any(x);
  };
  template<int I>
  bool any(ap_uint<I> x){
    return generic_any(x);
  };

  template<int W,int I>
  bool all(ap_fixed<W,I> x){
    return generic_all(x);
  };
  template<int W,int I>
  bool all(ap_ufixed<W,I> x){
    return generic_all(x);
  };
  template<int I>
  bool all(ap_int<I> x){
    return generic_all(x);
  };
  template<int I>
  bool all(ap_uint<I> x){
    return generic_all(x);
  };

  template<int W,int I>
  ap_fixed<W,I> bitselect(ap_fixed<W,I> x,ap_fixed<W,I> y, ap_fixed<W,I> z){
    return generic_bitselect(x,y,z);
  };
  template<int W,int I>
  ap_ufixed<W,I> bitselect(ap_ufixed<W,I> x,ap_ufixed<W,I> y,ap_ufixed<W,I> z){
    return generic_bitselect(x,y,z);
  };
  template<int I>
  ap_int<I> bitselect(ap_int<I> x,ap_int<I> y,ap_int<I> z){
    return generic_bitselect(x,y,z);
  };
  template<int I>
  ap_uint<I> bitselect(ap_uint<I> x,ap_uint<I> y,ap_uint<I> z){
    return generic_bitselect(x,y,z);
  };

  template<int W, int I>
  ap_fixed<W,I> erf(ap_fixed<W,I> x){
    return erf_erfc_fixed::erf(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> erf(ap_ufixed<W,I> x){
    return erf_erfc_fixed::erf(x);
  }
  template<int I>
  ap_int<I> erf(ap_int<I> x){
    return erf_erfc_fixed::erf(x);
  }
  template<int I>
  ap_uint<I> erf(ap_uint<I> x){
    return erf_erfc_fixed::erf(x);
  }

  template<int W, int I>
  ap_fixed<W,I> erfc(ap_fixed<W,I> x){
    return erf_erfc_fixed::erfc(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> erfc(ap_ufixed<W,I> x){
    return erf_erfc_fixed::erfc(x);
  }
  template<int I>
  ap_int<I> erfc(ap_int<I> x){
    return erf_erfc_fixed::erfc(x);
  }
  template<int I>
  ap_uint<I> erfc(ap_uint<I> x){
    return erf_erfc_fixed::erfc(x);
  }

  int8_t divide(int8_t,int8_t);
  int16_t divide(int16_t,int16_t);
  int32_t divide(int32_t,int32_t);
  uint8_t divide(uint8_t,uint8_t);
  uint16_t divide(uint16_t,uint16_t);
  uint32_t divide(uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> divide(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return hls_internal::generic_divide(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> divide(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return hls_internal::generic_divide(x, y);
  }
  template<int I>
  ap_int<I> divide(ap_int<I> x, ap_int<I> y){
    return hls_internal::generic_divide(x, y);
  }
  template<int I>
  ap_uint<I> divide(ap_uint<I> x, ap_uint<I> y){
    return hls_internal::generic_divide(x, y);
  }

  int8_t fmod(int8_t,int8_t);
  int16_t fmod(int16_t,int16_t);
  int32_t fmod(int32_t,int32_t);
  uint8_t fmod(uint8_t,uint8_t);
  uint16_t fmod(uint16_t,uint16_t);
  uint32_t fmod(uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> fmod(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return hls_internal::generic_fmod(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fmod(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return hls_internal::generic_fmod(x, y);
  }
  template<int I>
  ap_int<I> fmod(ap_int<I> x, ap_int<I> y){
    return hls_internal::generic_fmod(x, y);
  }
  template<int I>
  ap_uint<I> fmod(ap_uint<I> x, ap_uint<I> y){
    return hls_internal::generic_fmod(x, y);
  }

  int8_t remainder(int8_t,int8_t);
  int16_t remainder(int16_t,int16_t);
  int32_t remainder(int32_t,int32_t);
  uint8_t remainder(uint8_t,uint8_t);
  uint16_t remainder(uint16_t,uint16_t);
  uint32_t remainder(uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> remainder(ap_fixed<W,I> x, ap_fixed<W, I> y){
    return hls_internal::generic_remainder(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> remainder(ap_ufixed<W,I> x, ap_ufixed<W, I> y){
    return hls_internal::generic_remainder(x, y);
  }
  template<int I>
  ap_int<I> remainder(ap_int<I> x, ap_int<I> y){
    return hls_internal::generic_remainder(x, y);
  }
  template<int I>
  ap_uint<I> remainder(ap_uint<I> x, ap_uint<I> y){
    return hls_internal::generic_remainder(x, y);
  }

  int8_t remquo(int8_t,int8_t,int*);
  int16_t remquo(int16_t,int16_t,int*);
  int32_t remquo(int32_t,int32_t,int*);
  uint8_t remquo(uint8_t,uint8_t,int*);
  uint16_t remquo(uint16_t,uint16_t,int*);
  uint32_t remquo(uint32_t,uint32_t,int*);

  template<int W, int I>
  ap_fixed<W,I> remquo(ap_fixed<W,I> x, ap_fixed<W,I> y, int* quo){
    return hls_internal::generic_remquo(x, y, quo);
  }
  template<int W, int I>
  ap_ufixed<W,I> remquo(ap_ufixed<W,I> x, ap_ufixed<W, I> y, int* quo){
    return hls_internal::generic_remquo(x, y, quo);
  }
  template<int I>
  ap_int<I> remquo(ap_int<I> x, ap_int<I> y, int* quo){
    return hls_internal::generic_remquo(x, y, quo);
  }
  template<int I>
  ap_uint<I> remquo(ap_uint<I> x, ap_uint<I> y, int* quo){
    return hls_internal::generic_remquo(x, y, quo);
  }

  template<int W, int I>
  bool signbit(ap_fixed<W, I> x) {
    return signbit_fixed(x);
  }
  template<int W, int I>
  bool signbit(ap_ufixed<W, I> x) {
    return signbit_fixed(x);
  }
  template<int I>
  bool signbit(ap_int<I> x) {
    return signbit_fixed(x);
  }
  template<int I>
  bool signbit(ap_uint<I> x) {
    return signbit_fixed(x);
  }
  bool signbit(int8_t);
  bool signbit(uint8_t);
  bool signbit(int16_t);
  bool signbit(uint16_t);
  bool signbit(int32_t);
  bool signbit(uint32_t);


  int8_t mad(int8_t,int8_t,int8_t);
  int16_t mad(int16_t,int16_t,int16_t);
  int32_t mad(int32_t,int32_t,int32_t);
  uint8_t mad(uint8_t,uint8_t,uint8_t);
  uint16_t mad(uint16_t,uint16_t,uint16_t);
  uint32_t mad(uint32_t,uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> mad(ap_fixed<W,I> x,ap_fixed<W,I> y,ap_fixed<W,I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int W, int I>
  ap_ufixed<W,I> mad(ap_ufixed<W,I> x,ap_ufixed<W,I> y,ap_ufixed<W,I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int I>
  ap_int<I> mad(ap_int<I> x,ap_int<I> y,ap_int<I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int I>
  ap_uint<I> mad(ap_uint<I> x,ap_uint<I> y,ap_uint<I> z){
    return hls_mad::generic_mad(x,y,z);
  }

  int8_t fma(int8_t,int8_t,int8_t);
  int16_t fma(int16_t,int16_t,int16_t);
  int32_t fma(int32_t,int32_t,int32_t);
  uint8_t fma(uint8_t,uint8_t,uint8_t);
  uint16_t fma(uint16_t,uint16_t,uint16_t);
  uint32_t fma(uint32_t,uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> fma(ap_fixed<W,I> x,ap_fixed<W,I> y,ap_fixed<W,I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int W, int I>
  ap_ufixed<W,I> fma(ap_ufixed<W,I> x,ap_ufixed<W,I> y,ap_ufixed<W,I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int I>
  ap_int<I> fma(ap_int<I> x,ap_int<I> y,ap_int<I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int I>
  ap_uint<I> fma(ap_uint<I> x,ap_uint<I> y,ap_uint<I> z){
    return hls_mad::generic_mad(x,y,z);
  }

  int8_t fract(int8_t);
  int16_t fract(int16_t);
  int32_t fract(int32_t);
  uint8_t fract(uint8_t);
  uint16_t fract(uint16_t);
  uint32_t fract(uint32_t);

  template<int W, int I>
  ap_fixed<W,I> fract(ap_fixed<W,I> x){
    return hls_fract::generic_fract(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> fract(ap_ufixed<W,I> x){
    return hls_fract::generic_fract(x);
  }
  template<int I>
  ap_int<I> fract(ap_int<I> x){
    return hls_fract::generic_fract(x);
  }
  template<int I>
  ap_uint<I> fract(ap_uint<I> x){
    return hls_fract::generic_fract(x);
  }

  template<int W, int I>
  ap_fixed<W,I> cbrt(ap_fixed<W,I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> cbrt(ap_ufixed<W,I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  template<int I>
  ap_int<I> cbrt(ap_int<I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  template<int I>
  ap_uint<I> cbrt(ap_uint<I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  int8_t cbrt(int8_t);
  uint8_t cbrt(uint8_t);
  int16_t cbrt(int16_t);
  uint16_t cbrt(uint16_t);
  int32_t cbrt(int32_t);
  uint32_t cbrt(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> nextafter(ap_fixed<W, I> x, ap_fixed<W, I> y) {
    return fp_internal::nextafter(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> nextafter(ap_ufixed<W, I> x, ap_ufixed<W, I> y) {
    return fp_internal::nextafter(x, y);
  }
  template<int I>
  ap_int<I> nextafter(ap_int<I> x, ap_int<I> y) {
    return fp_internal::nextafter(x, y);
  }
  template<int I>
  ap_uint<I> nextafter(ap_uint<I> x, ap_uint<I> y) {
    return fp_internal::nextafter(x, y);
  }
  int8_t nextafter(int8_t, int8_t);
  uint8_t nextafter(uint8_t, uint8_t);
  int16_t nextafter(int16_t, int16_t);
  uint16_t nextafter(uint16_t, uint16_t);
  int32_t nextafter(int32_t, int32_t);
  uint32_t nextafter(uint32_t, uint32_t);


  template<int W, int I>
  ap_fixed<W,I> nexttoward(ap_fixed<W, I> x, ap_fixed<W, I> y) {
    return fp_internal::nexttoward(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> nexttoward(ap_ufixed<W, I> x, ap_ufixed<W, I> y) {
    return fp_internal::nexttoward(x, y);
  }
  template<int I>
  ap_int<I> nexttoward(ap_int<I> x, ap_int<I> y) {
    return fp_internal::nexttoward(x, y);
  }
  template<int I>
  ap_uint<I> nexttoward(ap_uint<I> x, ap_uint<I> y) {
    return fp_internal::nexttoward(x, y);
  }
  int8_t nexttoward(int8_t, int8_t);
  uint8_t nexttoward(uint8_t, uint8_t);
  int16_t nexttoward(int16_t, int16_t);
  uint16_t nexttoward(uint16_t, uint16_t);
  int32_t nexttoward(int32_t, int32_t);
  uint32_t nexttoward(uint32_t, uint32_t);


  template<int W, int I>
  ap_fixed<W,I> hypot(ap_fixed<W,I> x, ap_fixed<W,I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> hypot(ap_ufixed<W,I> x, ap_ufixed<W,I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  template<int I>
  ap_int<I> hypot(ap_int<I> x, ap_int<I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  template<int I>
  ap_uint<I> hypot(ap_uint<I> x, ap_uint<I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  int8_t hypot(int8_t, int8_t);
  uint8_t hypot(uint8_t, uint8_t);
  int16_t hypot(int16_t, int16_t);
  uint16_t hypot(uint16_t, uint16_t);
  int32_t hypot(int32_t, int32_t);
  uint32_t hypot(uint32_t, uint32_t);

  template<int W, int I>
  ap_fixed<W,I> exp2(ap_fixed<W,I> x) {
    return exp_reduce::exp2(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> exp2(ap_ufixed<W,I> x) {
    return exp_reduce::exp2(x);
  }

  template<int I>
  ap_int<I> exp2(ap_int<I> x) {
    return exp_reduce::exp2(x);
  }

  template<int I>
  ap_uint<I> exp2(ap_uint<I> x) {
    return exp_reduce::exp2(x);
  }

  template<int W, int I>
  ap_fixed<W,I> exp10(ap_fixed<W,I> x) {
    return exp_reduce::exp10(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> exp10(ap_ufixed<W,I> x) {
    return exp_reduce::exp10(x);
  }

  template<int I>
  ap_int<I> exp10(ap_int<I> x) {
    return exp_reduce::exp10(x);
  }

  template<int I>
  ap_uint<I> exp10(ap_uint<I> x) {
    return exp_reduce::exp10(x);
  }

  template<int W, int I>
  ap_fixed<W,I> expm1(ap_fixed<W,I> x) {
    return exp_reduce::expm1(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> expm1(ap_ufixed<W,I> x) {
    return exp_reduce::expm1(x);
  }

  template<int I>
  ap_int<I> expm1(ap_int<I> x) {
    return exp_reduce::expm1(x);
  }

  template<int I>
  ap_uint<I> expm1(ap_uint<I> x) {
    return exp_reduce::expm1(x);
  }

  template<int W, int I>
  ap_fixed<W,I> log1p(ap_fixed<W,I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> log1p(ap_ufixed<W,I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int I>
  ap_int<I> log1p(ap_int<I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int I>
  ap_uint<I> log1p(ap_uint<I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int W, int I>
  ap_fixed<W,I> ilogb(ap_fixed<W,I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> ilogb(ap_ufixed<W,I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int I>
  ap_int<I> ilogb(ap_int<I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int I>
  ap_uint<I> ilogb(ap_uint<I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int W, int I>
  ap_fixed<W,I> ldexp(ap_fixed<W,I> x, int exp) {
    return hls_ldexp::ldexp(x, exp);
  }

  template<int W, int I>
  ap_ufixed<W,I> ldexp(ap_ufixed<W,I> x, int exp) {
    return hls_ldexp::ldexp(x, exp);
  }

  template<int I>
  ap_int<I> ldexp(ap_int<I> x, int exp) {
    return hls_ldexp::ldexp(x, exp);
  }

  template<int I>
  ap_uint<I> ldexp(ap_uint<I> x, int exp) {
    return hls_ldexp::ldexp(x, exp);
  }

  template<int W, int I>
  ap_fixed<W,I> scalbn(ap_fixed<W,I> x, int n) {
    return hls_ldexp::scalbn(x, n);
  }

  template<int W, int I>
  ap_ufixed<W,I> scalbn(ap_ufixed<W,I> x, int n) {
    return hls_ldexp::scalbn(x, n);
  }

  template<int I>
  ap_int<I> scalbn(ap_int<I> x, int n) {
    return hls_ldexp::scalbn(x, n);
  }

  template<int I>
  ap_uint<I> scalbn(ap_uint<I> x, int n) {
    return hls_ldexp::scalbn(x, n);
  }

  template<int W, int I>
  ap_fixed<W,I> scalbln(ap_fixed<W,I> x, long int n) {
    return hls_ldexp::scalbln(x, n);
  }

  template<int W, int I>
  ap_ufixed<W,I> scalbln(ap_ufixed<W,I> x, long int n) {
    return hls_ldexp::scalbln(x, n);
  }

  template<int I>
  ap_int<I> scalbln(ap_int<I> x, long int n) {
    return hls_ldexp::scalbln(x, n);
  }

  template<int I>
  ap_uint<I> scalbln(ap_uint<I> x, long int n) {
    return hls_ldexp::scalbln(x, n);
  }

    int8_t ldexp(int8_t x, int exp);
    int16_t ldexp(int16_t x, int exp);
    int32_t ldexp(int32_t x, int exp);
    uint8_t ldexp(uint8_t x, int exp);
    uint16_t ldexp(uint16_t x, int exp);
    uint32_t ldexp(uint32_t x, int exp);

    int8_t scalbn(int8_t x, int n);
    int16_t scalbn(int16_t x, int n);
    int32_t scalbn(int32_t x, int n);
    uint8_t scalbn(uint8_t x, int n);
    uint16_t scalbn(uint16_t x, int n);
    uint32_t scalbn(uint32_t x, int n);

    int8_t scalbln(int8_t x, int n);
    int16_t scalbln(int16_t x, int n);
    int32_t scalbln(int32_t x, int n);
    uint8_t scalbln(uint8_t x, int n);
    uint16_t scalbln(uint16_t x, int n);
    uint32_t scalbln(uint32_t x, int n);

    int8_t exp2(int8_t x);
    int16_t exp2(int16_t x);
    int32_t exp2(int32_t x);
    uint8_t exp2(uint8_t x);
    uint16_t exp2(uint16_t x);
    uint32_t exp2(uint32_t x);

    int8_t exp10(int8_t x);
    int16_t exp10(int16_t x);
    int32_t exp10(int32_t x);
    uint8_t exp10(uint8_t x);
    uint16_t exp10(uint16_t x);
    uint32_t exp10(uint32_t x);

    int8_t expm1(int8_t x);
    int16_t expm1(int16_t x);
    int32_t expm1(int32_t x);
    uint8_t expm1(uint8_t x);
    uint16_t expm1(uint16_t x);
    uint32_t expm1(uint32_t x);

    int8_t ilogb(int8_t x);
    int16_t ilogb(int16_t x);
    int32_t ilogb(int32_t x);
    uint8_t ilogb(uint8_t x);
    uint16_t ilogb(uint16_t x);
    uint32_t ilogb(uint32_t x);

    int8_t log1p(int8_t x);
    int16_t log1p(int16_t x);
    int32_t log1p(int32_t x);
    uint8_t log1p(uint8_t x);
    uint16_t log1p(uint16_t x);
    uint32_t log1p(uint32_t x);

    int8_t log2(int8_t);
    uint8_t log2(uint8_t);
    int16_t log2(int16_t);
    uint16_t log2(uint16_t);
    int32_t log2(int32_t);
    uint32_t log2(uint32_t);

    int8_t logb(int8_t);
    uint8_t logb(uint8_t);
    int16_t logb(int16_t);
    uint16_t logb(uint16_t);
    int32_t logb(int32_t);
    uint32_t logb(uint32_t);

};
# 50 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_video.h" 2





# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_types.h" 1
# 177 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_types.h"
template<int T> struct Type { typedef ap_int<T-12> name; static const int bitdepth = T-12; };
template<> struct Type<0> { typedef unsigned char name; static const int bitdepth = 8; };
template<> struct Type<1> { typedef char name; static const int bitdepth = 8; };
template<> struct Type<8> { typedef ap_uint<10> name; static const int bitdepth = 10; };
template<> struct Type<9> { typedef ap_int<10> name; static const int bitdepth = 10; };
template<> struct Type<10> { typedef ap_uint<12> name; static const int bitdepth = 12; };
template<> struct Type<11> { typedef ap_int<12> name; static const int bitdepth = 12; };
template<> struct Type<2> { typedef unsigned short name; static const int bitdepth = 16; };
template<> struct Type<3> { typedef short name; static const int bitdepth = 16; };
template<> struct Type<4> { typedef int name; static const int bitdepth = 32; };
template<> struct Type<5> { typedef float name; static const int bitdepth = 32; };
template<> struct Type<6> { typedef double name; static const int bitdepth = 64; };

template<typename PIXEL_T> struct pixel_op_type { typedef PIXEL_T T; };
template<> struct pixel_op_type<unsigned char> { typedef ap_uint<8> T; };
template<> struct pixel_op_type<char> { typedef ap_int<8> T; };
template<> struct pixel_op_type<unsigned short> { typedef ap_uint<16> T; };
template<> struct pixel_op_type<short> { typedef ap_int<16> T; };
template<> struct pixel_op_type<unsigned int> { typedef ap_uint<32> T; };
template<> struct pixel_op_type<int> { typedef ap_int<32> T; };
template<int W> struct pixel_op_type<ap_int<W> > { typedef ap_int<W> T; };
template<int W> struct pixel_op_type<ap_uint<W> > { typedef ap_uint<W> T; };
# 225 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_types.h"
template<typename T> struct Name
{ static const int _min = -2147483647; static const int _max = 2147483647; };
template<> struct Name<unsigned char>
{ static const int _min = 0; static const int _max = 255; };
template<> struct Name<char>
{ static const int _min = -127; static const int _max = 127; };
template<> struct Name<unsigned short>
{ static const int _min = 0; static const int _max = 65535; };
template<> struct Name<short>
{ static const int _min = -32767; static const int _max = 32767; };
template<> struct Name<int>
{ static const int _min = -2147483647; static const int _max = 2147483647; };

template<typename T>
unsigned char Convert2uchar(T v)
{
    unsigned char result=0;
    if(v>=255)
    {
        result=255;
    }
    else if(v>=0&&v<255)
    {
        ap_fixed<9,9,AP_RND> temp=v;
        result=temp;
    }
    return result;
}
template<typename T>
char Convert2char(T v)
{
    char result=-127;
    if(v>=127)
    {
        result=127;
    }
    else if(v>=-127&&v<127)
    {
        ap_fixed<9,9,AP_RND> temp=v;
        result=temp;
    }
    return result;
}
template<typename T>
unsigned short Convert2ushort(T v)
{
    unsigned short result=0;
    if(v>=65535)
    {
        result=65535;
    }
    else if(v>=0&&v<65535)
    {
        ap_fixed<17,17,AP_RND> temp=v;
        result=temp;
    }
    return result;
}
template<typename T>
short Convert2short(T v)
{
    short result=-32767;
    if(v>=32767)
    {
        result=32767;
    }
    else if(v>=-32767&&v<32767)
    {
        ap_fixed<17,17,AP_RND> temp=v;
        result=temp;
    }
    return result;
}
template<typename T>
int Convert2int(T v)
{
    int result=-2147483647;
    if(v>=2147483647)
    {
        result=2147483647;
    }
    else if(v>=-2147483647&&v<2147483647)
    {
        ap_fixed<32,32,AP_RND> temp=v;
        result=temp;
    }
    return result;
}

typedef ap_uint<32> HLS_SIZE_T;
typedef ap_uint<5> HLS_CHANNEL_T;

namespace hls {



template<typename T2> class sr_cast_class { };

template<> class sr_cast_class<float> {
public:
    template<typename T1>
    inline float operator()(T1 v) { return v; }
    inline float operator()(double v) { return ((float)(v)); }
};

template<> class sr_cast_class<double> {
public:
    template<typename T1>
    inline double operator()(T1 v) { return v; }
    inline double operator()(float v) { return ((double)(v)); }
};

template<int N2> class sr_cast_class<ap_int<N2> > {
public:
    template<int N1>
    inline ap_int<N2> operator()(ap_int<N1> v) {
        return ap_fixed<N2,N2,AP_TRN,AP_SAT>(v);
    }
    template<int N1>
    inline ap_int<N2> operator()(ap_uint<N1> v) {
        return ap_fixed<N2,N2,AP_TRN,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
    inline ap_int<N2> operator()(ap_fixed<W,I, _AP_Q, _AP_O> v) {
        return ap_fixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
    inline ap_int<N2> operator()(ap_ufixed<W,I, _AP_Q, _AP_O> v) {
        return ap_fixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int N>
    inline ap_int<N2> operator()(ap_fixed_base<W,I, true, _AP_Q, _AP_O, N> v) {
        return ap_fixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int N>
    inline ap_int<N2> operator()(ap_fixed_base<W,I, false,_AP_Q, _AP_O, N> v) {
        return ap_fixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    inline ap_int<N2> operator()(float v) {
        if(::hls::__isnan(v)) return 0;
        else return ap_fixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    inline ap_int<N2> operator()(double v) {
        if(::hls::__isnan(v)) return 0;
        else return ap_fixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    inline ap_int<N2> operator()(unsigned char v) {
        return operator()(ap_uint<8>(v));
    }
    inline ap_int<N2> operator()(char v) {
        return operator()(ap_int<8>(v));
    }
    inline ap_int<N2> operator()(unsigned short v) {
        return operator()(ap_uint<16>(v));
    }
    inline ap_int<N2> operator()(short v) {
        return operator()(ap_int<16>(v));
    }
    inline ap_int<N2> operator()(unsigned int v) {
        return operator()(ap_uint<32>(v));
    }
    inline ap_int<N2> operator()(int v) {
        return operator()(ap_int<32>(v));
    }
    inline ap_int<N2> operator()(unsigned long long v) {
        return operator()(ap_uint<64>(v));
    }
    inline ap_int<N2> operator()(long long v) {
        return operator()(ap_int<64>(v));
    }
};

template<int N2> class sr_cast_class<ap_uint<N2> > {
public:
    template<int N1>
    inline ap_uint<N2> operator()(ap_int<N1> v) {
        return ap_ufixed<N2,N2,AP_TRN,AP_SAT>(v);
    }
    template<int N1>
    inline ap_uint<N2> operator()(ap_uint<N1> v) {
        return ap_ufixed<N2,N2,AP_TRN,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
    inline ap_uint<N2> operator()(ap_fixed<W,I, _AP_Q, _AP_O> v) {
        return ap_ufixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
    inline ap_uint<N2> operator()(ap_ufixed<W,I, _AP_Q, _AP_O> v) {
        return ap_ufixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int N>
    inline ap_uint<N2> operator()(ap_fixed_base<W,I, true, _AP_Q, _AP_O, N> v) {
        return ap_ufixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int N>
    inline ap_uint<N2> operator()(ap_fixed_base<W,I, false,_AP_Q, _AP_O, N> v) {
        return ap_ufixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    inline ap_uint<N2> operator()(float v) {
        if(::hls::__isnan(v)) return 0;
        else return ap_ufixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    inline ap_uint<N2> operator()(double v) {
        if(::hls::__isnan(v)) return 0;
        else return ap_ufixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    inline ap_uint<N2> operator()(unsigned char v) {
        return operator()(ap_uint<8>(v));
    }
    inline ap_uint<N2> operator()(char v) {
        return operator()(ap_int<8>(v));
    }
    inline ap_uint<N2> operator()(unsigned short v) {
        return operator()(ap_uint<16>(v));
    }
    inline ap_uint<N2> operator()(short v) {
        return operator()(ap_int<16>(v));
    }
    inline ap_uint<N2> operator()(unsigned int v) {
        return operator()(ap_uint<32>(v));
    }
    inline ap_uint<N2> operator()(int v) {
        return operator()(ap_int<32>(v));
    }
    inline ap_uint<N2> operator()(unsigned long long v) {
        return operator()(ap_uint<64>(v));
    }
    inline ap_uint<N2> operator()(long long v) {
        return operator()(ap_int<64>(v));
    }
};

template<> class sr_cast_class<unsigned char> : public sr_cast_class<ap_uint<8> > {
public:
    using sr_cast_class<ap_uint<8> >::operator();
};

template<> class sr_cast_class<char> : public sr_cast_class<ap_int<8> > {
public:
    using sr_cast_class<ap_int<8> >::operator();
};

template<> class sr_cast_class<unsigned short> : public sr_cast_class<ap_uint<16> > {
public:
    using sr_cast_class<ap_uint<16> >::operator();
};

template<> class sr_cast_class<short> : public sr_cast_class<ap_int<16> > {
public:
    using sr_cast_class<ap_int<16> >::operator();
};

template<> class sr_cast_class<unsigned int> : public sr_cast_class<ap_uint<32> > {
public:
    using sr_cast_class<ap_uint<32> >::operator();
};

template<> class sr_cast_class<int> : public sr_cast_class<ap_int<32> > {
public:
    using sr_cast_class<ap_int<32> >::operator();
};

template<> class sr_cast_class<unsigned long long> : public sr_cast_class<ap_uint<64> > {
public:
    using sr_cast_class<ap_uint<64> >::operator();
};

template<> class sr_cast_class<long long> : public sr_cast_class<ap_int<64> > {
public:
    using sr_cast_class<ap_int<64> >::operator();
};

template<typename T2, typename T1> inline T2 sr_cast(T1 v)
{
    ::hls::sr_cast_class<T2> V;
    return V(v);
}


typedef struct{
  unsigned char Y;
  char UV;
}yuv422_8;

typedef struct{
  unsigned char Y;
  char U;
  char V;
}yuv444_8;

typedef struct{
  unsigned char R;
  unsigned char G;
  unsigned char B;
}rgb_8;

typedef yuv422_8 yuv420_8;

typedef struct{
  char A;
  unsigned char Y;
  char UV;
}yuva422_8;

typedef struct{
  char A;
  unsigned char Y;
  char U;
  char V;
}yuva444_8;

typedef struct{
  char A;
  unsigned char R;
  unsigned char G;
  unsigned char B;
}rgba_8;

typedef struct{
  char AUV;
  unsigned char Y;
}yuva420_8;

typedef struct{
  unsigned char D;
  unsigned char Y;
  char UV;
}yuvd422_8;

typedef struct{
  unsigned char D;
  unsigned char Y;
  char U;
  char V;
}yuvd444_8;

typedef struct{
  unsigned char D;
  unsigned char R;
  unsigned char G;
  unsigned char B;
}rgbd_8;

typedef yuvd422_8 yuvd420_8;

typedef struct{
  unsigned char CMY;
}bayer_8;

typedef struct{
  unsigned char Y;
}luma_8;

}
# 56 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_video.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h" 1
# 45 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
namespace hls {


template<int ROWS, int COLS, typename T>
class Window {
public:
    Window() {
_ssdm_SpecArrayPartition( val, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( val, 2, "COMPLETE", 0, "");
    };


    void shift_pixels_left();
    void shift_pixels_right();
    void shift_pixels_up();
    void shift_pixels_down();
    void insert_pixel(T value, int row, int col);
    void insert_row(T value[COLS], int row);
    void insert_top_row(T value[COLS]);
    void insert_bottom_row(T value[COLS]);
    void insert_col(T value[ROWS], int col);
    void insert_left_col(T value[ROWS]);
    void insert_right_col(T value[ROWS]);
    T& getval(int row, int col);
    T& operator ()(int row, int col);


    void shift_left();
    void shift_right();
    void shift_up();
    void shift_down();
    void insert(T value, int row, int col);
    void insert_top(T value[COLS]);
    void insert_bottom(T value[COLS]);
    void insert_left(T value[ROWS]);
    void insert_right(T value[ROWS]);



    T val[ROWS][COLS];





};
# 113 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_pixels_left() {
_ssdm_InlineSelf(0, "");







    HLS_SIZE_T i, j;
    for(i = 0; i < ROWS; i++) {
_ssdm_Unroll(0,0,0, "");
        for(j = 0; j < COLS-1; j++) {
_ssdm_Unroll(0,0,0, "");
            val[i][j] = val[i][j+1];
        }
    }
# 145 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}





template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_pixels_right() {
_ssdm_InlineSelf(0, "");







    HLS_SIZE_T i, j;
    for(i = 0; i < ROWS; i++) {
_ssdm_Unroll(0,0,0, "");
        for(j = COLS-1; j > 0; j--) {
_ssdm_Unroll(0,0,0, "");
            val[i][j] = val[i][j-1];
        }
    }
# 183 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}





template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_pixels_up() {
_ssdm_InlineSelf(0, "");







    HLS_SIZE_T i, j;
    for(i = 0; i < ROWS-1; i++) {
_ssdm_Unroll(0,0,0, "");
        for(j = 0; j < COLS; j++) {
_ssdm_Unroll(0,0,0, "");
            val[i][j] = val[i+1][j];
        }
    }
# 221 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}





template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_pixels_down() {
_ssdm_InlineSelf(0, "");







    HLS_SIZE_T i, j;
    for(i = ROWS-1; i > 0; i--) {
_ssdm_Unroll(0,0,0, "");
        for(j = 0; j < COLS; j++) {
_ssdm_Unroll(0,0,0, "");
            val[i][j] = val[i-1][j];
        }
    }
# 259 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_pixel(T value, int row, int col) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (row >= 0 && row < ROWS && col >= 0 && col < COLS) ? void (0) : __assert_fail ("row >= 0 && row < ROWS && col >= 0 && col < COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h", 266, __extension__ __PRETTY_FUNCTION__));







    val[row][col] = value;
# 291 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_row(T value[COLS], int row) {
_ssdm_InlineSelf(0, "");







    HLS_SIZE_T j;
    for(j = 0; j < COLS; j++) {
_ssdm_Unroll(0,0,0, "");
        val[row][j] = value[j];
    }
# 326 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_top_row(T value[COLS]) {
_ssdm_InlineSelf(0, "");







    insert_row(value, 0);
# 357 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_bottom_row(T value[COLS]) {
_ssdm_InlineSelf(0, "");







    insert_row(value, ROWS-1);
# 388 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_col(T value[ROWS], int col) {
_ssdm_InlineSelf(0, "");







    HLS_SIZE_T i;
    for(i = 0; i < ROWS; i++) {
_ssdm_Unroll(0,0,0, "");
        val[i][col] = value[i];
    }
# 423 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_left_col(T value[ROWS]) {
_ssdm_InlineSelf(0, "");







    insert_col(value, 0);
# 454 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_right_col(T value[ROWS]) {
_ssdm_InlineSelf(0, "");







    insert_col(value, COLS-1);
# 485 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> T& Window<ROWS, COLS, T>::getval(int row, int col) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (row >= 0 && row < ROWS && col >= 0 && col < COLS) ? void (0) : __assert_fail ("row >= 0 && row < ROWS && col >= 0 && col < COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h", 492, __extension__ __PRETTY_FUNCTION__));
    return val[row][col];
}




template<int ROWS, int COLS, typename T> T& Window<ROWS, COLS, T>::operator ()(int row, int col) {
_ssdm_InlineSelf(0, "");
    return getval(row, col);
}
# 531 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_left() {
_ssdm_InlineSelf(0, "");
    shift_pixels_left();
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_right() {
_ssdm_InlineSelf(0, "");
    shift_pixels_right();
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_up() {
_ssdm_InlineSelf(0, "");
    shift_pixels_up();
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_down() {
_ssdm_InlineSelf(0, "");
    shift_pixels_down();
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert(T value, int row, int col) {
_ssdm_InlineSelf(0, "");
    insert_pixel(value, row, col);
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_top(T value[COLS]) {
_ssdm_InlineSelf(0, "");
    insert_bottom_row(value);
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_bottom(T value[COLS]) {
_ssdm_InlineSelf(0, "");
    insert_top_row(value);
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_left(T value[ROWS]) {
_ssdm_InlineSelf(0, "");
    insert_right_col(value);
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_right(T value[ROWS]) {
_ssdm_InlineSelf(0, "");
    insert_left_col(value);
}


template<int ROWS, int COLS, typename T, int RESHAPE=0>
class LineBuffer;

template<int ROWS, int COLS, typename T>
class LineBuffer<ROWS, COLS, T, 0> {
public:
    LineBuffer() {
_ssdm_SpecArrayPartition( val, 1, "COMPLETE", 0, "");
_ssdm_SpecDependence( val, 0, 0, -1, 0, 1);
_ssdm_SpecDependence( val, 0, 0, -1, 0, 0);
    };

    void shift_pixels_up(int col);
    void shift_pixels_down(int col);
    void insert_bottom_row(T value, int col);
    void insert_top_row(T value, int col);
    void get_col(T value[ROWS], int col);
    T& getval(int row, int col);
    T& operator ()(int row, int col);


    void shift_up(int col);
    void shift_down(int col);
    void insert_bottom(T value, int col);
    void insert_top(T value, int col);



    T val[ROWS][COLS];





};
# 676 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::shift_pixels_down(int col) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (col >= 0 && col < COLS) ? void (0) : __assert_fail ("col >= 0 && col < COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h", 678, __extension__ __PRETTY_FUNCTION__));







    HLS_SIZE_T i;
    for(i = ROWS-1; i > 0; i--) {
_ssdm_Unroll(0,0,0, "");
        val[i][col] = val[i-1][col];
    }
# 710 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}





template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::shift_pixels_up(int col) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (col >= 0 && col < COLS) ? void (0) : __assert_fail ("col >= 0 && col < COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h", 718, __extension__ __PRETTY_FUNCTION__));







    HLS_SIZE_T i;
    for(i = 0; i < ROWS-1; i++) {
_ssdm_Unroll(0,0,0, "");
        val[i][col] = val[i+1][col];
    }
# 750 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::insert_bottom_row(T value, int col) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (col >= 0 && col < COLS) ? void (0) : __assert_fail ("col >= 0 && col < COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h", 757, __extension__ __PRETTY_FUNCTION__));







    val[ROWS-1][col] = value;
# 782 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}




template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::insert_top_row(T value, int col) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (col >= 0 && col < COLS) ? void (0) : __assert_fail ("col >= 0 && col < COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h", 789, __extension__ __PRETTY_FUNCTION__));







    val[0][col] = value;
# 814 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}




template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::get_col(T value[ROWS], int col) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (col >= 0 && col < COLS) ? void (0) : __assert_fail ("col >= 0 && col < COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h", 821, __extension__ __PRETTY_FUNCTION__));
    HLS_SIZE_T i;
    for(i = 0; i < ROWS; i++) {
_ssdm_Unroll(0,0,0, "");
        value[i] = val[i][col];
    }
}




template <int ROWS, int COLS, typename T> T& LineBuffer<ROWS, COLS, T>::getval(int row, int col) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (row >= 0 && row < ROWS && col >= 0 && col < COLS) ? void (0) : __assert_fail ("row >= 0 && row < ROWS && col >= 0 && col < COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h", 834, __extension__ __PRETTY_FUNCTION__));
    return val[row][col];
}




template<int ROWS, int COLS, typename T> T& LineBuffer<ROWS, COLS, T>::operator ()(int row, int col) {
_ssdm_InlineSelf(0, "");
    return getval(row, col);
}






template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::shift_down(int col) {
_ssdm_InlineSelf(0, "");
    shift_pixels_down(col);
}






template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::shift_up(int col) {
_ssdm_InlineSelf(0, "");
    shift_pixels_up(col);
}






template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::insert_bottom(T value, int col) {
_ssdm_InlineSelf(0, "");
    insert_top_row(value, col);
}






template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::insert_top(T value, int col) {
_ssdm_InlineSelf(0, "");
    insert_bottom_row(value, col);
}
# 907 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
template<int ROWS, int COLS, typename T>
class LineBuffer<ROWS, COLS, T, 1> {
public:
    LineBuffer() {
_ssdm_SpecArrayReshape( val, 1, "complete", 0, "");
_ssdm_SpecDependence( val, 0, 0, -1, 0, 1);
_ssdm_SpecDependence( val, 0, 0, -1, 0, 0);
    };

    void shift_pixels_up(int col);
    void shift_pixels_down(int col);
    void insert_bottom_row(T value, int col);
    void insert_top_row(T value, int col);
    void get_col(T value[ROWS], int col);
    T& getval(int row, int col);
    T& operator ()(int row, int col);


    void shift_up(int col);
    void shift_down(int col);
    void insert_bottom(T value, int col);
    void insert_top(T value, int col);



    T val[ROWS][COLS];





};
# 964 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::shift_pixels_down(int col) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (col >= 0 && col < COLS) ? void (0) : __assert_fail ("col >= 0 && col < COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h", 966, __extension__ __PRETTY_FUNCTION__));







    HLS_SIZE_T i;
    for(i = ROWS-1; i > 0; i--) {
_ssdm_Unroll(0,0,0, "");
        val[i][col] = val[i-1][col];
    }
# 998 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}





template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::shift_pixels_up(int col) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (col >= 0 && col < COLS) ? void (0) : __assert_fail ("col >= 0 && col < COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h", 1006, __extension__ __PRETTY_FUNCTION__));







    HLS_SIZE_T i;
    for(i = 0; i < ROWS-1; i++) {
_ssdm_Unroll(0,0,0, "");
        val[i][col] = val[i+1][col];
    }
# 1038 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::insert_bottom_row(T value, int col) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (col >= 0 && col < COLS) ? void (0) : __assert_fail ("col >= 0 && col < COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h", 1045, __extension__ __PRETTY_FUNCTION__));







    val[ROWS-1][col] = value;
# 1070 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}




template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::insert_top_row(T value, int col) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (col >= 0 && col < COLS) ? void (0) : __assert_fail ("col >= 0 && col < COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h", 1077, __extension__ __PRETTY_FUNCTION__));







    val[0][col] = value;
# 1102 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}




template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::get_col(T value[ROWS], int col) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (col >= 0 && col < COLS) ? void (0) : __assert_fail ("col >= 0 && col < COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h", 1109, __extension__ __PRETTY_FUNCTION__));
    HLS_SIZE_T i;
    for(i = 0; i < ROWS; i++) {
_ssdm_Unroll(0,0,0, "");
        value[i] = val[i][col];
    }
}




template <int ROWS, int COLS, typename T> T& LineBuffer<ROWS, COLS, T, 1>::getval(int row, int col) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> (row >= 0 && row < ROWS && col >= 0 && col < COLS) ? void (0) : __assert_fail ("row >= 0 && row < ROWS && col >= 0 && col < COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h", 1122, __extension__ __PRETTY_FUNCTION__));
    return val[row][col];
}




template<int ROWS, int COLS, typename T> T& LineBuffer<ROWS, COLS, T, 1>::operator ()(int row, int col) {
_ssdm_InlineSelf(0, "");
    return getval(row, col);
}






template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::shift_down(int col) {
_ssdm_InlineSelf(0, "");
    shift_pixels_down(col);
}






template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::shift_up(int col) {
_ssdm_InlineSelf(0, "");
    shift_pixels_up(col);
}






template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::insert_bottom(T value, int col) {
_ssdm_InlineSelf(0, "");
    insert_top_row(value, col);
}






template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::insert_top(T value, int col) {
_ssdm_InlineSelf(0, "");
    insert_bottom_row(value, col);
}
# 1194 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_mem.h"
}
# 57 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_video.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_core.h" 1
# 84 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_core.h"
namespace hls {


template<typename T>
class Point_ {
public:
    Point_();
    Point_(T _x, T _y);
    Point_(const Point_& pt);
    ~Point_();

    T x, y;
};


template<typename T> inline Point_<T>::Point_() {}
template<typename T> inline Point_<T>::Point_(T _x, T _y) : x(_x), y(_y) {}
template<typename T> inline Point_<T>::Point_(const Point_<T>& pt) : x(pt.x), y(pt.y) {}
template<typename T> inline Point_<T>::~Point_() {}

typedef Point_<int> Point;



template<typename T>
class Size_ {
public:
    Size_();
    Size_(T _width, T _height);
    Size_(const Size_<T>& sz);
    Size_(const Point_<T>& pt);
    T area();
    ~Size_();

    T width, height;
};


template<typename T> inline Size_<T>::Size_() {}
template<typename T> inline Size_<T>::Size_(T _width, T _height) : width(_width), height(_height) {}
template<typename T> inline Size_<T>::Size_(const Size_<T>& sz) : width(sz.width), height(sz.height) {}
template<typename T> inline Size_<T>::Size_(const Point_<T>& pt) : width(pt.x), height(pt.y) {}
template<typename T> inline T Size_<T>::area() { return width*height; }
template<typename T> inline Size_<T>::~Size_() {}

typedef Size_<int> Size;



template<typename T>
class Rect_ {
public:
    Rect_();
    Rect_(T _x, T _y, T _width, T _height);
    Rect_(const Rect_& rect);
    Rect_(const Point_<T>& pt, const Size_<T>& sz);
    T area();
    Size_<T> size();
    Point_<T> tl();
    Point_<T> tr();
    Point_<T> bl();
    Point_<T> br();
    bool bContains(const Point_<T>& pt);
    ~Rect_();

    T x, y, width, height;
};


template<typename T> inline Rect_<T>::Rect_() {}
template<typename T> inline Rect_<T>::Rect_(T _x, T _y, T _width, T _height) : x(_x), y(_y), width(_width), height(_height) {}
template<typename T> inline Rect_<T>::Rect_(const Rect_<T>& rect) : x(rect.x), y(rect.y), width(rect.width), height(rect.height) {}
template<typename T> inline Rect_<T>::Rect_(const Point_<T>& pt, const Size_<T>& sz) : x(pt.x), y(pt.y), width(sz.width), height(sz.height) {}
template<typename T> inline T Rect_<T>::area() { return width*height; }
template<typename T> inline Size_<T> Rect_<T>::size() { return Size_<T>(width, height); }
template<typename T> inline Point_<T> Rect_<T>::tl() { return Point_<T>(x, y); }
template<typename T> inline Point_<T> Rect_<T>::tr() { return Point_<T>(x+width, y); }
template<typename T> inline Point_<T> Rect_<T>::bl() { return Point_<T>(x, y+height); }
template<typename T> inline Point_<T> Rect_<T>::br() { return Point_<T>(x+width, y+height); }
template<typename T> inline bool Rect_<T>::bContains(const Point_<T>& pt) { return (pt.x >= x && pt.x < x+width && pt.y >= y && pt.y < y+height); }
template<typename T> inline Rect_<T>::~Rect_() {}

typedef Rect_<int> Rect;


template<bool c>
struct eqb {};

template<>
struct eqb <true> { typedef void type; };

template<typename T1, typename T2>
struct eqwt { typedef typename eqb<Type_BitWidth<T1>::Value == Type_BitWidth<T2>::Value>::type type; };


template<int N, typename T>
class Scalar {
public:
    Scalar() {
_ssdm_SpecArrayPartition( val, 1, "COMPLETE", 0, "");
        (static_cast <bool> (N > 0) ? void (0) : __assert_fail ("N > 0", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_core.h", 184, __extension__ __PRETTY_FUNCTION__));
    }
    Scalar(T v0) {
_ssdm_SpecArrayPartition( val, 1, "COMPLETE", 0, "");
        (static_cast <bool> (N >= 1 && "Scalar must have enough channels for constructor.") ? void (0) : __assert_fail ("N >= 1 && \"Scalar must have enough channels for constructor.\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_core.h", 188, __extension__ __PRETTY_FUNCTION__));
        val[0] = v0;
    }
    Scalar(T v0, T v1) {
_ssdm_SpecArrayPartition( val, 1, "COMPLETE", 0, "");
        (static_cast <bool> (N >= 2 && "Scalar must have enough channels for constructor.") ? void (0) : __assert_fail ("N >= 2 && \"Scalar must have enough channels for constructor.\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_core.h", 193, __extension__ __PRETTY_FUNCTION__));
        val[0] = v0; val[1] = v1;
    }
    Scalar(T v0, T v1, T v2) {
_ssdm_SpecArrayPartition( val, 1, "COMPLETE", 0, "");
        (static_cast <bool> (N >= 3 && "Scalar must have enough channels for constructor.") ? void (0) : __assert_fail ("N >= 3 && \"Scalar must have enough channels for constructor.\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_core.h", 198, __extension__ __PRETTY_FUNCTION__));
        val[0] = v0; val[1] = v1; val[2] = v2;
    }
    Scalar(T v0, T v1, T v2, T v3) {
_ssdm_SpecArrayPartition( val, 1, "COMPLETE", 0, "");
        (static_cast <bool> (N >= 4 && "Scalar must have enough channels for constructor.") ? void (0) : __assert_fail ("N >= 4 && \"Scalar must have enough channels for constructor.\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_core.h", 203, __extension__ __PRETTY_FUNCTION__));
        val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    }

    void operator = (T value);


    template<typename T2>
    typename eqwt<T,T2>::type operator = (const Scalar<N, T2> &value) {
_ssdm_InlineSelf(0, "");
        for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
            val[k] = (T)value.val[k];
        }
    }

    Scalar<N, T> operator + (T value);
    Scalar<N, T> operator + (Scalar<N, T> s);
    Scalar<N, T> operator - (T value);
    Scalar<N, T> operator - (Scalar<N, T> s);
    Scalar<N, T> operator * (T value);
    Scalar<N, T> operator * (Scalar<N, T> s);
    Scalar<N, T> operator / (T value);
    Scalar<N, T> operator / (Scalar<N, T> s);

    T val[N];
};

template<int N, typename T>
void Scalar<N, T>::operator = (T value) {
_ssdm_InlineSelf(0, "");
    for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
        val[k] = value;
    }
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator + (T value) {
_ssdm_InlineSelf(0, "");
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
        res.val[k] = val[k] + value;
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator + (Scalar<N, T> s) {
_ssdm_InlineSelf(0, "");
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
        res.val[k] = val[k] + s.val[k];
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator - (T value) {
_ssdm_InlineSelf(0, "");
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
        res.val[k] = val[k] - value;
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator - (Scalar<N, T> s) {
_ssdm_InlineSelf(0, "");
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
        res.val[k] = val[k] - s.val[k];
    }
    return res;
}


template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator * (T value) {
_ssdm_InlineSelf(0, "");
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
        res.val[k] = val[k] * value;
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator * (Scalar<N, T> s) {
_ssdm_InlineSelf(0, "");
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
        res.val[k] = val[k] * s.val[k];
    }
    return res;
}


template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator / (T value) {
_ssdm_InlineSelf(0, "");
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
        res.val[k] = val[k] / value;
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator / (Scalar<N, T> s) {
_ssdm_InlineSelf(0, "");
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
        res.val[k] = val[k] / s.val[k];
    }
    return res;
}





template<typename T>
yuv422_8 Scalar_to_yuv422_8(Scalar<2, T> scl) {
_ssdm_InlineSelf(0, "");
    yuv422_8 pix;
    pix.Y = (unsigned char)scl.val[0];
    pix.UV = (char)scl.val[1];
    return pix;
}
template<typename T>
Scalar<2, T> yuv422_8_to_Scalar(yuv422_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<2, T> scl;
    scl.val[0] = (T)pix.Y;
    scl.val[1] = (T)pix.UV;
    return scl;
}


template<typename T>
yuv444_8 Scalar_to_yuv444_8(Scalar<3, T> scl) {
_ssdm_InlineSelf(0, "");
    yuv444_8 pix;
    pix.Y = (unsigned char)scl.val[0];
    pix.U = (char)scl.val[1];
    pix.V = (char)scl.val[2];
    return pix;
}
template<typename T>
Scalar<3, T> yuv444_8_to_Scalar(yuv444_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<3, T> scl;
    scl.val[0] = (T)pix.Y;
    scl.val[1] = (T)pix.U;
    scl.val[2] = (T)pix.V;
    return scl;
}


template<typename T>
rgb_8 Scalar_to_rgb_8(Scalar<3, T> scl) {
_ssdm_InlineSelf(0, "");
    rgb_8 pix;
    pix.R = (unsigned char)scl.val[0];
    pix.G = (unsigned char)scl.val[1];
    pix.B = (unsigned char)scl.val[2];
    return pix;
}
template<typename T>
Scalar<3, T> rgb_8_to_Scalar(rgb_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<3, T> scl;
    scl.val[0] = (T)pix.R;
    scl.val[1] = (T)pix.G;
    scl.val[2] = (T)pix.B;
    return scl;
}


template<typename T>
yuva422_8 Scalar_to_yuva422_8(Scalar<3, T> scl) {
_ssdm_InlineSelf(0, "");
    yuva422_8 pix;
    pix.A = (char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    pix.UV = (char)scl.val[2];
    return pix;
}
template<typename T>
Scalar<3, T> yuva422_8_to_Scalar(yuva422_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<3, T> scl;
    scl.val[0] = (T)pix.A;
    scl.val[1] = (T)pix.Y;
    scl.val[2] = (T)pix.UV;
    return scl;
}


template<typename T>
yuva444_8 Scalar_to_yuva444_8(Scalar<4, T> scl) {
_ssdm_InlineSelf(0, "");
    yuva444_8 pix;
    pix.A = (char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    pix.U = (char)scl.val[2];
    pix.V = (char)scl.val[3];
    return pix;
}
template<typename T>
Scalar<4, T> yuva444_8_to_Scalar(yuva444_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<4, T> scl;
    scl.val[0] = (T)pix.A;
    scl.val[1] = (T)pix.Y;
    scl.val[2] = (T)pix.U;
    scl.val[3] = (T)pix.V;
    return scl;
}


template<typename T>
rgba_8 Scalar_to_rgba_8(Scalar<4, T> scl) {
_ssdm_InlineSelf(0, "");
    rgba_8 pix;
    pix.A = (char)scl.val[0];
    pix.R = (unsigned char)scl.val[1];
    pix.G = (unsigned char)scl.val[2];
    pix.B = (unsigned char)scl.val[3];
    return pix;
}
template<typename T>
Scalar<4, T> rgba_8_to_Scalar(rgba_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<4, T> scl;
    scl.val[0] = (T)pix.A;
    scl.val[1] = (T)pix.R;
    scl.val[2] = (T)pix.G;
    scl.val[3] = (T)pix.B;
    return scl;
}


template<typename T>
yuva420_8 Scalar_to_yuva420_8(Scalar<2, T> scl) {
_ssdm_InlineSelf(0, "");
    yuva420_8 pix;
    pix.AUV = (char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    return pix;
}
template<typename T>
Scalar<2, T> yuva420_8_to_Scalar(yuva420_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<2, T> scl;
    scl.val[0] = (T)pix.AUV;
    scl.val[1] = (T)pix.Y;
    return scl;
}


template<typename T>
yuvd422_8 Scalar_to_yuvd422_8(Scalar<3, T> scl) {
_ssdm_InlineSelf(0, "");
    yuvd422_8 pix;
    pix.D = (unsigned char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    pix.UV = (char)scl.val[2];
    return pix;
}
template<typename T>
Scalar<3, T> yuvd422_8_to_Scalar(yuvd422_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<3, T> scl;
    scl.val[0] = (T)pix.D;
    scl.val[1] = (T)pix.Y;
    scl.val[2] = (T)pix.UV;
    return scl;
}


template<typename T>
yuvd444_8 Scalar_to_yuvd444_8(Scalar<4, T> scl) {
_ssdm_InlineSelf(0, "");
    yuvd444_8 pix;
    pix.D = (unsigned char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    pix.U = (char)scl.val[2];
    pix.V = (char)scl.val[3];
    return pix;
}
template<typename T>
Scalar<4, T> yuvd444_8_to_Scalar(yuvd444_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<4, T> scl;
    scl.val[0] = (T)pix.D;
    scl.val[1] = (T)pix.Y;
    scl.val[2] = (T)pix.U;
    scl.val[3] = (T)pix.V;
    return scl;
}


template<typename T>
rgbd_8 Scalar_to_rgbd_8(Scalar<4, T> scl) {
_ssdm_InlineSelf(0, "");
    rgbd_8 pix;
    pix.D = (unsigned char)scl.val[0];
    pix.R = (unsigned char)scl.val[1];
    pix.G = (unsigned char)scl.val[2];
    pix.B = (unsigned char)scl.val[3];
    return pix;
}
template<typename T>
Scalar<4, T> rgbd_8_to_Scalar(rgbd_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<4, T> scl;
    scl.val[0] = (T)pix.D;
    scl.val[1] = (T)pix.R;
    scl.val[2] = (T)pix.G;
    scl.val[3] = (T)pix.B;
    return scl;
}


template<typename T>
bayer_8 Scalar_to_bayer_8(Scalar<1, T> scl) {
_ssdm_InlineSelf(0, "");
    bayer_8 pix;
    pix.CMY = (unsigned char)scl.val[0];
    return pix;
}
template<typename T>
Scalar<1, T> bayer_8_to_Scalar(bayer_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<1, T> scl;
    scl.val[0] = (T)pix.CMY;
    return scl;
}


template<typename T>
luma_8 Scalar_to_luma_8(Scalar<1, T> scl) {
_ssdm_InlineSelf(0, "");
    luma_8 pix;
    pix.Y = (unsigned char)scl.val[0];
    return pix;
}
template<typename T>
Scalar<1, T> luma_8_to_Scalar(luma_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<1, T> scl;
    scl.val[0] = (T)pix.Y;
    return scl;
}


template<int ROWS, int COLS, int T>
class Mat {
public:
    Mat();
    Mat(int _rows, int _cols);
    Mat(Size _sz);

    void init(int _rows, int _cols);
    void assignto(Mat<ROWS, COLS, T>& mat);

    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> read();

    void read(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name>& s);
    template <typename T2>
    typename eqwt<typename Type<((T) & ((1 << 11) - 1))>::name,T2>::type read(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), T2>& s){
_ssdm_InlineSelf(0, "");
        s = read();
    }

    void write(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> s);
    template<typename T2>
    typename eqwt<typename Type<((T) & ((1 << 11) - 1))>::name,T2>::type write(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), T2> s) {
_ssdm_InlineSelf(0, "");
_ssdm_DataPack( data_stream, 0, 0, "", "", "");
    HLS_CHANNEL_T i;
        {



_ssdm_op_SpecProtocol(0, "");
            for (i = 0; i < ((((T) & ((512 - 1) << 11)) >> 11) + 1); i++) {
_ssdm_Unroll(0,0,0, "");
                data_stream[i] << s.val[i];
            }
        }
    }

   void operator >> (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name>& s);
    template <typename T2>
    typename eqwt<typename Type<((T) & ((1 << 11) - 1))>::name,T2>::type operator >> (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), T2>& s) {
_ssdm_InlineSelf(0, "");
        s = read();
    }

    void operator << (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> s);
    template<typename T2>
    typename eqwt<typename Type<((T) & ((1 << 11) - 1))>::name,T2>::type operator << (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), T2> s) {
_ssdm_InlineSelf(0, "");
        write(s);
    }

    bool empty();

    const int type() const;
    const int depth() const;
    const int channels() const;

    HLS_SIZE_T rows, cols;

    hls::stream<typename Type<((T) & ((1 << 11) - 1))>::name> data_stream[((((T) & ((512 - 1) << 11)) >> 11) + 1)];
};


template<int ROWS, int COLS, int T>
inline Mat<ROWS, COLS, T>::Mat() {
_ssdm_InlineSelf(0, "");
    init(ROWS, COLS);
}

template<int ROWS, int COLS, int T>
inline Mat<ROWS, COLS, T>::Mat(int _rows, int _cols) {
_ssdm_InlineSelf(0, "");
    init(_rows, _cols);
}

template<int ROWS, int COLS, int T>
inline Mat<ROWS, COLS, T>::Mat(Size _sz) {
_ssdm_InlineSelf(0, "");
    init(_sz.height, _sz.width);
}

template<int ROWS, int COLS, int T>
inline void Mat<ROWS, COLS, T>::init(int _rows, int _cols) {
_ssdm_InlineSelf(0, "");
    (static_cast <bool> ((_rows > 0) && (_rows <= ROWS) && (_cols > 0) && (_cols <= COLS) && "The number of rows and columns must be less than the template arguments.") ? void (0) : __assert_fail ("(_rows > 0) && (_rows <= ROWS) && (_cols > 0) && (_cols <= COLS) && \"The number of rows and columns must be less than the template arguments.\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_core.h", 655, __extension__ __PRETTY_FUNCTION__));

    rows = _rows;
    cols = _cols;
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::assignto(Mat<ROWS, COLS, T>& mat) {
_ssdm_InlineSelf(0, "");
    mat.rows = rows;
    mat.cols = cols;
}

template<int ROWS, int COLS, int T>
Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> Mat<ROWS, COLS, T>::read() {
_ssdm_InlineSelf(0, "");
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> scl;
    HLS_CHANNEL_T i;
    {



        _ssdm_op_SpecProtocol(0, "");
        for (i = 0; i < ((((T) & ((512 - 1) << 11)) >> 11) + 1); i++) {
_ssdm_Unroll(0,0,0, "");
            data_stream[i] >> scl.val[i];
        }
    }
    return scl;
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::read(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name>& s) {
_ssdm_InlineSelf(0, "");
    s = read();
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::write(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> s) {
_ssdm_InlineSelf(0, "");
_ssdm_DataPack( data_stream, 0, 0, "", "", "");
    HLS_CHANNEL_T i;
    {



_ssdm_op_SpecProtocol(0, "");
        for (i = 0; i < ((((T) & ((512 - 1) << 11)) >> 11) + 1); i++) {
_ssdm_Unroll(0,0,0, "");
            data_stream[i] << s.val[i];
        }
    }
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::operator >> (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name>& s) {
_ssdm_InlineSelf(0, "");
    s = read();
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::operator << (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> s) {
_ssdm_InlineSelf(0, "");
    write(s);
}

template<int ROWS, int COLS, int T>
bool Mat<ROWS, COLS, T>::empty() {
_ssdm_InlineSelf(0, "");
    unsigned char flag = 0;
    for (HLS_CHANNEL_T i = 0; i < ((((T) & ((512 - 1) << 11)) >> 11) + 1); i++) {
_ssdm_Unroll(0,0,0, "");
        flag += (data_stream[i].empty()) ? 1 : 0;
    }




    return ((flag == ((((T) & ((512 - 1) << 11)) >> 11) + 1)) ? true : false);
}

template<int ROWS, int COLS, int T>
const int Mat<ROWS, COLS, T>::type() const {
_ssdm_InlineSelf(0, "");
    return ((T) & ((1 << 11)*512 - 1));
}

template<int ROWS, int COLS, int T>
const int Mat<ROWS, COLS, T>::depth() const {
_ssdm_InlineSelf(0, "");
    return ((T) & ((1 << 11) - 1));
}
template<int ROWS, int COLS, int T>
const int Mat<ROWS, COLS, T>::channels() const {
_ssdm_InlineSelf(0, "");
    return ((((T) & ((512 - 1) << 11)) >> 11) + 1);
}

}
# 58 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_video.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgbase.h" 1
# 86 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgbase.h"
namespace hls {

enum {MORPH_RECT,MORPH_CROSS,MORPH_ELLIPSE};

class border_mode {
public:
    enum values {BORDER_CONSTANT,BORDER_REPLICATE,BORDER_REFLECT,BORDER_WRAP,BORDER_REFLECT_101};
    typedef void isBorderMode;
};

class BORDER_CONSTANT : public border_mode { public: static const values value = border_mode::BORDER_CONSTANT; };
class BORDER_REPLICATE : public border_mode { public: static const values value = border_mode::BORDER_REPLICATE; };
class BORDER_REFLECT : public border_mode { public: static const values value = border_mode::BORDER_REFLECT; };
class BORDER_WRAP : public border_mode { public: static const values value = border_mode::BORDER_WRAP; };
class BORDER_REFLECT_101 : public border_mode { public: static const values value = border_mode::BORDER_REFLECT_101; };
class BORDER_DEFAULT : public border_mode { public: static const values value = border_mode::BORDER_REFLECT_101; };
# 113 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgbase.h"
static int borderInterpolate( int p, int len, int borderType )
{
    _ssdm_InlineSelf(0, "");
    (static_cast <bool> (borderType != BORDER_WRAP::value && "BORDER_WRAP is not supported.") ? void (0) : __assert_fail ("borderType != BORDER_WRAP::value && \"BORDER_WRAP is not supported.\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgbase.h", 116, __extension__ __PRETTY_FUNCTION__));

    if( p >= 0 && p < len )
        return p;
    else if( borderType == BORDER_REPLICATE::value )
        p = p < 0 ? 0 : len - 1;
    else if( borderType == BORDER_REFLECT::value)
    {
        if( len == 1 )
            return 0;
        if(p<0)
        {
            p=-p-1;
        }
        if( p >= len )
        {
            p=2*len-p-1;
        }
    }
    else if(borderType == BORDER_REFLECT_101::value )
    {
        if( len == 1 )
            return 0;
        if(p<0)
        {

            p=-p;
        }
        if( p >= len )
        {

            p=2*len-p-2;
        }
    }

    else if( borderType == BORDER_CONSTANT::value )
        p = -1;
    return p;
}

template <typename anchor_T,typename kernel_T>
inline void normalizeAnchor(
        hls::Point_<anchor_T> &anchor,
        hls::Size_<kernel_T> kernel_size)
{
_ssdm_InlineSelf(0, "");
    if(anchor.x==-1)
        anchor.x=kernel_size.width/2;
    if(anchor.y==-1)
        anchor.y=kernel_size.height/2;

    (static_cast <bool> (anchor.x>=0) ? void (0) : __assert_fail ("anchor.x>=0", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgbase.h", 167, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (anchor.x<=kernel_size.width-1) ? void (0) : __assert_fail ("anchor.x<=kernel_size.width-1", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgbase.h", 168, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (anchor.y>=0) ? void (0) : __assert_fail ("anchor.y>=0", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgbase.h", 169, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (anchor.y<=kernel_size.height-1) ? void (0) : __assert_fail ("anchor.y<=kernel_size.height-1", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgbase.h", 170, __extension__ __PRETTY_FUNCTION__));
}
template<int SRC_T,int ROWS,int COLS>
void DuplicateImageN(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, SRC_T> _dst[],
  int num
                )
{
    int cols=_src.cols;
    int rows=_src.rows;
 loop_size: for(int k=0;k<num;k++) {
        _dst[k].rows=rows;
        _dst[k].cols=cols;
    }
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
 loop_height: for(int i= 0;i<rows;i++)
 {
_ssdm_op_SpecLoopTripCount(20, 2000, 1010, "");
    loop_width: for (int j= 0;j<cols;j++)
_ssdm_op_SpecLoopTripCount(20, 2000, 1010, "");
  {
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
                        _src >> s;
                        for(int k=0;k<num;k++)
                        _dst[k] << s;
                }
        }
}
}
# 59 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_video.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h" 1
# 41 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h"
namespace hls {
# 50 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h"
template<int W, int ROWS, int COLS, int T>
int AXIvideo2Mat(stream<ap_axiu<W,1,1,1> >& AXI_video_strm,
                 Mat<ROWS, COLS, T>& img)
{
    int res = 0;
    ap_axiu<W,1,1,1> axi;
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix;
    int depth = Type<((T) & ((1 << 11) - 1))>::bitdepth;

    (static_cast <bool> (W >= depth*((((T) & ((512 - 1) << 11)) >> 11) + 1) && "Bit-Width of AXI stream must be greater than the total number of bits in a pixel") ? void (0) : __assert_fail ("W >= depth*HLS_MAT_CN(T) && \"Bit-Width of AXI stream must be greater than the total number of bits in a pixel\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h", 59, __extension__ __PRETTY_FUNCTION__));
    HLS_SIZE_T rows = img.rows;
    HLS_SIZE_T cols = img.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h", 62, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h", 63, __extension__ __PRETTY_FUNCTION__));
    bool sof = 0;
 loop_wait_for_start: while (!sof) {
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
_ssdm_op_SpecLoopTripCount(0, 0, 0, "");
        AXI_video_strm >> axi;
        sof = axi.user.to_int();
    }
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
        bool eol = 0;
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            if (sof || eol) {
                sof = 0;
                eol = axi.last.to_int();
            } else {

                AXI_video_strm >> axi;
                eol = axi.last.to_int();
                bool user = axi.user.to_int();
                if(user) {
                    res |= (1 << 0);
                }
            }
            if (eol && (j != cols-1)) {
                res |= (1 << 0);
            }
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                AXIGetBitFields(axi, k*depth, depth, pix.val[k]);
            }
            img << pix;
        }
    loop_wait_for_eol: while (!eol) {
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
_ssdm_op_SpecLoopTripCount(0, 0, 0, "");

            AXI_video_strm >> axi;
            eol = axi.last.to_int();
            res |= (1 << 1);
        }
    }
    return res;
}



template<int W, int ROWS, int COLS, int T>
int Mat2AXIvideo(Mat<ROWS, COLS, T>& img,
                 stream<ap_axiu<W,1,1,1> >& AXI_video_strm)
{
    int res = 0;
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix;
    ap_axiu<W,1,1,1> axi;
    int depth = Type<((T) & ((1 << 11) - 1))>::bitdepth;

    (static_cast <bool> (W >= depth*((((T) & ((512 - 1) << 11)) >> 11) + 1) && "Bit-Width of AXI stream must be greater than the total number of bits in a pixel") ? void (0) : __assert_fail ("W >= depth*HLS_MAT_CN(T) && \"Bit-Width of AXI stream must be greater than the total number of bits in a pixel\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h", 119, __extension__ __PRETTY_FUNCTION__));
    HLS_SIZE_T rows = img.rows;
    HLS_SIZE_T cols = img.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h", 122, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h", 123, __extension__ __PRETTY_FUNCTION__));
    bool sof = 1;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            if (sof) {
                axi.user = 1;
                sof = 0;
            } else {
                axi.user = 0;
            }
            if (j == (cols-1)) {
                axi.last = 1;
            } else {
                axi.last = 0;
            }
            img >> pix;
            axi.data = -1;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                AXISetBitFields(axi, k*depth, depth, pix.val[k]);
            }
            axi.keep = -1;
            AXI_video_strm << axi;
        }
    }
    return res;
}




template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Array2Mat(FB_T fb[ROWS*FB_COLS], int rowStride,
             Mat<ROWS, COLS, T>& img)
{
    int res = 0;
    HLS_SIZE_T rows = img.rows;
    HLS_SIZE_T cols = img.cols;
    (static_cast <bool> (cols <= rowStride) ? void (0) : __assert_fail ("cols <= rowStride", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h", 162, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (rowStride <= FB_COLS) ? void (0) : __assert_fail ("rowStride <= FB_COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h", 163, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h", 164, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h", 165, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (COLS <= FB_COLS) ? void (0) : __assert_fail ("COLS <= FB_COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h", 166, __extension__ __PRETTY_FUNCTION__));
    int fb_BitWidth = Type_BitWidth<FB_T>::Value;
    int depth = Type<((T) & ((1 << 11) - 1))>::bitdepth;
    int ch = ((((T) & ((512 - 1) << 11)) >> 11) + 1);
    (static_cast <bool> (fb_BitWidth >= ch*depth && "Bit-Width of frame buffer must be greater than the total number of bits in a pixel") ? void (0) : __assert_fail ("fb_BitWidth >= ch*depth && \"Bit-Width of frame buffer must be greater than the total number of bits in a pixel\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h", 170, __extension__ __PRETTY_FUNCTION__));
    HLS_SIZE_T col = 0;
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix;
loop_pixel:
    for (HLS_SIZE_T row = 0; row < rows; row++) {
        for (HLS_SIZE_T col = 0; col < cols; col++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            FB_T fb_pix = fb[row*rowStride+col];
            ap_uint<((((T) & ((512 - 1) << 11)) >> 11) + 1)*Type<((T) & ((1 << 11) - 1))>::bitdepth> pix_value;
            AXISetBitFields(pix_value, 0, ((((T) & ((512 - 1) << 11)) >> 11) + 1)*Type<((T) & ((1 << 11) - 1))>::bitdepth, fb_pix);
loop_channels:
            for (HLS_CHANNEL_T k = 0; k < ((((T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
                AXIGetBitFields(pix_value, k*depth, depth, pix.val[k]);
            }
            img << pix;
        }
    }
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Array2Mat(FB_T fb[ROWS*FB_COLS],
              Mat<ROWS, COLS, T>& img)
{
    int res = 0;
    res=Array2Mat<FB_COLS>(fb, FB_COLS, img);
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int AXIM2Mat(FB_T fb[ROWS*FB_COLS],
             Mat<ROWS, COLS, T>& img)
{
    int res = 0;
    res=Array2Mat<FB_COLS>(fb, FB_COLS, img);
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int AXIM2Mat(FB_T fb[ROWS*FB_COLS], int rowStride,
             Mat<ROWS, COLS, T>& img)
{
    int res = 0;
    res=Array2Mat<FB_COLS>(fb, rowStride, img);
    return res;
}



template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Mat2Array(Mat<ROWS, COLS, T>& img,
             FB_T fb[ROWS*FB_COLS], int rowStride)
{
    int res = 0;
    HLS_SIZE_T rows = img.rows;
    HLS_SIZE_T cols = img.cols;
    (static_cast <bool> (cols <= rowStride) ? void (0) : __assert_fail ("cols <= rowStride", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h", 228, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (rowStride <= FB_COLS) ? void (0) : __assert_fail ("rowStride <= FB_COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h", 229, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h", 230, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h", 231, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (COLS <= FB_COLS) ? void (0) : __assert_fail ("COLS <= FB_COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h", 232, __extension__ __PRETTY_FUNCTION__));
    int fb_BitWidth = Type_BitWidth<FB_T>::Value;
    int depth = Type<((T) & ((1 << 11) - 1))>::bitdepth;
    int ch = ((((T) & ((512 - 1) << 11)) >> 11) + 1);
    (static_cast <bool> (fb_BitWidth >= ch*depth && "Bit-Width of frame buffer must be greater than the total number of bits in a pixel") ? void (0) : __assert_fail ("fb_BitWidth >= ch*depth && \"Bit-Width of frame buffer must be greater than the total number of bits in a pixel\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_io.h", 236, __extension__ __PRETTY_FUNCTION__));
    HLS_SIZE_T col = 0;
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix;
loop_pixel:
    for (HLS_SIZE_T row = 0; row < rows; row++) {
        for (HLS_SIZE_T col = 0; col < cols; col++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            ap_uint<((((T) & ((512 - 1) << 11)) >> 11) + 1)*Type<((T) & ((1 << 11) - 1))>::bitdepth> pix_value;
            img >> pix;
loop_channels:
            for (HLS_CHANNEL_T k = 0; k < ((((T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
                AXISetBitFields(pix_value, k*depth, depth, pix.val[k]);
            }
            FB_T fb_pix;
            AXIGetBitFields(pix_value, 0, ((((T) & ((512 - 1) << 11)) >> 11) + 1)*Type<((T) & ((1 << 11) - 1))>::bitdepth, fb_pix);
            fb[row*rowStride+col] = fb_pix;
        }
    }
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Mat2Array(Mat<ROWS, COLS, T>& img,
              FB_T fb[ROWS*FB_COLS])
{
    int res = 0;
    res=Mat2Array<FB_COLS>(img, fb, FB_COLS);
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Mat2AXIM(Mat<ROWS, COLS, T>& img,
             FB_T fb[ROWS*FB_COLS])
{
    int res = 0;
    res=Mat2Array<FB_COLS>(img, fb, FB_COLS);
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Mat2AXIM(Mat<ROWS, COLS, T>& img,
             FB_T fb[ROWS*FB_COLS], int rowStride)
{
    int res = 0;
    res=Mat2Array<FB_COLS>(img, fb, rowStride);
    return res;
}

}
# 60 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_video.h" 2

# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h" 1
# 88 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
namespace hls {
# 110 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
typedef ap_fixed<64,32,AP_RND> _AP_T;
typedef unsigned long long _SUM_T;

class kernel_min {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");

        if(src1<src2) {
            dst=sr_cast<DST_T>(src1);
        } else {
            dst=sr_cast<DST_T>(src2);
        }
    }
};

class kernel_max {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");

        if(src1>src2) {
            dst=sr_cast<DST_T>(src1);
        } else {
            dst=sr_cast<DST_T>(src2);
        }
    }
};

class kernel_absdiff {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        typename pixel_op_type<SRC1_T>::T src1_cast = src1;
        typename pixel_op_type<SRC2_T>::T src2_cast = src2;
        typedef typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T >::ADD_T TEMP_TYPE;
        TEMP_TYPE diff = src1_cast-src2_cast;
        TEMP_TYPE mdiff = src2_cast-src1_cast;
        dst = sr_cast<DST_T>((src1_cast > src2_cast) ? diff : mdiff);
    }
};

template<typename P_T, typename SRC1_T, typename SRC2_T, typename DST_T>
void kernel_and_apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst) {
_ssdm_InlineSelf(0, "");
    dst = (sr_cast<DST_T>(src1)) & (sr_cast<DST_T>(src2));
}

template<typename P_T>
void kernel_and_apply(float& src1, float& src2, float& dst) {
_ssdm_InlineSelf(0, "");
    fp_struct<float> src1_fp(src1);
    fp_struct<float> src2_fp(src2);
    unsigned int dst_tmp = src1_fp.to_int() & src2_fp.to_int();
    fp_struct<float> dst_fp(dst_tmp);
    dst = dst_fp.to_float();
}

class kernel_and {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        kernel_and_apply<P_T>(src1, src2, dst);
    }
};

class kernel_not {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src, SRC2_T& val, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        dst = ~(sr_cast<DST_T>(src));
    }
};

class kernel_set {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src, SRC2_T& val, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        dst = sr_cast<DST_T>(val);
    }
};

class kernel_scale {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src, SRC2_T& val, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        typedef typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<P_T>::T>::MULT_T MULT_T;
        typedef typename x_traits<typename pixel_op_type<P_T>::T, MULT_T>::ADD_T ADD_T;
        MULT_T mult_t=(typename pixel_op_type<SRC1_T>::T)src * (typename pixel_op_type<P_T>::T)p0;
        ADD_T sum_t=mult_t + (typename pixel_op_type<P_T>::T)p1;

        dst = sr_cast<DST_T>(sum_t);
    }
};

class kernel_add {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::ADD_T t =
            (typename pixel_op_type<SRC1_T>::T)src1 + (typename pixel_op_type<SRC2_T>::T)src2;
        dst = sr_cast<DST_T>(t);
    }
};

class kernel_sub {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::SUB_T t =
            (typename pixel_op_type<SRC1_T>::T)src1 - (typename pixel_op_type<SRC2_T>::T)src2;
        dst = sr_cast<DST_T>(t);
    }
};

class kernel_subR {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::SUB_T t =
            (typename pixel_op_type<SRC2_T>::T)src2 - (typename pixel_op_type<SRC1_T>::T)src1;
        dst = sr_cast<DST_T>(t);
    }
};

class kernel_mul {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T, typename P2_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P2_T p1=0, P2_T p2=0) {
_ssdm_InlineSelf(0, "");
        typedef typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::MULT_T MULT_T;
        MULT_T t1 = (typename pixel_op_type<SRC1_T>::T)src1 * (typename pixel_op_type<SRC2_T>::T)src2;
        typename x_traits<MULT_T, typename pixel_op_type<P_T>::T>::MULT_T t2 = t1 * (typename pixel_op_type<P_T>::T)p0;

        dst = sr_cast<DST_T>(t2);
    }
};

class kernel_mul2 {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::MULT_T t =
            (typename pixel_op_type<SRC1_T>::T)src1 * (typename pixel_op_type<SRC2_T>::T)src2;

        dst = sr_cast<DST_T>(t);
    }
};

class kernel_addWeighted {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        typedef typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<P_T>::T>::MULT_T MULT_T1;
        MULT_T1 t1 = (typename pixel_op_type<SRC1_T>::T)src1 * (typename pixel_op_type<P_T>::T)p0;
        typedef typename x_traits<typename pixel_op_type<SRC2_T>::T, typename pixel_op_type<P_T>::T>::MULT_T MULT_T2;
        MULT_T2 t2 = (typename pixel_op_type<SRC2_T>::T)src2 * (typename pixel_op_type<P_T>::T)p1;
        typedef typename x_traits<MULT_T1, MULT_T2>::ADD_T ADD_T;
        ADD_T sum = t1 + t2 + p2;

        dst = sr_cast<DST_T>(sum);
    }
};

class kernel_cmp {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        switch (p0) {
            case 0:
            dst = (src1==src2 ? 255 : 0);
            break;
            case 1:
            dst = (src1 >src2 ? 255 : 0);
            break;
            case 2:
            dst = (src1>=src2 ? 255 : 0);
            break;
            case 3:
            dst = (src1 <src2 ? 255 : 0);
            break;
            case 4:
            dst = (src1<=src2 ? 255 : 0);
            break;
            case 5:
            dst = (src1!=src2 ? 255 : 0);
            break;
            default:
            break;
        }
    }
};

class kernel_sum {
public:
    template<typename SRC_T>
    static void apply(SRC_T& s, _SUM_T& sum, _SUM_T& sqsum) {
_ssdm_InlineSelf(0, "");
        sum = sum+(_SUM_T)s;
    }
};

class kernel_avgsdv {
public:
    template<typename SRC_T>
    static void apply(SRC_T& s, _SUM_T& sum, _SUM_T& sqsum) {
_ssdm_InlineSelf(0, "");
        sum=sum+ (_SUM_T)s;
        sqsum=sqsum+ ((_SUM_T)s*(_SUM_T)s);
    }
};



template<typename KERNEL, int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T, typename P0_T, typename P1_T, typename P2_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC1_T>& src1,
            Mat<ROWS, COLS, SRC2_T>& src2,
            Mat<ROWS, COLS, DST_T>& dst,
            P0_T p0=0,
            P1_T p1=0,
            P2_T p2=0)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 349, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 350, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC1_T) & ((1 << 11) - 1))>::name> s1;
    Scalar<((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC2_T) & ((1 << 11) - 1))>::name> s2;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name > d;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src1 >> s1;
            src2 >> s2;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                opr.template apply(s1.val[k], s2.val[k], d.val[k], p0, p1, p2);
            }
            dst << d;
        }
    }
}


template<typename KERNEL, int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC1_T>& src1,
            Mat<ROWS, COLS, SRC2_T>& src2,
            Mat<ROWS, COLS, DST_T>& dst,
            Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
            Mat<ROWS, COLS, DST_T>& dst_ref)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 380, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 381, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC1_T) & ((1 << 11) - 1))>::name> s1;
    Scalar<((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC2_T) & ((1 << 11) - 1))>::name> s2;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d_ref, d;
    Scalar<1, unsigned char> m;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src1 >> s1;
            src2 >> s2;
            mask >> m;
            dst_ref >> d_ref;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                if (m.val[0] == 0) {
                    d.val[k] = d_ref.val[k];
                } else {
                    opr.template apply(s1.val[k], s2.val[k], d.val[k]);
                }
            }
            dst << d;
        }
    }
}



template<typename KERNEL, int ROWS, int COLS, int SRC_T, typename _T, int DST_T, typename P0_T, typename P1_T, typename P2_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC_T>& src,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
            Mat<ROWS, COLS, DST_T>& dst,
            P0_T p0=0,
            P1_T p1=0,
            P2_T p2=0)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 420, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 421, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    _s = scl;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {

                opr.template apply(s.val[k], _s.val[k], d.val[k], p0, p1, p2);

            }
            dst << d;
        }
    }
}


template<typename KERNEL, int ROWS, int COLS, typename _T, int DST_T, typename P0_T, typename P1_T, typename P2_T>
void arithm_pro(
            Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
            Mat<ROWS, COLS, DST_T>& dst,
            P0_T p0=0,
            P1_T p1=0,
            P2_T p2=0)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 453, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 454, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), _T> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    _s = scl;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            _T s = 0;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                opr.template apply(s, _s.val[k], d.val[k], p0, p1, p2);
            }
            dst << d;
        }
    }
}


template<typename KERNEL, int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC_T>& src,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
            Mat<ROWS, COLS, DST_T>& dst,
            Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
            Mat<ROWS, COLS, DST_T>& dst_ref)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 483, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 484, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d_ref, d;
    Scalar<1, unsigned char> m;
    _s = scl;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            mask >> m;
            dst_ref >> d_ref;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                if (m.val[0] == 0) {
                    d.val[k] = d_ref.val[k];
                } else {

                    opr.template apply(s.val[k], _s.val[k], d.val[k]);

                }
            }
            dst << d;
        }
    }
}


template<typename KERNEL, int ROWS, int COLS, int SRC_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC_T>& src,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T>& sum,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T>& sqsum)
{
    KERNEL opr;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 521, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 522, __extension__ __PRETTY_FUNCTION__));
 loop_init: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        sum.val[k] = 0;
        sqsum.val[k] = 0;
    }
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                opr.template apply(s.val[k], sum.val[k], sqsum.val[k]);
            }
        }
    }
}


template<typename KERNEL, int ROWS, int COLS, int SRC_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC_T>& src,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T>& sum,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T>& sqsum,
            int& ncount,
            Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    KERNEL opr;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 553, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 554, __extension__ __PRETTY_FUNCTION__));
 loop_init: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        sum.val[k] = 0;
        sqsum.val[k] = 0;
    }
    ncount = 0;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<1, unsigned char> m;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            mask >> m;
            if (m.val[0]) {
            loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                    opr.template apply(s.val[k], sum.val[k], sqsum.val[k]);
                }
                ncount++;
            }
        }
    }
}


template<typename INTER_SUM_T, int ROWS, int COLS, int SRC_T, int DST_ROWS, int DST_COLS, int DST_T>
void reduce_opr(
        Mat<ROWS, COLS, SRC_T> &src,
        Mat<DST_ROWS, DST_COLS, DST_T> &dst,
        int dim,
        int op=1)
{
    LineBuffer<1,DST_COLS,INTER_SUM_T> dst_buffer[((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)];
_ssdm_SpecArrayPartition( dst_buffer, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( dst_buffer, 2, "COMPLETE", 0, "");
    HLS_SIZE_T rows=src.rows;
    HLS_SIZE_T cols=src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 592, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 593, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),INTER_SUM_T> internal;
 loop_init: for(HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        internal.val[k]=0;
    }
 loop_height: for(HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
        loop_channels: for(HLS_CHANNEL_T k= 0;k< ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++) {
                typename Type<((SRC_T) & ((1 << 11) - 1))>::name src_val;
                src.data_stream[k]>>src_val;
                if(dim==0) {
                    if(i!=0) {
                        internal.val[k]=(INTER_SUM_T)dst_buffer[k].val[i][0];
                    } else {
                        if(op==1||op==2)
                            internal.val[k]=0;
                        else if(op==3||op==4)
                            internal.val[k]=src_val;
                    }
                }
                switch (op) {
                    case 1:
                    internal.val[k]=internal.val[k]+src_val;
                    break;
                    case 2:
                    internal.val[k]=internal.val[k]+src_val;
                    break;
                    case 3:
                    internal.val[k]=(internal.val[k]>(INTER_SUM_T)src_val?internal.val[k]:src_val);
                    break;
                    case 4:
                    internal.val[k]=(internal.val[k]<(INTER_SUM_T)src_val?internal.val[k]:src_val);
                    break;
  }
                if(dim==0) {
                    if(i==rows-1) {
                        if(op==2)
                            dst.data_stream[k] << ((typename Type<((DST_T) & ((1 << 11) - 1))>::name)internal.val[k])/rows;
                        else
                            dst.data_stream[k]<< (typename Type<((DST_T) & ((1 << 11) - 1))>::name)internal.val[k];
                    } else {
                        dst_buffer[k].val[i][0]=internal.val[k];
                    }
                }
            }
            if(dim==1&&j==cols-1) {
            loop_output: for(HLS_CHANNEL_T k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++) {
                    if(op==2) {
                        dst.data_stream[k] << ((typename Type<((DST_T) & ((1 << 11) - 1))>::name)internal.val[k])/cols;
                    } else {
                        dst.data_stream[k] << (typename Type<((DST_T) & ((1 << 11) - 1))>::name)internal.val[k];
                    }
                    internal.val[k]=0;
                }
            }
        }
    }
}



template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void Min(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
# 671 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
    arithm_pro<kernel_min>(src1, src2, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void Max(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
# 688 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
    arithm_pro<kernel_max>(src1, src2, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void MinS(
        Mat<ROWS, COLS, SRC_T>& src,
        _T value,
        Mat<ROWS, COLS, DST_T>& dst)
{






    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl;
 loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        scl.val[k] = (value);
    }
    arithm_pro<kernel_min>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void MaxS(
        Mat<ROWS, COLS, SRC_T>& src,
        _T value,
        Mat<ROWS, COLS, DST_T>& dst)
{






    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl;
 loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        scl.val[k] = (value);
    }
    arithm_pro<kernel_max>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void AddS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{






    arithm_pro<kernel_add>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void AddS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
        Mat<ROWS, COLS, DST_T>& dst_ref)
{






    arithm_pro<kernel_add>(src, scl, dst, mask, dst_ref);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void SubS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{






    arithm_pro<kernel_sub>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void SubS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
        Mat<ROWS, COLS, DST_T>& dst_ref)
{






    arithm_pro<kernel_sub>(src, scl, dst, mask, dst_ref);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void SubRS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{






    arithm_pro<kernel_subR>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void SubRS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
        Mat<ROWS, COLS, DST_T>& dst_ref)
{






    arithm_pro<kernel_subR>(src, scl, dst, mask, dst_ref);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T, typename P_T>
void Mul(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst,
        P_T scale)
{
# 842 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
    arithm_pro<kernel_mul>(src1, src2, dst, scale, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void Mul(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
# 859 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
    arithm_pro<kernel_mul2>(src1, src2, dst, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T, typename P_T>
void AddWeighted(
        Mat<ROWS, COLS, SRC1_T>& src1,
        P_T alpha,
        Mat<ROWS, COLS, SRC2_T>& src2,
        P_T beta,
        P_T gamma,
        Mat<ROWS, COLS, DST_T>& dst)
{
# 879 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
    arithm_pro<kernel_addWeighted>(src1, src2, dst, alpha, beta, gamma);
}

template<int ROWS, int COLS, int SRC_T, int DST_T, typename P_T>
void Scale(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst,
        P_T scale=1.0,
        P_T shift=0.0)
{






    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> scl;
    arithm_pro<kernel_scale>(src, scl, dst, scale, shift, (P_T)0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void Set(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{






    arithm_pro<kernel_set>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, typename _T, int DST_T>
void Set(
        Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{
    arithm_pro<kernel_set>(scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Zero(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s0;
 loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        s0.val[k] = 0;
    }
    arithm_pro<kernel_set>(src, s0, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int DST_T>
void Zero(
        Mat<ROWS, COLS, DST_T>& dst)
{
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> s0;
 loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        s0.val[k] = 0;
    }
    arithm_pro<kernel_set>(s0, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void AbsDiff(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
# 961 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
    arithm_pro<kernel_absdiff>(src1, src2, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Not(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst)
{






    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> scl;
    arithm_pro<kernel_not>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void Cmp(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst,
        int cmp_op)
{
# 994 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
    arithm_pro<kernel_cmp>(src1, src2, dst, cmp_op, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename P_T, int DST_T>
void CmpS(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T value,
        Mat<ROWS, COLS, DST_T>& dst,
        int cmp_op)
{






    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), P_T> scl;
    for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        scl.val[k] = (value);
    }
    arithm_pro<kernel_cmp>(src, scl, dst, cmp_op, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void And(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
# 1032 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
    arithm_pro<kernel_and>(src1, src2, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void And(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
        Mat<ROWS, COLS, DST_T>& dst_ref)
{
# 1051 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
    arithm_pro<kernel_and>(src1, src2, dst, mask, dst_ref);
}

template<typename INTER_SUM_T, int ROWS, int COLS, int SRC_T, int DST_ROWS, int DST_COLS, int DST_T>
void Reduce(
         Mat<ROWS, COLS, SRC_T> &src,
         Mat<DST_ROWS, DST_COLS, DST_T> &dst,
         int dim,
         int op=1)
{
    reduce_opr<INTER_SUM_T>(src, dst, dim, op);
}

template<int ROWS, int COLS, int SRC_T, int DST_T, typename P_T>
void Range(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst,
        P_T start,
        P_T end)
{
# 1079 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1081, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1082, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    _AP_T _dis = end-start;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                d.val[k] = _dis*(i*cols+j)/(rows*cols);
            }
            dst << d;
        }
    }
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> Sum(
        Mat<ROWS, COLS, SRC_T>& src)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = src.rows * src.cols;
    arithm_pro<kernel_sum>(src, sum, sqsum);
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> res;
    for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        res.val[k] = sr_cast<DST_T>(sum.val[k]);
    }
    return res;
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> Avg(
        Mat<ROWS, COLS, SRC_T>& src)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = src.rows * src.cols;
    _AP_T _sum = 0;
    arithm_pro<kernel_sum>(src, sum, sqsum);
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> avg;
    for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        _sum = sum.val[k];
        avg.val[k] = _sum/ncount;
    }
    return avg;
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> Avg(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = 0;
    _AP_T _sum = 0;
    arithm_pro<kernel_sum>(src, sum, sqsum, ncount, mask);
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> avg;
    for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        _sum = sum.val[k];
        avg.val[k] = _sum/ncount;
    }
    return avg;
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
DST_T Mean(
        Mat<ROWS, COLS, SRC_T>& src)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> avg;
    avg = Avg<DST_T>(src);
    return avg.val[0];
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
DST_T Mean(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> avg;
    avg = Avg<DST_T>(src, mask);
    return avg.val[0];
}

template<int ROWS, int COLS, int SRC_T, typename _T>
void AvgSdv(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T>& avg,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T>& sdv)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = src.rows * src.cols;
    _AP_T _sum = 0;
    ap_fixed<64,40,AP_RND> _sqsum = 0;
    arithm_pro<kernel_avgsdv>(src, sum, sqsum);
    for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
        _sum = sum.val[k];
        _sqsum = sqsum.val[k];
        avg.val[k] = _sum/ncount;
        sdv.val[k] = sqrt((double)((_sqsum*ncount)-((_sum)*(_sum))))/ncount;
    }
}

template<int ROWS, int COLS, int SRC_T, typename _T>
void AvgSdv(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T>& avg,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T>& sdv,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = 0;
    _AP_T _sum = 0;
    ap_fixed<64,40,AP_RND> _sqsum = 0;
    arithm_pro<kernel_avgsdv>(src, sum, sqsum, ncount, mask);
    for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
        _sum = sum.val[k];
        _sqsum = sqsum.val[k];
        avg.val[k] = _sum/ncount;
        sdv.val[k] = sqrt((double)((_sqsum*ncount)-((_sum)*(_sum))))/ncount;
    }
}

template<typename S_T>
class MinMaxLoc_opr
{
public:
template<int ROWS, int COLS, int SRC_T, typename P_T>
static void get_max_min(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc)
{
_ssdm_InlineSelf(0, "");




    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1226, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1227, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Name<typename Type<((SRC_T) & ((1 << 11) - 1))>::name> type_val;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _min_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name) type_val._max;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _max_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name) type_val._min;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            if (s.val[0] < _min_val) {
                _min_val = s.val[0];
                min_loc.x = j;
                min_loc.y = i;
            }
            if (s.val[0] > _max_val) {
                _max_val = s.val[0];
                max_loc.x = j;
                max_loc.y = i;
            }
        }
    }
    *min_val = sr_cast<P_T>(_min_val);
    *max_val = sr_cast<P_T>(_max_val);
}

template<int ROWS, int COLS, int SRC_T, typename P_T>
static void get_max_min(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
_ssdm_InlineSelf(0, "");




    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1269, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1270, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<1, unsigned char> m;
    Name<typename Type<((SRC_T) & ((1 << 11) - 1))>::name> type_val;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _min_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name)type_val._max;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _max_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name)type_val._min;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            mask >> m;
            if (m.val[0]) {
                if (s.val[0] < (_min_val)) {
                    _min_val = s.val[0];
                    min_loc.x = j;
                    min_loc.y = i;
                }
                if (s.val[0] > (_max_val)) {
                    _max_val = s.val[0];
                    max_loc.x = j;
                    max_loc.y = i;
                }
            }
        }
    }
    *min_val = sr_cast<P_T>(_min_val);
    *max_val = sr_cast<P_T>(_max_val);
}

};

template< >
class MinMaxLoc_opr<float>
{
public:
template<int ROWS, int COLS, int SRC_T, typename P_T>
static void get_max_min(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc)
{
_ssdm_InlineSelf(0, "");




    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1321, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1322, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Name<typename Type<((SRC_T) & ((1 << 11) - 1))>::name> type_val;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _min_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name) type_val._max;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _max_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name) type_val._min;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            fp_struct<float> min_fp(_min_val);
         fp_struct<float> max_fp(_max_val);
         fp_struct<float> s_fp(s.val[0]);
            if (min_fp.sign==1 && s_fp.sign==1) {
                if(s_fp.to_int() > min_fp.to_int()) {
                    _min_val = s.val[0];
                    min_loc.x = j;
                    min_loc.y = i;
                }
            }
            else {
                if(s_fp.to_int() < min_fp.to_int()) {
                    _min_val = s.val[0];
                    min_loc.x = j;
                    min_loc.y = i;
                }
            }

            if (max_fp.sign==1 && s_fp.sign==1) {
                if(s_fp.to_int() < max_fp.to_int()) {
                    _max_val = s.val[0];
                    max_loc.x = j;
                    max_loc.y = i;
                }
            }
            else {
                if(s_fp.to_int() > max_fp.to_int()) {
                    _max_val = s.val[0];
                    max_loc.x = j;
                    max_loc.y = i;
                }
            }
        }
    }
    *min_val = sr_cast<P_T>(_min_val);
    *max_val = sr_cast<P_T>(_max_val);
}

template<int ROWS, int COLS, int SRC_T, typename P_T>
static void get_max_min(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
_ssdm_InlineSelf(0, "");




    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1386, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1387, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<1, unsigned char> m;
    Name<typename Type<((SRC_T) & ((1 << 11) - 1))>::name> type_val;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _min_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name)type_val._max;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _max_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name)type_val._min;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            mask >> m;
            fp_struct<float> min_fp(_min_val);
         fp_struct<float> max_fp(_max_val);
         fp_struct<float> s_fp(s.val[0]);
            if (m.val[0]) {
                if (min_fp.sign==1 && s_fp.sign==1) {
                    if(s_fp.to_int() > min_fp.to_int()) {
                        _min_val = s.val[0];
                        min_loc.x = j;
                        min_loc.y = i;
                    }
                }
                else {
                    if(s_fp.to_int() < min_fp.to_int()) {
                        _min_val = s.val[0];
                        min_loc.x = j;
                        min_loc.y = i;
                    }
                }

                if (max_fp.sign==1 && s_fp.sign==1) {
                    if(s_fp.to_int() < max_fp.to_int()) {
                        _max_val = s.val[0];
                        max_loc.x = j;
                        max_loc.y = i;
                    }
                }
                else {
                    if(s_fp.to_int() > max_fp.to_int()) {
                        _max_val = s.val[0];
                        max_loc.x = j;
                        max_loc.y = i;
                    }
                }
            }
        }
    }
    *min_val = sr_cast<P_T>(_min_val);
    *max_val = sr_cast<P_T>(_max_val);
}

};

template<int ROWS, int COLS, int SRC_T, typename P_T>
void MinMaxLoc(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc)
{
    MinMaxLoc_opr< typename Type<((SRC_T) & ((1 << 11) - 1))>::name >::get_max_min(src, min_val, max_val, min_loc, max_loc);
}

template<int ROWS, int COLS, int SRC_T, typename P_T>
void MinMaxLoc(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    MinMaxLoc_opr< typename Type<((SRC_T) & ((1 << 11) - 1))>::name >::get_max_min(src, min_val, max_val, min_loc, max_loc, mask);
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Threshold(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst,
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name thresh,
        typename Type<((DST_T) & ((1 << 11) - 1))>::name maxval,
        int thresh_type)
{
# 1480 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1482, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1483, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _thresh = sr_cast<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>(thresh);
    typename Type<((DST_T) & ((1 << 11) - 1))>::name _maxval = sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(maxval);
    typename Type<((DST_T) & ((1 << 11) - 1))>::name _zero = 0;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                switch (thresh_type) {
                    case 0:
                    d.val[k] = (s.val[k] > _thresh) ? (_maxval) : _zero;
                    break;
                    case 1:
                    d.val[k] = (s.val[k] > _thresh) ? _zero : (_maxval);
                    break;
                    case 2:
                    d.val[k] = (s.val[k] > _thresh) ? (_thresh) : s.val[k];
                    break;
                    case 3:
                    d.val[k] = (s.val[k] > _thresh) ? (s.val[k]) : _zero;
                    break;
                    case 4:
                    d.val[k] = (s.val[k] > _thresh) ? _zero : (s.val[k]);
                    break;
                    default:
                    d.val[k] = s.val[k];
                    break;
                }
            }
            dst << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T>
void Consume(
        Mat<ROWS, COLS, SRC_T>& src)
{
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1527, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1528, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Duplicate(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst1,
        Mat<ROWS, COLS, DST_T>& dst2)
{







    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1554, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1555, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            dst1 << s;
            dst2 << s;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Split(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst0,
        Mat<ROWS, COLS, DST_T>& dst1)
{
# 1582 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1586, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1587, __extension__ __PRETTY_FUNCTION__));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            d.val[0] = s.val[0]; dst0 << d;
            d.val[0] = s.val[1]; dst1 << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Split(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst0,
        Mat<ROWS, COLS, DST_T>& dst1,
        Mat<ROWS, COLS, DST_T>& dst2)
{
# 1615 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1619, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1620, __extension__ __PRETTY_FUNCTION__));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            d.val[0] = s.val[0]; dst0 << d;
            d.val[0] = s.val[1]; dst1 << d;
            d.val[0] = s.val[2]; dst2 << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Split(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst0,
        Mat<ROWS, COLS, DST_T>& dst1,
        Mat<ROWS, COLS, DST_T>& dst2,
        Mat<ROWS, COLS, DST_T>& dst3)
{
# 1651 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1655, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1656, __extension__ __PRETTY_FUNCTION__));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            d.val[0] = s.val[0]; dst0 << d;
            d.val[0] = s.val[1]; dst1 << d;
            d.val[0] = s.val[2]; dst2 << d;
            d.val[0] = s.val[3]; dst3 << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Merge(
        Mat<ROWS, COLS, SRC_T>& src0,
        Mat<ROWS, COLS, SRC_T>& src1,
        Mat<ROWS, COLS, DST_T>& dst)
{
# 1684 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1688, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1689, __extension__ __PRETTY_FUNCTION__));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src0 >> s; d.val[0] = s.val[0];
            src1 >> s; d.val[1] = s.val[0];
            dst << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Merge(
        Mat<ROWS, COLS, SRC_T>& src0,
        Mat<ROWS, COLS, SRC_T>& src1,
        Mat<ROWS, COLS, SRC_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
# 1717 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1721, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1722, __extension__ __PRETTY_FUNCTION__));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src0 >> s; d.val[0] = s.val[0];
            src1 >> s; d.val[1] = s.val[0];
            src2 >> s; d.val[2] = s.val[0];
            dst << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Merge(
        Mat<ROWS, COLS, SRC_T>& src0,
        Mat<ROWS, COLS, SRC_T>& src1,
        Mat<ROWS, COLS, SRC_T>& src2,
        Mat<ROWS, COLS, SRC_T>& src3,
        Mat<ROWS, COLS, DST_T>& dst)
{
# 1753 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h"
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1757, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_arithm.h", 1758, __extension__ __PRETTY_FUNCTION__));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src0 >> s; d.val[0] = s.val[0];
            src1 >> s; d.val[1] = s.val[0];
            src2 >> s; d.val[2] = s.val[0];
            src3 >> s; d.val[3] = s.val[0];
            dst << d;
        }
    }
}

}
# 62 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_video.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h" 1
# 91 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h"
namespace hls {
# 144 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h"
class erode_kernel
{
    public:
    template<typename SRC_T,typename DST_T,typename FILTER_T, int F_HEIGHT, int F_WIDTH>
    void apply(Window<F_HEIGHT,F_WIDTH,FILTER_T> &_kernel_filter,
            Window<F_HEIGHT,F_WIDTH,SRC_T> &_kernel_pixel,
            DST_T &out)
    {
_ssdm_InlineSelf(0, "");
        out = hls::numeric_limits<DST_T>::max();
    loop_height: for( int m=0;m< F_HEIGHT;m++)
        {
        loop_width: for( int n=0;n<F_WIDTH;n++)
            {
                DST_T temp;
                if(_kernel_filter.val[F_HEIGHT-m-1][F_WIDTH-1-n]>0)
                {
                    temp=_kernel_pixel.val[F_HEIGHT-m-1][(F_WIDTH-1-n)];
                    if (temp<out)
                        out=temp;
                }
            }
        }
    }
};

class dilate_kernel
{
    public:
    template<typename SRC_T,typename DST_T,typename FILTER_T, int F_HEIGHT, int F_WIDTH>
    void apply(Window<F_HEIGHT,F_WIDTH,FILTER_T> &_kernel_filter,
            Window<F_HEIGHT,F_WIDTH,SRC_T> &_kernel_pixel,
            DST_T &out)
    {
_ssdm_InlineSelf(0, "");
    out = hls::numeric_limits<DST_T>::min();
    loop_height: for( int m=0;m< F_HEIGHT;m++)
        {
        loop_width: for( int n=0;n<F_WIDTH;n++)
            {
                DST_T temp;
                if(_kernel_filter.val[F_HEIGHT-m-1][F_WIDTH-1-n]>0)
                {
                    temp=_kernel_pixel.val[F_HEIGHT-m-1][(F_WIDTH-1-n)];
                    if (temp>out)
                        out=temp;
                }
            }
        }
    }
};


template <typename SRC_T, typename FILTER_T, int SIZE=0>
struct filter2d_traits {
    typedef typename fixed_type<SRC_T>::T SRC_CAST_T;
    typedef typename fixed_type<FILTER_T>::T FILTER_CAST_T;
    typedef typename x_traits<SRC_CAST_T, FILTER_CAST_T >::MULT_T MULT_T;
    typedef typename x_traits_d<MULT_T, SIZE>::ACCUM_T ACCUM_T;
    typedef typename x_traits<ACCUM_T, ap_fixed<1,1> >::MULT_T TEMP_T;
};

template <int SIZE , int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
struct filter2d_traits<float, ap_fixed<W, I, _AP_Q, _AP_O>, SIZE> {
    typedef float SRC_CAST_T;
    typedef float FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};
template <int SIZE, int W>
struct filter2d_traits<float, ap_int<W>, SIZE> {
    typedef float SRC_CAST_T;
    typedef ap_int<W> FILTER_CAST_T;
    typedef float MULT_T;
    typedef float ACCUM_T;
    typedef float TEMP_T;
};
template <int SIZE>
struct filter2d_traits<unsigned char,float, SIZE> {
    typedef unsigned char SRC_CAST_T;
    typedef float FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<float, unsigned char, SIZE> {
    typedef float SRC_CAST_T;
    typedef unsigned char FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<float, float, SIZE> {
    typedef float SRC_CAST_T;
    typedef float FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<double, double, SIZE> {
    typedef double SRC_CAST_T;
    typedef double FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<float, double, SIZE> {
    typedef float SRC_CAST_T;
    typedef double FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<double, float, SIZE> {
    typedef double SRC_CAST_T;
    typedef float FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};

class filter2d_kernel
{
    public:
    template<typename SRC_T,typename DST_T,typename FILTER_T, int F_HEIGHT, int F_WIDTH>
    void apply(Window<F_HEIGHT,F_WIDTH,FILTER_T> &_kernel_filter,
               Window<F_HEIGHT,F_WIDTH,SRC_T> &_kernel_pixel,
               DST_T &out,
               const bool cast)
    {
_ssdm_InlineSelf(0, "");
     typename filter2d_traits<SRC_T, FILTER_T>::SRC_CAST_T src_v;
     typename filter2d_traits<SRC_T, FILTER_T>::FILTER_CAST_T filter_v;
        typename filter2d_traits<SRC_T, FILTER_T, F_HEIGHT*F_WIDTH-1>::ACCUM_T sum=0;
        typename filter2d_traits<SRC_T, FILTER_T>::MULT_T temp=0;
        loop_height: for(int m = 0; m < F_HEIGHT; m++) {
            loop_width: for(int n = 0; n < F_WIDTH; n++) {
                src_v = _kernel_pixel.val[F_HEIGHT-m-1][F_WIDTH-1-n];
                filter_v = _kernel_filter.val[m][n];
                temp = src_v * filter_v;
                sum = sum + temp;
            }
        }
        out=sum;
    }

    template<typename SRC_T,typename DST_T,typename FILTER_T, int F_HEIGHT, int F_WIDTH>
    void apply(Window<F_HEIGHT,F_WIDTH,FILTER_T> &_kernel_filter,
               Window<F_HEIGHT,F_WIDTH,SRC_T> &_kernel_pixel,
               DST_T &out)
    {
_ssdm_InlineSelf(0, "");
        typename filter2d_traits<SRC_T, FILTER_T, F_HEIGHT*F_WIDTH-1>::ACCUM_T sum=0;
     apply(_kernel_filter,_kernel_pixel,sum,true);
     out=sr_cast<DST_T>(sum);
    }
};

template <typename SRC_T,typename SIZE_T,typename POINT_T,int HEIGHT,int WIDTH>
void getStructuringElement(
        int shape,
        Size_<SIZE_T> ksize,
        Point_<POINT_T> anchor,
        Window<HEIGHT,WIDTH,SRC_T> &result)
{
_ssdm_InlineSelf(0, "");
    int i, j;
    int r = 0, c = 0;
    ap_fixed<31,11,AP_RND> inv_r2 = 0;

    if( ksize.width==1&&ksize.height == 1 )
        shape = MORPH_RECT;

    if( shape == MORPH_ELLIPSE )
    {
        r = ksize.height/2;
        c = ksize.width/2;
        if(r!=0)
        {
            inv_r2 =(ap_fixed<31,11,AP_RND>) 1/(r*r) ;
        }
        else
            inv_r2=0;
    }
 loop_height: for( i = 0; i < ksize.height; i++ )
    {
        int j1 = 0, j2 = 0;
        if( shape == MORPH_RECT || (shape ==MORPH_CROSS && i == anchor.y) )
            j2 = ksize.width;
        else if( shape == MORPH_CROSS ) {
            j1 = anchor.x;
            j2 = j1 + 1;
        } else
        {
            int dy = i - r;
            if( abs(dy) <= r )
            {
     ap_fixed<12,12,AP_RND> dxx = (c*::hls::sqrt(double(((r-dy)*(r+dy))*inv_r2)));
                int dx=dxx;
                j1 = (c - dx)> 0?( c - dx):0;
                j2 = (c + dx + 1)< ksize.width?(c + dx + 1):ksize.width;
            }
        }
    loop_width: for( j = 0; j < ksize.width; j++ ) {
            if(shape == MORPH_RECT || (j >= j1 && j < j2)) {
                result.val[i][j] = 1;
            } else {
                result.val[i][j] = 0;
            }
        }
    }
}


template<typename P_T,typename W_T,int W_HEIGHT, int W_WIDTH,typename BUF_T,int BUF_HEIGHT,int BUF_WIDTH >
void fill_pixelkernel(
        LineBuffer<BUF_HEIGHT,BUF_WIDTH,BUF_T> &col_buf,
        Window<W_HEIGHT,W_WIDTH,W_T> &kernel,
        Point_<P_T> curp,
        int borderType, int ref,
        int imgheight,int constval=0, bool forceconst = false)
{
_ssdm_InlineSelf(0, "");
 loop_fill: for(int buf_row= 0;buf_row<W_HEIGHT;buf_row++)
    {
        int locy;
        int t = borderInterpolate(curp.y,imgheight,borderType);
        locy = ref - t;
        curp.y--;
        kernel.val[buf_row][0] = (t < 0 || forceconst) ? constval : col_buf.val[locy][0];
    }
}

template<typename OPR_KERNEL, typename BORDERMODE>
class filter_opr {
public:
template<int SRC_T, int DST_T, typename KN_T, typename POINT_T,
         int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &kernel,
        Point_<POINT_T> _anchor,
        int rows,int cols)
    {
_ssdm_InlineSelf(0, "");
    OPR_KERNEL fk_opr;

    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_win[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    LineBuffer<2*K_HEIGHT,IMG_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];


    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> right_border_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    (static_cast <bool> (rows >= 8) ? void (0) : __assert_fail ("rows >= 8", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 407, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols >= 8) ? void (0) : __assert_fail ("cols >= 8", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 408, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (rows <= IMG_HEIGHT) ? void (0) : __assert_fail ("rows <= IMG_HEIGHT", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 409, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= IMG_WIDTH) ? void (0) : __assert_fail ("cols <= IMG_WIDTH", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 410, __extension__ __PRETTY_FUNCTION__));

_ssdm_SpecArrayPartition( col_buf, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( &kernel, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_win, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( k_buf, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( right_border_buf, 0, "COMPLETE", 0, "");

    Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=K_WIDTH;
    kernel_size.height=K_HEIGHT;
    normalizeAnchor(anchor,kernel_size);
    (static_cast <bool> (anchor.x >= 0) ? void (0) : __assert_fail ("anchor.x >= 0", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 425, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (anchor.x <= K_WIDTH-1) ? void (0) : __assert_fail ("anchor.x <= K_WIDTH-1", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 426, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (anchor.y >= 0) ? void (0) : __assert_fail ("anchor.y >= 0", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 427, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (anchor.y <= K_HEIGHT-1) ? void (0) : __assert_fail ("anchor.y <= K_HEIGHT-1", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 428, __extension__ __PRETTY_FUNCTION__));

    int start_row;
    int row_index;
    int col_index;
    int stop_row;
    get_parameters<K_HEIGHT, K_WIDTH>(rows, anchor, start_row, stop_row, row_index, col_index);
    (static_cast <bool> (start_row >= 0) ? void (0) : __assert_fail ("start_row >= 0", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 435, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (start_row <= K_HEIGHT-1) ? void (0) : __assert_fail ("start_row <= K_HEIGHT-1", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 436, __extension__ __PRETTY_FUNCTION__));

    int heightloop= rows+start_row+1;
    int widthloop = cols+K_WIDTH-1;
    Point_<int> ImagLoc;
    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);

 loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
    loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {

_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++)
                {
                    ImagLoc.x=j-anchor.x;
                    int x = borderInterpolate(ImagLoc.x, cols, BORDERMODE::value);
                    (static_cast <bool> (x < cols) ? void (0) : __assert_fail ("x < cols", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 453, __extension__ __PRETTY_FUNCTION__));


                    for(int buf_row=0; buf_row<K_HEIGHT; buf_row++) {
                        if((i<stop_row) && (ImagLoc.x>=cols)) {
                            col_buf[k](buf_row,0)=right_border_buf[k](buf_row,cols-1-x);
                        } else {
                            col_buf[k](buf_row,0)=k_buf[k](K_HEIGHT+buf_row,x);
                        }
                    }


                    if(ImagLoc.x >= 0 && ImagLoc.x < cols) {
                        if(i<=start_row) {
                            typename Type<((SRC_T) & ((1 << 11) - 1))>::name src_temp;
                            _src.data_stream[k] >> src_temp;
                            for(int buf_row=2*K_HEIGHT-1; buf_row>=0; buf_row--) {
                                int y = borderInterpolate(2*K_HEIGHT-1-anchor.y-buf_row, rows, BORDERMODE::value);
                                if(y==i) {
                                    k_buf[k](buf_row,x)=src_temp;
                                }
                            }
                        } else if(i<stop_row) {


                            for(int buf_row=0; buf_row<K_HEIGHT; buf_row++) {
                                for(int buf_col=K_WIDTH-1; buf_col>0; buf_col--) {
                                    if(buf_col <= col_index) {
                                         right_border_buf[k](buf_row,buf_col)=right_border_buf[k](buf_row,buf_col-1);
                                    }
                                }
                                right_border_buf[k](buf_row,0)=col_buf[k](buf_row,0);
                            }

                            for(int buf_row=2*K_HEIGHT-1; buf_row>0; buf_row--) {
                                if(buf_row>row_index) {
                                    k_buf[k](buf_row,x)=k_buf[k](buf_row-1,x);
                                }
                            }
                            if(i<rows) {
                                _src.data_stream[k] >> k_buf[k](row_index,x);
                            }
                        }
                    }


              src_kernel_win[k].shift_right();

                    for(int buf_row=0; buf_row<K_HEIGHT; buf_row++){
                        if(i<=stop_row) {
                            src_kernel_win[k](buf_row,0)=col_buf[k](buf_row,0);
                        }
                        else {
                            int y = borderInterpolate((i-(stop_row-rows+1)-buf_row), rows, BORDERMODE::value);
                            src_kernel_win[k](buf_row,0)=col_buf[k](rows-1-y,0);
                        }
                    }


                    if(i > start_row && j >= K_WIDTH-1) {
                  typename Type<((DST_T) & ((1 << 11) - 1))>::name temp;
                        fk_opr.apply(kernel,src_kernel_win[k],temp);
                        _dst.data_stream[k]<<temp;
                    }
                }
            }
        }
    }

private:
template<int K_HEIGHT, int K_WIDTH, typename POINT_T>
static void get_parameters(int rows, Point_<POINT_T> anchor, int &start_row, int &stop_row, int &row_index, int &col_index)
    {
_ssdm_InlineSelf(0, "");
        switch(BORDERMODE::value) {
            case BORDER_REPLICATE::value:
                start_row=K_HEIGHT-1-anchor.y;
                row_index=K_HEIGHT;
                col_index=0;
                stop_row=rows;
                break;
            case BORDER_REFLECT::value:
                col_index=K_WIDTH-1-anchor.x-1;
                if(anchor.y<=K_HEIGHT/2) {
                    start_row=K_HEIGHT-1-anchor.y;
                    row_index=K_HEIGHT;
                    stop_row=rows;
                } else {
                    start_row=anchor.y-1;
                    row_index=2*K_HEIGHT-2*anchor.y;
                    stop_row=rows+K_HEIGHT-row_index;
                }
                break;
            case BORDER_REFLECT_101::value:
                col_index=K_WIDTH-1-anchor.x;
                if(anchor.y<=K_HEIGHT/2) {
                    start_row=K_HEIGHT-1-anchor.y;
                    row_index=K_HEIGHT;
                    stop_row=rows;
                } else {
                    start_row=anchor.y;
                    row_index=2*K_HEIGHT-2*anchor.y-1;
                    stop_row=rows+K_HEIGHT-row_index;
                }
                break;
            default:
                col_index=K_WIDTH-1-anchor.x;
                if(anchor.y<=K_HEIGHT/2) {
                    start_row=K_HEIGHT-1-anchor.y;
                    row_index=K_HEIGHT;
                    stop_row=rows;
                } else {
                    start_row=anchor.y;
                    row_index=2*K_HEIGHT-2*anchor.y-1;
                    stop_row=rows+K_HEIGHT-row_index;
                }
                break;
        }
    }

};

template<typename OPR_KERNEL>
class filter_opr<OPR_KERNEL, BORDER_CONSTANT> {
public:
template<int SRC_T, int DST_T, typename KN_T, typename POINT_T,
         int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
    static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &kernel,
        Point_<POINT_T> _anchor,
        int rows,int cols)
{
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name fillvalue = 0;
_ssdm_InlineSelf(0, "");
    OPR_KERNEL fk_opr;

    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_win[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    LineBuffer<K_HEIGHT,IMG_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    Window<1,K_HEIGHT,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

_ssdm_SpecArrayPartition( &kernel, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_win, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( k_buf, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( col_buf, 0, "COMPLETE", 0, "");

    (static_cast <bool> (rows <= IMG_HEIGHT) ? void (0) : __assert_fail ("rows <= IMG_HEIGHT", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 602, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= IMG_WIDTH) ? void (0) : __assert_fail ("cols <= IMG_WIDTH", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 603, __extension__ __PRETTY_FUNCTION__));


    Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=K_WIDTH;
    kernel_size.height=K_HEIGHT;
    normalizeAnchor(anchor,kernel_size);
    (static_cast <bool> (anchor.x >= 0) ? void (0) : __assert_fail ("anchor.x >= 0", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 613, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (anchor.x <= K_WIDTH-1) ? void (0) : __assert_fail ("anchor.x <= K_WIDTH-1", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 614, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (anchor.y >= 0) ? void (0) : __assert_fail ("anchor.y >= 0", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 615, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (anchor.y <= K_HEIGHT-1) ? void (0) : __assert_fail ("anchor.y <= K_HEIGHT-1", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 616, __extension__ __PRETTY_FUNCTION__));

    int start_row=K_HEIGHT-1-anchor.y;
    int start_col=K_WIDTH-1-anchor.x;
    int heightloop= rows+start_row;
    int widthloop = cols+start_col;
    Point_<int> ImagLoc;
    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);

 loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
    loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++)
                {
                    typename Type<((SRC_T) & ((1 << 11) - 1))>::name src_temp;
                    if((j<cols) && (i<rows)) {
                        _src.data_stream[k] >> src_temp;
                    }

                    if(j<cols) {
                        for(int buf_row=K_HEIGHT-1; buf_row>0; buf_row--) {
                            col_buf[k](0,buf_row)=k_buf[k](buf_row-1,j);
                        }
                    } else {
                        for(int buf_row=K_HEIGHT-1; buf_row>=0; buf_row--) {
                            col_buf[k](0,buf_row)=fillvalue;
                        }
                    }

                    if(j<cols) {
                        if(i==0) {
                            for(int buf_row=K_HEIGHT-1; buf_row>0; buf_row--) {
                                k_buf[k](buf_row,j)=fillvalue;
                                col_buf[k](0,buf_row)=fillvalue;
                            }
                            k_buf[k](0,j)=src_temp;
                            col_buf[k](0,0)=src_temp;
                        } else {
                            if(i>=rows) {
                                src_temp=fillvalue;
                            }
                            k_buf[k].shift_down(j);
                            k_buf[k](0,j)=src_temp;
                            col_buf[k](0,0)=src_temp;
                        }
                    }

                    if(j==0) {
                        for(int buf_row=K_HEIGHT-1; buf_row>=0; buf_row--) {
                            for(int buf_col=K_WIDTH-1; buf_col>0; buf_col--) {
                                src_kernel_win[k](buf_row,buf_col)=fillvalue;
                            }
                        }
                    } else {
                  src_kernel_win[k].shift_right();
                    }
              src_kernel_win[k].insert_right(col_buf[k].val[0]);


                    if(i >= start_row && j >= start_col) {
                  typename Type<((DST_T) & ((1 << 11) - 1))>::name temp;
                        fk_opr.apply(kernel,src_kernel_win[k],temp);
                        _dst.data_stream[k]<<temp;
                    }
                }
            }
        }
    }
};

template<typename OPR_KERNEL, typename BORDERMODE>
class sepfilter_opr {
private:

template<int CH, int IMG_HEIGHT, int IMG_WIDTH, int SRC_T, typename DST_T,
         typename KNY_T, typename POINT_T, int K_HEIGHT>
static void column_filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        stream<DST_T> (&_dst)[CH],
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
        int cols)
{
    OPR_KERNEL fk_opr;

    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_winY[CH];

    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[CH];


    LineBuffer<2*K_HEIGHT,IMG_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[CH];

    (static_cast <bool> (rows >= 8) ? void (0) : __assert_fail ("rows >= 8", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 710, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols >= 8) ? void (0) : __assert_fail ("cols >= 8", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 711, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (rows <= IMG_HEIGHT) ? void (0) : __assert_fail ("rows <= IMG_HEIGHT", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 712, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= IMG_WIDTH) ? void (0) : __assert_fail ("cols <= IMG_WIDTH", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 713, __extension__ __PRETTY_FUNCTION__));

_ssdm_SpecArrayPartition( col_buf, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( &kernelY, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_winY, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( k_buf, 1, "COMPLETE", 0, "");

    Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=1;
    kernel_size.height=K_HEIGHT;
    normalizeAnchor(anchor,kernel_size);

    int start_row;
    int row_index;
    int stop_row;

    switch(BORDERMODE::value) {
        case BORDER_REPLICATE::value:
            start_row=K_HEIGHT-1-anchor.y;
            row_index=K_HEIGHT;
            stop_row=rows;
            break;
        case BORDER_REFLECT::value:
            start_row = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT-1-anchor.y : anchor.y-1;
            row_index = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT : 2*K_HEIGHT-2*anchor.y;
            stop_row = (anchor.y<=K_HEIGHT/2) ? rows : rows+K_HEIGHT-row_index;
            break;
        case BORDER_REFLECT_101::value:
            start_row = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT-1-anchor.y : anchor.y;
            row_index = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT : 2*K_HEIGHT-2*anchor.y-1;
            stop_row = (anchor.y<=K_HEIGHT/2) ? rows : rows+K_HEIGHT-row_index;
            break;
        default:
            start_row = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT-1-anchor.y : anchor.y;
            row_index = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT : 2*K_HEIGHT-2*anchor.y-1;
            stop_row = (anchor.y<=K_HEIGHT/2) ? rows : rows+K_HEIGHT-row_index;
            break;
    }

    int heightloop = rows+start_row+1;
    int widthloop = cols;

    loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
        loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {

    _ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
    _ssdm_SpecLoopFlatten(1, "");
    _ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            channelloop: for(HLS_CHANNEL_T k= 0; k < CH; k++)
            {


                for(int buf_row=0; buf_row<K_HEIGHT; buf_row++) {
                    col_buf[k](buf_row,0)=k_buf[k](2*K_HEIGHT-1-buf_row,j);
                }

                typename Type<((SRC_T) & ((1 << 11) - 1))>::name src_temp;
                if (i<rows) {
                    _src.data_stream[k] >> src_temp;
                }

                if(i<=start_row) {
                    for(int buf_row=2*K_HEIGHT-1; buf_row>=0; buf_row--) {
                        int y = borderInterpolate(2*K_HEIGHT-1-anchor.y-buf_row, rows, BORDERMODE::value);
                        if(y==i) {
                            k_buf[k](buf_row,j)=src_temp;
                        }
                    }
                } else if(i<stop_row) {
                    for(int buf_row=2*K_HEIGHT-1; buf_row>0; buf_row--) {
                        if(buf_row>row_index) {
                            k_buf[k](buf_row,j)=k_buf[k](buf_row-1,j);
                        }
                    }
                    if(i<rows) {
                        k_buf[k](row_index,j) = src_temp;
                    }
                }

                for(int buf_row=0; buf_row<K_HEIGHT; buf_row++){
                    if(i<=stop_row) {
                        src_kernel_winY[k](buf_row,0)=col_buf[k](K_HEIGHT-1-buf_row,0);
                    }
                    else {
                        int y = borderInterpolate(i-(stop_row-rows+1)-buf_row, rows, BORDERMODE::value);


                        int index = (rows-K_HEIGHT>0) ? rows-K_HEIGHT : 0;
                        src_kernel_winY[k](buf_row,0)=col_buf[k](y-index,0);
                    }
                }

                if(i > start_row) {
                    DST_T tempY;
                    fk_opr.apply(kernelY,src_kernel_winY[k],tempY,false);
                    _dst[k]<<tempY;
                }
            }
        }
    }
}

template<int CH, int IMG_HEIGHT, int IMG_WIDTH, typename SRC_T, int DST_T,
         typename KNX_T, typename POINT_T, int K_WIDTH, typename SCALE_T>
static void row_filter(
        stream<SRC_T> (&_src)[CH],
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Point_<POINT_T> _anchor,
        int rows,
        int cols,
        SCALE_T scale)
{
    OPR_KERNEL fk_opr;

    Window<1,K_WIDTH,SRC_T> src_kernel_winX[CH];

    SRC_T src_kernel_winX_temp[CH][K_WIDTH];


    Window<1,2*K_WIDTH,SRC_T> row_buf[CH];




    LineBuffer<1,K_WIDTH,SRC_T> l_border_buf[CH];
    LineBuffer<1,K_WIDTH,SRC_T> r_border_buf[CH];

    (static_cast <bool> (rows >= 8) ? void (0) : __assert_fail ("rows >= 8", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 844, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols >= 8) ? void (0) : __assert_fail ("cols >= 8", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 845, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (rows <= IMG_HEIGHT) ? void (0) : __assert_fail ("rows <= IMG_HEIGHT", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 846, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= IMG_WIDTH) ? void (0) : __assert_fail ("cols <= IMG_WIDTH", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 847, __extension__ __PRETTY_FUNCTION__));

_ssdm_SpecArrayPartition( &kernelX, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_winX, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_winX_temp, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( row_buf, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( l_border_buf, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( r_border_buf, 1, "COMPLETE", 0, "");

    Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=K_WIDTH;
    kernel_size.height=1;
    normalizeAnchor(anchor,kernel_size);



    int left_border;

    int right_border;

    int index;

    int start;

    int stop;

    switch(BORDERMODE::value) {
        case BORDER_REPLICATE::value:
            left_border = 0;
            right_border = cols-1;
            index = anchor.x;
            break;
        case BORDER_REFLECT::value:
            left_border = (anchor.x-1>0) ? anchor.x-1: 0;
            right_border = cols-(K_WIDTH-anchor.x)+1;
            index = (2*anchor.x-1>0) ? 2*anchor.x-1: 0;
            break;
        case BORDER_REFLECT_101::value:
            left_border = anchor.x;
            right_border = cols-(K_WIDTH-anchor.x);
            index = 2*anchor.x;
            break;
        default:
            left_border = anchor.x;
            right_border = cols-(K_WIDTH-anchor.x);
            index = 2*anchor.x;
            break;
    }


    right_border = right_border<0 ? 0 : right_border;
    start = K_WIDTH+left_border;
    stop = cols+index;
    int heightloop= rows;
    int widthloop = cols+start;
    SRC_T src_temp;

    loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
        loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {

    _ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
    _ssdm_SpecLoopFlatten(1, "");
    _ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            channelloop: for(HLS_CHANNEL_T k=0; k<CH; k++)
            {
                int x = borderInterpolate(j-index-1, cols, BORDERMODE::value);

                if (j<cols)
                    _src[k] >> src_temp;


                for (int buf_col=K_WIDTH-1; buf_col>0; buf_col--) {
                    src_kernel_winX_temp[k][buf_col] = src_kernel_winX_temp[k][buf_col-1];
                }

                if (j<=left_border) {
                    l_border_buf[k](0,j) = src_temp;
                }
                if ((j>=right_border) && (j<cols)) {
                    r_border_buf[k](0,cols-1-j) = src_temp;
                }

                if ((j>left_border) && (j<=index)) {

                    src_kernel_winX_temp[k][0] = l_border_buf[k](0,x);
                } else if (j<=stop) {

                    src_kernel_winX_temp[k][0] = row_buf[k](0,0);
                } else {

                    src_kernel_winX_temp[k][0] = r_border_buf[k](0,cols-1-x);
                }

                for (int buf_col=0; buf_col<2*K_WIDTH; buf_col++) {
                    if (buf_col<index)
                        row_buf[k](0,buf_col) = row_buf[k](0,buf_col+1);
                }
                row_buf[k](0,index) = src_temp;

                for (int buf_col=0; buf_col<K_WIDTH; buf_col++) {
                    src_kernel_winX[k](0,buf_col) = src_kernel_winX_temp[k][buf_col];
                }

                if(j >= start) {
                    typedef typename filter2d_traits<SRC_T, KNX_T, K_WIDTH*1-1>::TEMP_T tempX_T;
                    tempX_T tempX;
                    fk_opr.apply(kernelX,src_kernel_winX[k],tempX,false);
                    _dst.data_stream[k]<<sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(tempX*scale);
                }
            }
        }
    }
}

public:
template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
         int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH, typename SCALE_T>
static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
     int cols,
     SCALE_T scale)

{
_ssdm_InlineSelf(0, "");
_ssdm_op_SpecDataflowPipeline(-1, 0, "");

    typedef typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, KNY_T, K_HEIGHT*1-1>::TEMP_T tempY_T;
    stream<tempY_T> tempY_stream[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    column_filter<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)>(_src, tempY_stream, kernelY, Point_<POINT_T>(0,_anchor.y), rows, cols);

    row_filter<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)>(tempY_stream, _dst, kernelX, Point_<POINT_T>(_anchor.x,0), rows, cols, scale);
}

template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
         int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
     int cols)

{
_ssdm_InlineSelf(0, "");
    filter(_src, _dst, kernelX, kernelY, _anchor, rows, cols, 1);
}

};

template<typename OPR_KERNEL>
class sepfilter_opr<OPR_KERNEL, BORDER_CONSTANT> {
public:
template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
         int IMG_HEIGHT, int IMG_WIDTH, int K_HEIGHT, int K_WIDTH, typename SCALE_T>
    static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
     int cols,
     SCALE_T scale)
{
_ssdm_InlineSelf(0, "");
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name fillvalue = 0;
    OPR_KERNEL fk_opr;
    typedef typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, KNY_T, K_HEIGHT*1-1>::TEMP_T tempY_T;

    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_winY[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    Window<1,K_WIDTH,tempY_T> src_kernel_winX[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    tempY_T src_kernel_winX_temp[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)][K_WIDTH];

    LineBuffer<K_HEIGHT,IMG_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

_ssdm_SpecArrayPartition( &kernelX, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( &kernelY, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_winX, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_winX_temp, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_winY, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( k_buf, 1, "COMPLETE", 0, "");

    (static_cast <bool> (rows <= IMG_HEIGHT) ? void (0) : __assert_fail ("rows <= IMG_HEIGHT", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 1040, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= IMG_WIDTH) ? void (0) : __assert_fail ("cols <= IMG_WIDTH", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 1041, __extension__ __PRETTY_FUNCTION__));


    Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=K_WIDTH;
    kernel_size.height=K_HEIGHT;
    normalizeAnchor(anchor,kernel_size);

    int heightloop= rows+K_HEIGHT-1;
    int widthloop = cols+K_WIDTH-1;
    Point_<int> ImagLoc;
    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);

    loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
        loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
    _ssdm_SpecLoopFlatten(1, "");
    _ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++) {


                ImagLoc.x=j-anchor.x;
                ImagLoc.y=i-anchor.y;



                for(int buf_col=K_WIDTH-1; buf_col>=1; buf_col--) {
                    src_kernel_winX_temp[k][buf_col] = src_kernel_winX_temp[k][buf_col-1];
                }

                if(ImagLoc.x >= 0 && ImagLoc.x < cols) {
                    for(int buf_row= K_HEIGHT-1;buf_row >= 1;buf_row--) {
                        src_kernel_winY[k](buf_row,0)=k_buf[k](buf_row-1,ImagLoc.x);
                        k_buf[k](buf_row,ImagLoc.x)=k_buf[k](buf_row-1,ImagLoc.x);
                    }

                    typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp=fillvalue;
                    if(ImagLoc.y >= 0 && ImagLoc.y < rows) {
                        _src.data_stream[k] >> temp;
                    }
                    src_kernel_winY[k](0,0)=temp;
                    k_buf[k](0,ImagLoc.x)=temp;
                }





                if(ImagLoc.x < 0 || ImagLoc.x >= cols) {

                    src_kernel_winX_temp[k][0] = fillvalue;
                } else if(i >= (K_HEIGHT-1)) {
                    tempY_T tempY;
                    fk_opr.apply(kernelY,src_kernel_winY[k],tempY,false);

                    src_kernel_winX_temp[k][0] = tempY;
                }

                for (int buf_col=0; buf_col<K_WIDTH; buf_col++) {
                    src_kernel_winX[k](0,buf_col) = src_kernel_winX_temp[k][buf_col];
                }



                if(i >= (K_HEIGHT-1) && j >= (K_WIDTH-1)) {
                    typename filter2d_traits<tempY_T, KNX_T, 1*K_WIDTH>::ACCUM_T tempX;
                    fk_opr.apply(kernelX,src_kernel_winX[k],tempX,false);
                    _dst.data_stream[k]<<sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(tempX*scale);
                }
            }
        }
    }
}

template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
         int IMG_HEIGHT, int IMG_WIDTH, int K_HEIGHT, int K_WIDTH>
    static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
     int cols)
{
_ssdm_InlineSelf(0, "");
    filter(_src, _dst, kernelX, kernelY, _anchor, rows, cols, 1);
}

};

template<typename OPR_KERNEL, typename BORDERMODE, int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void filter_opr_flow_more(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> &anchor,
        int rows, int cols
        )
{
    filter_opr<OPR_KERNEL, BORDERMODE>::filter(_src,_dst,_kernel,anchor,rows,cols);
}
template<typename OPR_KERNEL, typename BORDERMODE, int ITERATIONS,int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void filter_opr_iter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> &anchor,
        int rows,int cols )
{
_ssdm_op_SpecDataflowPipeline(-1, 0, "");
    Mat<IMG_HEIGHT,IMG_WIDTH,DST_T> internal[ITERATIONS-1];
_ssdm_SpecArrayPartition( internal, 1, "complete", 0, "");
    filter_opr_flow_more<OPR_KERNEL,BORDERMODE,SRC_T,DST_T,KN_T,POINT_T>(_src,internal[0],_kernel,anchor,rows,cols);
loop_iterations: for(int iter=0;iter<ITERATIONS-2;iter++)
    {
_ssdm_Unroll(0,0,0, "");
        filter_opr_flow_more<OPR_KERNEL,BORDERMODE,SRC_T,DST_T,KN_T,POINT_T>(internal[iter],internal[iter+1],_kernel,anchor,rows, cols);
    }
    filter_opr_flow_more<OPR_KERNEL,BORDERMODE,SRC_T,DST_T,KN_T,POINT_T>(internal[ITERATIONS-2],_dst,_kernel,anchor,rows,cols);
}
template<typename OPR_KERNEL, typename BORDERMODE, int SRC_T, int DST_T,
    int IMG_HEIGHT,int IMG_WIDTH>
void morp_opr(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst)
{
_ssdm_InlineSelf(0, "");
    int rows=_src.rows;
    int cols=_src.cols;
    Size_<int> size;
    Point_<int> anchor;
    anchor.x=1;
    anchor.y=1;
    size.width=2*1+1;
    size.height=2*1+1;
    Window<2*1+1,2*1+1,unsigned char> temp_kernel;
    getStructuringElement<unsigned char,int,int,2*1+1,2*1+1>(MORPH_RECT, size, anchor,temp_kernel);

    filter_opr<OPR_KERNEL, BORDERMODE>::filter(_src,_dst,temp_kernel,anchor,rows,cols);
}
template<typename OPR_KERNEL, typename BORDERMODE, int Shape_type, int ITERATIONS, int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void morp_opr(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> anchor)
{
_ssdm_InlineSelf(0, "");
    int rows=_src.rows;
    int cols=_src.cols;
    if((Shape_type==MORPH_RECT)&&ITERATIONS>1)
    {
        Size_<int> size;
        anchor.x=ITERATIONS*(anchor.x);
        anchor.y=ITERATIONS*(anchor.y);
        size.width=K_WIDTH+ITERATIONS*(K_WIDTH-1);
        size.height=K_HEIGHT+ITERATIONS*(K_HEIGHT-1);
        Window<K_WIDTH+ITERATIONS*(K_WIDTH-1),K_HEIGHT+ITERATIONS*(K_HEIGHT-1),KN_T> temp_kernel;
        getStructuringElement<KN_T,int,int,K_WIDTH+ITERATIONS*(K_WIDTH-1),K_HEIGHT+ITERATIONS*(K_HEIGHT-1)>(MORPH_RECT, size, anchor,temp_kernel);

        filter_opr<OPR_KERNEL, BORDERMODE>::filter(_src,_dst,temp_kernel,anchor,rows,cols);
    }
    else if(ITERATIONS==1)
    {
        filter_opr<OPR_KERNEL, BORDERMODE>::filter(_src,_dst,_kernel,anchor,rows,cols);
    }
    else if(ITERATIONS>=2)
    {
        filter_opr_iter<OPR_KERNEL, BORDERMODE, ITERATIONS,SRC_T,DST_T,KN_T,POINT_T>(_src,_dst,_kernel,anchor,rows,cols);
    }
}





template<int SRC_T, int DST_T, int IMG_HEIGHT,int IMG_WIDTH>
void Erode(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst)
{



    morp_opr<erode_kernel,BORDER_REPLICATE>(_src,_dst);
}
template<int Shape_type,int ITERATIONS,int SRC_T, int DST_T, typename KN_T,int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void Erode(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel)
{
_ssdm_InlineSelf(0, "");



    Point_<int> anchor(K_WIDTH/2,K_HEIGHT/2);
    morp_opr<erode_kernel,BORDER_REPLICATE,Shape_type,ITERATIONS>(_src,_dst,_kernel,anchor);
}




template<int SRC_T, int DST_T, int IMG_HEIGHT,int IMG_WIDTH>
void Dilate(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst)
{



    morp_opr<dilate_kernel,BORDER_REPLICATE>(_src,_dst);
}
template<int Shape_type,int ITERATIONS,int SRC_T, int DST_T, typename KN_T,int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void Dilate(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel)
{
_ssdm_InlineSelf(0, "");



    Point_<int> anchor(K_WIDTH/2,K_HEIGHT/2);
    morp_opr<dilate_kernel,BORDER_REPLICATE,Shape_type,ITERATIONS>(_src,_dst,_kernel,anchor);
}



template<typename BORDERMODE, int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void Filter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> anchor)
{



    int rows=_src.rows;
    int cols=_src.cols;
    filter_opr<filter2d_kernel, BORDERMODE>::filter(_src,_dst,_kernel,anchor,rows,cols);
}

template<int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void Filter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> anchor)
{



    int rows=_src.rows;
    int cols=_src.cols;
    filter_opr<filter2d_kernel, BORDER_DEFAULT>::filter(_src,_dst,_kernel,anchor,rows,cols);
}

template<typename BORDERMODE, int SRC_T, int DST_T, typename KNX_T, typename KNY_T,
typename POINT_T, int IMG_HEIGHT, int IMG_WIDTH, int K_HEIGHT, int K_WIDTH, typename SCALE_T>
void SepFilter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &_kernelX,
        Window<K_HEIGHT,1,KNY_T> &_kernelY,
        Point_<POINT_T> anchor,
        SCALE_T scale)
{



    int rows=_src.rows;
    int cols=_src.cols;
    sepfilter_opr<filter2d_kernel, BORDERMODE>::filter(_src,_dst,_kernelX,_kernelY,anchor,rows,cols,scale);
}

template<typename BORDERMODE, int SRC_T, int DST_T, typename KNX_T, typename KNY_T,
typename POINT_T, int IMG_HEIGHT, int IMG_WIDTH, int K_HEIGHT, int K_WIDTH>
void SepFilter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &_kernelX,
        Window<K_HEIGHT,1,KNY_T> &_kernelY,
        Point_<POINT_T> anchor)
{



    int rows=_src.rows;
    int cols=_src.cols;
    sepfilter_opr<filter2d_kernel, BORDERMODE>::filter(_src,_dst,_kernelX,_kernelY,anchor,rows,cols);
}

template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void SepFilter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &_kernelX,
        Window<K_HEIGHT,1,KNY_T> &_kernelY,
        Point_<POINT_T> anchor)
{



    int rows=_src.rows;
    int cols=_src.cols;
    sepfilter_opr<filter2d_kernel, BORDER_DEFAULT>::filter(_src,_dst,_kernelX,_kernelY,anchor,rows,cols);
}



class CvtColor_mode {
public:
    enum values {RGB2GRAY,BGR2GRAY,GRAY2RGB,GRAY2BGR,
                 BGR2XYZ, RGB2XYZ, XYZ2BGR, XYZ2RGB,
                 BGR2YCrCb, RGB2YCrCb, YCrCb2BGR, YCrCb2RGB,
                 BGR2HSV, RGB2HSV, HSV2BGR, HSV2RGB,
                 BGR2HLS, RGB2HLS, HLS2BGR, HLS2RGB};
    typedef void isCvtColorMode;
};

}

class HLS_RGB2GRAY : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2GRAY; };
class HLS_BGR2GRAY : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2GRAY; };
class HLS_GRAY2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::GRAY2RGB; };
class HLS_GRAY2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::GRAY2BGR; };

class HLS_RGB2XYZ : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2XYZ; };
class HLS_BGR2XYZ : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2XYZ; };
class HLS_XYZ2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::XYZ2RGB; };
class HLS_XYZ2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::XYZ2BGR; };

class HLS_RGB2YCrCb : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2YCrCb; };
class HLS_BGR2YCrCb : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2YCrCb; };
class HLS_YCrCb2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::YCrCb2RGB; };
class HLS_YCrCb2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::YCrCb2BGR; };

class HLS_RGB2HSV : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2HSV; };
class HLS_BGR2HSV : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2HSV; };
class HLS_HSV2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::HSV2RGB; };
class HLS_HSV2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::HSV2BGR; };

class HLS_RGB2HLS : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2HLS; };
class HLS_BGR2HLS : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2HLS; };
class HLS_HLS2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::HLS2RGB; };
class HLS_HLS2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::HLS2BGR; };

namespace hls {

    template <typename T> class CvtColor_traits {

    };

    template <> class CvtColor_traits<unsigned char> {
    public:
        typedef unsigned char T;
        typedef ap_fixed<25,3> COEFF_T;
     typedef ap_ufixed<20,1,AP_RND> INV_T;

        const int delta;
        const unsigned int hrange;
        const unsigned int scale;
        const INV_T inv_scale;
        const INV_T inv_hrange;
        typedef typename x_traits<COEFF_T, typename fixed_type<T>::T >::MULT_T MULT_T;
        typedef typename x_traits_d<MULT_T, 3>::ACCUM_T ACCUM_T;
        typedef typename x_traits<typename fixed_type<T>::T, typename fixed_type<T>::T>::SUB_T SUB_T;
        typedef typename x_traits<typename fixed_type<T>::T, typename fixed_type<T>::T>::ADD_T ADD_T;
        typedef typename x_traits<ap_fixed<17,17>, INV_T>::MULT_T H_MULT_T;
        typedef typename x_traits<typename fixed_type<T>::T, INV_T>::MULT_T S_MULT_T;
        CvtColor_traits() : delta(128), hrange(180), scale(255),
       inv_scale(0.0039215686274509804), inv_hrange(0.0333333333333333333) {};
    };
    template <int N> class CvtColor_traits< ap_uint<N> > {
    public:
        typedef ap_uint<N> T;
        typedef ap_fixed<25,3> COEFF_T;
     typedef ap_ufixed<20,1,AP_RND> INV_T;

        const int delta;
        const unsigned int hrange;
        const unsigned int scale;
        const INV_T inv_scale;
        const INV_T inv_hrange;
        typedef typename x_traits<COEFF_T, typename fixed_type<T>::T >::MULT_T MULT_T;
        typedef typename x_traits_d<MULT_T, 3>::ACCUM_T ACCUM_T;
        typedef typename x_traits<typename fixed_type<T>::T, typename fixed_type<T>::T>::SUB_T SUB_T;
        typedef typename x_traits<typename fixed_type<T>::T, typename fixed_type<T>::T>::ADD_T ADD_T;
        typedef typename x_traits<ap_fixed<17,17>, INV_T>::MULT_T H_MULT_T;
        typedef typename x_traits<typename fixed_type<T>::T, INV_T>::MULT_T S_MULT_T;
        CvtColor_traits() : delta(1 << (N-1)), hrange(180),
                            scale(::hls::numeric_limits<T>::max()),
                            inv_scale(1.0/::hls::numeric_limits<T>::max()),
                            inv_hrange(0.0333333333333333333) {};
    };
    template <> class CvtColor_traits<float> {
    public:
        typedef float T;
        typedef float COEFF_T;
        typedef float INV_T;
        const float delta;
        const float hrange;
        const float scale;
        const INV_T inv_scale;
        const INV_T inv_hrange;
        typedef float MULT_T;
        typedef float ACCUM_T;
        typedef float SUB_T;
        typedef float ADD_T;
        typedef float H_MULT_T;
        typedef float S_MULT_T;
        CvtColor_traits() : delta(0.5f), hrange(360), scale(1), inv_scale(1),
       inv_hrange(0.0166666666666666667) {};
    };
    template <> class CvtColor_traits<double> {
    public:
        typedef double T;
        typedef double COEFF_T;
        typedef double INV_T;
        const double delta;
        const double hrange;
        const double scale;
        const INV_T inv_scale;
        const INV_T inv_hrange;
        typedef double MULT_T;
        typedef double ACCUM_T;
        typedef double SUB_T;
        typedef double ADD_T;
        typedef double H_MULT_T;
        typedef double S_MULT_T;
        CvtColor_traits() : delta(0.5f), hrange(360), scale(1), inv_scale(1),
       inv_hrange(0.0166666666666666667) {};
};

template <typename SRC_T, typename DST_T>
class ColorConverter {
public:
    template <int CN1>
    static void convert(Scalar<CN1,SRC_T>& _src, DST_T& result, Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > par) {
_ssdm_InlineSelf(0, "");
        typename CvtColor_traits<SRC_T>::MULT_T b,g,r;
        r=par.val[0]*_src.val[0];
        b=par.val[1]*_src.val[1];
        g=par.val[2]*_src.val[2];
        typename CvtColor_traits<SRC_T>::ACCUM_T c;
        c=r+g+b;
        result=sr_cast<DST_T> (c);
    }
};

template <typename SRC_T, typename DST_T>
class MaxMin{
public:
    template <int CN1>
    static void max(Scalar<CN1,SRC_T>& _src, DST_T& result) {
_ssdm_InlineSelf(0, "");

 for(int i=0; i<CN1; i++) {
   result=(_src.val[i]>result) ? _src.val[i] : result;
 }
    }

    template <int CN1>
    static void min(Scalar<CN1,SRC_T>& _src, DST_T& result) {
_ssdm_InlineSelf(0, "");

 for(int i=0; i<CN1; i++) {
   result=(_src.val[i]<result) ? _src.val[i] : result;
 }
    }
};

template <typename CONVERSION, typename SRC_T, typename DST_T>
class kernel_CvtColor {};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2GRAY, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > par;
public:
    kernel_CvtColor() : par(0.114,0.587,0.299) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[0], par);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2GRAY, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > par;
public:
    kernel_CvtColor() : par(0.299,0.587,0.114) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[0], par);
    }
};
template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_GRAY2RGB, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
_ssdm_InlineSelf(0, "");
        _dst.val[0] = sr_cast<DST_T> (_src.val[0]);
        _dst.val[1] = sr_cast<DST_T> (_src.val[0]);
        _dst.val[2] = sr_cast<DST_T> (_src.val[0]);
    }
};
template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_GRAY2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
_ssdm_InlineSelf(0, "");
        _dst.val[0] = sr_cast<DST_T> (_src.val[0]);
        _dst.val[1] = sr_cast<DST_T> (_src.val[0]);
        _dst.val[2] = sr_cast<DST_T> (_src.val[0]);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2XYZ, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parX;
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parY;
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parZ;
public:
    kernel_CvtColor() : parX(0.412453, 0.357580, 0.180423),
                        parY(0.212671, 0.715160, 0.072169),
                        parZ(0.019334, 0.119193, 0.950227) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[0], parX);
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[1], parY);
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[2], parZ);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2XYZ, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> src2;
        src2.val[0] = _src.val[2];
        src2.val[1] = _src.val[1];
        src2.val[2] = _src.val[0];
        kernel_CvtColor<HLS_RGB2XYZ,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(src2, _dst);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_XYZ2RGB, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parR;
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parG;
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parB;
public:
    kernel_CvtColor() : parR( 3.240479, -1.53715, -0.498535),
                        parG(-0.969256, 1.875991, 0.041556),
                        parB( 0.055648, -0.204043, 1.057311) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[0], parR);
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[1], parG);
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[2], parB);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_XYZ2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> dst2;
        kernel_CvtColor<HLS_XYZ2RGB,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(_src, dst2);
        _dst.val[0] = dst2.val[2];
        _dst.val[1] = dst2.val[1];
        _dst.val[2] = dst2.val[0];
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2YCrCb, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > par;
    typename CvtColor_traits<SRC_T>::COEFF_T Cr;
    typename CvtColor_traits<SRC_T>::COEFF_T Cb;
public:
    kernel_CvtColor() : par(0.299,0.587,0.114),Cr(.713),Cb(.564) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        SRC_T R = _src.val[0];
        SRC_T G = _src.val[1];
        SRC_T B = _src.val[2];
        DST_T Y;
        ColorConverter<SRC_T,DST_T>::convert(_src, Y, par);
        _dst.val[0] = Y;
        _dst.val[1] = sr_cast<DST_T>((R-Y)*Cr+ CvtColor_traits<SRC_T>().delta);
        _dst.val[2] = sr_cast<DST_T>((B-Y)*Cb+ CvtColor_traits<SRC_T>().delta);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2YCrCb, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> src2;
        src2.val[0] = _src.val[2];
        src2.val[1] = _src.val[1];
        src2.val[2] = _src.val[0];
        kernel_CvtColor<HLS_RGB2YCrCb,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(src2, _dst);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_YCrCb2RGB, SRC_T, DST_T> {
    typename CvtColor_traits<SRC_T>::COEFF_T parGr;
    typename CvtColor_traits<SRC_T>::COEFF_T parGb;
    typename CvtColor_traits<SRC_T>::COEFF_T parCr;
    typename CvtColor_traits<SRC_T>::COEFF_T parCb;
public:
    kernel_CvtColor() : parGr(-0.714), parGb(-0.344), parCr(1.403), parCb(1.773) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        SRC_T Y = _src.val[0];
        SRC_T Cr = _src.val[1];
        SRC_T Cb = _src.val[2];
        _dst.val[0] = sr_cast<DST_T> (Y + parCr * (Cr-CvtColor_traits<SRC_T>().delta));
        _dst.val[1] = sr_cast<DST_T> (Y + parGr * (Cr-CvtColor_traits<SRC_T>().delta) + parGb * (Cb-CvtColor_traits<SRC_T>().delta));
        _dst.val[2] = sr_cast<DST_T> (Y + parCb * (Cb-CvtColor_traits<SRC_T>().delta));
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_YCrCb2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> dst2;
        kernel_CvtColor<HLS_YCrCb2RGB,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(_src, dst2);
        _dst.val[0] = dst2.val[2];
        _dst.val[1] = dst2.val[1];
        _dst.val[2] = dst2.val[0];
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2HSV, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
 _ssdm_InlineSelf(0, "");
        SRC_T R = _src.val[0];
        SRC_T G = _src.val[1];
        SRC_T B = _src.val[2];
 typename CvtColor_traits<DST_T>::H_MULT_T H;
 typename CvtColor_traits<DST_T>::S_MULT_T S;
 typename CvtColor_traits<DST_T>::SUB_T sub;
 typename CvtColor_traits<DST_T>::INV_T inv_max = 0;
 typename CvtColor_traits<DST_T>::INV_T inv_diff = 0;
 DST_T max = B;
 DST_T min = B;
 DST_T diff;

 MaxMin<SRC_T,DST_T>::max(_src, max);
 MaxMin<SRC_T,DST_T>::min(_src, min);
 diff=max-min;

 if(max!=0)
   inv_max = (typename CvtColor_traits<DST_T>::INV_T) 1/max;
 else
   inv_max = 0;

 S=inv_max*diff;

 if(diff!=0)
   inv_diff = (typename CvtColor_traits<DST_T>::INV_T) 1/diff;
 else
   inv_diff = 0;

 sub=(max==R) ? (G-B) : (max==G) ? (B-R) : (R-G);
 H=(max==R) ? 0 : (max==G) ? 120 : 240;
 H+=60*sub*inv_diff;

 if(180==CvtColor_traits<SRC_T>().hrange) {
   H=H/2;
   H+=((H+(typename CvtColor_traits<DST_T>::H_MULT_T)0.5)<0) ? 180 : 0;
 }
 else
   H+=(H<0) ? 360 :0;

        _dst.val[0] = sr_cast<DST_T>(H);
        _dst.val[1] = (180==CvtColor_traits<SRC_T>().hrange) ? sr_cast<DST_T>(255*S) : sr_cast<DST_T>(S);
        _dst.val[2] = max;
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2HSV, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> src2;
        src2.val[0] = _src.val[2];
        src2.val[1] = _src.val[1];
        src2.val[2] = _src.val[0];
        kernel_CvtColor<HLS_RGB2HSV,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(src2, _dst);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_HSV2RGB, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
 _ssdm_InlineSelf(0, "");
        SRC_T H = _src.val[0];
        SRC_T S = _src.val[1];
        SRC_T V = _src.val[2];
 typename CvtColor_traits<DST_T>::S_MULT_T tab[4];
 typename CvtColor_traits<DST_T>::S_MULT_T f;
 static const int sector_data[][3]=
  {{0,3,1}, {2,0,1}, {1,0,3}, {1,2,0}, {3,1,0},{0,1,2}};
_ssdm_SpecConstant(sector_data);
# 1776 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h"

 typename CvtColor_traits<DST_T>::S_MULT_T S_scale;
 unsigned char h_i;

 _ssdm_SpecArrayPartition( tab, 0, "COMPLETE", 0, "");

 h_i = (unsigned char)(H*(CvtColor_traits<SRC_T>().inv_hrange));
 f = H*(CvtColor_traits<SRC_T>().inv_hrange) - h_i;
 if(h_i >= 6)
   h_i -= 6;

 S_scale=S*(CvtColor_traits<SRC_T>().inv_scale);

 tab[0] = V;
 tab[1] = V*(1-S_scale);
 tab[2] = V*(1-f*S_scale);
 tab[3] = V*(1-S_scale+f*S_scale);

        _dst.val[0] = sr_cast<DST_T>(tab[sector_data[h_i][0]]);
        _dst.val[1] = sr_cast<DST_T>(tab[sector_data[h_i][1]]);
        _dst.val[2] = sr_cast<DST_T>(tab[sector_data[h_i][2]]);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_HSV2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> dst2;
        kernel_CvtColor<HLS_HSV2RGB,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(_src, dst2);
        _dst.val[0] = dst2.val[2];
        _dst.val[1] = dst2.val[1];
        _dst.val[2] = dst2.val[0];
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2HLS, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
 _ssdm_InlineSelf(0, "");
        SRC_T R = _src.val[0];
        SRC_T G = _src.val[1];
        SRC_T B = _src.val[2];
 typename CvtColor_traits<DST_T>::H_MULT_T H;
 typename CvtColor_traits<DST_T>::S_MULT_T S;
 DST_T L;
 typename CvtColor_traits<DST_T>::SUB_T sub;
 typename CvtColor_traits<DST_T>::ADD_T add;
 typename CvtColor_traits<DST_T>::INV_T inv_add = 0;
 typename CvtColor_traits<DST_T>::INV_T inv_add_comp= 0;
 typename CvtColor_traits<DST_T>::INV_T inv_diff = 0;
 DST_T max = B;
 DST_T min = B;
 DST_T diff;

 MaxMin<SRC_T,DST_T>::max(_src, max);
 MaxMin<SRC_T,DST_T>::min(_src, min);
 diff=max-min;
 add=max+min;
 L=sr_cast<DST_T>((max+min)/2);

 if(add!=0)
   inv_add = (typename CvtColor_traits<DST_T>::INV_T) 1/add;
 else
   inv_add = 0;



 if((2*(CvtColor_traits<SRC_T>().scale)-add)!=0)
   inv_add_comp = (typename CvtColor_traits<DST_T>::INV_T) 1/(2*(CvtColor_traits<SRC_T>().scale)-add);
 else
   inv_add_comp = 0;

 if(L<=CvtColor_traits<SRC_T>().delta)
   S=inv_add*diff;
 else
   S=inv_add_comp*diff;

 if(diff!=0)
   inv_diff = (typename CvtColor_traits<DST_T>::INV_T) 1/diff;
 else
   inv_diff = 0;

 sub=(max==R) ? (G-B) : (max==G) ? (B-R) : (R-G);
 H=(max==R) ? 0 : (max==G) ? 120 : 240;
 H+=60*sub*inv_diff;

 if(180==CvtColor_traits<SRC_T>().hrange) {
   H=H/2;
   H+=((H+(typename CvtColor_traits<DST_T>::H_MULT_T)0.5)<0) ? 180 : 0;
 }
 else
   H+=(H<0) ? 360 :0;

        _dst.val[0] = sr_cast<DST_T>(H);
        _dst.val[1] = L;
        _dst.val[2] = (180==CvtColor_traits<SRC_T>().hrange) ?
            sr_cast<DST_T>(CvtColor_traits<SRC_T>().scale*S) :
            sr_cast<DST_T>(S);

    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2HLS, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> src2;
        src2.val[0] = _src.val[2];
        src2.val[1] = _src.val[1];
        src2.val[2] = _src.val[0];
        kernel_CvtColor<HLS_RGB2HLS,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(src2, _dst);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_HLS2RGB, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
 _ssdm_InlineSelf(0, "");
        SRC_T H = _src.val[0];
        SRC_T L = _src.val[1];
        SRC_T S = _src.val[2];
 typename CvtColor_traits<DST_T>::S_MULT_T tab[4];
 typename CvtColor_traits<DST_T>::S_MULT_T f;
 static const int sector_data[][3]=
  {{0,3,1}, {2,0,1}, {1,0,3}, {1,2,0}, {3,1,0},{0,1,2}};
_ssdm_SpecConstant(sector_data);
# 1909 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h"

 typename CvtColor_traits<DST_T>::S_MULT_T S_scale;
 unsigned char h_i;

 _ssdm_SpecArrayPartition( tab, 0, "COMPLETE", 0, "");

 h_i = (unsigned char)(H*(CvtColor_traits<SRC_T>().inv_hrange));
 f = H*(CvtColor_traits<SRC_T>().inv_hrange) - h_i;
 if(h_i >= 6)
   h_i -= 6;

 S_scale=S*(CvtColor_traits<SRC_T>().inv_scale);

 if(L<=0.5*CvtColor_traits<SRC_T>().scale)
   tab[0] = L+L*S_scale;

 else
    tab[0] = L+S-L*S_scale;

 tab[1] = 2*L-tab[0];
 tab[2] = tab[0]-(tab[0]-tab[1])*f;
 tab[3] = tab[1]+(tab[0]-tab[1])*f;

        _dst.val[0] = sr_cast<DST_T>(tab[sector_data[h_i][0]]);
        _dst.val[1] = sr_cast<DST_T>(tab[sector_data[h_i][1]]);
        _dst.val[2] = sr_cast<DST_T>(tab[sector_data[h_i][2]]);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_HLS2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> dst2;
        kernel_CvtColor<HLS_HLS2RGB,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(_src, dst2);
        _dst.val[0] = dst2.val[2];
        _dst.val[1] = dst2.val[1];
        _dst.val[2] = dst2.val[0];
    }
};

template<typename CONVERSION,int SRC_T, int DST_T,
    int ROWS,int COLS>
void CvtColor(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS, COLS, DST_T> &_dst
        )
{
    kernel_CvtColor<CONVERSION,typename Type<((SRC_T) & ((1 << 11) - 1))>::name,typename Type<((DST_T) & ((1 << 11) - 1))>::name> kernel_opr;
    int cols=_src.cols;
    int rows=_src.rows;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 1963, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 1964, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
 loop_height: for(int i= 0; i < rows; i++) {
    loop_width: for (int j= 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            _src >> _s;
            kernel_opr.apply(_s,_d);
            _dst << _d;
        }
    }
}

template<int SRC_T, int DST_T,
int ROWS,int COLS>
void Integral(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS+1, COLS+1, DST_T> &_sum
        )
{
    LineBuffer<1,COLS+1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> k_buf;
    int cols=_src.cols;
    int rows=_src.rows;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 1988, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 1989, __extension__ __PRETTY_FUNCTION__));
    Scalar<1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
    int sqsum, sum=0;

 loop_height: for(int i= 0;i<rows+1;i++) {
    loop_width: for (int j= 0;j<cols+1;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            if(i==0||(j==0&&i!=0))
            {
                k_buf.val[0][j]=0;
                _d.val[0]=0;
                sum=0;
            }
            else
            {
                _src>>_s;
                sum=sum+_s.val[0];
                _d.val[0]=sum+k_buf.val[0][j];
                k_buf.val[0][j]=_d.val[0];
            }
            _sum<<_d;
        }
    }
}
template<int SRC_T, int DST_T,int DSTSQ_T,
    int ROWS,int COLS>
void Integral(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS+1, COLS+1, DST_T> &_sum,
  Mat<ROWS+1, COLS+1, DSTSQ_T> &_sqsum
                )
{
    LineBuffer<1,COLS+1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> k_buf;
    LineBuffer<1,COLS+1,typename Type<((DSTSQ_T) & ((1 << 11) - 1))>::name> k_sqbuf;
    int cols=_src.cols;
    int rows=_src.rows;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 2027, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 2028, __extension__ __PRETTY_FUNCTION__));
    Scalar<1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
    Scalar<1,typename Type<((DSTSQ_T) & ((1 << 11) - 1))>::name> _sqd;
    int sqsum, sum=0;

 loop_height: for(int i= 0;i<rows+1;i++) {
    loop_width: for (int j= 0;j<cols+1;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            if(i==0||(j==0&&i!=0))
            {
                k_buf.val[0][j]=0;
                k_sqbuf.val[0][j]=0;
                _d.val[0]=0;
                _sqd.val[0]=0;
                sum=0;
                sqsum=0;
            }
            else
            {
                _src>>_s;
                sum=sum+_s.val[0];
                sqsum=sqsum+_s.val[0]*_s.val[0];

                _d.val[0]=sum+k_buf.val[0][j];
                _sqd.val[0]=sqsum+k_sqbuf.val[0][j];
                k_buf.val[0][j]=_d.val[0];
                k_sqbuf.val[0][j]=_sqd.val[0];
            }
            _sum<<_d;
            _sqsum<<_sqd;
        }
    }
}







template <int NTAPS, int NPHASES, int COEFF_BITS,typename HT, typename VT>
void init_scale_coefficients(HT *Hcoefs, VT *Vcoefs) {

_ssdm_InlineSelf(2, "");
    static const float A = -0.5;
_ssdm_SpecConstant(&A);
# 2074 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h"

    double t;
    double coeff[NPHASES][NTAPS];
    int i,j;

    for (i=0; i<NPHASES; i++) {
        t=((double) i)/NPHASES;
        coeff[i][0] = A*(t*((2-t)*t-1));
        coeff[i][1] = A*(t*t*(3*t-5)+2);
        coeff[i][2] = A*(t*((4-3*t)*t+1));
        coeff[i][3] = A*((t-1)*t*t);
    }
    for (i = 0; i < NPHASES; i++) {
        for (j = 0; j < NTAPS; j++) {
            Hcoefs[(NTAPS*i)+j] = (HT)coeff[i][j];
            Vcoefs[(NTAPS*i)+j] = (VT)coeff[i][j];
        }
    }
}

template<int NTAPS, int COEFF_BITS, int T,typename FILTER_T>
hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> scale_operator(hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> *samples, FILTER_T *coeffs) {

    typedef typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, FILTER_T, NTAPS>::SRC_CAST_T SRCT;
    int i,j,ch;
    hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix_out;
CHAN_LOOP : for (ch =0; ch<((((T) & ((512 - 1) << 11)) >> 11) + 1); ch++) {
        typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, FILTER_T, NTAPS>::ACCUM_T t=0;
        typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, FILTER_T, NTAPS>::MULT_T temp;
    TAPS_LOOP : for (i = 0,t=0.5; i < NTAPS; i++) {
_ssdm_InlineSelf(0, "");
            typename Type<((T) & ((1 << 11) - 1))>::name sample = samples[i].val[ch];
            temp = ((SRCT)sample)*coeffs[NTAPS-1-i];
            t = t - temp ;
        }
        pix_out.val[ch] = sr_cast<typename Type<((T) & ((1 << 11) - 1))>::name> (t);
    }
    return pix_out;
}


template <int COLS, int ROWS,int DCOLS, int DROWS, int T>
void Resize_opr_bicubic(hls::Mat<ROWS, COLS, T>& _src, hls::Mat<DROWS, DCOLS, T>& _dst) {
    typedef ap_fixed<32, 16, AP_RND> FT;
    typedef short N16;
    const int NTAPS = 4;
    const int NPHASES = 16;
    const int COEFF_BITS = 16;
    const short ES = 2;
    typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, ap_fixed<25, 5, AP_RND>, NTAPS>::FILTER_CAST_T hcoeffs[NPHASES][NTAPS];
    typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, ap_fixed<25, 5, AP_RND>, NTAPS>::FILTER_CAST_T vcoeffs[NPHASES][NTAPS];
    N16 row, col;
    N16 rows, cols;
    ap_uint<32> v_phase_acc;
    ap_uint<32> h_phase_acc;

    hls::LineBuffer<NTAPS, (COLS>DCOLS?COLS:DCOLS) + 3, hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> > linebuf;
    hls::Window<1, NTAPS, hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> > h_shreg;
    hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix_in, h_fir_out, pix_out, h_fir[NTAPS], v_fir[NTAPS];
    hls::Scalar < ((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name > temp_in[NTAPS];
    hls::Scalar < ((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name > temp_out[NTAPS];
    typename Type<((T) & ((1 << 11) - 1))>::name pix_in_ch, pix_out_ch;

    N16 rows_rw = -1, cols_rw = -1;
    bool col_rd_en;
    bool row_rd_en;
    bool col_wr_en;
    bool row_wr_en;
    ap_uint<4> v_phase;
    ap_uint<4> h_phase;
_ssdm_SpecArrayPartition( temp_in, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( temp_out, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( h_fir, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( v_fir, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( hcoeffs, 2, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( vcoeffs, 2, "COMPLETE", 0, "");


    init_scale_coefficients<NTAPS, NPHASES, COEFF_BITS>(hcoeffs[0], vcoeffs[0]);

    N16 rows_in = _src.rows;
    N16 cols_in = _src.cols;
    N16 rows_out = _dst.rows;
    N16 cols_out = _dst.cols;
    FT row_ratio = (FT(rows_out)) / (FT)rows_in;
    FT col_ratio = (FT(cols_out)) / (FT)cols_in;

    int row_rate = (ap_fixed<4, 2, AP_RND>(0.5) + row_ratio * 65536);
    int col_rate = (ap_fixed<4, 2, AP_RND>(0.5) + col_ratio * 65536);
    rows = (rows_in > rows_out) ? rows_in : rows_out;
    cols = (cols_in > cols_out) ? cols_in : cols_out;
    (static_cast <bool> (rows<=ROWS || rows<=DROWS) ? void (0) : __assert_fail ("rows<=ROWS || rows<=DROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 2165, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols<=COLS || cols<=DCOLS) ? void (0) : __assert_fail ("cols<=COLS || cols<=DCOLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 2166, __extension__ __PRETTY_FUNCTION__));
    v_phase_acc = 0;

 ROW_LOOP: for (row = 0; row < rows + 3; row++) {
    COL_LOOP: for (col = 0; col < cols + 3; col++) {
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
_ssdm_SpecLoopFlatten(1, "");
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
              if (col == 0) {
                  v_phase = (v_phase_acc >> 12) & 15;
                  if (row_rate < 65536) {
                      row_rd_en = true;
                      N16 drow = row * row_ratio;
                      if (rows_rw != drow) {
                          row_wr_en = true;
                          rows_rw = drow;
                      } else
                          row_wr_en = false;
                  } else {
                      row_wr_en = true;
                      N16 drow = row / row_ratio;
                      if (rows_rw != drow) {
                          row_rd_en = true;
                          rows_rw = drow;
                      } else
                          row_rd_en = false;
                  }
                  if (row_rate < 65536 || row_rd_en)
                      v_phase_acc = v_phase_acc + row_rate;
              }

              h_phase = (h_phase_acc >> 12) & 15;
              if (col_rate < 65536) {
                  col_rd_en = true;
                  N16 dcol = col * col_ratio;
                  if (col == 0 || (col > 0 && cols_rw != dcol)) {
                      col_wr_en = true;
                      cols_rw = dcol;
                  } else
                      col_wr_en = false;
              } else {
                  col_wr_en = true;
                  N16 dcol = col / col_ratio;
                  if (col == 0 || (col > 0 && cols_rw != dcol)) {
                      col_rd_en = true;
                      cols_rw = dcol;
                  } else
                      col_rd_en = false;
              }

              if (col > 0 && (col_rate < 65536 || col_rd_en))
                  h_phase_acc = h_phase_acc + col_rate;
              else
                  h_phase_acc = col_rate;

              if (col_rd_en) {
                  h_shreg.shift_left();
                  if (row_rd_en) {
                      if (row < rows && col < cols) {
                          pix_in = _src.read();
                          h_shreg.insert(pix_in, 0, NTAPS - 1);
                      } else if (col >= cols && row < rows) {
                          h_shreg.insert(pix_in, 0, NTAPS - 1);
                      } else if (row >= rows) {
                          for (int m = 0; m < ((((T) & ((512 - 1) << 11)) >> 11) + 1); m++)
                              pix_in.val[0] = 0;
                          h_shreg.insert(pix_in, 0, NTAPS - 1);
                      }
                  }
              }

              for (int i = 0; i < NTAPS; i++) {
                  temp_in[i] = linebuf.val[i][col];
              }

              if (col_wr_en) {
                  if ((row_rd_en) || (row < ES) || (row >= rows - ES)) {
                      for (int i = NTAPS - 1; i > 0; i--) {
                          temp_out[i] = temp_in[i - 1];
                      }
H_LOOP: for (int i = 0; i < NTAPS; i++) {
            h_fir[i] =
                (col > i) ?
                h_shreg.getval(0, i) :
                h_shreg.getval(0, NTAPS - 1 - col);
        }
        h_fir_out = scale_operator<NTAPS, COEFF_BITS, T>(h_fir,
                hcoeffs[h_phase]);
        temp_out[0] = h_fir_out;
        v_fir[NTAPS - 1] = h_fir_out;
                  } else {
                      for (int i = NTAPS - 1; i >= 0; i--) {
                          temp_out[i] = temp_in[i];
                      }
                      v_fir[NTAPS - 1] = temp_in[0];
                  }
V_LOOP: for (int i = 0; i < NTAPS - 1; i++) {
            v_fir[i] =
                (row > 0) ? temp_out[NTAPS - 1 - i] : temp_out[0];
        }
              }

              for (int i = 0; i < NTAPS; i++) {
                  linebuf.val[i][col] = (row > 0) ? temp_out[i] : temp_out[0];
              }

              if (row >= 3 && col >= 3 && row_wr_en && col_wr_en) {
                  pix_out = scale_operator<NTAPS, COEFF_BITS, T>(v_fir, vcoeffs[v_phase]);
                  _dst.write(pix_out);
              }
          }
          }
}

template<int SRC_T, int ROWS,int COLS,int DROWS,int DCOLS>
void Resize_opr_linear (
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<DROWS, DCOLS, SRC_T> &_dst )
{
    LineBuffer<2,(COLS>DCOLS?COLS:DCOLS)+1,Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> > k_buf;
    Window<2,2,Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> > win;
    short dcols=_dst.cols;
    short drows=_dst.rows;
    short srows=_src.rows;
    short scols=_src.cols;
    ap_fixed<32,16,AP_RND> row_rate=((ap_fixed<32,16,AP_RND> )srows)/(ap_fixed<32,16,AP_RND>)drows;
    ap_fixed<32,16,AP_RND> col_rate=((ap_fixed<32,16,AP_RND> )scols)/(ap_fixed<32,16,AP_RND>)dcols;
    typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, ap_fixed<20,2,AP_RND> ,4>::FILTER_CAST_T u,v, u1,v1;

    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s, temp, d;
    ap_fixed<4,2,AP_RND> par=0.5;
    ap_fixed<20,10,AP_RND> offset_row=row_rate/2-par;
    ap_fixed<20,10,AP_RND> offset_col=col_rate/2-par;
    ap_fixed<32,16,AP_RND> fx=0;
    ap_fixed<32,16,AP_RND> fy=0;

    short rows=srows > drows ? srows : (drows+1);
    short cols=scols > dcols ? scols : (dcols+1);
    (static_cast <bool> (rows<=ROWS || rows<=DROWS+1) ? void (0) : __assert_fail ("rows<=ROWS || rows<=DROWS+1", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 2304, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols<=COLS || cols<=DCOLS+1) ? void (0) : __assert_fail ("cols<=COLS || cols<=DCOLS+1", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 2305, __extension__ __PRETTY_FUNCTION__));

    short x=0;
    short pre_fy=-10;
    short pre_fx=-10;
    bool row_rd=false;
    bool row_wr=false;

    for(short i= 0;i<rows;i++) {
        for(short j= 0;j<cols;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

            bool col_rd=false;
            bool col_wr=false;

            short dy = row_rate>1 ? (short)(i/row_rate):(i-1);
            short dx = col_rate>1 ? (short)(j/col_rate):(j-1);

            fy =(dy)*row_rate+offset_row;
            fx =(dx)*col_rate+offset_col;

            short sx=(short)fx;
            short sy=(short)fy;
            if(fx-sx>0)
                u=fx-sx;
            else
                u=0;
            if(fy-sy>0)
                v=fy-sy;
            else
                v=0;
            u1=1-u;
            v1=1-v;
            if(sx>scols-1)
            {
                sx=scols-1;
                u=0;
            }
            if(sy>srows-1)
            {
                sy=srows-1;
                v=0;
            }
            if(j==0)
            {
                x=0;
                pre_fx=-10;
                if(row_rate>1)
                {
                    row_rd=true;
                    row_wr= (sy==(i-1)) ? true : false;
                }
                else
                {
                    if(i==0){
                        row_rd=true;
                    }
                    else if(sy!=pre_fy)
                    {
                        row_rd=true;
                        pre_fy=sy;
                    }
                    else {
                        row_rd=false;
                    }
                    row_wr= i>0? true: false;
                }
            }
            if(col_rate>1)
            {
                col_rd=true;
                col_wr= (sx==(j-1)) ? true : false;
            }else{
                if(j==0){
                    col_rd=true;
                }
                else if(sx!=pre_fx)
                {
                    col_rd=true;
                    pre_fx=sx;
                }
                else
                    col_rd=false;
                col_wr= j>0? true: false;
            }
            if(col_rd)
            {
                for(int r= 0;r<2;r++)
                {
                    win.val[r][1]=win.val[r][0];
                }
                if(row_rd)
                {

                    k_buf.val[1][x]=k_buf.val[0][x];
                    win.val[1][0]=k_buf.val[0][x];
                    if(sy<srows-1&&sx<scols-1)
                    {
                        _src >> s;
                        k_buf.val[0][x]=s;
                        win.val[0][0]=k_buf.val[0][x];
                    }
                    else if(sx>=scols-1&&sy<srows-1){
                        k_buf.val[0][x]=s;
                    }
                    else if(sy>=srows-1){
                        win.val[0][0]=k_buf.val[0][x];
                    }
                }
                else
                {
                    for(int r= 0;r<2;r++)
                    {
                        win.val[r][0]=k_buf.val[r][x];
                    }
                }

                x++;
            }
            if(row_wr && col_wr)
            {
                for(int k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++)
                {
                    typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, ap_fixed<15,1,AP_RND> ,4>::ACCUM_T t=0;
                    typedef typename fixed_type<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>::T SRCT;

                    t=((SRCT)win.val[1][1].val[k])*u1*v1+
                        ((SRCT)win.val[1][0].val[k])*v1*u+
                        ((SRCT)win.val[0][1].val[k])*u1*v+
                        ((SRCT)win.val[0][0].val[k])*u*v;
                    d.val[k]=sr_cast<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>(t);
                }
                _dst << d;
            }
        }
    }
}







template<int SRC_T, int ROWS,int COLS,int DROWS,int DCOLS>
void Resize (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, SRC_T> &_dst,
        int interpolation=1 )
{
    switch(interpolation) {
    case 0:



        break;
    case 2:



        break;
    case 4:



        break;
    case 3:
        Resize_opr_bicubic(_src,_dst);
        break;
    case 1:
        Resize_opr_linear(_src,_dst);
        break;
    }
}

template<int SRC_T, int DST_T,
    int ROWS,int COLS>
void ConvertScale (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS, COLS, DST_T> &_dst,
        double alpha=1,
        double beta=0
        )
{
    int cols=_src.cols;
    int rows=_src.rows;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 2493, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 2494, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
loop_height: for(int i= 0;i<rows;i++) {
    loop_width: for (int j= 0;j<cols;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            _src>>_s;
        loop_channels: for(int k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++)
            {
                _d.val[k]=sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(_s.val[k]*alpha+beta);
            }
            _dst<<_d;
        }
    }
}

template<int SRC_T, int DST_T,
    int ROWS,int COLS>
void ConvertScaleAbs (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS, COLS, DST_T> &_dst,
        double alpha=1,
        double beta=0
        )
{
    int cols=_src.cols;
    int rows=_src.rows;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 2522, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 2523, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
loop_height: for(int i= 0;i<rows;i++) {
    loop_width: for (int j= 0;j<cols;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            _src>>_s;
        loop_channels: for(int k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++)
            {
                _d.val[k]=sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(abs(_s.val[k]*alpha+beta));
            }
            _dst<<_d;
        }
    }
}
template<int XORDER, int YORDER, int SIZE, typename T>
void Sobel_kernel(Window<SIZE,SIZE,T > &kernel)
{
    int kerI[SIZE+1];
    Window<1,SIZE,T> kernelX;
    Window<SIZE,1,T> kernelY;

    for(int k=0; k<2; k++)
    {
        int order = k == 0 ? XORDER : YORDER;

        if( SIZE==3 )
        {
            if(order==0 )
                kerI[0]=1, kerI[1]=2, kerI[2]=1;
            else if( order == 1 )
                kerI[0]=-1, kerI[1]=0, kerI[2]=1;
            else
                kerI[0]=1, kerI[1]=-2, kerI[2]=1;
        }
        else
        {
            int oldval, newval;
            kerI[0] = 1;
            for(int i=0; i<SIZE; i++)
                kerI[i+1] = 0;

            for(int i=0; i<SIZE-order-1; i++)
            {
                oldval = kerI[0];
                for(int j = 1; j <= SIZE; j++ )
                {
                    newval = kerI[j]+kerI[j-1];
                    kerI[j-1] = oldval;
                    oldval = newval;
                }
            }

            for(int i = 0; i < order; i++ )
            {
                oldval = -kerI[0];
                for(int j = 1; j <= SIZE; j++ )
                {
                    newval = kerI[j-1] - kerI[j];
                    kerI[j-1] = oldval;
                    oldval = newval;
                }
            }
        }

        for(int i=0; i<SIZE; i++) {
         if(k==0)
             kernelX(0,i)=kerI[i];
         else
             kernelY(i,0)=kerI[i];
     }
    }

    for(int i=0; i<SIZE; i++) {
        for(int j=0; j<SIZE; j++) {
            kernel(i,j)=kernelY(i,0)*kernelX(0,j);
     }
    }

}

template<int XORDER, int YORDER, int SIZE, typename BORDERMODE, int SRC_T, int DST_T, int ROWS,int COLS,int DROWS,int DCOLS>
void Sobel (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, DST_T> &_dst)
{




    Window<SIZE,SIZE,ap_int<8> > kernel;
    Sobel_kernel<XORDER, YORDER >(kernel);
    Point_<int> c_point;
    c_point.x=-1;
    c_point.y=-1;
    Filter2D<BORDERMODE>(_src,_dst,kernel, c_point);
}

template<int XORDER, int YORDER, int SIZE, int SRC_T, int DST_T, int ROWS,int COLS,int DROWS,int DCOLS>
void Sobel (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, DST_T> &_dst)
{
    Sobel<XORDER,YORDER,SIZE,BORDER_DEFAULT>(_src, _dst);
}

template<int KH,int KW,typename K_T,typename XT, typename YT>
void getGaussianKernel(
        Window<KH,KW,K_T> &kernel,
        XT sigmaX=0,
        YT sigmaY=0
        )
{
_ssdm_InlineSelf(2, "");
     float kval[KH][KW];
     float sum=0;
     if(sigmaX <= 0)
     {
         sigmaX=0.3*((KW-1)*0.5-1)+0.8;
     }
     if(sigmaY <= 0)
     {
         sigmaY=0.3*((KH-1)*0.5-1)+0.8;
     }
     for (int i = 0; i < KH; i++) {
            for (int j = 0; j < KW; j++) {
                float index1=powf( (i-(KH-1)/2),2)*1.0/(2*sigmaY*sigmaY);
                float index2=powf( (j-(KW-1)/2),2)*1.0/(2*sigmaX*sigmaX);
                float index= -index1-index2;
                kval[i][j] = expf(index);
                sum+=kval[i][j];
            }
        }
     for (int i = 0; i < KH; i++) {
         for (int j = 0; j < KW; j++) {
             kval[i][j]=kval[i][j]/sum;
             kernel.val[i][j]=kval[i][j];
         }
     }

}

template<int KH,int KW,typename BORDERMODE,int SRC_T,int DST_T,int ROWS,int COLS>
void GaussianBlur(
  Mat<ROWS, COLS, SRC_T> &_src,
                Mat<ROWS, COLS, DST_T> &_dst,
                double sigmaX=0,
                double sigmaY=0)
{
    Point_<int> anchor;
    anchor.x = -1;
    anchor.y = -1;
    Window<KW, KH, ap_fixed<16,2,AP_RND> > kernel;
    getGaussianKernel(kernel,sigmaX,sigmaY);
    Filter2D<BORDERMODE>(_src, _dst, kernel, anchor);
}

template<int KH,int KW,int SRC_T,int DST_T,int ROWS,int COLS>
void GaussianBlur(
  Mat<ROWS, COLS, SRC_T> &_src,
                Mat<ROWS, COLS, DST_T> &_dst,
                double sigmaX=0,
                double sigmaY=0)
{
    GaussianBlur<KH,KW,BORDER_DEFAULT>(_src, _dst, sigmaX, sigmaY);
}


template <int KH,int KW>
void Box_kernel_1d(
        Window<1, KW, ap_ufixed<1,1> >& kernelX,
        Window<KH, 1, ap_ufixed<1,1> >& kernelY
        )
{
    float kval[KW];

    for (int i = 0; i < KW; i++) {
        kernelX.val[0][i] = 1;
    }

    for (int i = 0; i < KH; i++) {
        kernelY.val[i][0] = 1;
    }
}

template<int KH,int KW, bool NORMALIZE,typename BORDERMODE,
  int SRC_T,int DST_T,int ROWS,int COLS>
void BoxFilter(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        Point_<int> anchor=Point_<int>(-1,-1))
{
    Window<1, KW, ap_ufixed<1,1> > kernelX;
    Window<KH, 1, ap_ufixed<1,1> > kernelY;
    Box_kernel_1d(kernelX,kernelY);

    if( NORMALIZE)
    {
        const int BW = BitWidth<KH*KW>::Value+Type<((SRC_T) & ((1 << 11) - 1))>::bitdepth;
        const ap_ufixed<BW+1,1> scale = 1.0/(KH*KW);
        SepFilter2D<BORDERMODE>(_src, _dst, kernelX, kernelY, anchor, scale);
    }
    else
    {
        SepFilter2D<BORDERMODE>(_src, _dst, kernelX, kernelY, anchor);
    }
}

template<int KH,int KW, typename BORDERMODE, int SRC_T,int DST_T,int ROWS,int COLS>
void BoxFilter(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        Point_<int> anchor=Point_<int>(-1,-1))
{
    BoxFilter<KH,KW,true,BORDERMODE>(_src, _dst, anchor);
}

template<int KH,int KW, int SRC_T,int DST_T,int ROWS,int COLS>
void BoxFilter(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        Point_<int> anchor=Point_<int>(-1,-1))
{
    BoxFilter<KH,KW,true,BORDER_DEFAULT>(_src, _dst, anchor);
}


template <typename T,typename FT, int KH,int KW>
void Pyr_kernel(
        Window<KH, KW, T>& kernel,
        FT factor
        )
{
    int k[25]={1, 4, 6, 4, 1, 4, 16, 24, 16, 4, 6, 24, 36, 24, 6, 4, 16, 24, 16, 4, 1, 4, 6, 4, 1};
    for(int i=0; i<5; i++)
        for(int j=0; j<5; j++)
            kernel.val[i][j]=k[i*5+j]*(1.0/256)*factor;
}
template<int K_HEIGHT,int K_WIDTH,int SRC_T, int DST_T, typename KN_T,
         int ROWS,int COLS,int DROWS, int DCOLS>
void PyrUp_opr(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, DST_T> &_dst,
        Window<5,5,KN_T> &kernel
        )
{
    HLS_SIZE_T rows=_src.rows;
    HLS_SIZE_T cols=_src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 2772, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 2773, __extension__ __PRETTY_FUNCTION__));
_ssdm_InlineSelf(0, "");

    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_win[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    LineBuffer<K_HEIGHT,COLS,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];


    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> right_border_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

_ssdm_SpecArrayPartition( col_buf, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( &kernel, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_win, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( k_buf, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( right_border_buf, 0, "COMPLETE", 0, "");

    Point_< ap_int<14> > anchor;
    anchor.x=K_HEIGHT/2;
    anchor.y=K_WIDTH/2;
    ap_int<14> heightloop= 2*(rows+K_HEIGHT-1+K_HEIGHT);
    ap_int<14> widthloop = 2*(cols+K_WIDTH-1);
    Point_<ap_int<14> > ImagLoc;

    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);
 loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
    loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
                bool oddrow=(i+1)&1;
                bool oddcol=(j+1)&1;
                ImagLoc.x=j/2-anchor.x;
                ImagLoc.y=i/2-K_HEIGHT-anchor.y;
                int x= ImagLoc.x;
                if(ImagLoc.x<0)
                    x= -ImagLoc.x;
                else if( ImagLoc.x >= cols )
                    x=2*cols- ImagLoc.x-1;
channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++)
                {
                    if(oddcol)
                    {

                        for(int row= 0;row<K_HEIGHT;row++)
                            for(int col= K_WIDTH-1;col>=1;col--)
                                src_kernel_win[k](row,col) = src_kernel_win[k](row,col-1);

                        for(int buf_row = 0; buf_row < K_HEIGHT; buf_row++)
                        {

                            col_buf[k](buf_row,0) = k_buf[k](buf_row,x);
                        }

                        if((ImagLoc.y < (-anchor.y)) ||
                                (ImagLoc.y >= K_HEIGHT-1 && ImagLoc.y < rows-1 )) {

                            if(ImagLoc.x >= 0 && ImagLoc.x < cols) {
                                typename Type<((SRC_T) & ((1 << 11) - 1))>::name Toppixel = col_buf[k](K_HEIGHT-1,0);
                                src_kernel_win[k](K_HEIGHT-1,0) = Toppixel;
                                for(int buf_row= K_HEIGHT-1;buf_row >= 1;buf_row--)
                                {
                                    typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp = col_buf[k](buf_row-1,0);
                                    src_kernel_win[k](buf_row-1,0)=temp;
                                }
                                if(oddrow)
                                {
                                    if(ImagLoc.x >= cols - K_WIDTH)
                                    {
                                        right_border_buf[k](0,ImagLoc.x-(cols-K_WIDTH)) = Toppixel;
                                    }
                                    for(int buf_row= K_HEIGHT-1;buf_row >= 1;buf_row--)
                                    {
                                        typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp = col_buf[k](buf_row-1,0);
                                        k_buf[k](buf_row,x)=temp;
                                        if(ImagLoc.x >= cols - K_WIDTH)
                                        {
                                            right_border_buf[k](K_HEIGHT-buf_row,ImagLoc.x-(cols-K_WIDTH)) = temp;
                                        }
                                    }
                                    typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp=0;
                                    _src.data_stream[k] >> temp;
                                    k_buf[k](0,x)=temp;
                                }
                            }
                            else if(ImagLoc.x < 0)
                            {
                                for(int buf_row = 0;buf_row < K_HEIGHT; buf_row++)
                                {
                                    src_kernel_win[k](buf_row,0) = col_buf[k](buf_row,0);
                                }
                            }
                            else if (ImagLoc.x >= cols) {
                                for(int buf_row= 0;buf_row < K_HEIGHT; buf_row++)
                                {
                                    src_kernel_win[k](buf_row,0) = right_border_buf[k](K_HEIGHT-1-buf_row,x-(cols-K_WIDTH));
                                }
                                if(!oddrow)
                                {
                                   for(int buf_row= K_HEIGHT-1;buf_row>0;buf_row--)
                                     src_kernel_win[k](buf_row,0)= src_kernel_win[k](buf_row-1,0);
                                }

                            }
                        }
                        else if(ImagLoc.y > 0 )
                        {
                            ap_int<14> ref = K_HEIGHT-1;
                            if(ImagLoc.y >= rows-1)
                                ref = rows-1;
                            ap_int<14> y = ImagLoc.y;
                            for(int buf_row= 0;buf_row<K_HEIGHT;buf_row++)
                            {
                                ap_int<14> t=y;
                                if(y<0)
                                    t=-y;
                                else if( y >= rows )
                                    t=2*rows-y-1;

                                ap_int<14> locy = ref - t;
                                src_kernel_win[k](buf_row,0) = col_buf[k](locy,0);
                                y--;
                            }
                           if(ImagLoc.y >= rows-1&&!oddrow)
                            {
                                for(int buf_row= K_HEIGHT-1;buf_row>0;buf_row--)
                                   src_kernel_win[k](buf_row,0)= src_kernel_win[k](buf_row-1,0);
                            }
                        }

                    }

                    if(i >= 2*(K_HEIGHT + K_HEIGHT - 1) && j >= 2*(K_WIDTH-1))
                    {
                        typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, KN_T, K_HEIGHT*K_WIDTH>::ACCUM_T result=0;
                        if(oddrow)
                        {
                            if(oddcol)
                            {
                                for(int m=0; m<K_HEIGHT; m++)
                                    for(int n=0; n<K_WIDTH; n++)
                                        result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[2*m][2*n];
                            }
                            else
                            {
                                for(int m=0; m<K_HEIGHT; m++)
                                    for(int n=1; n<K_WIDTH; n++)
                                        result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[2*m][2*n-1];
                            }
                        }else
                        {
                            if(oddcol)
                            {
                                for(int m=0; m<K_HEIGHT-1; m++)
                                    for(int n=0; n<K_WIDTH; n++)
                                        result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[2*m+1][2*n];
                            }
                            else
                            {

                                for(int m=0; m<K_HEIGHT-1; m++)
                                    for(int n=1; n<K_WIDTH; n++)
                                        result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[2*m+1][2*n-1];
                            }
                        }
                        _dst.data_stream[k]<< sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(result);
                    }
                }
            }
             }
}
template<int SRC_T,int DST_T,int ROWS,int COLS, int DROWS, int DCOLS>
void PyrUp(
  Mat<ROWS, COLS, SRC_T> &_src,
                Mat<DROWS, DCOLS, DST_T> &_dst
                )
{



    Window<5, 5, ap_fixed<16,2,AP_RND> > kernel;
    Pyr_kernel(kernel, 4);
    PyrUp_opr<3,3>(_src, _dst, kernel);
}

template<int K_HEIGHT,int K_WIDTH,int SRC_T, int DST_T, typename KN_T,
         int ROWS,int COLS,int DROWS, int DCOLS>
void PyrDown_opr(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, DST_T> &_dst,
        Window<5,5,KN_T> &kernel
        )
{



_ssdm_InlineSelf(0, "");

    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_win[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    LineBuffer<K_HEIGHT,COLS,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];


    LineBuffer<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> right_border_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    LineBuffer<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

_ssdm_SpecArrayPartition( col_buf, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( &kernel, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_win, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( k_buf, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( right_border_buf, 0, "COMPLETE", 0, "");

    Point_< ap_int<4> > anchor;
    anchor.x=K_WIDTH/2;
    anchor.y=K_HEIGHT/2;

    HLS_SIZE_T rows=_src.rows;
    HLS_SIZE_T cols=_src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 2993, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 2994, __extension__ __PRETTY_FUNCTION__));
    HLS_SIZE_T heightloop= rows+K_HEIGHT-1+K_HEIGHT;
    HLS_SIZE_T widthloop = cols+K_WIDTH-1;
    Point_< ap_int<14> > ImagLoc;

    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);
 loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
    loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
                bool oddrow=(i+1)&1;
                bool oddcol=(j+1)&1;

                ImagLoc.x=j-anchor.x;
                ImagLoc.y=i-K_HEIGHT-anchor.y;
                int x=ImagLoc.x ;
                if(ImagLoc.x<0)
                    x=-ImagLoc.x;
                else if( ImagLoc.x >= cols )
                    x=2*cols-ImagLoc.x-2;
channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++)
                {

                    for(int row= 0;row<K_HEIGHT;row++)
                        for(int col= K_WIDTH-1;col>=1;col--)
                            src_kernel_win[k](row,col) = src_kernel_win[k](row,col-1);

                    for(int buf_row = 0; buf_row < K_HEIGHT; buf_row++)
                    {

                        col_buf[k](buf_row,0) = k_buf[k](buf_row,x);
                    }
                    if((ImagLoc.y < (-anchor.y)) ||
                            (ImagLoc.y >= K_HEIGHT-1 && ImagLoc.y < rows-1 ))
                    {

                        if(ImagLoc.x >= 0 && ImagLoc.x < cols)
                        {
                            typename Type<((SRC_T) & ((1 << 11) - 1))>::name Toppixel = col_buf[k](K_HEIGHT-1,0);
                            src_kernel_win[k](K_HEIGHT-1,0) = Toppixel;
                            if(ImagLoc.x >= cols - K_WIDTH)
                            {
                                right_border_buf[k](0,ImagLoc.x-(cols-K_WIDTH)) = Toppixel;
                            }
                            for(int buf_row= K_HEIGHT-1;buf_row >= 1;buf_row--)
                            {
                                typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp = col_buf[k](buf_row-1,0);
                                src_kernel_win[k](buf_row-1,0)=temp;
                                k_buf[k](buf_row,x)=temp;
                                if(ImagLoc.x >= cols - K_WIDTH)
                                {
                                    right_border_buf[k](K_HEIGHT-buf_row,ImagLoc.x-(cols-K_WIDTH)) = temp;
                                }
                            }
                            typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp=0;
                            _src.data_stream[k] >> temp;
                            k_buf[k](0,x)=temp;
                        }
                        else if(ImagLoc.x < 0)
                        {
                            for(int buf_row = 0;buf_row < K_HEIGHT; buf_row++)
                            {
                                src_kernel_win[k](buf_row,0) = col_buf[k](buf_row,0);
                            }
                        }
                        else if (ImagLoc.x >= cols)
                        {
                            for(int buf_row= 0;buf_row < K_HEIGHT; buf_row++)
                            {
                                src_kernel_win[k](buf_row,0) = right_border_buf[k](K_HEIGHT-1-buf_row,x-(cols-K_WIDTH));
                            }
                        }
                    }
                    else if(ImagLoc.y >= 0) {

                        ap_int<14> ref = K_HEIGHT-1;
                        if(ImagLoc.y >= rows-1)
                            ref = rows-1;
                        ap_int<14> y = ImagLoc.y;
                        for(int buf_row= 0;buf_row<K_HEIGHT;buf_row++)
                        {
                            ap_int<14> t = y;
                            if(y<0)
                                t=-y;
                            else if( y>= rows )
                                t=2*rows-y-2;
                            ap_int<14> locy = ref - t;
                            (static_cast <bool> (t < 0 || (locy >= 0 && locy < K_HEIGHT)) ? void (0) : __assert_fail ("t < 0 || (locy >= 0 && locy < K_HEIGHT)", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_imgproc.h", 3082, __extension__ __PRETTY_FUNCTION__));
                            src_kernel_win[k](buf_row,0) = col_buf[k](locy,0);
                            y--;
                        }
                    }

                    if(i >= (K_HEIGHT + K_HEIGHT - 1) && j >= (K_WIDTH-1))
                    {
                        typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, KN_T, 5*5>::ACCUM_T result=0;
                        if(!oddrow&&oddcol)
                        {
                            for(int m=0; m<K_HEIGHT; m++)
                                for(int n=0; n<K_WIDTH; n++)
                                    result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[m][n];
                            _dst.data_stream[k]<< sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(result);
                        }
                    }
                }
            }
             }
}
template<int SRC_T,int DST_T,int ROWS,int COLS, int DROWS, int DCOLS>
void PyrDown(
  Mat<ROWS, COLS, SRC_T> &_src,
                Mat<DROWS, DCOLS, DST_T> &_dst
                )
{
    Window<5, 5, ap_fixed<16,2,AP_RND> > kernel;
    Pyr_kernel(kernel, 1);
    PyrDown_opr<5,5>(_src, _dst, kernel);
}

}
# 63 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_video.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_histogram.h" 1
# 39 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_histogram.h"
namespace hls {

template<int SRC_T, int DST_T,int ROW, int COL, int N>
void Equalize(
 Mat<ROW, COL, SRC_T> &_src,
 Mat<ROW, COL, DST_T> &_dst,
    ap_uint<8> (&map)[N]
                      )
{

    const int NUM_STATES=4;
    Window<1,NUM_STATES,ap_uint<8> > addr_win;

    ap_uint<BitWidth<ROW*COL>::Value> hist_out[N];
    Window<1,NUM_STATES,ap_uint<BitWidth<ROW*COL>::Value> > hist_win;
    ap_uint<BitWidth<ROW*COL>::Value> hist;
    ap_uint<8> addr;
    ap_uint<8> addr_last;
    ap_uint<BitWidth<ROW*COL>::Value> hist_last;
    ap_uint<8> addr_flag;
    ap_uint<BitWidth<ROW*COL>::Value> hist_flag;
    ap_uint<8> addr_w;
    ap_uint<BitWidth<ROW*COL>::Value> hist_w;

    for(int i=0;i<NUM_STATES;i++) {
    _ssdm_Unroll(0,0,0, "");
        addr_win(0,i)=i;
        hist_win(0,i)=0;
    }

    for(int i=0;i<N;i++)
        hist_out[i]=0;

    int cols=_src.cols;
    int rows=_src.rows;
    (static_cast <bool> (rows<=ROW) ? void (0) : __assert_fail ("rows<=ROW", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_histogram.h", 74, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols<=COL) ? void (0) : __assert_fail ("cols<=COL", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_histogram.h", 75, __extension__ __PRETTY_FUNCTION__));
 loop_height: for(int i=0;i<rows;i++)
    {
    loop_width: for(int j=0;j<cols;j++)
        {
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
_ssdm_SpecLoopFlatten(1, "");
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
            ap_uint<4> flag=NUM_STATES;
            typename Type<((SRC_T) & ((1 << 11) - 1))>::name tempsrc=0;
            typename Type<((DST_T) & ((1 << 11) - 1))>::name tempdst=0;
            _src.data_stream[0].read(tempsrc);
            tempdst=map[tempsrc];
            _dst.data_stream[0]<<tempdst;

            for (int m=0; m<NUM_STATES; m++) {
                if (tempsrc==addr_win(0,m)) {
                    flag = m;
                    break;
                }
            }

            latency_region:{
            _ssdm_op_SpecLatency(0, 1, "");
            addr_last = addr_win(0,NUM_STATES-1);
            hist_last = hist_win(0,NUM_STATES-1)+1;

            for (int m=NUM_STATES-1; m>0; m--) {
                addr = addr_win(0,m-1);
                hist = hist_win(0,m-1);
                if (m==NUM_STATES/2) {
                    addr_w = addr;
                    if (m==flag+1) {
                        hist_w = hist+1;
                    } else {
                        hist_w = hist;
                    }
                }
                if (m==flag+1) {
                    addr_flag = addr;
                    hist_flag = hist+1;
                    addr_win(0,m) = addr_flag;
                    hist_win(0,m) = hist_flag;
                } else {
                    addr_win(0,m) = addr;
                    hist_win(0,m) = hist;
                }
            }

            if (flag==NUM_STATES) {
                hist_win(0,0) = hist_out[tempsrc]+1;
                addr_win(0,0) = tempsrc;
            } else if (flag==NUM_STATES-1) {
                addr_win(0,0) = addr_last;
                hist_win(0,0) = hist_last;
            } else if (flag>=NUM_STATES/2) {
                addr_win(0,0) = addr_flag;
                hist_win(0,0) = hist_flag;
            } else {
                addr_win(0,0) = addr_w;
                hist_win(0,0) = hist_w;
            }

            hist_out[addr_w] = hist_w;
            }
        }
    }
    for (int m=0; m<NUM_STATES/2; m++) {
    _ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
        hist_out[addr_win(0,m)]=hist_win(0,m);
    }



    float scale = 1.f;
    ap_uint<BitWidth<ROW*COL>::Value> sum=0;
    bool flag = false;
 loop_normalize: for(int i=0;i<N;i++)
    {
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

        if (!flag) {
            if (hist_out[i] != 0) {
                flag = true;
                scale = 255.0f/(cols*rows - hist_out[i]);
                map[i] = 0;
                continue;
            }
        }

        sum+=hist_out[i];
        ap_uint<8> val=sr_cast< ap_uint<8> > (sum*scale);
        map[i]=val;
    }
    map[0]=0;
}

static ap_uint<8> lut[256];
template<int SRC_T, int DST_T,int ROW, int COL>
void EqualizeHist(
  Mat<ROW, COL, SRC_T> &_src,
  Mat<ROW, COL, DST_T> &_dst)
{
_ssdm_InlineSelf(0, "");
    Equalize(_src, _dst, lut);
}
}
# 64 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_video.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_fast.h" 1
# 39 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_fast.h"
namespace hls {

    template<int PSize,int KERNEL_SIZE,int NUM,typename SRC_T, typename DIFF_T>
int fast_pixel_diff(
        Window<KERNEL_SIZE,KERNEL_SIZE,SRC_T> &win,
        SRC_T _threshold,
        ap_uint<2> (&flag_val)[NUM],
        DIFF_T (&flag_d)[NUM],
        int (&flag)[PSize][2])
{
_ssdm_InlineSelf(0, "");
    DIFF_T d1,d2;
    int vt1,vt2;
    int x1,x2,y1,y2;
    int result=3;
    int K=PSize/2;
    for(int index=0;index<K;index++) {
        int kernel_half=KERNEL_SIZE/2;
        x1=flag[index][0];
        y1=flag[index][1];
        x2=flag[index+K][0];
        y2=flag[index+K][1];
        d1=win.val[kernel_half][kernel_half]-win.val[ y1 ][ x1 ];
        d2=win.val[kernel_half][kernel_half]-win.val[ y2 ][ x2 ];
        flag_d[index]=d1;
        flag_d[index+K]=d2;
        flag_d[index+PSize]=d1;
        if (d1 > _threshold)
            vt1=1;
        else if(d1 < -_threshold)
            vt1=2;
        else
            vt1=0;
        if (d2 > _threshold)
            vt2=1;
        else if(d2 < -_threshold)
            vt2=2;
        else
            vt2=0;
        result &= vt1 | vt2;
        flag_val[index] = vt1;
        flag_val[index+K] = vt2;
        flag_val[index+PSize] = vt1;
    }
    flag_val[PSize/2+PSize] = flag_val[PSize/2];
    flag_d[PSize/2+PSize] = flag_d[PSize/2];
    return result;
}

    template<int PSize,int NUM, typename DIFF_T, typename SRC_T>
int coreScore(DIFF_T (&flag_d)[NUM], SRC_T _threshold)
{
_ssdm_InlineSelf(0, "");

    DIFF_T flag_d_min2[NUM-1];
    DIFF_T flag_d_max2[NUM-1];
    DIFF_T flag_d_min4[NUM-3];
    DIFF_T flag_d_max4[NUM-3];
    DIFF_T flag_d_min8[NUM-7];
    DIFF_T flag_d_max8[NUM-7];
_ssdm_SpecArrayPartition( flag_d_min2, 0, "complete", 0, "");
_ssdm_SpecArrayPartition( flag_d_max2, 0, "complete", 0, "");
_ssdm_SpecArrayPartition( flag_d_min4, 0, "complete", 0, "");
_ssdm_SpecArrayPartition( flag_d_max4, 0, "complete", 0, "");
    if(PSize == 16) {
        for(int i=0;i<NUM-1;i++) {
            flag_d_min2[i] = reg(hls::min<int>(flag_d[i],flag_d[i+1]));
            flag_d_max2[i] = reg(hls::max<int>(flag_d[i],flag_d[i+1]));
        }
        for(int i=0;i<NUM-3;i++) {
            flag_d_min4[i] = reg(hls::min<int>(flag_d_min2[i],flag_d_min2[i+2]));
            flag_d_max4[i] = reg(hls::max<int>(flag_d_max2[i],flag_d_max2[i+2]));
        }

        for(int i=0;i<NUM-7;i++) {
            flag_d_min8[i] = reg(hls::min<int>(flag_d_min4[i],flag_d_min4[i+4]));
            flag_d_max8[i] = reg(hls::max<int>(flag_d_max4[i],flag_d_max4[i+4]));
        }
    } else {



    }

    DIFF_T a0 = _threshold;
    for(int i=0;i<PSize;i+=2) {
        DIFF_T a = hls::numeric_limits<DIFF_T>::max();
        if(PSize == 16) {
            a = flag_d_min8[i+1];
        } else {
            for(int j=1;j<PSize/2+1;j++) {
                a=hls::min<int>(a,flag_d[i+j]);
            }
        }
        a0 = hls::max<int>(a0,hls::min<int>(a,flag_d[i]));
        a0 = hls::max<int>(a0,hls::min<int>(a,flag_d[i+PSize/2+1]));
    }
    DIFF_T b0 = -_threshold;
    for(int i=0;i<PSize;i+=2) {
        DIFF_T b = hls::numeric_limits<DIFF_T>::min();
        if(PSize == 16) {
            b = flag_d_max8[i+1];
        } else {
            for(int j=1;j<PSize/2+1;j++) {
                b=hls::max<int>(b,flag_d[i+j]);
            }
        }
        b0 = hls::min<int>(b0,hls::max<int>(b,flag_d[i]));
        b0 = hls::min<int>(b0,hls::max<int>(b,flag_d[i+PSize/2+1]));
    }
    return hls::max<int>(a0,(DIFF_T)-b0)-1;
}

template<int PSize,int KERNEL_SIZE,typename SRC_T, typename DIFF_T>
bool fast_judge(Window<KERNEL_SIZE,KERNEL_SIZE,SRC_T> & win,
                SRC_T _threshold,
                ap_uint<2> (&flag_val)[PSize+PSize/2+1],
                DIFF_T (&flag_d)[PSize+PSize/2+1],
                int (&flag)[PSize][2],
                int &core,
                bool _nonmax_supression) {
_ssdm_SpecArrayPartition( flag_val, 0, "complete", 0, "");
_ssdm_SpecArrayPartition( flag_d, 0, "complete", 0, "");

_ssdm_InlineSelf(0, "");
    bool iscorner=false;
    int kernel_half=KERNEL_SIZE/2;
    int result=fast_pixel_diff<PSize>(win,_threshold,flag_val,flag_d,flag);
    int count=1;
    for(int c=1;c<PSize+PSize/2+1;c++)
    {
        if(flag_val[c-1]==flag_val[c] && flag_val[c]>0)
        {
            count++;
            if(count>PSize/2)
            {
                iscorner=true;
            }
        }
        else
        {
            count=1;
        }
    }
    if(_nonmax_supression && iscorner) {
        core=coreScore<PSize>(flag_d,_threshold);
    }
    return iscorner;
}
template<int KERNEL_SIZE,typename SRC_T>
bool fast_nonmax(
        Window<KERNEL_SIZE,KERNEL_SIZE,SRC_T> & core_win
        )
{
_ssdm_InlineSelf(0, "");
    bool iscorner=true;
    for(int k=0;k<3;k++) {
        if(core_win.val[1][1]>core_win.val[0][k])
            iscorner=iscorner && true;
        else
            iscorner=iscorner && false;
    }
    for(int k=0;k<3;k++) {
        if(core_win.val[1][1]>core_win.val[2][k])
            iscorner=iscorner && true;
        else
            iscorner=iscorner && false;
    }
    if(core_win.val[1][1]>core_win.val[1][0]&&core_win.val[1][1]>core_win.val[1][2])
        iscorner=iscorner && true;
    else
        iscorner=iscorner && false;
    return iscorner;
}

template<int PSize,int KERNEL_SIZE,int SRC_T,int ROWS,int COLS>
void FAST_t_opr(
        Mat<ROWS,COLS,SRC_T> &_src,
        Mat<ROWS,COLS,(((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> &_mask,
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name _threshold,
        bool _nonmax_supression,
        int (&flag)[PSize][2]) {
    typedef typename pixel_op_type<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>::T INPUT_T;
    LineBuffer<KERNEL_SIZE-1,COLS,INPUT_T> k_buf;
    LineBuffer<2,COLS+KERNEL_SIZE,ap_int<16> > core_buf;
    Window<3,3,ap_int<16> > core_win;
    Window<KERNEL_SIZE,KERNEL_SIZE,INPUT_T> win;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<(((((((0) & ((1 << 11) - 1)) + (((1)-1) << 11))) & ((512 - 1) << 11)) >> 11) + 1),typename Type<(((((0) & ((1 << 11) - 1)) + (((1)-1) << 11))) & ((1 << 11) - 1))>::name> d;
    int rows= _src.rows;
    int cols= _src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_fast.h", 230, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_fast.h", 231, __extension__ __PRETTY_FUNCTION__));
    int kernel_half=KERNEL_SIZE/2;
    ap_uint<2> flag_val[PSize+PSize/2+1];
    int flag_d[PSize+PSize/2+1];
_ssdm_SpecArrayPartition( flag_val, 0, "complete", 0, "");
_ssdm_SpecArrayPartition( flag_d, 0, "complete", 0, "");

    int index=0;
    int offset=KERNEL_SIZE/2;
    if(_nonmax_supression)
    {
        offset=offset+1;
    }
 loop_height: for(HLS_SIZE_T i=0;i<rows+offset;i++) {
    loop_width: for(HLS_SIZE_T j=0;j<cols+offset;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            d.val[0]=0;
            if((i<rows&&j<cols)) {
                for(int r= 0;r<KERNEL_SIZE;r++) {
                    for(int c=0;c<KERNEL_SIZE-1;c++) {
                        win.val[r][c]=win.val[r][c+1];
                    }
                }
                win.val[0][KERNEL_SIZE-1]=k_buf.val[0][j];
                for(int buf_row= 1;buf_row< KERNEL_SIZE-1;buf_row++) {
                    win.val[buf_row][KERNEL_SIZE-1]=k_buf.val[buf_row][j];
                    k_buf.val[buf_row-1][j]=k_buf.val[buf_row][j];
                }

                _src>>s;
                win.val[KERNEL_SIZE-1][KERNEL_SIZE-1]=s.val[0];
                k_buf.val[KERNEL_SIZE-2][j]=s.val[0];
            }

            for(int r= 0;r<3;r++)
            {
                for(int c=0;c<3-1;c++)
                {
                    core_win.val[r][c]=core_win.val[r][c+1];
                }
            }
            core_win.val[0][3-1]=core_buf.val[0][j];
            for(int buf_row= 1;buf_row< 3-1;buf_row++)
            {
                core_win.val[buf_row][3-1]=core_buf.val[buf_row][j];
                core_buf.val[buf_row-1][j]=core_buf.val[buf_row][j];
            }
            int core=0;


            if(i>=KERNEL_SIZE-1 && i<rows && j>=KERNEL_SIZE-1 & j<cols)
            {

                bool iscorner=fast_judge<PSize>(win,(INPUT_T)_threshold,flag_val,flag_d,flag,core,_nonmax_supression);
                if(iscorner&&!_nonmax_supression)
                {
                    d.val[0]=255;
                }
            }
            if(i>=rows||j>=cols)
            {
                core=0;
            }
            if(_nonmax_supression)
            {
                core_win.val[3-1][3-1]=core;
                core_buf.val[3-2][j]=core;
                if(core_win.val[1][1]!=0&&i>=KERNEL_SIZE&&j>=KERNEL_SIZE)
                {
                    bool iscorner=fast_nonmax(core_win);
                    if(iscorner)
                    {
                        d.val[0]=255;
                    }
                }
            }

            if(i>=offset&&j>=offset)
            {
                _mask<<d;
            }
        }
    }
}
template<int SRC_T,int ROWS,int COLS>
void FASTX(
        Mat<ROWS,COLS,SRC_T> &_src,
        Mat<ROWS,COLS,(((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> &_mask,
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name _threshold,
        bool _nomax_supression
        )
{
_ssdm_InlineSelf(0, "");
    int flag[16][2]={{3,0},{4,0},{5,1},{6,2},{6,3},{6,4},{5,5},{4,6},
        {3,6},{2,6},{1,5},{0,4},{0,3},{0,2},{1,1},{2,0}};
    FAST_t_opr<16,7>(_src,_mask,_threshold,_nomax_supression,flag);
}

template<int PSize,int KERNEL_SIZE,typename T, int N, int SRC_T,int ROWS,int COLS>
void FAST_t_opr(
        Mat<ROWS,COLS,SRC_T> &_src,
        Point_<T> (&_keypoints)[N],
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name _threshold,
        bool _nonmax_supression,
        int (&flag)[PSize][2]
        )
{
    typedef typename pixel_op_type<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>::T INPUT_T;
    LineBuffer<KERNEL_SIZE-1,COLS,INPUT_T> k_buf;
    LineBuffer<2,COLS+KERNEL_SIZE,ap_int<16> > core_buf;
    Window<3,3,ap_int<16> > core_win;
    Window<KERNEL_SIZE,KERNEL_SIZE,INPUT_T> win;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    int rows= _src.rows;
    int cols= _src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_fast.h", 347, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_fast.h", 348, __extension__ __PRETTY_FUNCTION__));
    int kernel_half=KERNEL_SIZE/2;
    ap_uint<2> flag_val[PSize+PSize/2+1];
    int flag_d[PSize+PSize/2+1];
_ssdm_SpecArrayPartition( flag_val, 0, "complete", 0, "");
_ssdm_SpecArrayPartition( flag_d, 0, "complete", 0, "");
    int index=0;
    int offset=KERNEL_SIZE/2;

    if(_nonmax_supression)
    {
        offset=offset+1;
    }
 loop_height: for(HLS_SIZE_T i=0;i<rows+offset;i++) {
    loop_width: for(HLS_SIZE_T j=0;j<cols+offset;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            if(i<rows&&j<cols) {
                for(int r= 0;r<KERNEL_SIZE;r++) {
                    for(int c=0;c<KERNEL_SIZE-1;c++) {
                        win.val[r][c]=win.val[r][c+1];
                    }
                }
                win.val[0][KERNEL_SIZE-1]=k_buf.val[0][j];
                for(int buf_row= 1;buf_row< KERNEL_SIZE-1;buf_row++) {
                    win.val[buf_row][KERNEL_SIZE-1]=k_buf.val[buf_row][j];
                    k_buf.val[buf_row-1][j]=k_buf.val[buf_row][j];
                }

                _src>>s;
                win.val[KERNEL_SIZE-1][KERNEL_SIZE-1]=s.val[0];
                k_buf.val[KERNEL_SIZE-2][j]=s.val[0];
            }

            for(int r= 0;r<3;r++)
            {
                for(int c=0;c<3-1;c++)
                {
                    core_win.val[r][c]=core_win.val[r][c+1];
                }
            }
            core_win.val[0][3-1]=core_buf.val[0][j];
            for(int buf_row= 1;buf_row< 3-1;buf_row++)
            {
                core_win.val[buf_row][3-1]=core_buf.val[buf_row][j];
                core_buf.val[buf_row-1][j]=core_buf.val[buf_row][j];
            }
            int core=0;


            if(i>=KERNEL_SIZE-1 && i<rows && j>=KERNEL_SIZE-1 & j<cols)
            {

                bool iscorner=fast_judge<PSize>(win,(INPUT_T)_threshold,flag_val,flag_d,flag,core,_nonmax_supression);
                if(iscorner&&!_nonmax_supression)
                {
                    if(index<N)
                    {
                    _keypoints[index].x=j-offset;
                    _keypoints[index].y=i-offset;
                    index++;
                    }
                }
            }
            if(i>=rows||j>=cols)
            {
                core=0;
            }
            if(_nonmax_supression)
            {
                core_win.val[3-1][3-1]=core;
                core_buf.val[3-2][j]=core;
                if(i>=KERNEL_SIZE&&j>=KERNEL_SIZE&&core_win.val[1][1]!=0)
                {
                    bool iscorner=fast_nonmax(core_win);
                    if(iscorner)
                    {
                    if(index<N)
                    {
                        _keypoints[index].x=j-offset;
                        _keypoints[index].y=i-offset;
                        index++;
                    }
                    }
                }
            }

        }
    }
}
template<typename T, int N, int SRC_T,int ROWS,int COLS>
void FASTX(
        Mat<ROWS,COLS,SRC_T> &_src,
        Point_<T> (&_keypoints)[N],
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name _threshold,
        bool _nomax_supression
        )
{
_ssdm_InlineSelf(0, "");
    int flag[16][2]={{3,0},{4,0},{5,1},{6,2},{6,3},{6,4},{5,5},{4,6},
        {3,6},{2,6},{1,5},{0,4},{0,3},{0,2},{1,1},{2,0}};
    FAST_t_opr<16,7>(_src,_keypoints,_threshold,_nomax_supression,flag);
}
template<int SRC_T,int MASK_T,int ROWS,int COLS>
void PaintMask(
        Mat<ROWS,COLS,SRC_T> &_src,
        Mat<ROWS,COLS,MASK_T> &_mask,
        Mat<ROWS,COLS,SRC_T> &_dst,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _color
        )
{






    int rows= _src.rows;
    int cols= _src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_fast.h", 467, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_fast.h", 468, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> d;
    Scalar<((((MASK_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MASK_T) & ((1 << 11) - 1))>::name> m;
 loop_height: for(HLS_SIZE_T i=0;i<rows;i++) {
    loop_width: for(HLS_SIZE_T j=0;j<cols;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            _src >> s;
            _mask >> m;
            if(m.val[0]!=0)
            {
                d = _color;
            }
            else
            {
                d = s;
            }
            _dst << d;
        }
    }
}
}
# 65 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_video.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h" 1
# 83 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h"
namespace hls {

template <int N, typename T,typename PT>
void LU( T A[N][N], PT pos[N])
{
    int imax = 0;
    T lu[N] ;
    for (int i = 0; i < N; i++)
    {
        lu[i]=0;
    }
    for (int i = 0; i < N; i++) {
        T big = 0.0;
        for (int j = 0; j < N; j++) {
            T temp = ::hls::abs((double)A[i][j]);
            if (temp > big) big = temp;
        }
        lu[i] = ((T)1.0)/big;
    }
    for (int j = 0; j < N; j++) {
        for (int i = 0; i < j; i++) {
            T sum = A[i][j];
            for (int k = 0; k < i; k++) sum -= A[i][k] * A[k][j];
            A[i][j] = sum;
        }
        T big = 0.0;
        for (int i = j; i < N; i++) {
            T sum = A[i][j];
            for (int k = 0; k < j; k++) sum -= A[i][k] * A[k][j];
            A[i][j] = sum;
            T dum = lu[i] *((T) ::hls::abs((double)sum));
            if (dum >= big) {
                big = dum;
                imax = i;
            }
        }
        if (j != imax&&imax<N&&imax>=0) {
            for (int i = 0; i < N; i++) {
                T mid = A[imax][i];
                A[imax][i] = A[j][i];
                A[j][i] = mid;
            }
            T mid = lu[j];
            lu[j] = lu[imax];
            lu[imax] = mid;
        }
        pos[j] = imax;
        if (j != N - 1) {
            T dum = ((T)1.0)/(A[j][j]);
            for (int i = j + 1; i < N; i++) A[i][j] *= dum;
        }
    }
}
template <int N, typename T, typename PT,typename BT>
void LUex(T A[N][N], PT pos[N],BT b[N])
{
    int ii = 0;
    for (int i = 0; i < N; i++) {
        int ip = pos[i];
        T sum=0;
        if(ip<N&& ip>=0)
        {
            sum = b[ip];
            b[ip] = b[i];
        }
        if (ii != 0)
            for (int j = ii - 1; j < i; j++) sum -= A[i][j] * b[j];
        else
            ii = i + 1;
        b[i] = sum;
    }
    for (int i = N - 1; i >= 0; i--) {
        T sum = b[i];
        for (int j = i + 1; j < N; j++) sum -= A[i][j]*b[j];
        b[i] = (sum)*((T) 1.0/A[i][i]);
    }
}


template <int N,typename T>
void Invert(T A[N][N],T Ar[N][N], int flags=0)
{
    T b[N];
    int pos[N];
    for (int i = 0; i < N; i++) {
        b[i]=0;
        pos[i]=0;
    }
    LU<N>(A,pos);
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) b[j] = 0;
        b[i] = 1.0;
        LUex<N>(A,pos,b);
        for (int j = 0; j < N; j++) Ar[j][i] = b[j];
    }
}
template<int AROW, int ACOL, int BCOL, typename AT, typename BT, typename CT>
void mul(
               AT A [AROW][ ACOL],
               BT B [ACOL][ BCOL],
               CT C [AROW][ BCOL]
)
{
 loop_i: for(int i=0; i<AROW; i++)
    {
    loop_j: for(int j=0; j<BCOL; j++)
        {
            CT sum=0;
        loop_k: for(int k=0; k<ACOL; k++)
                {
                sum=sum+A[i][k]*B[k][j];

            }
            C[i][j]=sum;
        }
    }
}





template <int WIN_ROW, int ROWS, int COLS, int SRC_T, int DST_T, int MAP1_T, int MAP2_T>
void Remap_nearest(
           Mat<ROWS, COLS, SRC_T> &src,
           Mat<ROWS, COLS, DST_T> &dst,
           Mat<ROWS, COLS, MAP1_T> &map1,
           Mat<ROWS, COLS, MAP2_T> &map2


        )
{
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> buf[WIN_ROW][COLS];
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    Scalar<((((MAP1_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MAP1_T) & ((1 << 11) - 1))>::name> m1;
    Scalar<((((MAP2_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MAP2_T) & ((1 << 11) - 1))>::name> m2;
    int rows=src.rows;
    int cols=src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h", 222, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h", 223, __extension__ __PRETTY_FUNCTION__));
    int ishift=WIN_ROW/2;
    int r[WIN_ROW] = {};

 loop_height: for( int i=0; i< rows+ishift; i++)
    {
_ssdm_SpecLoopFlatten(1, "");
    loop_width: for( int j=0; j< cols; j++)
        {
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
            if(i<rows&& j<cols)
            {
                src >> s;
            }
            buf[i % WIN_ROW][j] = s;
            r[i % WIN_ROW] = i;

            if(i>=ishift)
            {
                map1 >> m1;
                map2 >> m2;
                int x=m1.val[0]+1;
                int y=m1.val[1]+1;

                bool in_range = (y>=0 && y<rows && r[y%WIN_ROW] == y && x>=0 && x<cols);
                if(in_range) {
                    d = buf[y%WIN_ROW][x];
                } else {
                    for(int k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++) {
                        d.val[k]=0;
                    }
                }
                dst<< d;
            }
        }
    }
}

template <int WIN_ROW, int ROWS, int COLS, int SRC_T, int DST_T, int MAP1_T, int MAP2_T>
void Remap_linear(
           Mat<ROWS, COLS, SRC_T> &src,
           Mat<ROWS, COLS, DST_T> &dst,
           Mat<ROWS, COLS, MAP1_T> &map1,
           Mat<ROWS, COLS, MAP2_T> &map2


        )
{

    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> buf[WIN_ROW/2+1][2][COLS/2+1][2];
_ssdm_SpecArrayPartition( buf, 2, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( buf, 4, "COMPLETE", 0, "");
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((MAP1_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MAP1_T) & ((1 << 11) - 1))>::name> m1;
    Scalar<((((MAP2_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MAP2_T) & ((1 << 11) - 1))>::name> m2;
    int rows=src.rows;
    int cols=src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h", 281, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h", 282, __extension__ __PRETTY_FUNCTION__));
    int ishift=WIN_ROW/2;
    int r1[WIN_ROW] = {};
    int r2[WIN_ROW] = {};

 loop_height: for( int i=0; i< rows+ishift; i++)
    {
_ssdm_SpecLoopFlatten(1, "");
    loop_width: for( int j=0; j< cols; j++)
        {
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
            if(i<rows&& j<cols)
            {
                src >> s;
            }
            if((i % WIN_ROW) % 2) {
                buf[(i % WIN_ROW)/2][(i % WIN_ROW) % 2][j/2][j%2] = s;
            } else {
                buf[(i % WIN_ROW)/2][(i % WIN_ROW) % 2][j/2][j%2] = s;
            }
            r1[i % WIN_ROW] = i;
            r2[i % WIN_ROW] = i;

            if(i>=ishift)
            {
                map1 >> m1;
                map2 >> m2;
                int x=m1.val[0];
                int y=m1.val[1];

                int ynext = y+1;

                ap_ufixed<5, 0> iu, iv;
                iu(5 -1, 0) = m2.val[0] & (32 -1);
                iv(5 -1, 0) = (m2.val[0] >> 5) & (32 -1);



                bool in_range = (y>=0 && y<rows && r1[y%WIN_ROW] == y && r2[ynext%WIN_ROW] == ynext && x>=0 && x<cols);

                int xa0, xa1, ya0, ya1;
# 337 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h"
                (static_cast <bool> (((WIN_ROW & (WIN_ROW-1)) == 0) && "WIN_ROW must be a power of two") ? void (0) : __assert_fail ("((WIN_ROW & (WIN_ROW-1)) == 0) && \"WIN_ROW must be a power of two\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h", 337, __extension__ __PRETTY_FUNCTION__));
                xa0 = x/2 + x%2;
                xa1 = x/2;
                ya0 = (y/2 + y%2)%(WIN_ROW/2);
                ya1 = (y/2)%(WIN_ROW/2);

                Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d00,d01,d10,d11;
                d00=buf[ya0][0][xa0][0];
                d01=buf[ya0][0][xa1][1];
                d10=buf[ya1][1][xa0][0];
                d11=buf[ya1][1][xa1][1];

                Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d_t00,d_t01,d_t10,d_t11;
                if(x%2) {
                    d_t00 = d00;
                    d_t01 = d01;
                    d00 = d_t01;
                    d01 = d_t00;

                    d_t10 = d10;
                    d_t11 = d11;
                    d10 = d_t11;
                    d11 = d_t10;


                }
                if(y%2) {
                    d_t00 = d00;
                    d_t10 = d10;
                    d00 = d_t10;
                    d10 = d_t00;

                    d_t01 = d01;
                    d_t11 = d11;
                    d01 = d_t11;
                    d11 = d_t01;


                }
                ap_ufixed<2*5 + 1, 1> k01 = (1-iv)*( iu);
                ap_ufixed<2*5 + 1, 1> k10 = ( iv)*(1-iu);
                ap_ufixed<2*5 + 1, 1> k11 = ( iv)*( iu);
                ap_ufixed<2*5 + 1, 1> k00 = 1-iv-k01;
                (static_cast <bool> (k00 + k01 + k10 + k11 == 1) ? void (0) : __assert_fail ("k00 + k01 + k10 + k11 == 1", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h", 380, __extension__ __PRETTY_FUNCTION__));

                Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;

                for(int k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                    if(in_range) {
                        d.val[k] =
                            d00.val[k] * k00 +
                            d01.val[k] * k01 +
                            d10.val[k] * k10 +
                            d11.val[k] * k11;
                    } else {
                        d.val[k] = 0;
                    }
                }
                dst<< d;
            }
        }
    }
}

template <int WIN_ROW, int ROWS, int COLS, int SRC_T, int DST_T, int MAP1_T, int MAP2_T>
void Remap(
           Mat<ROWS, COLS, SRC_T> &src,
           Mat<ROWS, COLS, DST_T> &dst,
           Mat<ROWS, COLS, MAP1_T> &map1,
           Mat<ROWS, COLS, MAP2_T> &map2,
           int interpolation=0


        )
{
    if(interpolation==0) {
        Remap_nearest<WIN_ROW>(src, dst, map1, map2);
    } else if(interpolation==1) {
        Remap_linear<WIN_ROW>(src, dst, map1, map2);
    }
}



template <typename T>
class RangeAnalyzer {
public:
# 435 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h"
    void operator ()(T x) {};



};
# 458 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h"
template<typename T>
T one_over_x_approx(T x) {
    return T(1.0)/x;
}


template <int W, int I, ap_q_mode Q, ap_o_mode O>
ap_fixed<W,I,Q,O> one_over_x_approx(ap_fixed<W,I,Q,O> x) {
    return 2-x;
}

template <int W, int I, ap_q_mode Q, ap_o_mode O>
ap_ufixed<W,I,Q,O> one_over_x_approx(ap_ufixed<W,I,Q,O> x) {
    return 2-x;
}



template<typename T>
T one_over_one_plus_x_approx(T x) {
    return T(1.0)/(T(1.0)+x);
}


template <int W, int I, ap_q_mode Q, ap_o_mode O>
ap_fixed<W,I,Q,O> one_over_one_plus_x_approx(ap_fixed<W,I,Q,O> x) {
    return 1-x;
}

template <int W, int I, ap_q_mode Q, ap_o_mode O>
ap_ufixed<W,I,Q,O> one_over_one_plus_x_approx(ap_ufixed<W,I,Q,O> x) {
    return 1-x;
}

template <typename FRAMET, typename FRAME2T, typename ROWT, typename COLT, typename ROWOUTT, typename COLOUTT, typename CMT, typename DT, typename ICMT, int N>
void computeUndistortCoordinates(Window<3,3, CMT> cameraMatrix,
                                 DT (&distCoeffs)[N],
                                 Window<3,3, ICMT> ir,
                                 int noRotation,
                                 ROWT i, COLT j,
                                 ROWOUTT &u, COLOUTT &v) {

    DT zo=0;
    DT k1=distCoeffs[0];
    DT k2=distCoeffs[1];
    DT p1=distCoeffs[2];
    DT p2=distCoeffs[3];
    DT k3= N>=5? distCoeffs[4] : zo;
    DT k4= N>=8? distCoeffs[5] : zo;
    DT k5= N>=8? distCoeffs[6] : zo;
    DT k6= N>=8? distCoeffs[7] : zo;
    CMT u0= cameraMatrix.val[0][2];
    CMT v0= cameraMatrix.val[1][2];
    CMT fx= cameraMatrix.val[0][0];
    CMT fy= cameraMatrix.val[1][1];
# 524 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h"
    FRAMET _x, _y, x, y;
    _x=i*ir.val[0][1] + j * ir.val[0][0] + ir.val[0][2];
    _y=i*ir.val[1][1] + j * ir.val[1][0] + ir.val[1][2];

    float x_gold = ((float)i*(float)ir.val[0][1] + (float)j*(float)ir.val[0][0] + (float)ir.val[0][2]);
    if(noRotation) {

        x=_x;
        y=_y;
    } else {
        FRAMET w=i*ir.val[2][1] + j * ir.val[2][0] + ir.val[2][2];
        FRAMET winv = one_over_x_approx(w);
        float winv_gold = 1.0f/((float)i*(float)ir.val[2][1] + (float)j*(float)ir.val[2][0] + (float)ir.val[2][2]);





        x = (FRAMET)(_x*winv);
        y = (FRAMET)(_y*winv);
        x_gold = x_gold*winv_gold;
    }

    typename x_traits<FRAMET,FRAMET>::MULT_T x2t = x*x, y2t = y*y;
    FRAME2T _2xy = 2*x*y;
    FRAME2T r2 = x2t + y2t;
    FRAME2T x2 = x2t, y2 = y2t;

    FRAMET kr = (1 + FRAMET(FRAMET(k3*r2 + k2)*r2 + k1)*r2);
    FRAME2T krd = FRAMET(FRAMET(k6*r2 + k5)*r2 + k4)*r2;

    if(N >5) kr = kr*one_over_one_plus_x_approx(krd);

    float kr_gold = (1 + (((float)k3*(float)r2 + (float)k2)*(float)r2 + (float)k1)*(float)r2)/
                    (1 + (((float)k6*(float)r2 + (float)k5)*(float)r2 + (float)k4)*(float)r2);

    u = fx*(FRAMET(x*kr) + FRAMET(p1*_2xy) + FRAMET(p2*(2*x2 + r2))) + u0;
    v = fy*(FRAMET(y*kr) + FRAMET(p1*(r2 + 2*y2)) + FRAMET(p2*_2xy)) + v0;
# 575 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h"
}

template <typename ROWT, typename COLT, typename ROWOUTT, typename COLOUTT, int N>
void computeUndistortCoordinatesRef(Window<3,3, float> cameraMatrix,
                                 float (&distCoeffs)[N],
                                 Window<3,3, float> ir,
                                 int noRotation,
                                 ROWT i, COLT j,
                                 ROWOUTT &u, COLOUTT &v) {
    typedef float DT;
    typedef float CMT;
    typedef float FRAMET;
    typedef float FRAME2T;

    DT zo=0;
    DT k1=distCoeffs[0];
    DT k2=distCoeffs[1];
    DT p1=distCoeffs[2];
    DT p2=distCoeffs[3];
    DT k3= N>=5? distCoeffs[4] : zo;
    DT k4= N>=8? distCoeffs[5] : zo;
    DT k5= N>=8? distCoeffs[6] : zo;
    DT k6= N>=8? distCoeffs[7] : zo;
    CMT u0= cameraMatrix.val[0][2];
    CMT v0= cameraMatrix.val[1][2];
    CMT fx= cameraMatrix.val[0][0];
    CMT fy= cameraMatrix.val[1][1];


    FRAMET _x, _y, x, y;
    _x=i*ir.val[0][1] + j * ir.val[0][0] + ir.val[0][2];
    _y=i*ir.val[1][1] + j * ir.val[1][0] + ir.val[1][2];

    if(noRotation) {

        (static_cast <bool> (ir.val[2][0] == 0) ? void (0) : __assert_fail ("ir.val[2][0] == 0", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h", 610, __extension__ __PRETTY_FUNCTION__));
        (static_cast <bool> (ir.val[2][1] == 0) ? void (0) : __assert_fail ("ir.val[2][1] == 0", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h", 611, __extension__ __PRETTY_FUNCTION__));
        (static_cast <bool> (ir.val[2][1] == 1) ? void (0) : __assert_fail ("ir.val[2][1] == 1", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h", 612, __extension__ __PRETTY_FUNCTION__));
        x=_x;
        y=_y;
    } else {
        FRAMET w=i*ir.val[2][1] + j * ir.val[2][0] + ir.val[2][2];
        float winv = 1.0f/w;




        x = (FRAMET)(_x*winv);
        y = (FRAMET)(_y*winv);
    }

    typename x_traits<FRAMET,FRAMET>::MULT_T x2t = x*x, y2t = y*y;

    FRAME2T _2xy = 2*x*y;
    FRAME2T r2 = x2t + y2t;
    FRAME2T x2 = x2t, y2 = y2t;

    FRAMET kr = (1 + FRAMET(FRAMET(k3*r2 + k2)*r2 + k1)*r2);
    if(N >5) kr = kr/
        (1 + FRAMET(FRAMET(k6*r2 + k5)*r2 + k4)*r2);

    u = fx*(FRAMET(x*kr) + FRAMET(p1*_2xy) + FRAMET(p2*(2*x2 + r2))) + u0;
    v = fy*(FRAMET(y*kr) + FRAMET(p1*(r2 + 2*y2)) + FRAMET(p2*_2xy)) + v0;
# 651 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h"
}

template<typename T>
struct InitUndistortRectifyMap_traits {
    typedef T FRAMET;
    typedef T FRAME2T;
};

template<int W, int I>
struct InitUndistortRectifyMap_traits<ap_fixed<W,I> > {
    typedef ap_fixed<18,2> FRAMET;
    typedef ap_fixed<23,4,AP_RND,AP_SAT> FRAME2T;
};
template<typename CMT, typename DT, typename ICMT, int ROWS, int COLS, int MAP1_T, int MAP2_T, int N>
void InitUndistortRectifyMapInverse (
                            Window<3,3, CMT> cameraMatrix,
                            DT (&distCoeffs)[N],
                            Window<3,3, ICMT> ir,
                            Mat<ROWS, COLS, MAP1_T> &map1,
                            Mat<ROWS, COLS, MAP2_T> &map2,
                            int noRotation=false)
{
_ssdm_SpecArrayPartition( distCoeffs, 1, "COMPLETE", 0, "");
    int rows= map1.rows;
    int cols= map1.cols;
    Scalar<((((MAP1_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((MAP1_T) & ((1 << 11) - 1))>::name> m1;
    Scalar<((((MAP2_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((MAP2_T) & ((1 << 11) - 1))>::name> m2;

    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h", 679, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h", 680, __extension__ __PRETTY_FUNCTION__));

    static RangeAnalyzer<float> rau, rav;
    static RangeAnalyzer<float> rauerr, raverr;

 loop_height: for(int i=0; i< rows; i++) {
    loop_width: for(int j=0; j< cols; j++) {
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            typedef ap_uint<BitWidth<ROWS>::Value> ROWT;
            typedef ap_uint<BitWidth<COLS>::Value> COLT;
            ROWT ifixed = i;
            COLT jfixed = j;

            ap_fixed<1+BitWidth<COLS>::Value+5, 1+BitWidth<COLS>::Value, AP_RND, AP_SAT> u;
            ap_fixed<1+BitWidth<ROWS>::Value+5, 1+BitWidth<ROWS>::Value, AP_RND, AP_SAT> v;
            computeUndistortCoordinates
                <typename InitUndistortRectifyMap_traits<CMT>::FRAMET, typename InitUndistortRectifyMap_traits<CMT>::FRAME2T>
                (cameraMatrix, distCoeffs, ir, noRotation,ifixed,jfixed,u,v);
# 719 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h"
            (static_cast <bool> (MAP1_T==(((3) & ((1 << 11) - 1)) + (((2)-1) << 11))) ? void (0) : __assert_fail ("MAP1_T==HLS_16SC2", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_undistort.h", 719, __extension__ __PRETTY_FUNCTION__));
            {
                int iu = sr_cast<int>(u*32);
                int iv = sr_cast<int>(v*32);
                m1.val[0]=(iu >> 5);
                m1.val[1]=(iv >> 5);
                m2.val[0]=(unsigned short)((iv &(32 -1))*32 + (iu & (32 -1)));
            }






            map1<< m1;
            map2<< m2;
        }
    }







}
template< typename CMT, typename RT, typename DT, int ROWS, int COL, int MAP1_T, int MAP2_T, int N>
void InitUndistortRectifyMap(
                            Window<3,3, CMT> cameraMatrix,
                            DT (&distCoeffs)[N],
                            Window<3,3, RT> R,
                            Window<3,3, CMT> newcameraMatrix,
                            Mat<ROWS, COL, MAP1_T> &map1,
                            Mat<ROWS, COL, MAP2_T> &map2
                            )
{
    Window<3,3, RT> iR;
    Window<3,3, RT> ir;
    mul<3, 3, 3>(newcameraMatrix.val, R.val, iR.val);
    Invert<3>(iR.val, ir.val);
    InitUndistortRectifyMapInverse(cameraMatrix, distCoeffs,ir,map1,map2);
}
}
# 66 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_video.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_hough.h" 1
# 83 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_hough.h"
namespace hls {

typedef ap_fixed<19,2,AP_RND> angleAccuracy_T;

template<typename AT,typename RT>
struct Polar_
{
 AT angle;
 RT rho;
};

template<unsigned int theta,unsigned int rho,typename ACCUMT,int SRC_T, int ROW,int COL, typename S_T>
void HoughPolar(
        Mat<ROW,COL,SRC_T> &_src,
        ACCUMT accum[][(2*(COL+ROW)+1)/rho+2],
        S_T (&sinval)[180/theta],
        S_T (&cosval)[180/theta]
        )
{
    ACCUMT addr[180/theta];
    ACCUMT accbuf[2][180/theta];
_ssdm_SpecArrayPartition( addr, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( accbuf, 0, "COMPLETE", 0, "");
    int rows=_src.rows;
    int cols=_src.cols;
    unsigned int rhoN =(2*(COL+ROW)+1)/ rho;
    unsigned int Half_rhoN=(rhoN-1)/2;
    unsigned int AngleN= 180/theta;
_ssdm_SpecArrayPartition( sinval, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( cosval, 0, "COMPLETE", 0, "");
 loop_init_r: for(int r=0;r<rhoN+2;r++)
    {
    loop_init_n: for(int n=0;n<AngleN+2;n++)
        {
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            accum[n][r]=0;
        }
    }

 loop_init: for(int n = 0; n < AngleN; n++ )
    {
        addr[n]=0;
        accbuf[0][n]=accum[n+1][Half_rhoN+1];
        sinval[n]=sinval[n]/rho;
        cosval[n]=cosval[n]/rho;
    }


 loop_height: for( int i = 0; i < rows; i++ )
    {
    loop_width: for( int j = 0; j < cols; j++ )
        {
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
            typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp;
            _src.data_stream[0]>>temp;
            if(temp!=0&&!(i==0&&j==0))
            {
            loop_angle: for(int n = 0; n < AngleN; n++ )
                {
                    accbuf[1][n]=accbuf[0][n];
                    ACCUMT r=j*cosval[n]+i*sinval[n];
                    r+=Half_rhoN;
                    accbuf[0][n]=accum[n+1][r+1];
                    if(r==addr[n])
                        accbuf[0][n]=accbuf[0][n]+1;

                    accum[n+1][addr[n]+1]=accbuf[1][n]+1;
                    addr[n]=r;
                }
            }

        }
    }
 loop_exit: for(int n = 0; n < AngleN; n++ )
    {
        accum[n+1][addr[n]+1]=accbuf[0][n]+1;
    }
}
template<int rho,int ROW,int COL,typename ACCUMT, typename AT, typename RT,int linesMax>
void Sort_insert(
        ACCUMT accum[][(2*(COL+ROW)+1)/rho+2],
        Polar_<AT,RT> (&lines)[linesMax],
        unsigned int threshold,
        unsigned int theta,
        unsigned int& storenum)
{
    LineBuffer<2,((2*(COL+ROW)+1)/rho+2),ACCUMT> accum_buf;
    Window<3,3,ACCUMT> accum_win;
    ACCUMT lines_val[linesMax+1];
    ap_uint<1> lines_flag[linesMax+1];
    unsigned int rhoN =(2*(COL+ROW)+1)/ rho;
    unsigned int AngleN= 180/theta;
    unsigned int Half_rhoN=(rhoN-1)/2;

_ssdm_SpecArrayPartition( &accum_buf, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( lines_val, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( lines, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( &accum_win, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( lines_flag, 0, "COMPLETE", 0, "");

 loop_init: for(int i=0;i<linesMax;i++)
    {
        lines[i].angle=0;
        lines[i].rho=0;
        lines_val[i]=0;
        lines_flag[i]=0;
    }
        lines_val[linesMax]=0;
        lines_flag[linesMax]=0;

 loop_n: for(int n=0;n<AngleN+2;n++)
    {
    loop_r: for(int r=0;r<rhoN+2;r++)
        {
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 0);
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            for(int row=2;row>=0;row--)
            {
                for(int col=2;col>=1;col--)
                {
                    accum_win.val[row][col]=accum_win.val[row][col-1];
                }
            }

            ACCUMT temp=accum[n][r];

            ACCUMT accum_buf0=accum_buf.val[0][r];

            accum_win.val[2][0]=accum_buf.val[1][r];
            accum_win.val[1][0]=accum_buf0;
            accum_win.val[0][0]=temp;

            accum_buf.val[1][r]=accum_buf0;

            accum_buf.val[0][r]=temp;

            if(r>=2&&r!=Half_rhoN+2&&r<rhoN+2&&n>=2&&n<AngleN+2)
            {
                if((accum_win.val[1][1]>threshold)&&(accum_win.val[1][1]>accum_win.val[1][2])&&(accum_win.val[1][1]>=accum_win.val[1][0])&&(accum_win.val[1][1]>accum_win.val[2][1])&&(accum_win.val[1][1]>=accum_win.val[0][1] ))
                {

                loop_lines: for(int i=linesMax-2;i>=0;i--)
                    {
                        ACCUMT max=lines_val[i];
                        if(accum_win.val[1][1]>max)
                        {
                            lines[i+1].rho=lines[i].rho;
                            lines[i+1].angle=lines[i].angle;
                            lines_val[i+1]=max;
                            lines_flag[i]=0;
                        }
                        else
                        {
                            lines_flag[i]=1;
                        }
                    }
                    int sum=0;
                loop_sum: for(int i=0;i<linesMax;i++)
                        sum+=lines_flag[i];

                    lines[sum].rho=r-1;
                    lines[sum].angle=n-1;
                    lines_val[sum]=accum_win.val[1][1];
                    storenum++;
                }
            }
        }
    }
}
template<typename _AT, typename _RT,typename AT, typename RT,int linesMax>
void inline GetTopLines(
        Polar_<_AT,_RT> (&_lines)[linesMax],
        Polar_<AT,RT> (&lines)[linesMax+1],
        unsigned int storenum,
        unsigned int theta,
        unsigned int rho,
        unsigned int Half_rhoN)
{
    angleAccuracy_T Angle_accuracy=3.1415926*theta/180;
loop_lines: for(int i=0;i<linesMax;i++)
    {
        if(i<storenum)
        {
            RT r=lines[i].rho-1;
            AT n=lines[i].angle-1;
            _RT _rho = (r - Half_rhoN) * rho;
            _AT _angle = n * Angle_accuracy;
            _lines[i].rho=_rho;
            _lines[i].angle=_angle;
        }
        else
        {
                _lines[i].rho=0;
                _lines[i].angle=0;
        }
    }
}



template<unsigned int theta,unsigned int rho,typename AT,typename RT,typename ACCUMT,int SRC_T,int ROW,int COL,unsigned int linesMax, typename S_T>
void HoughLinesStandard(
        Mat<ROW,COL,SRC_T> &_src,
        Polar_<AT,RT> (&_lines)[linesMax],
        ACCUMT _accum[][(2*(COL+ROW)+1)/rho+2],
        unsigned int _threshold,
        S_T (&sinval)[180/theta],
        S_T (&cosval)[180/theta]
        )
{
    unsigned int storenum=0;
    Polar_<ap_uint<10>,ACCUMT > lines[linesMax+1];
    unsigned int rhoN =(2*(COL+ROW)+1)/ rho;
    unsigned int Half_rhoN=(rhoN-1)/2;

    HoughPolar<theta,rho>(_src,_accum, sinval, cosval);
    Sort_insert<rho,ROW,COL>(_accum,lines, _threshold,theta,storenum);
    GetTopLines(_lines,lines,storenum,theta,rho,Half_rhoN);
}
# 312 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_hough.h"
template<unsigned int theta,unsigned int rho,typename AT,typename RT,int SRC_T,int ROW,int COL,unsigned int linesMax>
void HoughLines2(
        Mat<ROW,COL,SRC_T> & _src,
 Polar_<AT,RT> (&_lines)[linesMax],
 unsigned int threshold
        )
{
 static ap_uint<12> _accum[180/theta+2][(2*(COL+ROW)+1)/rho+2];
 _ssdm_SpecArrayPartition( _accum, 1, "COMPLETE", 0, "");
        ap_fixed<19,2,AP_RND> sinval[180/theta];
        ap_fixed<19,2,AP_RND> cosval[180/theta];
        angleAccuracy_T Angle_accuracy=3.1415926*theta/180;
 loop_init: for(int i=0;i<180/theta;i++)
        {
            sinval[i]=::hls::sinf((i*Angle_accuracy));
            cosval[i]=::hls::cosf(i*Angle_accuracy);
        }
 HoughLinesStandard<theta,rho>(_src,_lines,_accum,threshold, sinval,cosval);
}

}
# 67 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_video.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_harris.h" 1
# 83 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_harris.h"
namespace hls {

template<int KH,int KW, typename SRC_T>
bool IsMax(Window<KH,KW,SRC_T> & core_win)
{
_ssdm_InlineSelf(0, "");
    bool isMax=true;
    for(int i=0;i<KH;i++) {
        for(int j=0;j<KW;j++) {
            if(((i!=KH/2)||(j!=KW/2))&&core_win.val[i][j]>core_win.val[KH/2][KW/2])
                isMax=false;
        }
    }
    return isMax;
}
template<int KH, int KW, int SRC_T,int DST_T,int ROWS,int COLS>
void FindMax(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name threshold
                )
{
    LineBuffer<KH-1,COLS,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf;
    Window<KH,KW,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> win;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    int rows= _src.rows;
    int cols= _src.cols;
    int ioffset=KH/2+1;
    int joffset=KH/2+1;
    for(HLS_SIZE_T i=0;i<rows+ioffset;i++)
    {
_ssdm_op_SpecLoopTripCount(0, ROWS, 0, "");
        for(HLS_SIZE_T j=0;j<cols+joffset;j++)
        {
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
_ssdm_op_SpecLoopTripCount(0, COLS, 0, "");
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            d.val[0]=0;
            for(int r= 0;r<KH;r++)
            {
                for(int c=0;c<KW-1;c++)
                {
                    win.val[r][c]=win.val[r][c+1];
                }
            }
            if(i<rows&&j<cols)
            {
                win.val[0][KW-1]=k_buf.val[0][j];
                for(int buf_row= 1;buf_row< KH-1;buf_row++)
                {
                    win.val[buf_row][KW-1]=k_buf.val[buf_row][j];
                    k_buf.val[buf_row-1][j]=k_buf.val[buf_row][j];
                }

                _src>>s;
                win.val[KH-1][KW-1]=s.val[0];
                k_buf.val[KH-2][j]=s.val[0];
            }
            else if(j>=cols)
            {

                for(int i= 1;i< KW;i++)
                    win.val[i][KW-1]=0;
            }
            if(win.val[1][1]>=threshold&&i>=KH&&j>=KW)
            {
                bool _ismax=IsMax(win);
                if(_ismax)
                {

                    d.val[0]=255;
                }
            }

            if(i>=ioffset&&j>=joffset)
            {
                _dst<<d;
            }
        }
    }
}
template<typename KT, typename ST, int X2_T,int Y2_T,int XY_T,int DST_T,int ROWS,int COLS>
void CalCim(
  Mat<ROWS, COLS, X2_T> &_gradx,
  Mat<ROWS, COLS, Y2_T> &_grady,
  Mat<ROWS, COLS, XY_T> &_gradxy,
  Mat<ROWS, COLS, DST_T> &_dst,
        KT k,
        ST scale
        )
{
    Scalar<((((X2_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((X2_T) & ((1 << 11) - 1))>::name> gx;
    Scalar<((((Y2_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((Y2_T) & ((1 << 11) - 1))>::name> gy;
    Scalar<((((XY_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((XY_T) & ((1 << 11) - 1))>::name> gxy;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    int rows= _grady.rows;
    int cols= _grady.cols;
    for(HLS_SIZE_T i=0;i<rows;i++)
    {
_ssdm_op_SpecLoopTripCount(0, ROWS, 0, "");
        for(HLS_SIZE_T j=0;j<cols;j++)
        {
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
_ssdm_op_SpecLoopTripCount(0, COLS, 0, "");
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            d.val[0]=0;
            _gradx>> gx;
            _grady>> gy;
            _gradxy>> gxy;
            typename Type<((DST_T) & ((1 << 11) - 1))>::name lgx = sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(gx.val[0])*typename Type<((DST_T) & ((1 << 11) - 1))>::name(scale*scale);
            typename Type<((DST_T) & ((1 << 11) - 1))>::name lgy = sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(gy.val[0])*typename Type<((DST_T) & ((1 << 11) - 1))>::name(scale*scale);
            typename Type<((DST_T) & ((1 << 11) - 1))>::name lgxy= sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(gxy.val[0])*typename Type<((DST_T) & ((1 << 11) - 1))>::name(scale*scale);
            typename Type<((DST_T) & ((1 << 11) - 1))>::name det = lgx*lgy - lgxy*lgxy;
            typename Type<((DST_T) & ((1 << 11) - 1))>::name trac= lgx + lgy;

            typename Type<((DST_T) & ((1 << 11) - 1))>::name cim = det - k*(trac)*(trac);
            d.val[0] = cim;
            _dst<<d;
        }
    }
}
template<int blockSize,int Ksize, bool NORMALIZE, class BORDERMODEL, int GT, int G2T, typename ST, typename KT,int SRC_T,int DST_T,int ROWS,int COLS>
void Harris_opr(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS, COLS, DST_T> &_dst,
        KT k,
        ST scale)
{
_ssdm_InlineSelf(0, "");
_ssdm_op_SpecDataflowPipeline(-1, 0, "");



    int rows = _src.rows;
    int cols = _src.cols;
    Mat<ROWS,COLS,SRC_T> gray1(rows,cols);
    Mat<ROWS,COLS,SRC_T> gray2(rows,cols);

    Mat<ROWS,COLS,GT> grad_x(rows,cols);
    Mat<ROWS,COLS,GT> grad_x1(rows,cols);
    Mat<ROWS,COLS,GT> grad_x2(rows,cols);
    Mat<ROWS,COLS,GT> grad_x3(rows,cols);
    Mat<ROWS,COLS,GT> grad_x4(rows,cols);

    Mat<ROWS,COLS,GT> grad_y(rows,cols);
    Mat<ROWS,COLS,GT> grad_y1(rows,cols);
    Mat<ROWS,COLS,GT> grad_y2(rows,cols);
    Mat<ROWS,COLS,GT> grad_y3(rows,cols);
    Mat<ROWS,COLS,GT> grad_y4(rows,cols);

    Mat<ROWS,COLS,G2T> grad_xx(rows,cols);
    Mat<ROWS,COLS,G2T> grad_yy(rows,cols);
    Mat<ROWS,COLS,G2T> grad_xy(rows,cols);

    Mat<ROWS,COLS,G2T> grad_gx(rows,cols);
    Mat<ROWS,COLS,G2T> grad_gy(rows,cols);
    Mat<ROWS,COLS,G2T> grad_gxy(rows,cols);

    Duplicate(_src,gray1,gray2);

    Sobel<1,0,Ksize,BORDERMODEL>(gray1,grad_x);
    Duplicate(grad_x,grad_x1,grad_x2);
    Duplicate(grad_x1,grad_x3,grad_x4);
    Sobel<0,1,Ksize,BORDERMODEL>(gray2,grad_y);
    Duplicate(grad_y,grad_y1,grad_y2);
    Duplicate(grad_y1,grad_y3,grad_y4);

    Mul(grad_x3,grad_x4,grad_xx);
    Mul(grad_y3,grad_y4,grad_yy);
    Mul(grad_x2,grad_y2,grad_xy);

    BoxFilter<blockSize,blockSize,NORMALIZE,BORDERMODEL>(grad_xx,grad_gx);
    BoxFilter<blockSize,blockSize,NORMALIZE,BORDERMODEL>(grad_yy,grad_gy);
    BoxFilter<blockSize,blockSize,NORMALIZE,BORDERMODEL>(grad_xy,grad_gxy);

    CalCim(grad_gx,grad_gy,grad_gxy, _dst,k, scale);
}

template<int blockSize,int Ksize,typename KT,int SRC_T,int DST_T,int ROWS,int COLS>
void CornerHarris(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        KT k)
{
_ssdm_InlineSelf(0, "");
    ap_uint<9> sc=(1 << ((Ksize>0 ? Ksize:3)-1))*blockSize;



    if(SRC_T==(((0) & ((1 << 11) - 1)) + (((1)-1) << 11))||SRC_T==(((8) & ((1 << 11) - 1)) + (((1)-1) << 11)))
    {
        ap_fixed<25,-7-Ksize> scale = (ap_fixed<25,2>(1.0f)/255) / sc;
        switch(Ksize) {
            case 3:
                Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((10 +1 +12) & ((1 << 11) - 1)) + (((1)-1) << 11)),
                        (((20 +1 +BitWidth<blockSize*blockSize>::Value+12) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
                break;
            case 5:
                Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((14 +1 +12) & ((1 << 11) - 1)) + (((1)-1) << 11)),
                        (((28 +1 +BitWidth<blockSize*blockSize>::Value+12) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
                break;
            case 7:
                Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((18 +1 +12) & ((1 << 11) - 1)) + (((1)-1) << 11)),
                        (((36 +1 +BitWidth<blockSize*blockSize>::Value+12) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
                break;
            default:
                Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((10 +1 +12) & ((1 << 11) - 1)) + (((1)-1) << 11)),
                        (((20 +1 +BitWidth<blockSize*blockSize>::Value+12) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
        }

    }
    else
    {
        float scale = 1.0f / sc;
        Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((5) & ((1 << 11) - 1)) + (((1)-1) << 11)), (((5) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
    }
}

template<int blockSize,int Ksize,typename KT,int SRC_T,int DST_T,int ROWS,int COLS>
void Harris(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        KT k,
        int threshold)
{
_ssdm_InlineSelf(0, "");
    Mat<ROWS,COLS,(((5) & ((1 << 11) - 1)) + (((1)-1) << 11))> res(_src.rows,_src.cols);
    CornerHarris<blockSize,Ksize>(_src, res, k);
    FindMax<3,3>(res,_dst,threshold);
}

}
# 68 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_video.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_haar.h" 1
# 41 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_haar.h"
namespace hls {

typedef ap_fixed<12,6,AP_RND> VAR_T;
typedef ap_uint<3> WEIGHT_T;
typedef unsigned int STHRESHOLD_T;
typedef short CTHRESHOLD_T;
typedef unsigned short ALPHA_T;

struct HaarRect
{
    Rect_< ap_uint<6> > r;
    WEIGHT_T weight;
};
struct HaarFeature
{
    public:
    HaarFeature()
    {
_ssdm_SpecArrayPartition( rect, 1, "COMPLETE", 0, "");
    };
    HaarRect rect[3];

};
template <int FEATURE_MAX>
struct HaarClassifier
{
    public:
    HaarClassifier()
    {
_ssdm_SpecArrayPartition( haar_feature, 1, "COMPLETE", 0, "");
        };
        unsigned short count;
        HaarFeature haar_feature[FEATURE_MAX];
        CTHRESHOLD_T threshold[FEATURE_MAX];
        ap_int<5> left[FEATURE_MAX];
        ap_int<5> right[FEATURE_MAX];
        ALPHA_T alpha[FEATURE_MAX+1];
        };
template <int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
struct HaarStageClassifier
{
    public:
    HaarStageClassifier()
    {
_ssdm_SpecArrayPartition( classifier, 1, "COMPLETE", 0, "");
        };
        unsigned char count[STAGE];
        STHRESHOLD_T threshold[STAGE];
        HaarClassifier<FEATURE_MAX> classifier[CLASSIFIER_ALL];




        };
template <int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
struct HaarClassifierCascade
{
    public:
        HaarClassifierCascade()
        {
        };
        unsigned short count;
        Size_<unsigned char> real_window_size;
        HaarStageClassifier<STAGE,CLASSIFIER_ALL,FEATURE_MAX> stage_classifier;
};

class HaarLoadData
{
        public:
template <int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
HaarLoadData(HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &cascade,

        const int ca_count,

        const Size_<unsigned char> ca_real_window_size,
        const int s_count[],
        const float s_threshold[],
        const int c_left[][FEATURE_MAX],
        const int c_right[][FEATURE_MAX],
        const float c_threshold[][FEATURE_MAX],
        const float c_alpha[][FEATURE_MAX+1],
        const unsigned int haar_feature[][FEATURE_MAX][4*3],
        const float haar_feature_weight[][FEATURE_MAX][3]




        )
{

        cascade.count=ca_count;

        cascade.real_window_size=ca_real_window_size;
        for(int i=0;i<STAGE;i++)
        {
                cascade.stage_classifier.count[i]=s_count[i];
                cascade.stage_classifier.threshold[i]=s_threshold[i];



        }
        for(int i=0;i<CLASSIFIER_ALL;i++)
        {

               for(int j=0;j<FEATURE_MAX;j++)
               {
                      cascade.stage_classifier.classifier[i].left[j]=c_left[i][j];
                      cascade.stage_classifier.classifier[i].right[j]=c_right[i][j];
                      cascade.stage_classifier.classifier[i].threshold[j]=c_threshold[i][j];
                      cascade.stage_classifier.classifier[i].alpha[j]=c_alpha[i][j];
                      cascade.stage_classifier.classifier[i].alpha[FEATURE_MAX]=c_alpha[i][FEATURE_MAX];

                      for(int n=0;n<3;n++)
                      {
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[n].r.x=haar_feature[i][j][n*4+0];
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[n].r.y=haar_feature[i][j][n*4+1];
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[n].r.width=haar_feature[i][j][n*4+2];
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[n].r.height=haar_feature[i][j][n*4+3];
                       }
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[0].weight=-1;
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[1].weight=haar_feature_weight[i][j][1];
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[2].weight=haar_feature_weight[i][j][2];
                 }
        }
}
};

template<typename SUMT, typename VART,int ROWS,int COLS>
void intergral_win(
        Window<ROWS,COLS,VART> &win_var,
        SUMT &var
        )
{
_ssdm_InlineSelf(0, "");
    var=0;
    for(int j=0;j<COLS;j++)
    {
        SUMT t = 0;
        for(int i=0;i<ROWS;i++)
        {
            var=var+win_var.val[i][j];
            t += win_var.val[i][j];
        }

    }
}

template< typename SRC_T,int ROWS,int COLS,int FEATURE_MAX>
ALPHA_T icvEvalHidHaarClassifier(HaarClassifier<FEATURE_MAX> & classifier,Window<ROWS,COLS,SRC_T>& win,VAR_T &variance )
{
_ssdm_InlineSelf(2, "");
_ssdm_SpecFuncInstantiation(&classifier, "");


    int m=0,i=0;
    for(m=0;m<FEATURE_MAX;m++)
    {
        Rect_<ap_uint<6> > rr=classifier.haar_feature[i].rect[0].r;
        if(i>0||(i==0&&m==0))
        {

            CTHRESHOLD_T sum=-(win.val[rr.height][rr.width]-win.val[rr.height][rr.x]-win.val[rr.y][rr.width]+win.val[rr.y][rr.x]);
            for(int j=1;j<3;j++)
            {
                WEIGHT_T weight=classifier.haar_feature[i].rect[j].weight;
                Rect_< ap_uint<6> > rj=classifier.haar_feature[i].rect[j].r;
                sum+=(win.val[rj.height][rj.width]-win.val[rj.height][rj.x]-win.val[rj.y][rj.width]+win.val[rj.y][rj.x])*weight;
            }
            if(sum<classifier.threshold[i]*variance)
            {
                i=classifier.left[i];
            }
            else
            {
                i=classifier.right[i];
            }
        }


    }
    return classifier.alpha[-i] ;
}

template< typename SRC_T,int ROWS,int COLS,int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
bool RunHaarClassifierCascade(HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &cascade,Window<ROWS,COLS,SRC_T>&win,VAR_T &variance )
{
_ssdm_InlineSelf(0, "");
    ALPHA_T sum=0;
    bool result=true;
    unsigned char stage_index=0;
    unsigned char stage_count=0;
    for (int i=0;i<CLASSIFIER_ALL;i++)
    {
        sum+=icvEvalHidHaarClassifier(cascade.stage_classifier.classifier[i],win,variance);
        stage_count++;
        if(cascade.stage_classifier.count[stage_index]==stage_count)
        {
            if(sum < cascade.stage_classifier.threshold[stage_index])
            {
                result =false;
            }
            sum=0;
            stage_count=0;
            stage_index++;
        }
    }
    return result;
}
template < typename T>
T TaylorExp(T &t)
{
   return (1+((T)0.5)*(t)-((T)0.125)*(t)*(t));
}

template< int K_H,int K_W,int S_T,int ROWS,int COLS,int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX, int DST_T>
void HaarClassifierObject_opr(
                HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &cascade,
  Mat<ROWS, COLS, S_T> &_src,
  Mat<ROWS, COLS, DST_T> &_mask
  )
{
    int storage_count=0;






    Window<1,K_W+1,ap_uint<16+16> > sqwin;
    Window<K_H+1,K_W+1,ap_uint<8+16> > swin;
    LineBuffer<K_H,COLS,typename Type<((S_T) & ((1 << 11) - 1))>::name> sbuf;

    int rows=_src.rows;
    int cols=_src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_haar.h", 275, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_haar.h", 276, __extension__ __PRETTY_FUNCTION__));
    Scalar<1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> m;
    Scalar<((((S_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((S_T) & ((1 << 11) - 1))>::name> ss;

    for(int i=0;i<rows;i++)
    {
        for(int j=0;j<cols;j++)
        {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);

            {
_ssdm_SpecExprBalance(0, "");
            sqwin.shift_left();
            swin.shift_left();
            swin.val[0][K_W]=(j == 0 ? ap_uint<24>(0) :swin.val[0][K_W-1])+sbuf.val[0][j];
            ap_uint<16> col_sum=sbuf.val[0][j];
            ap_uint<32> col_sum_sq=0;
            for(int buf_row= 1;buf_row<K_H;buf_row++)
            {
                ss.val[0]=sbuf.val[buf_row][j];
                sbuf.val[buf_row-1][j]=ss.val[0];
                col_sum += ss.val[0];
                col_sum_sq += ss.val[0] * ss.val[0];
                swin.val[buf_row][K_W] = (j == 0 ? ap_uint<24>(0) :swin.val[buf_row][K_W-1]) + col_sum;
            }
            _src >> ss;
            sbuf.val[K_H-1][j]=ss.val[0];
            col_sum += ss.val[0];
            col_sum_sq += ss.val[0] * ss.val[0];
            swin.val[K_H][K_W] = (j == 0 ? ap_uint<24>(0) : swin.val[K_H][K_W-1]) + col_sum;
            sqwin.val[0][K_W] = (j == 0 ? ap_uint<32>(0) : sqwin.val[0][K_W-1]) + col_sum_sq;
# 322 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_haar.h"
            }

            m.val[0]=0;
            if(i>=K_H && j>=K_W &&( (j & 1)==0 ))
            {
                int b=K_H,s=0;

                float inv_window_area=1.0/(K_H*K_W);
                ap_uint<26> varsum=sqwin.val[0][K_W] - sqwin.val[0][0];






                ap_uint<17> meansum=swin.val[b][b]-swin.val[b][s]-swin.val[s][b]+swin.val[s][s];
                ap_fixed<32,18,AP_RND> mean=(meansum)*inv_window_area;
                ap_fixed<32,18,AP_RND> meansq=mean*mean;
                ap_fixed<32,18,AP_RND> var_a=varsum*inv_window_area;
                ap_fixed<32,18,AP_RND> variance=var_a-meansq;
                if(variance>0)
                {

                    variance = (variance/100);
                    ap_fixed<32,18,AP_RND> t=variance-1;
                    if(variance<=4)
                        variance= TaylorExp(t)+1;
                    else if(variance >4 && variance <=16)
                    {
                        ap_fixed<32,18,AP_RND> tt=t/4;
                        variance= 2*TaylorExp(tt)+1;
                    }
                    else if(variance >16 && variance <=64)
                    {
                        ap_fixed<32,18,AP_RND> tt=t/16;
                        variance= 4*TaylorExp(tt)+1;
                    }
                    else if(variance >64 && variance <=256)
                    {
                        ap_fixed<32,18,AP_RND> tt=t/64;
                        variance= 8*TaylorExp(tt)+1;
                    }
                    else
                        variance=16;
                }
                else
                {
                    variance = 1;
                }

                ap_fixed<12,6,AP_RND> var=variance;
                bool Isface=RunHaarClassifierCascade(cascade,swin,var);
                if(Isface)
                {
                    if(variance>65)
                    {
                        variance=65;
                    }
                    variance=variance*1000;
                    storage_count++;

                    m.val[0]=(unsigned char)variance;
                }
            }
            _mask << m;
        }
    }

}
template<int K_H,int K_W,int SRC_T,int DST_T,int ROWS,int COLS,int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
void HaarClassifierObject(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_mask,
                HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &_cascade
                )
{
_ssdm_InlineSelf(0, "");
# 409 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_haar.h"
        HaarClassifierObject_opr<K_H,K_W>(_cascade,_src, _mask);
}

template<typename RECT_T>
void CombineStorage(Rect_<RECT_T> _storage_group[][300],int m, Rect_<RECT_T> _storage[],int num)
{
        int count=0;
        for(int i=0;i<m;i++)
        {
                for(int j=0;j<num;j++)
                {
                        if(count<num&&_storage_group[i][j].width!=0&&_storage_group[i][j].height!=0)
                        {
                            _storage[count++]=_storage_group[i][j];
                        }
                }
        }
        for(int i=0;i<num;i++)
        {
         if(i>=count)
            {
               _storage[count].x=0;
               _storage[count].y=0;
               _storage[count].width=0;
               _storage[count].height=0;

            }
         }
}
template<int SRC_T, int DST_T,int ROWS,int COLS>
void Combin_mask(
  Mat<ROWS, COLS, SRC_T> &mask0,
  Mat<ROWS/2, COLS/2, SRC_T> &mask1,
  Mat<ROWS/4, COLS/4, SRC_T> &mask2,
  Mat<ROWS/8, COLS/8, SRC_T> &mask3,
  Mat<ROWS, COLS, DST_T> &dst
                )
{
    int rows =mask0.rows;
    int cols =mask0.cols;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> m;

    int i1=0;
    int i2=0;
    int i3=0;
    for(int i=0;i<rows;i++)
    {
        int j1=0;
        int j2=0;
        int j3=0;
        for(int j=0;j<cols;j++)
        {
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            s.val[0]=0;
            mask0>> m;
            if(m.val[0]!=0)
                s.val[0]=255;
            if(i==i1*2&&j==j1*2)
            {
                mask1>>m;
                s.val[0]=s.val[0]|m.val[0];
                j1++;
            }
            if(i==i2*4&&j==j2*4)
            {
                mask2>>m;
                s.val[0]=s.val[0]|m.val[0];
                j2++;
            }
            if(i==i3*8&&j==j3*8)
            {
                mask3>>m;
                s.val[0]=s.val[0]|m.val[0];
                j3++;
            }
            dst<<s;
        }
        if(i==i1*2)
            i1++;
        if(i==i2*4)
            i2++;
        if(i==i3*8)
            i3++;
    }
}

template<int K_H,int K_W,int SRC_T,int DST_T,int ROWS,int COLS,int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
void HaarClassifierObject_group(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_mask,
                HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &_cascade
                )
{
_ssdm_InlineSelf(0, "");
        int rows =_src.rows;
        int cols =_src.cols;
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray1(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray2(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray3(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray4(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray5(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray6(rows,cols);
        Duplicate(_src, gray1, gray2 );
        Duplicate(gray1, gray3, gray4 );
        Duplicate(gray2, gray5, gray6 );
 Mat<ROWS/2, COLS/2, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> internal_1(rows/2,cols/2);
 Mat<ROWS/4, COLS/4, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> internal_2(rows/4,cols/4);
 Mat<ROWS/8, COLS/8, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> internal_3(rows/8,cols/8);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> mask_0(rows,cols);
 Mat<ROWS/2, COLS/2, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> mask_1(rows/2,cols/2);
 Mat<ROWS/4, COLS/4, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> mask_2(rows/4,cols/4);
 Mat<ROWS/8, COLS/8, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> mask_3(rows/8,cols/8);
        Resize(gray4,internal_1);
        Resize(gray5,internal_2);
        Resize(gray6,internal_3);
        HaarClassifierObject<K_H, K_W > ( gray3, mask_0, _cascade);
        HaarClassifierObject<K_H, K_W > ( internal_1, mask_1, _cascade);
        HaarClassifierObject<K_H, K_W > ( internal_2, mask_2, _cascade);
        HaarClassifierObject<K_H, K_W > ( internal_3, mask_3, _cascade);
        Combin_mask<DST_T,DST_T,ROWS,COLS>(mask_0,mask_1,mask_2,mask_3,_mask);
}

}
# 69 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_video.h" 2
# 1 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h" 1
# 100 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h"
namespace hls {







template<int WSIZE, int NDISP, int NDISP_UNIT>
class StereoBMState {
public:

    int preFilterType;
    int preFilterSize;
    int preFilterCap;


    int SADWindowSize;
    int minDisparity;
    int numberOfDisparities;


    int textureThreshold;

    int uniquenessRatio;





    int ndisp_unit;
    int sweepFactor;
    int remainder;

    StereoBMState() {
        preFilterType = 1;
        preFilterSize = WSIZE;
        preFilterCap = 32;
        SADWindowSize = WSIZE;
        minDisparity = 0;
        numberOfDisparities = NDISP;
        textureThreshold = 10;
        uniquenessRatio = 15;
        sweepFactor = (NDISP/NDISP_UNIT) + ((NDISP%NDISP_UNIT) != 0);
        ndisp_unit = NDISP_UNIT;
        remainder = NDISP_UNIT*sweepFactor - NDISP;
    }
};

template<int PWSIZE, int SRC_T, int DST_T, int ROWS, int COLS>
void PreFilterNorm(
            Mat<ROWS, COLS, SRC_T>& src,
            Mat<ROWS, COLS, DST_T>& dst,
            int cap)
{
    int rows = src.rows;
    int cols = src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 157, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 158, __extension__ __PRETTY_FUNCTION__));

    LineBuffer<PWSIZE, COLS+PWSIZE-1, Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> > buff;
    Window<PWSIZE, PWSIZE, Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> > win;

    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> tmp[PWSIZE];
_ssdm_SpecArrayPartition( tmp, 0, "COMPLETE", 0, "");
    int sum_cols[PWSIZE];
_ssdm_SpecArrayPartition( tmp, 0, "COMPLETE", 0, "");
    int sum;

loop_sum_row:
    for (int row = 0; row < rows+PWSIZE-1; row++) {
loop_sum_init:
        for (int i = 0; i < PWSIZE; i++) {
            sum_cols[i] = 0;
        }
        sum = 0;
loop_sum_col:
        for (int col = 0; col < cols+PWSIZE-1; col++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> pix_in(0);
            buff.shift_down(col);
            if (!(row < (PWSIZE-1)/2 || row >= rows+(PWSIZE-1)/2 || col < (PWSIZE-1)/2 || col >= cols+(PWSIZE-1)/2)) {
                src >> pix_in;
            }
            buff.insert_bottom(pix_in, col);
            for (int i = 0; i< PWSIZE; i++) {
                tmp[i] = buff.val[i][col];
            }


            int a_sum = 0, b_sum = 0;
            for (int i = 0; i < PWSIZE; i++) {
                b_sum += tmp[i].val[0];
            }
            a_sum = sum_cols[PWSIZE-1];
            for (int j = PWSIZE-1; j > 0; j--) {
                sum_cols[j] = sum_cols[j-1];
            }
            sum_cols[0] = b_sum;
            sum = sum - a_sum + b_sum;
            win.shift_right();
            win.insert_right(tmp);

            if (row >= PWSIZE-1 && col >= PWSIZE-1) {
                int avg = sum / (PWSIZE*PWSIZE);
                Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> pix_out;
                int center = win.val[PWSIZE/2][PWSIZE/2].val[0];
                pix_out.val[0] = hls::min<int>(hls::max<int>(center-avg, -cap), cap) + cap;
                dst << pix_out;
            }
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Clip(
            Mat<ROWS, COLS, SRC_T>& src,
            Mat<ROWS, COLS, DST_T>& dst,
            int cap)
{
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 223, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 224, __extension__ __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    for (HLS_SIZE_T i = 0; i < rows; i++) {
        for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            for (HLS_SIZE_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                s.val[k] = s.val[k] < -cap ? 0 : s.val[k] > cap ? cap*2 : s.val[k] + cap;
                d.val[k] = s.val[k];
            }
            dst << d;
        }
    }
}

template<typename T>
T absdiff(T a, T b) {
_ssdm_InlineSelf(0, "");
    long long x = a-b;
    long long y = b-a;
    T r;
    if(x < 0) {
        r = y;
        (static_cast <bool> (r == y) ? void (0) : __assert_fail ("r == y", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 248, __extension__ __PRETTY_FUNCTION__));
    } else {
        r = x;
        (static_cast <bool> (r == x) ? void (0) : __assert_fail ("r == x", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 251, __extension__ __PRETTY_FUNCTION__));
    }
    return r;
}

template<int WSIZE, class T>
void UpdateTexture(
            Window<WSIZE, WSIZE, T>& window,
            T* col_tbi,
            int& text_sum,
            int row,
            int col,
            T cap)
{
_ssdm_InlineSelf(0, "");
    int tmp = 0;
    for (int i = 0; i < WSIZE; i++) {

        tmp += (i > row? 0 : absdiff(col_tbi[i], cap)) - ((col < WSIZE || i > row) ? 0 : absdiff(window.val[i][WSIZE-1], cap));
    }
    text_sum += tmp;
}

template<int WSIZE, int L_WIN_COLS, int R_WIN_COLS, typename T>
int SAD_compute_inc(
            Window<WSIZE, L_WIN_COLS, T>& l_win,
            Window<WSIZE, R_WIN_COLS, T>& r_win_s,
            int d,
            int col,
            int sad_cols_d[WSIZE])
{
_ssdm_InlineSelf(0, "");
    int a_sum = 0, b_sum = 0;

    for (int i = 0; i < WSIZE; i++) {
        b_sum += absdiff(l_win.val[i][0], r_win_s.val[i][d]);
    }

    if (col < d) b_sum = 0;

    a_sum = sad_cols_d[WSIZE-1];

    for (int j = WSIZE-1; j > 0; j--) {
        sad_cols_d[j] = sad_cols_d[j-1];
    }

    sad_cols_d[0] = b_sum;

    return (-a_sum+b_sum);
}

template<int SIZE>
class MinSAD {
public:
    template <typename T, typename T_idx>
    static void find(T a[SIZE], T_idx &loc, T &val) {
_ssdm_InlineSelf(0, "");
_ssdm_SpecArrayPartition( a, 0, "COMPLETE", 0, "");
        T a1[SIZE/2];
        T a2[SIZE-SIZE/2];
        for(int i = 0; i < SIZE/2; i++) {
            a1[i] = a[i];
        }
        for(int i = 0; i < SIZE-SIZE/2; i++) {
            a2[i] = a[i+SIZE/2];
        }
        T_idx l1,l2;
        T v1,v2;
        MinSAD<SIZE/2>::find(a1,l1,v1);
        MinSAD<SIZE-SIZE/2>::find(a2,l2,v2);
        if(v1 >= v2) {
            val = v2;
            loc = l2+SIZE/2;
        } else {
            val = v1;
            loc = l1;
        }
    }
};

template<>
class MinSAD<1> {
public:
    template <typename T, typename T_idx>
    static void find(T a[1], T_idx &loc, T &val) {_ssdm_SpecArrayDimSize(a, 1);
_ssdm_InlineSelf(0, "");
_ssdm_SpecArrayPartition( a, 0, "COMPLETE", 0, "");
        loc = 0;
        val = a[0];
    }
};

template<>
class MinSAD<2> {
public:
    template <typename T, typename T_idx>
    static void find(T a[2], T_idx &loc, T &val) {_ssdm_SpecArrayDimSize(a, 2);
_ssdm_InlineSelf(0, "");
_ssdm_SpecArrayPartition( a, 0, "COMPLETE", 0, "");
        T_idx l1=0, l2=1;
        T v1=a[0], v2=a[1];
        if(v1 >= v2) {
            val = v2;
            loc = l2;
        } else {
            val = v1;
            loc = l1;
        }
    }
};

template<int WSIZE, int NDISP, int NDISP_UNIT, int ROWS, int COLS, int SRC_T, int DST_T>
void SADBlockMatching(
            Mat<ROWS, COLS, SRC_T>& left,
            Mat<ROWS, COLS, SRC_T>& right,
            Mat<ROWS, COLS, DST_T>& disp,
            StereoBMState<WSIZE, NDISP, NDISP_UNIT>& state)




{
    int rows = left.rows;
    int cols = left.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 375, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 376, __extension__ __PRETTY_FUNCTION__));
    LineBuffer<WSIZE, COLS+WSIZE-1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> l_buff;
    LineBuffer<WSIZE, COLS+WSIZE-1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> r_buff;
    Window<WSIZE, WSIZE, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> l_window;
    Window<WSIZE, WSIZE+NDISP_UNIT-1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> r_window_search;
    int ndisp = state.numberOfDisparities;
    int mindisp = 0;

    typename Type<((DST_T) & ((1 << 11) - 1))>::name FILTERED = (typename Type<((DST_T) & ((1 << 11) - 1))>::name)((mindisp - 1) << 4);
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name cap = state.preFilterCap;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name l_tmp[WSIZE];
_ssdm_SpecArrayPartition( l_tmp, 0, "COMPLETE", 0, "");
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name r_tmp[WSIZE];
_ssdm_SpecArrayPartition( r_tmp, 0, "COMPLETE", 0, "");
    int text_sum = 0;
    int sad[NDISP_UNIT];
_ssdm_SpecArrayPartition( sad, 0, "COMPLETE", 0, "");
    int sad_cols[NDISP_UNIT][WSIZE];
_ssdm_SpecArrayPartition( sad_cols, 0, "COMPLETE", 0, "");
    int minsad[COLS+WSIZE-1];
    int mind[COLS+WSIZE-1];
    int skip[COLS+WSIZE-1];
    int skip_val[COLS+WSIZE-1];
    int edge_neighbor[COLS+WSIZE-1];
    int edge[COLS+WSIZE-1];
    int minsad_p[COLS+WSIZE-1];
    int minsad_n[COLS+WSIZE-1];

    int d = 0;
loop_row:
    for (int row = 0; row < rows+WSIZE-1; row++) {
loop_mux:
        for (int sweep = 0; sweep < state.sweepFactor; sweep++) {
loop_col:
            for (int col = 0; col < cols+WSIZE-1; col++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
                if (col == 0) {
loop_sad_init:
                    for (d = 0; d < NDISP_UNIT; d++) {
_ssdm_Unroll(0,0,0, "");
                        sad[d] = 0;
                        for (int i = 0; i < WSIZE; i++) {
_ssdm_Unroll(0,0,0, "");
                            sad_cols[d][i] = 0;
                        }
                    }
                }

                Scalar<1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> l_in(cap), r_in(cap);
                if (sweep == 0) {

                    l_buff.shift_down(col);
                    r_buff.shift_down(col);
                    if (!(row < (WSIZE-1)/2 || row >= rows+(WSIZE-1)/2 || col < (WSIZE-1)/2 || col >= cols+(WSIZE-1)/2)) {
                        left >> l_in;
                        right >> r_in;
                    }
                    l_buff.insert_bottom(l_in.val[0], col);
                    r_buff.insert_bottom(r_in.val[0], col);
loop_get_data_from_linebuff:
                    for (int i = 0; i < WSIZE; i++) {
                        l_tmp[i] = l_buff.val[i][col];
                        r_tmp[i] = r_buff.val[i][col];
                    }
                } else {
                    int offset = sweep * NDISP_UNIT;
loop_get_data_from_linebuff_with_offset:
                    for (int i = 0; i < WSIZE; i++) {
                        l_tmp[i] = l_buff.val[i][col];
                        r_tmp[i] = r_buff.val[i][col-offset < 0 ? 0 : col-offset];
                    }
                }

                UpdateTexture<WSIZE, typename Type<((SRC_T) & ((1 << 11) - 1))>::name>(l_window, l_tmp, text_sum, row, col, cap);

                l_window.shift_right();
                r_window_search.shift_right();
                l_window.insert_right(l_tmp);
                r_window_search.insert_right(r_tmp);

loop_sad_compute:
                for (d = 0; d < NDISP_UNIT; d++) {
                    sad[d] += SAD_compute_inc<WSIZE, WSIZE, WSIZE+NDISP_UNIT-1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name>(l_window, r_window_search, d, col, sad_cols[d]);
                    if (sweep == state.sweepFactor-1 && d >= (NDISP_UNIT-state.remainder)) sad[d] = 2147483647;
                }


                if (row >= WSIZE-1 && col >= WSIZE-1) {
                    int skip_flag = 0;
                    Scalar<1, typename Type<((DST_T) & ((1 << 11) - 1))>::name> out_pix;
                    if (text_sum < state.textureThreshold) skip_flag = 1;
                    if ((row - WSIZE+1) < (WSIZE-1)/2 || (row - WSIZE+1) >= rows - (WSIZE-1)/2) skip_flag = 1;
                    if ((col - WSIZE+1) < NDISP-1 + (WSIZE-1)/2 || (col - WSIZE+1) >= cols - (WSIZE-1)/2) skip_flag = 1;
                    int gminsad = ((sweep > 0) ? minsad[col] : 2147483647);
                    int gmind = ((sweep > 0) ? mind[col] : 0);
                    int gskip = ((sweep > 0) ? skip[col] : 0);
                    int gskip_val = ((sweep > 0) ? skip_val[col] : 2147483647);
                    int gedge_neighbor = ((sweep > 0) ? edge_neighbor[col] : 2147483647);
                    int gedge = ((sweep > 0) ? edge[col] : sad[1]);
                    int lminsad = 2147483647;
                    int lmind = 0;
                    int gminsad_p = ((sweep > 0) ? minsad_p[col] : 2147483647);
                    int gminsad_n = ((sweep > 0) ? (gmind == sweep*NDISP_UNIT-1 ? sad[0] : minsad_n[col]) : 2147483647);
                    MinSAD<NDISP_UNIT>::find(sad, lmind, lminsad);

                    if (lminsad <= gminsad) {
                        gskip = 0;
                        if (state.uniquenessRatio > 0) {
                            int thresh = lminsad + (lminsad * state.uniquenessRatio / 100);
                            if (gminsad <= thresh && lmind+sweep*NDISP_UNIT > gmind+1) {
                                gskip = 1;
                                gskip_val = gminsad;
                            } else if (gminsad <= thresh && lmind+sweep*NDISP_UNIT == gmind+1 && gskip_val <= thresh) {
                                gskip = 1;

                            } else if (gminsad <= thresh && lmind+sweep*NDISP_UNIT == gmind+1 && gedge_neighbor <= thresh) {
                                gskip = 1;
                                gskip_val = gedge_neighbor;
                            }
loop_unique_search_0:
                            for (d = 0; d < NDISP_UNIT; d++) {
                                if (sad[d] <= thresh && sad[d] < gskip_val && (d < lmind-1 || d > lmind+1)) {
                                    gskip = 1;
                                    gskip_val = sad[d];
                                }
                            }
                        }

                        gminsad_p = (lmind == 0 ? gedge : sad[lmind-1]);
                        gminsad_n = sad[lmind == NDISP_UNIT-1 ? lmind-1 : lmind+1];
                        gminsad = lminsad;
                        gmind = lmind + sweep*NDISP_UNIT;
                    } else {
                        if (state.uniquenessRatio > 0) {
                            int thresh = gminsad + (gminsad * state.uniquenessRatio / 100);
loop_unique_search_1:
                            for (d = 0; d < NDISP_UNIT; d++) {
                                if (sad[d] <= thresh && sad[d] < gskip_val && ((gmind == (sweep*NDISP_UNIT-1)) ? (d > 0) : 1)) {
                                    gskip = 1;
                                    gskip_val = sad[d];
                                }
                            }
                        }
                    }
                    minsad[col] = gminsad;
                    mind[col] = gmind;
                    skip[col] = gskip;
                    skip_val[col] = gskip_val;
                    edge_neighbor[col] = sad[NDISP_UNIT-2];
                    edge[col] = sad[NDISP_UNIT-1];
                    minsad_p[col] = gminsad_p;
                    minsad_n[col] = gminsad_n;

                    if (sweep == state.sweepFactor-1) {
                        ap_int<BitWidth<255*WSIZE*WSIZE>::Value> p = gminsad_p;
                        ap_int<BitWidth<255*WSIZE*WSIZE>::Value> n = gminsad_n;
                        ap_int<BitWidth<255*WSIZE*WSIZE>::Value> k = p + n - 2*gminsad + absdiff(p, n);
                        ap_int<BitWidth<255*WSIZE*WSIZE>::Value+8> num = p - n;
                        num = num << 8;
                        ap_int<10> delta = 0;
                        if (k != 0) delta = num/k;
                        out_pix.val[0] = ((gmind*256 + delta + 15) >> 4);

                        skip_flag |= gskip;
                        if (skip_flag) out_pix.val[0] = FILTERED;
                        disp << out_pix;
                    }
                }
            }
        }
    }
}


template<int WSIZE, int NDISP, int NDISP_UNIT, int ROWS, int COLS, int SRC_T, int DST_T>
void FindStereoCorrespondenceBM(
            Mat<ROWS, COLS, SRC_T>& left,
            Mat<ROWS, COLS, SRC_T>& right,
            Mat<ROWS, COLS, DST_T>& disp,
            StereoBMState<WSIZE, NDISP, NDISP_UNIT>& state)
{
    (static_cast <bool> (left.rows == right.rows && left.cols == right.cols && "All the images must have the same size") ? void (0) : __assert_fail ("left.rows == right.rows && left.cols == right.cols && \"All the images must have the same size\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 558, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (SRC_T == (((0) & ((1 << 11) - 1)) + (((1)-1) << 11)) && "Both input images must have HLS_8UC1 format") ? void (0) : __assert_fail ("SRC_T == HLS_8UC1 && \"Both input images must have HLS_8UC1 format\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 559, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (DST_T == (((3) & ((1 << 11) - 1)) + (((1)-1) << 11)) && "Disparity image must have HLS_16SC1 format") ? void (0) : __assert_fail ("DST_T == HLS_16SC1 && \"Disparity image must have HLS_16SC1 format\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 560, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (state.preFilterType == 0 || state.preFilterType == 1) ? void (0) : __assert_fail ("state.preFilterType == HLS_STEREO_BM_NORMALIZED_RESPONSE || state.preFilterType == HLS_STEREO_BM_XSOBEL", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 561, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (state.preFilterSize >= 5 && state.preFilterSize <= 21 && (state.preFilterSize & 1) && "preFilterSize must be odd and be within 5..HLS_STEREO_BM_MAX_WIN_SIZE") ? void (0) : __assert_fail ("state.preFilterSize >= 5 && state.preFilterSize <= HLS_STEREO_BM_MAX_WIN_SIZE && (state.preFilterSize & 1) && \"preFilterSize must be odd and be within 5..HLS_STEREO_BM_MAX_WIN_SIZE\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 562, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (state.preFilterCap >=1 && state.preFilterCap <= 63 && "preFilterCap must be within 1..63") ? void (0) : __assert_fail ("state.preFilterCap >=1 && state.preFilterCap <= 63 && \"preFilterCap must be within 1..63\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 563, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (state.SADWindowSize >= 5 && state.SADWindowSize <= 21 && (state.SADWindowSize & 1) && state.SADWindowSize < hls::min<int>(left.rows, left.cols) && "SADWindowSize must be odd, be within 5..HLS_STEREO_BM_MAX_WIN_SIZE and be lesser than image width or height") ? void (0) : __assert_fail ("state.SADWindowSize >= 5 && state.SADWindowSize <= HLS_STEREO_BM_MAX_WIN_SIZE && (state.SADWindowSize & 1) && state.SADWindowSize < hls::min<int>(left.rows, left.cols) && \"SADWindowSize must be odd, be within 5..HLS_STEREO_BM_MAX_WIN_SIZE and be lesser than image width or height\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 564, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (NDISP > 1 && "numberOfDisparities must be greater than 1") ? void (0) : __assert_fail ("NDISP > 1 && \"numberOfDisparities must be greater than 1\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 565, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (NDISP >= NDISP_UNIT && "numberOfDisparities must be not less than ndisp_unit") ? void (0) : __assert_fail ("NDISP >= NDISP_UNIT && \"numberOfDisparities must be not less than ndisp_unit\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 566, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (state.textureThreshold >= 0 && "texture threshold must be non-negative") ? void (0) : __assert_fail ("state.textureThreshold >= 0 && \"texture threshold must be non-negative\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 567, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (state.uniquenessRatio >= 0 && "uniqueness ratio must be non-negative") ? void (0) : __assert_fail ("state.uniquenessRatio >= 0 && \"uniqueness ratio must be non-negative\"", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 568, __extension__ __PRETTY_FUNCTION__));
    int rows = left.rows;
    int cols = left.cols;
    (static_cast <bool> (rows <= ROWS) ? void (0) : __assert_fail ("rows <= ROWS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 571, __extension__ __PRETTY_FUNCTION__));
    (static_cast <bool> (cols <= COLS) ? void (0) : __assert_fail ("cols <= COLS", "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls/hls_video_stereobm.h", 572, __extension__ __PRETTY_FUNCTION__));
    Mat<ROWS, COLS, SRC_T> _left_0(rows, cols);
    Mat<ROWS, COLS, SRC_T> _right_0(rows, cols);
_ssdm_op_SpecDataflowPipeline(-1, 0, "");
    if (state.preFilterType == 0) {
        PreFilterNorm<WSIZE>(left, _left_0, state.preFilterCap);
        PreFilterNorm<WSIZE>(right, _right_0, state.preFilterCap);
    } else {
        Mat<ROWS, COLS, (((3) & ((1 << 11) - 1)) + (((1)-1) << 11))> left_sobel(rows, cols);
        Mat<ROWS, COLS, (((3) & ((1 << 11) - 1)) + (((1)-1) << 11))> right_sobel(rows, cols);
        Sobel<1, 0, 3>(left, left_sobel);
        Sobel<1, 0, 3>(right, right_sobel);
        Clip(left_sobel, _left_0, state.preFilterCap);
        Clip(right_sobel, _right_0, state.preFilterCap);
    }
    SADBlockMatching(_left_0, _right_0, disp, state);
}

}
# 70 "/tools/Xilinx/Vivado/2019.2/common/technology/autopilot/hls_video.h" 2
# 25 "./src/ultranet.cpp" 2
# 34 "./src/ultranet.cpp"
void stream_to_mat(
    hls::stream<ap_uint<24>> &in,
    hls::Mat<360, 640, (((0) & ((1 << 11) - 1)) + (((3)-1) << 11))> &raw_img) {

  for (int i = 0; i < 360; i++) {
    for (int j = 0; j < 640; j++) {
#pragma HLS pipeline II = 1
 hls::Scalar<3, ap_uint<8>> pix;
      ap_uint<24> in_data = in.read();
      for (unsigned int p = 0; p < 3; p++) {

        pix.val[p] = in_data(8 * p + 7, 8 * p);
      }
      raw_img << pix;
    }
  }
}

void mat_to_stream(
    hls::Mat<160, 320, (((0) & ((1 << 11) - 1)) + (((3)-1) << 11))> &resize_img,
    hls::stream<ap_uint<24>> &out) {

  for (int i = 0; i < 160; i++) {
    for (int j = 0; j < 320; j++) {
#pragma HLS pipeline II = 1
 hls::Scalar<3, ap_uint<8>> pix;
      resize_img >> pix;
      ap_uint<24> out_data;
      for (unsigned int p = 0; p < 3; p++) {
        out_data(8 * p + 7, 8 * p) = pix.val[p];
      }
      out.write(out_data);
    }
  }
}

void resize(hls::stream<ap_uint<24>> &in, hls::stream<ap_uint<24>> &out) {
#pragma HLS dataflow
 hls::Mat<360, 640, (((0) & ((1 << 11) - 1)) + (((3)-1) << 11))> raw_img;
#pragma HLS STREAM variable = &raw_img depth = 1024 dim = 1
 hls::Mat<160, 320, (((0) & ((1 << 11) - 1)) + (((3)-1) << 11))> resize_img;
#pragma HLS STREAM variable = &resize_img depth = 1024 dim = 1
 stream_to_mat(in, raw_img);

  hls::Resize_opr_linear(raw_img, resize_img);
  mat_to_stream(resize_img, out);
}

void resize_batch(hls::stream<ap_uint<24>> &in, hls::stream<ap_uint<24>> &out,
                  unsigned int reps) {
  for (unsigned int rep = 0; rep < reps; rep++) {
    resize(in, out);
  }
}

void do_compute2(stream<my_ap_axis> &in, stream<my_ap_axis> &out,
                 const unsigned int reps = 1) {
#pragma HLS DATAFLOW

 const unsigned int num_per_rep = 360 * 640 * 3 * 8 / 64;

  hls::stream<ap_uint<64>> in_stream_extract("in_stream_extract");
#pragma HLS STREAM variable = &in_stream_extract depth = 1024 dim = 1
 ExtractPixels<64, num_per_rep>(in, in_stream_extract, reps);

  hls::stream<ap_uint<64 * 3>> in_stream0("in_stream0");
#pragma HLS STREAM variable = &in_stream0 depth = 1024 dim = 1
 StreamingDataWidthConverter_Batch<64, 64 * 3, num_per_rep>(in_stream_extract,
                                                             in_stream0, reps);

  hls::stream<ap_uint<8 * 3>> in_stream1("in_stream1");
#pragma HLS STREAM variable = &in_stream1 depth = 16 dim = 1

 StreamingDataWidthConverter_Batch<64 * 3, 8 * 3,
                                    num_per_rep / 3>(in_stream0, in_stream1,
                                                     reps);





  hls::stream<ap_uint<8 * 3>> in_stream2("in_stream2");
#pragma HLS STREAM variable = &in_stream2 depth = 16 dim = 1
 resize_batch(in_stream1, in_stream2, reps);




  hls::stream<ap_uint<4 * 16 * 2>> conv_0_out(
      "conv_0_out");
#pragma HLS STREAM variable = &conv_0_out depth = 128 dim = 1
 conv3x3_l0_bn_act_DSPopt<160, 320, 3,
                           8, 16, 4,
                           8, 26, 15,
                           32, 3, 3,
                           3, 16, 8>(
      in_stream2, conv_0_w_new, conv_0_inc_new, conv_0_bias_new, conv_0_out,
      reps);
# 141 "./src/ultranet.cpp"
  hls::stream<ap_uint<4 * 16 * 2>> pool_0_out(
      "pool_0_out");
#pragma HLS STREAM variable = &pool_0_out depth = 128 dim = 1
 max_pool2x2<160, 320, 16, 4,
              16>(conv_0_out, pool_0_out, reps);
# 154 "./src/ultranet.cpp"
  hls::stream<ap_uint<4 * 4 * 2>> conv_1_out(
      "conv_1_out");
#pragma HLS STREAM variable = &conv_1_out depth = 128 dim = 1
 conv3x3_bn_act_DSPopt<80, 160, 16,
                        4, 32, 4,
                        4, 16, 14,
                        23, 16, 4, 16,
                        4, 8>(
      pool_0_out, conv_1_w_new, conv_1_inc_new, conv_1_bias_new, conv_1_out,
      reps);
# 173 "./src/ultranet.cpp"
  hls::stream<ap_uint<4 * 4 * 2>> pool_1_out(
      "pool_1_out");
#pragma HLS STREAM variable = &pool_1_out depth = 128 dim = 1
 max_pool2x2<80, 160, 32, 4,
              4>(conv_1_out, pool_1_out, reps);
# 186 "./src/ultranet.cpp"
  hls::stream<ap_uint<4 * 8 * 2>> conv_2_out(
      "conv_2_out");
#pragma HLS STREAM variable = &conv_2_out depth = 128 dim = 1
 conv3x3_bn_act_DSPopt<40, 80, 32,
                        4, 64, 4,
                        4, 17, 13,
                        21, 8, 4, 4,
                        8, 8>(
      pool_1_out, conv_2_w_new, conv_2_inc_new, conv_2_bias_new, conv_2_out,
      reps);
# 205 "./src/ultranet.cpp"
  hls::stream<ap_uint<4 * 8 * 2>> pool_2_out(
      "pool_2_out");
#pragma HLS STREAM variable = &pool_2_out depth = 128 dim = 1
 max_pool2x2<40, 80, 64, 4,
              8>(conv_2_out, pool_2_out, reps);
# 218 "./src/ultranet.cpp"
  hls::stream<ap_uint<4 * 4 * 2>> conv_3_out(
      "conv_3_out");
#pragma HLS STREAM variable = &conv_3_out depth = 128 dim = 1
 conv3x3_bn_act_DSPopt<20, 40, 64,
                        4, 64, 4,
                        4, 18, 11,
                        20, 8, 4, 8,
                        4, 8>(
      pool_2_out, conv_3_w_new, conv_3_inc_new, conv_3_bias_new, conv_3_out,
      reps);
# 237 "./src/ultranet.cpp"
  hls::stream<ap_uint<4 * 4 * 2>> pool_3_out(
      "pool_3_out");
#pragma HLS STREAM variable = &pool_3_out depth = 128 dim = 1
 max_pool2x2<20, 40, 64, 4,
              4>(conv_3_out, pool_3_out, reps);
# 250 "./src/ultranet.cpp"
  hls::stream<ap_uint<4 * 2 * 2>> conv_4_out(
      "conv_4_out");
#pragma HLS STREAM variable = &conv_4_out depth = 128 dim = 1
 conv3x3_bn_act_DSPopt<10, 20, 64,
                        4, 64, 4,
                        4, 18, 12,
                        20, 4, 4, 4,
                        2, 8>(
      pool_3_out, conv_4_w_new, conv_4_inc_new, conv_4_bias_new, conv_4_out,
      reps);
# 269 "./src/ultranet.cpp"
  hls::stream<ap_uint<4 * 2 * 2>> conv_5_out(
      "conv_5_out");
#pragma HLS STREAM variable = &conv_5_out depth = 128 dim = 1
 conv3x3_bn_act_DSPopt<10, 20, 64,
                        4, 64, 4,
                        4, 18, 11,
                        21, 4, 4, 2,
                        2, 8>(
      conv_4_out, conv_5_w_new, conv_5_inc_new, conv_5_bias_new, conv_5_out,
      reps);
# 288 "./src/ultranet.cpp"
  hls::stream<ap_uint<4 * 2 * 2>> conv_6_out(
      "conv_6_out");
#pragma HLS STREAM variable = &conv_6_out depth = 128 dim = 1
 conv3x3_bn_act_DSPopt<10, 20, 64,
                        4, 64, 4,
                        4, 18, 12,
                        20, 4, 4, 2,
                        2, 8>(
      conv_5_out, conv_6_w_new, conv_6_inc_new, conv_6_bias_new, conv_6_out,
      reps);
# 307 "./src/ultranet.cpp"
  hls::stream<ap_uint<4 * 2 * 2>> conv_7_out(
      "conv_7_out");
#pragma HLS STREAM variable = &conv_7_out depth = 128 dim = 1
 conv3x3_bn_act_DSPopt<10, 20, 64,
                        4, 64, 4,
                        4, 18, 13,
                        22, 4, 4, 2,
                        2, 8>(
      conv_6_out, conv_7_w_new, conv_7_inc_new, conv_7_bias_new, conv_7_out,
      reps);







  hls::stream<ap_uint<32 * 2>> conv_8_out("conv_8_out");
#pragma HLS STREAM variable = &conv_8_out depth = 64 dim = 1
 conv1x1_DSPopt<10, 20, 64, 4,
                 36, 8, 13, 32,
                 4, 2, 2>(
      conv_7_out, conv_8_w_new, conv_8_bias_new, conv_8_out, reps);

  AddLast<10 * 20 * 36 / 2>(conv_8_out, out,
                                                               reps);
}

void ultra_net(stream<my_ap_axis> &in, stream<my_ap_axis> &out,
               const unsigned reps) {

#pragma HLS INTERFACE axis register both port = &out
#pragma HLS INTERFACE axis register both port = &in
#pragma HLS INTERFACE s_axilite port = &reps bundle = control
#pragma HLS INTERFACE s_axilite port = return bundle = control

#pragma HLS ARRAY_PARTITION variable = &conv_0_w_new complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &conv_0_w_new complete dim = 2
#pragma HLS ARRAY_PARTITION variable = &conv_0_inc_new complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &conv_0_bias_new complete dim = 1

#pragma HLS ARRAY_PARTITION variable = &conv_1_w_new complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &conv_1_w_new complete dim = 2
#pragma HLS ARRAY_PARTITION variable = &conv_1_inc_new complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &conv_1_bias_new complete dim = 1

#pragma HLS ARRAY_PARTITION variable = &conv_2_w_new complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &conv_2_w_new complete dim = 2
#pragma HLS ARRAY_PARTITION variable = &conv_2_inc_new complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &conv_2_bias_new complete dim = 1

#pragma HLS ARRAY_PARTITION variable = &conv_3_w_new complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &conv_3_w_new complete dim = 2
#pragma HLS ARRAY_PARTITION variable = &conv_3_inc_new complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &conv_3_bias_new complete dim = 1

#pragma HLS ARRAY_PARTITION variable = &conv_4_w_new complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &conv_4_w_new complete dim = 2
#pragma HLS ARRAY_PARTITION variable = &conv_4_inc_new complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &conv_4_bias_new complete dim = 1

#pragma HLS ARRAY_PARTITION variable = &conv_5_w_new complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &conv_5_w_new complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &conv_5_inc_new complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &conv_5_bias_new complete dim = 1

#pragma HLS ARRAY_PARTITION variable = &conv_6_w_new complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &conv_6_w_new complete dim = 2
#pragma HLS ARRAY_PARTITION variable = &conv_6_inc_new complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &conv_6_bias_new complete dim = 1

#pragma HLS ARRAY_PARTITION variable = &conv_7_w_new complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &conv_7_w_new complete dim = 2
#pragma HLS ARRAY_PARTITION variable = &conv_7_inc_new complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &conv_7_bias_new complete dim = 1

#pragma HLS ARRAY_PARTITION variable = &conv_8_w_new complete dim = 1
#pragma HLS ARRAY_PARTITION variable = &conv_8_bias_new complete dim = 1
 do_compute2(in, out, reps);
}



void load_data(const char *path, char *ptr, unsigned int size) {
  std::ifstream f(path, std::ios::in | std::ios::binary);
  if (!f) {
    std::cout << "no such file,please check the file name!/n";
    exit(0);
  }
  f.read(ptr, size);
  f.close();
}

void write_data(const char *path, char *ptr, unsigned int size) {
  std::ofstream f(path, std::ios::out | std::ios::binary);
  if (!f) {
    std::cout << "write no such file,please check the file name!/n";
    exit(0);
  }
  f.write(ptr, size);
  f.close();
}

int main(int argc, char const *argv[]) {
  uint8_t img[360][640][3];
  load_data("data/boat6_0.bin", (char *)img, sizeof(img));

  uint8_t *data = (uint8_t *)img;
  const int data_points_per_line = 8;
  const int nums_line_pre_img = 360 * 640 * 3 / 8;

  hls::stream<my_ap_axis> input_stream("input stream");
  hls::stream<my_ap_axis> input_stream_test("input stream_test");

  for (unsigned int i = 0; i < nums_line_pre_img; i++) {
    my_ap_axis temp;
    for (unsigned int j = 0; j < data_points_per_line; j++) {
      temp.data(8 * (j + 1) - 1, 8 * j) = data[i * data_points_per_line + j];
    }
    input_stream.write(temp);
  }
  for (unsigned int i = 0; i < nums_line_pre_img; i++) {
    my_ap_axis temp;
    for (unsigned int j = 0; j < data_points_per_line; j++) {
      temp.data(8 * (j + 1) - 1, 8 * j) = data[i * data_points_per_line + j];
    }
    input_stream.write(temp);
  }
  cout << "start ..... " << endl;
  hls::stream<my_ap_axis> output_stream("output stream");
  hls::stream<my_ap_axis> output_stream_test("output stream test");
  ultra_net(input_stream, output_stream, 2);

  cout << "output size :" << output_stream.size() << endl;
# 450 "./src/ultranet.cpp"
  return 0;
}
